var CABLES;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ core)
});

// NAMESPACE OBJECT: ./src/core/utils.js
var utils_namespaceObject = {};
__webpack_require__.r(utils_namespaceObject);
__webpack_require__.d(utils_namespaceObject, {
  UTILS: () => (UTILS),
  ajax: () => (ajax),
  ajaxSync: () => (ajaxSync),
  basename: () => (basename),
  cacheBust: () => (cacheBust),
  clamp: () => (clamp),
  cleanJson: () => (cleanJson),
  copyArray: () => (copyArray),
  filename: () => (filename),
  generateUUID: () => (generateUUID),
  getShortOpName: () => (getShortOpName),
  keyCodeToName: () => (keyCodeToName),
  logErrorConsole: () => (logErrorConsole),
  logStack: () => (logStack),
  map: () => (map),
  prefixedHash: () => (prefixedHash),
  request: () => (request),
  shortId: () => (shortId),
  shuffleArray: () => (shuffleArray),
  simpleId: () => (simpleId),
  smoothStep: () => (smoothStep),
  smootherStep: () => (smootherStep),
  uuid: () => (uuid)
});

// NAMESPACE OBJECT: ./src/core/anim.js
var anim_namespaceObject = {};
__webpack_require__.r(anim_namespaceObject);
__webpack_require__.d(anim_namespaceObject, {
  ANIM: () => (ANIM),
  Anim: () => (Anim)
});

;// CONCATENATED MODULE: ./src/core/constants.js
const CONSTANTS = {
    "ANIM": {
        "EASINGS": [
            "linear",
            "absolute",
            "smoothstep",
            "smootherstep",
            "Cubic In",
            "Cubic Out",
            "Cubic In Out",
            "Expo In",
            "Expo Out",
            "Expo In Out",
            "Sin In",
            "Sin Out",
            "Sin In Out",
            "Quart In",
            "Quart Out",
            "Quart In Out",
            "Quint In",
            "Quint Out",
            "Quint In Out",
            "Back In",
            "Back Out",
            "Back In Out",
            "Elastic In",
            "Elastic Out",
            "Bounce In",
            "Bounce Out",
        ],
        "EASING_LINEAR": 0,
        "EASING_ABSOLUTE": 1,
        "EASING_SMOOTHSTEP": 2,
        "EASING_SMOOTHERSTEP": 3,
        "EASING_CUBICSPLINE": 4,

        "EASING_CUBIC_IN": 5,
        "EASING_CUBIC_OUT": 6,
        "EASING_CUBIC_INOUT": 7,

        "EASING_EXPO_IN": 8,
        "EASING_EXPO_OUT": 9,
        "EASING_EXPO_INOUT": 10,

        "EASING_SIN_IN": 11,
        "EASING_SIN_OUT": 12,
        "EASING_SIN_INOUT": 13,

        "EASING_BACK_IN": 14,
        "EASING_BACK_OUT": 15,
        "EASING_BACK_INOUT": 16,

        "EASING_ELASTIC_IN": 17,
        "EASING_ELASTIC_OUT": 18,

        "EASING_BOUNCE_IN": 19,
        "EASING_BOUNCE_OUT": 21,

        "EASING_QUART_IN": 22,
        "EASING_QUART_OUT": 23,
        "EASING_QUART_INOUT": 24,

        "EASING_QUINT_IN": 25,
        "EASING_QUINT_OUT": 26,
        "EASING_QUINT_INOUT": 27,
    },

    "OP": {
        "OP_PORT_TYPE_VALUE": 0,
        "OP_PORT_TYPE_NUMBER": 0,
        "OP_PORT_TYPE_FUNCTION": 1,
        "OP_PORT_TYPE_TRIGGER": 1,
        "OP_PORT_TYPE_OBJECT": 2,
        "OP_PORT_TYPE_TEXTURE": 2,
        "OP_PORT_TYPE_ARRAY": 3,
        "OP_PORT_TYPE_DYNAMIC": 4,
        "OP_PORT_TYPE_STRING": 5,

        "OP_VERSION_PREFIX": "_v",
    },

    "PORT": {
        "PORT_DIR_IN": 0,
        "PORT_DIR_OUT": 1,
    },

    "PACO": {
        "PACO_CLEAR": 0,
        "PACO_VALUECHANGE": 1,
        "PACO_OP_DELETE": 2,
        "PACO_UNLINK": 3,
        "PACO_LINK": 4,
        "PACO_LOAD": 5,
        "PACO_OP_CREATE": 6,
        "PACO_OP_ENABLE": 7,
        "PACO_OP_DISABLE": 8,
        "PACO_UIATTRIBS": 9,
        "PACO_VARIABLES": 10,
        "PACO_TRIGGERS": 11,
        "PACO_PORT_SETVARIABLE": 12,
        "PACO_PORT_SETANIMATED": 13,
        "PACO_PORT_ANIM_UPDATED": 14,
        "PACO_DESERIALIZE": 15,
        "PACO_OP_RELOAD": 16
    },
};

;// CONCATENATED MODULE: ./src/core/utils.js

/**
 * @namespace external:CABLES#Utils
 */



const UTILS = {};
/**
 * Merge two Float32Arrays.
 * @function float32Concat
 * @memberof Utils
 * @param {Float32Array} first Left-hand side array
 * @param {Float32Array} second Right-hand side array
 * @return {Float32Array}
 * @static
 */
UTILS.float32Concat = function (first, second)
{
    if (!(first instanceof Float32Array)) first = new Float32Array(first);
    if (!(second instanceof Float32Array)) second = new Float32Array(second);

    const result = new Float32Array(first.length + second.length);

    result.set(first);
    result.set(second, first.length);

    return result;
};

/**
 * get op shortname: only last part of fullname and without version
 * @function getShortOpName
 * @memberof CABLES
 * @param {string} fullname full op name
 * @static
 */
const getShortOpName = function (fullname)
{
    let name = fullname.split(".")[fullname.split(".").length - 1];

    if (name.contains(CONSTANTS.OP.OP_VERSION_PREFIX))
    {
        const n = name.split(CONSTANTS.OP.OP_VERSION_PREFIX)[1];
        name = name.substring(0, name.length - (CONSTANTS.OP.OP_VERSION_PREFIX + n).length);
    }
    return name;
};

/**
 * randomize order of an array
 * @function shuffleArray
 * @memberof Utils
 * @param {Array|Float32Array} array {Array} original
 * @return {Array|Float32Array} shuffled array
 * @static
 */
const shuffleArray = function (array)
{
    for (let i = array.length - 1; i > 0; i--)
    {
        const j = Math.floor(Math.seededRandom() * (i + 1));
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
};


/**
 * generate a short "relativly unique" id
 * @function shortId
 * @memberof Utils
 * @return {String} generated ID
 * @static
 */

const _shortIds = {};
const _shortId = function ()
{
    let str = Math.random().toString(36).substr(2, 9);

    if (_shortIds.hasOwnProperty(str)) str = _shortId();
    _shortIds[str] = true;
    return str;
};
const shortId = _shortId;


/**
 * generate a UUID
 * @function uuid
 * @memberof Utils
 * @return {String} generated UUID
 * @static
 */
const _uuid = function ()
{
    let d = new Date().getTime();
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
    {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
    return uuid;
};
const uuid = _uuid;
const generateUUID = _uuid;



function cleanJson(obj)
{
    for (const i in obj)
    {
        if (obj[i] && typeof objValue === "object" && obj[i].constructor === Object) obj[i] = cleanJson(obj[i]);

        if (obj[i] === null || obj[i] === undefined) delete obj[i];
        else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];
    }

    return obj;
}


/**
 * @see http://stackoverflow.com/q/7616461/940217
 * @memberof Utils
 * @param str
 * @param prefix
 * @return {string}
 */
const _prefixedHash = function (str, prefix = "id")
{
    let hash = 0;
    if (Array.prototype.reduce)
    {
        hash = str.split("").reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0);
    }
    else
    {
        if (str.length > 0)
        {
            for (let i = 0; i < str.length; i++)
            {
                let character = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + character;
                hash &= hash; // Convert to 32bit integer
            }
        }
    }
    return prefix + "" + hash;
};
const prefixedHash = _prefixedHash;

/**
 * generate a simple ID
 * @function simpleId
 * @memberof Utils
 * @return {Number} new id
 * @static
 */
let simpleIdCounter = 0;
const simpleId = function ()
{
    simpleIdCounter++;
    return simpleIdCounter;
};

/**
 * smoothStep a value
 * @function smoothStep
 * @memberof Utils
 * @function
 * @param {Number} perc value value to be smoothed [0-1]
 * @return {Number} smoothed value
 * @static
 */
const smoothStep = function (perc)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * (3 - 2 * x); // smoothstep
    return perc;
};

/**
 * smootherstep a value
 * @function smootherStep
 * @memberof Utils
 * @param {Number} perc value to be smoothed [0-1]
 * @return {Number} smoothed value
 * @static
 */
const smootherStep = function (perc)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return perc;
};


/**
 * clamp number / make sure its between min/max
 * @function clamp
 * @memberof Utils
 * @param {Number} value value to be mapped
 * @param {Number} min minimum value
 * @param {Number} max maximum value
 * @static
 */
const clamp = function (value, min, max)
{
    return Math.min(Math.max(value, min), max);
};

/**
 * map a value in a range to a value in another range
 * @function map
 * @memberof Utils
 * @param {Number} x value to be mapped
 * @param {Number} _oldMin old range minimum value
 * @param {Number} _oldMax old range maximum value
 * @param {Number} _newMin new range minimum value
 * @param {Number} _newMax new range maximum value
 * @param {Number} _easing
 * @return {Number} mapped value
 * @static
 */
const map = function (x, _oldMin, _oldMax, _newMin, _newMax, _easing)
{
    if (x >= _oldMax) return _newMax;
    if (x <= _oldMin) return _newMin;

    let reverseInput = false;
    const oldMin = Math.min(_oldMin, _oldMax);
    const oldMax = Math.max(_oldMin, _oldMax);
    if (oldMin != _oldMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(_newMin, _newMax);
    const newMax = Math.max(_newMin, _newMax);
    if (newMin != _newMin) reverseOutput = true;

    let portion = 0;
    let r = 0;

    if (reverseInput) portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);
    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (!_easing) return r;
    if (_easing == 1)
    {
        // smoothstep
        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
        return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);
    }
    if (_easing == 2)
    {
        // smootherstep
        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
        return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);
    }

    return r;
};

/**
 * @namespace Math
 */
/**
 * set random seed for seededRandom()
 * @memberof Math
 * @type Number
 * @static
 */
Math.randomSeed = 1;


Math.setRandomSeed = function (seed)
{
    // https://github.com/cables-gl/cables_docs/issues/622
    Math.randomSeed = seed * 50728129;
    if (seed != 0)
    {
        Math.randomSeed = Math.seededRandom() * 17624813;
        Math.randomSeed = Math.seededRandom() * 9737333;
    }
};


/**
 * generate a seeded random number
 * @function seededRandom
 * @memberof Math
 * @param {Number} max minimum possible random number
 * @param {Number} min maximum possible random number
 * @return {Number} random value
 * @static
 */
Math.seededRandom = function (max, min)
{
    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;
    max = max || 1;
    min = min || 0;

    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const rnd = Math.randomSeed / 233280.0;

    return min + rnd * (max - min);
};


// ----------------------------------------------------------------

/**
 * returns true if parameter is a number
 * @function isNumeric
 * @memberof Utils
 * @param {Any} n value The value to check.
 * @return {Boolean}
 * @static
 */
UTILS.isNumeric = function (n)
{
    return !isNaN(parseFloat(n)) && isFinite(n);
};

/**
 * returns true if parameter is array
 * @function isArray
 * @param {Any} v value Value to check
 * @memberof Utils
 * @return {Boolean}
 * @static
 */
UTILS.isArray = function (v)
{
    return Object.prototype.toString.call(v) === "[object Array]";
};

/**
 * @namespace String
 */

/**
 * append a linebreak to a string
 * @function endl
 * @memberof String
 * @return {String} string with newline break appended ('\n')
 */
String.prototype.endl = function ()
{
    return this + "\n";
};

/**
 * return true if string starts with prefix
 * @function startsWith
 * @memberof String
 * @param {String} prefix The prefix to check.
 * @return {Boolean}
 */
String.prototype.startsWith = function (prefix)
{
    if (!this || !prefix) return false;
    if (this.length >= prefix.length)
    {
        if (this.substring(0, prefix.length) == prefix) return true;
    }
    return false;
    // return this.indexOf(prefix) === 0;
};

/**
 * return true if string ends with suffix
 * @function endsWith
 * @memberof String
 * @param {String} suffix
 * @return {Boolean}
 */
String.prototype.endsWith = String.prototype.endsWith || function (suffix)
{
    return this.match(suffix + "$") == suffix;
};

/**
 * return true if string contains string
 * @function contains
 * @memberof String
 * @param {String} searchStr
 * @return {Boolean}
 */
String.prototype.contains = String.prototype.contains || function (searchStr)
{
    return this.indexOf(searchStr) > -1;
};



// ----------------------------------------------------------------

/**
 * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached
 * @function cacheBust
 * @static
 * @memberof Utils
 * @param {String} url The url to append the cachebuster parameter to.
 * @return {String} url with cachebuster parameter
 */
const cacheBust = function (url = "")
{
    if (!url) return "";
    if (url.startsWith("data:")) return;
    if (url.contains("?")) url += "&";
    else url += "?";
    return url + "cache=" + CABLES.uuid();
};

/**
 * copy the content of an array
 * @function copyArray
 * @static
 * @memberof Utils
 * @param {Array} src sourceArray
 * @param {Array} dst optional
 * @return {Array} dst
 */
const copyArray = function (src, dst)
{
    if (!src) return null;
    dst = dst || [];
    dst.length = src.length;
    for (let i = 0; i < src.length; i++)
    {
        dst[i] = src[i];
    }

    return dst;
};


/**
 * return the filename part of a url without extension
 * @function basename
 * @static
 * @memberof Utils
 * @param {String} url
 * @return {String} just the filename
 */
const basename = function (url)
{
    let name = CABLES.filename(url);

    const parts2 = name.split(".");
    name = parts2[0];

    return name;
};

/**
 * output a stacktrace to the console
 * @function logStack
 * @static
 * @memberof Utils
 */
const logStack = function ()
{
    console.log("logstack", (new Error()).stack);
};

/**
 * return the filename part of a url
 * @function filename
 * @static
 * @memberof Utils
 * @param {String} url
 * @return {String} just the filename
 */
const filename = function (url)
{
    let name = "";
    if (!url) return "";

    if (url.startsWith("data:") && url.contains(":"))
    {
        const parts = url.split(",");
        return parts[0];
    }

    let parts = (url + "").split("/");
    if (parts.length > 0)
    {
        const str = parts[parts.length - 1];
        let parts2 = str.split("?");
        name = parts2[0];
    }

    return name || "";
};


const ajaxSync = function (url, cb, method, post, contenttype)
{
    request({
        "url": url,
        "cb": cb,
        "method": method,
        "data": post,
        "contenttype": contenttype,
        "sync": true,
    });
};

/**
 * make an ajax request
 * @static
 * @function ajax
 * @param url
 * @param cb
 * @param method
 * @param post
 * @param contenttype
 * @param jsonP
 * @param headers
 * @param options
 */
const ajax = function (url, cb, method, post, contenttype, jsonP, headers = {}, options = {})
{
    const requestOptions = {
        "url": url,
        "cb": cb,
        "method": method,
        "data": post,
        "contenttype": contenttype,
        "sync": false,
        "jsonP": jsonP,
        "headers": headers,
    };
    if (options && options.credentials) requestOptions.credentials = options.credentials;
    request(requestOptions);
};

const request = function (options)
{
    if (!options.hasOwnProperty("asynch")) options.asynch = true;

    let xhr;
    try
    {
        xhr = new XMLHttpRequest();
    }
    catch (e) {}

    xhr.onreadystatechange = function ()
    {
        if (xhr.readyState != 4) return;

        if (options.cb)
        {
            if (xhr.status == 200 || xhr.status == 0) options.cb(false, xhr.responseText, xhr);
            else options.cb(true, xhr.responseText, xhr);
        }
    };

    try
    {
        xhr.open(options.method ? options.method.toUpperCase() : "GET", options.url, !options.sync);
    }
    catch (e)
    {
        if (options.cb && e) options.cb(true, e.msg, xhr);
    }

    if (typeof options.headers === "object")
    {
        if (options.headers)
        {
            const keys = Object.keys(options.headers);
            for (let i = 0; i < keys.length; i++)
            {
                const name = keys[i];
                const value = options.headers[name];
                xhr.setRequestHeader(name, value);
            }
        }
    }

    if (options.credentials && options.credentials !== "omit")
    {
        xhr.withCredentials = true;
    }

    try
    {
        if (!options.post && !options.data)
        {
            xhr.send();
        }
        else
        {
            xhr.setRequestHeader(
                "Content-type",
                options.contenttype ? options.contenttype : "application/x-www-form-urlencoded",
            );
            xhr.send(options.data || options.post);
        }
    }
    catch (e)
    {
        if (options.cb) options.cb(true, e.msg, xhr);
    }
};


const keyCodeToName = function (keyCode)
{
    if (!keyCode && keyCode !== 0) return "Unidentified";
    const keys = {
        "8": "Backspace",
        "9": "Tab",
        "12": "Clear",
        "13": "Enter",
        "16": "Shift",
        "17": "Control",
        "18": "Alt",
        "19": "Pause",
        "20": "CapsLock",
        "27": "Escape",
        "32": "Space",
        "33": "PageUp",
        "34": "PageDown",
        "35": "End",
        "36": "Home",
        "37": "ArrowLeft",
        "38": "ArrowUp",
        "39": "ArrowRight",
        "40": "ArrowDown",
        "45": "Insert",
        "46": "Delete",
        "112": "F1",
        "113": "F2",
        "114": "F3",
        "115": "F4",
        "116": "F5",
        "117": "F6",
        "118": "F7",
        "119": "F8",
        "120": "F9",
        "121": "F10",
        "122": "F11",
        "123": "F12",
        "144": "NumLock",
        "145": "ScrollLock",
        "224": "Meta"
    };
    if (keys[keyCode])
    {
        return keys[keyCode];
    }
    else
    {
        return String.fromCharCode(keyCode);
    }
};
// ----------------------------------------------------------------

window.performance = window.performance || {
    "offset": Date.now(),
    "now": function now()
    {
        return Date.now() - this.offset;
    },
};


const logErrorConsole = function (initiator)
{
    CABLES.errorConsole = CABLES.errorConsole || { "log": [] };
    CABLES.errorConsole.log.push({ "initiator": initiator, "arguments": arguments });

    if (!CABLES.errorConsole.ele)
    {
        const ele = document.createElement("div");
        ele.id = "cablesErrorConsole";
        ele.style.width = "90%";
        ele.style.height = "300px";
        ele.style.zIndex = "9999999";
        ele.style.display = "inline-block";
        ele.style.position = "absolute";
        ele.style.padding = "10px";
        ele.style.fontFamily = "monospace";
        ele.style.color = "red";
        ele.style.backgroundColor = "#200";

        CABLES.errorConsole.ele = ele;
        document.body.appendChild(ele);
    }

    let logHtml = "ERROR<br/>for more info, open your browsers dev tools console (Ctrl+Shift+I or Command+Alt+I)<br/>";

    for (let l = 0; l < CABLES.errorConsole.log.length; l++)
    {
        logHtml += CABLES.errorConsole.log[l].initiator + " ";
        for (let i = 1; i < CABLES.errorConsole.log[l].arguments.length; i++)
        {
            if (i > 2)logHtml += ", ";
            let arg = CABLES.errorConsole.log[l].arguments[i];
            if (arg.constructor.name.indexOf("Error") > -1 || arg.constructor.name.indexOf("error") > -1)
            {
                let txt = "Uncaught ErrorEvent ";
                if (arg.message)txt += " message: " + arg.message;
                logHtml += txt;
            }
            else if (typeof arg == "string")
                logHtml += arg;
            else if (typeof arg == "number")
                logHtml += String(arg) + " ";
        }
        logHtml += "<br/>";
    }


    CABLES.errorConsole.ele.innerHTML = logHtml;
};




;// CONCATENATED MODULE: ../shared/client/src/logger.js
/* eslint-disable no-console */

class Logger
{
    constructor(initiator, options)
    {
        this.initiator = initiator;
        this._options = options;
    }

    stack(t)
    {
        console.info("[" + this.initiator + "] ", t);
        console.log((new Error()).stack);
    }

    groupCollapsed(t)
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent) console.log("[" + this.initiator + "]", ...arguments);

        console.groupCollapsed("[" + this.initiator + "] " + t);
    }

    table(t)
    {
        console.table(t);
    }

    groupEnd()
    {
        console.groupEnd();
    }

    error()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments)) || !CABLES.UI)
        {
            console.error("[" + this.initiator + "]", ...arguments);
        }

        if (this._options && this._options.onError)
        {
            this._options.onError(this.initiator, ...arguments);
            // console.log("emitevent onerror...");
            // CABLES.patch.emitEvent("onError", this.initiator, ...arguments);
            // CABLES.logErrorConsole("[" + this.initiator + "]", ...arguments);
        }
    }

    errorGui()
    {
        if (CABLES.UI) CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments);
    }

    warn()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 1 }, ...arguments)) || !CABLES.logSilent)
            console.warn("[" + this.initiator + "]", ...arguments);
    }

    verbose()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.log("[" + this.initiator + "]", ...arguments);
    }

    info()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.info("[" + this.initiator + "]", ...arguments);
    }

    log()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.log("[" + this.initiator + "]", ...arguments);
    }

    logGui()
    {
        if (CABLES.UI) CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments);
    }

    userInteraction(text)
    {
        // this.log({ "initiator": "userinteraction", "text": text });
    }
}

;// CONCATENATED MODULE: ./src/core/anim_key.js


const Key = function (obj)
{
    this.time = 0.0;
    this.value = 0.0;
    // this.ui = null;
    this.onChange = null;
    this._easing = 0;
    // this.bezTangIn = 0;
    // this.bezTangOut = 0;
    // this.bezTime = 0.5;
    // this.bezValue = 0;
    // this.bezTimeIn = -0.5;
    // this.bezValueIn = 0;

    this.cb = null;
    this.cbTriggered = false;

    // const bezierAnim = null;
    // this._updateBezier = false;

    this.setEasing(CONSTANTS.ANIM.EASING_LINEAR);
    this.set(obj);
};

Key.cubicSpline = function (perc, key1, key2)
{
    let
        previousPoint = key1.value,
        previousTangent = key1.bezTangOut,
        nextPoint = key2.value,
        nextTangent = key2.bezTangIn;
    let t = perc;
    let t2 = t * t;
    let t3 = t2 * t;

    return (2 * t3 - 3 * t2 + 1) * previousPoint + (t3 - 2 * t2 + t) * previousTangent + (-2 * t3 + 3 * t2) * nextPoint + (t3 - t2) * nextTangent;
};

Key.easeCubicSpline = function (perc, key2)
{
    return Key.cubicSpline(perc, this, key2);
};


Key.linear = function (perc, key1, key2)
{
    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;
};

Key.easeLinear = function (perc, key2)
{
    return Key.linear(perc, this, key2);
};

Key.easeAbsolute = function (perc, key2)
{
    return this.value;
};

const easeExpoIn = function (t)
{
    return (t = 2 ** (10 * (t - 1)));
};

Key.easeExpoIn = function (t, key2)
{
    t = easeExpoIn(t);
    return Key.linear(t, this, key2);
};

const easeExpoOut = function (t)
{
    t = -(2 ** (-10 * t)) + 1;
    return t;
};

Key.easeExpoOut = function (t, key2)
{
    t = easeExpoOut(t);
    return Key.linear(t, this, key2);
};

const easeExpoInOut = function (t)
{
    t *= 2;
    if (t < 1)
    {
        t = 0.5 * 2 ** (10 * (t - 1));
    }
    else
    {
        t--;
        t = 0.5 * (-(2 ** (-10 * t)) + 2);
    }
    return t;
};

Key.easeExpoInOut = function (t, key2)
{
    t = easeExpoInOut(t);
    return Key.linear(t, this, key2);
};

Key.easeSinIn = function (t, key2)
{
    t = -1 * Math.cos((t * Math.PI) / 2) + 1;
    return Key.linear(t, this, key2);
};

Key.easeSinOut = function (t, key2)
{
    t = Math.sin((t * Math.PI) / 2);
    return Key.linear(t, this, key2);
};

Key.easeSinInOut = function (t, key2)
{
    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);
    return Key.linear(t, this, key2);
};

const easeCubicIn = function (t)
{
    t = t * t * t;
    return t;
};

Key.easeCubicIn = function (t, key2)
{
    t = easeCubicIn(t);
    return Key.linear(t, this, key2);
};


// b 0
// c 1/2 or 1
// d always 1
// easeOutCubic: function (x, t, b, c, d) {
//     return c*((t=t/d-1)*t*t + 1) + b;

Key.easeInQuint = function (t, key2)
{
    t = t * t * t * t * t;
    return Key.linear(t, this, key2);
};
Key.easeOutQuint = function (t, key2)
{
    t = (t -= 1) * t * t * t * t + 1;
    return Key.linear(t, this, key2);
};
Key.easeInOutQuint = function (t, key2)
{
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;
    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);
    return Key.linear(t, this, key2);
};

Key.easeInQuart = function (t, key2)
{
    t = t * t * t * t;
    return Key.linear(t, this, key2);
};

Key.easeOutQuart = function (t, key2)
{
    // return -c * ((t=t/d-1)*t*t*t - 1) + b;
    t = -1 * ((t -= 1) * t * t * t - 1);
    return Key.linear(t, this, key2);
};

Key.easeInOutQuart = function (t, key2)
{
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;
    else t = -0.5 * ((t -= 2) * t * t * t - 2);
    return Key.linear(t, this, key2);
};

Key.bounce = function (t)
{
    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;
    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    return t;
};

Key.easeInBounce = function (t, key2)
{
    return Key.linear(Key.bounce(t), this, key2);
    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);
};

Key.easeOutBounce = function (t, key2)
{
    return Key.linear(Key.bounce(t), this, key2);
};

Key.easeInElastic = function (t, key2)
{
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else
    {
        if (!p) p = d * 0.3;
        if (a < Math.abs(c))
        {
            a = c;
            s = p / 4;
        }
        else s = (p / (2 * Math.PI)) * Math.asin(c / a);
        t = -(a * 2 ** (10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;
    }

    return Key.linear(t, this, key2);
};


Key.easeOutElastic = function (t, key2)
{
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else
    {
        if (!p) p = d * 0.3;
        if (a < Math.abs(c))
        {
            a = c;
            s = p / 4;
        }
        else s = (p / (2 * Math.PI)) * Math.asin(c / a);
        t = a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;
    }

    return Key.linear(t, this, key2);
};

Key.easeInBack = function (t, key2)
{
    const s = 1.70158;
    t = t * t * ((s + 1) * t - s);

    return Key.linear(t, this, key2);
};

Key.easeOutBack = function (t, key2)
{
    const s = 1.70158;
    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;

    return Key.linear(t, this, key2);
};

Key.easeInOutBack = function (t, key2)
{
    let s = 1.70158;
    const c = 1 / 2;
    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));
    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);

    return Key.linear(t, this, key2);
};

const easeCubicOut = function (t)
{
    t--;
    t = t * t * t + 1;
    return t;
};

Key.easeCubicOut = function (t, key2)
{
    t = easeCubicOut(t);
    return Key.linear(t, this, key2);
};

const easeCubicInOut = function (t)
{
    t *= 2;
    if (t < 1) t = 0.5 * t * t * t;
    else
    {
        t -= 2;
        t = 0.5 * (t * t * t + 2);
    }
    return t;
};

Key.easeCubicInOut = function (t, key2)
{
    t = easeCubicInOut(t);
    return Key.linear(t, this, key2);
};

Key.easeSmoothStep = function (perc, key2)
{
    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));
    const x = Math.max(0, Math.min(1, perc));
    perc = x * x * (3 - 2 * x); // smoothstep
    return Key.linear(perc, this, key2);
};

Key.easeSmootherStep = function (perc, key2)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return Key.linear(perc, this, key2);
};

Key.prototype.setEasing = function (e)
{
    this._easing = e;

    if (this._easing == CONSTANTS.ANIM.EASING_LINEAR) this.ease = Key.easeLinear;
    else if (this._easing == CONSTANTS.ANIM.EASING_ABSOLUTE) this.ease = Key.easeAbsolute;
    else if (this._easing == CONSTANTS.ANIM.EASING_SMOOTHSTEP) this.ease = Key.easeSmoothStep;
    else if (this._easing == CONSTANTS.ANIM.EASING_SMOOTHERSTEP) this.ease = Key.easeSmootherStep;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_IN) this.ease = Key.easeCubicIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_OUT) this.ease = Key.easeCubicOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_INOUT) this.ease = Key.easeCubicInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_IN) this.ease = Key.easeExpoIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_OUT) this.ease = Key.easeExpoOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_INOUT) this.ease = Key.easeExpoInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_IN) this.ease = Key.easeSinIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_OUT) this.ease = Key.easeSinOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_INOUT) this.ease = Key.easeSinInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_OUT) this.ease = Key.easeOutBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_IN) this.ease = Key.easeInBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_INOUT) this.ease = Key.easeInOutBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_IN) this.ease = Key.easeInElastic;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_OUT) this.ease = Key.easeOutElastic;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_INOUT) this.ease = Key.easeElasticInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_BOUNCE_IN) this.ease = Key.easeInBounce;
    else if (this._easing == CONSTANTS.ANIM.EASING_BOUNCE_OUT) this.ease = Key.easeOutBounce;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_OUT) this.ease = Key.easeOutQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_IN) this.ease = Key.easeInQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_INOUT) this.ease = Key.easeInOutQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_OUT) this.ease = Key.easeOutQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_IN) this.ease = Key.easeInQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_INOUT) this.ease = Key.easeInOutQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE)
    {
        // this._updateBezier = true;
        this.ease = Key.easeCubicSpline;
    }
    else
    {
        this._easing = CONSTANTS.ANIM.EASING_LINEAR;
        this.ease = Key.easeLinear;
    }
};

Key.prototype.trigger = function ()
{
    this.cb();
    this.cbTriggered = true;
};

Key.prototype.setValue = function (v)
{
    this.value = v;
    // this._updateBezier = true;
    if (this.onChange !== null) this.onChange();
};

Key.prototype.set = function (obj)
{
    if (obj)
    {
        if (obj.e) this.setEasing(obj.e);
        if (obj.cb)
        {
            this.cb = obj.cb;
            this.cbTriggered = false;
        }

        if (obj.b)
        {
            // this.bezTime = obj.b[0];
            // this.bezValue = obj.b[1];
            // this.bezTimeIn = obj.b[2];
            // this.bezValueIn = obj.b[3];
            // this._updateBezier = true;
        }

        if (obj.hasOwnProperty("t")) this.time = obj.t;
        if (obj.hasOwnProperty("time")) this.time = obj.time;
        if (obj.hasOwnProperty("v")) this.value = obj.v;
        else if (obj.hasOwnProperty("value")) this.value = obj.value;
    }
    if (this.onChange !== null) this.onChange();
};

Key.prototype.getSerialized = function ()
{
    const obj = {};
    obj.t = this.time;
    obj.v = this.value;
    obj.e = this._easing;
    // if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE) obj.b = [this.bezTime, this.bezValue, this.bezTimeIn, this.bezValueIn];

    return obj;
};

Key.prototype.getEasing = function ()
{
    return this._easing;
};



;// CONCATENATED MODULE: ./src/core/eventtarget.js


const EventTarget = function ()
{
    this._log = new Logger("eventtarget");
    this._eventCallbacks = {};
    this._logName = "";
    this._logEvents = false;
    this._listeners = {};

    this.addEventListener = this.on = function (which, cb, idPrefix)
    {
        const event =
        {
            "id": (idPrefix || "") + CABLES.simpleId(),
            "name": which,
            "cb": cb,
        };
        if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];
        else this._eventCallbacks[which].push(event);

        this._listeners[event.id] = event;

        return event.id;
    };

    this.hasEventListener = function (which, cb)
    {
        if (which && !cb)
        {
            // check by id
            if (this._listeners[which]) return true;
            else return false;
        }
        else
        {
            this._log.warn("old eventtarget function haseventlistener!");
            if (which && cb)
            {
                if (this._eventCallbacks[which])
                {
                    const idx = this._eventCallbacks[which].indexOf(cb);
                    if (idx == -1) return false;
                    return true;
                }
            }
        }
    };

    this.hasListenerForEventName = function (eventName)
    {
        return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;
    };

    this.removeEventListener = this.off = function (which, cb)
    {
        if (which === null || which === undefined) return;

        if (!cb) // new style, remove by id, not by name/callback
        {
            const event = this._listeners[which];
            if (!event)
            {
                this._log.log("removeEvent: could not find event...", which, this);
                return;
            }

            let found = true;
            while (found)
            {
                found = false;
                let index = -1;
                for (let i = 0; i < this._eventCallbacks[event.name].length; i++)
                {
                    if (this._eventCallbacks[event.name][i].id.startsWith(which)) // this._eventCallbacks[event.name][i].id == which ||
                    {
                        found = true;
                        index = i;
                    }
                }

                if (index !== -1)
                {
                    this._eventCallbacks[event.name].splice(index, 1);
                    delete this._listeners[which];
                }
            }

            return;
        }

        this._log.info("[eventtaget] ", "old function signature: removeEventListener! use listener id");
        this._log.log((new Error()).stack);

        let index = null;
        for (let i = 0; i < this._eventCallbacks[which].length; i++)
            if (this._eventCallbacks[which][i].cb == cb)
                index = i;

        if (index !== null)
        {
            delete this._eventCallbacks[index];
        }
        else this._log.warn("removeEventListener not found " + which);
    };

    this.logEvents = function (enabled, name)
    {
        this._logEvents = enabled;
        this._logName = name;
    };

    this.emitEvent = function (which, param1, param2, param3, param4, param5, param6)
    {
        if (this._logEvents) this._log.log("[event] ", this._logName, which, this._eventCallbacks);

        if (this._eventCallbacks[which])
        {
            for (let i = 0; i < this._eventCallbacks[which].length; i++)
            {
                if (this._eventCallbacks[which][i])
                {
                    this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);
                }
            }
        }
        else
        {
            if (this._logEvents) this._log.log("[event] has no event callback", which, this._eventCallbacks);
        }
    };
};



;// CONCATENATED MODULE: ./src/core/anim.js





/**
 * Keyframed interpolated animation.
 *
 * Available Easings:
 * <code>
 * CONSTANTS.ANIM.EASING_LINEAR
 * CONSTANTS.ANIM.EASING_ABSOLUTE
 * CONSTANTS.ANIM.EASING_SMOOTHSTEP
 * CONSTANTS.ANIM.EASING_SMOOTHERSTEP
 * CONSTANTS.ANIM.EASING_CUBICSPLINE

 * CONSTANTS.ANIM.EASING_CUBIC_IN
 * CONSTANTS.ANIM.EASING_CUBIC_OUT
 * CONSTANTS.ANIM.EASING_CUBIC_INOUT

 * CONSTANTS.ANIM.EASING_EXPO_IN
 * CONSTANTS.ANIM.EASING_EXPO_OUT
 * CONSTANTS.ANIM.EASING_EXPO_INOUT

 * CONSTANTS.ANIM.EASING_SIN_IN
 * CONSTANTS.ANIM.EASING_SIN_OUT
 * CONSTANTS.ANIM.EASING_SIN_INOUT

 * CONSTANTS.ANIM.EASING_BACK_IN
 * CONSTANTS.ANIM.EASING_BACK_OUT
 * CONSTANTS.ANIM.EASING_BACK_INOUT

 * CONSTANTS.ANIM.EASING_ELASTIC_IN
 * CONSTANTS.ANIM.EASING_ELASTIC_OUT

 * CONSTANTS.ANIM.EASING_BOUNCE_IN
 * CONSTANTS.ANIM.EASING_BOUNCE_OUT

 * CONSTANTS.ANIM.EASING_QUART_IN
 * CONSTANTS.ANIM.EASING_QUART_OUT
 * CONSTANTS.ANIM.EASING_QUART_INOUT

 * CONSTANTS.ANIM.EASING_QUINT_IN
 * CONSTANTS.ANIM.EASING_QUINT_OUT
 * CONSTANTS.ANIM.EASING_QUINT_INOUT
 * </code>
 * @class
 * @param cfg
 * @example
 * var anim=new CABLES.Anim();
 * anim.setValue(0,0);  // set value 0 at 0 seconds
 * anim.setValue(10,1); // set value 1 at 10 seconds
 * anim.getValue(5);    // get value at 5 seconds - this returns 0.5
 */

const Anim = function (cfg)
{
    EventTarget.apply(this);

    cfg = cfg || {};
    this.keys = [];
    this.onChange = null;
    this.stayInTimeline = false;
    this.loop = false;
    this._log = new Logger("Anim");
    this._lastKeyIndex = 0;
    this._cachedIndex = 0;
    this.name = cfg.name || null;

    /**
     * @member defaultEasing
     * @memberof Anim
     * @instance
     * @type {Number}
     */
    this.defaultEasing = cfg.defaultEasing || CONSTANTS.ANIM.EASING_LINEAR;
    this.onLooped = null;

    this._timesLooped = 0;
    this._needsSort = false;
};

Anim.prototype.forceChangeCallback = function ()
{
    if (this.onChange !== null) this.onChange();
    this.emitEvent("onChange", this);
};

Anim.prototype.getLoop = function ()
{
    return this.loop;
};

Anim.prototype.setLoop = function (target)
{
    this.loop = target;
    this.emitEvent("onChange", this);
};

/**
 * returns true if animation has ended at @time
 * checks if last key time is < time
 * @param {Number} time
 * @returns {Boolean}
 * @memberof Anim
 * @instance
 * @function
 */
Anim.prototype.hasEnded = function (time)
{
    if (this.keys.length === 0) return true;
    if (this.keys[this._lastKeyIndex].time <= time) return true;
    return false;
};

Anim.prototype.isRising = function (time)
{
    if (this.hasEnded(time)) return false;
    const ki = this.getKeyIndex(time);
    if (this.keys[ki].value < this.keys[ki + 1].value) return true;
    return false;
};

/**
 * remove all keys from animation before time
 * @param {Number} time
 * @memberof Anim
 * @instance
 * @function
 */
Anim.prototype.clearBefore = function (time)
{
    const v = this.getValue(time);
    const ki = this.getKeyIndex(time);

    this.setValue(time, v);

    if (ki > 1) this.keys.splice(0, ki);
    this._updateLastIndex();
};
/**
 * remove all keys from animation
 * @param {Number} [time=0] set a new key at time with the old value at time
 * @memberof Anim
 * @instance
 * @function
 */
Anim.prototype.clear = function (time)
{
    let v = 0;
    if (time) v = this.getValue(time);
    this.keys.length = 0;
    this._updateLastIndex();
    if (time) this.setValue(time, v);
    if (this.onChange !== null) this.onChange();
    this.emitEvent("onChange", this);
};

Anim.prototype.sortKeys = function ()
{
    this.keys.sort((a, b) => { return parseFloat(a.time) - parseFloat(b.time); });
    this._updateLastIndex();
    this._needsSort = false;
    if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);
};

Anim.prototype.getLength = function ()
{
    if (this.keys.length === 0) return 0;
    return this.keys[this.keys.length - 1].time;
};

Anim.prototype.getKeyIndex = function (time)
{
    let index = 0;
    let start = 0;
    if (this._cachedIndex && this.keys.length > this._cachedIndex && time >= this.keys[this._cachedIndex].time) start = this._cachedIndex;
    for (let i = start; i < this.keys.length; i++)
    {
        if (time >= this.keys[i].time) index = i;
        if (this.keys[i].time > time)
        {
            if (time != 0) this._cachedIndex = index;
            return index;
        }
    }

    return index;
};

/**
 * set value at time
 * @function setValue
 * @memberof Anim
 * @instance
 * @param {Number} time
 * @param {Number} value
 * @param {Function} cb callback
 */
Anim.prototype.setValue = function (time, value, cb)
{
    let found = null;

    if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time)
        for (let i = 0; i < this.keys.length; i++)
            if (this.keys[i].time == time)
            {
                found = this.keys[i];
                this.keys[i].setValue(value);
                this.keys[i].cb = cb;
                break;
            }

    if (!found)
    {
        found = new Key(
            {
                "time": time,
                "value": value,
                "e": this.defaultEasing,
                "cb": cb,
            });
        this.keys.push(found);

        // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);
        this._updateLastIndex();
    }

    if (this.onChange) this.onChange();
    this.emitEvent("onChange", this);
    this._needsSort = true;
    return found;
};

Anim.prototype.setKeyEasing = function (index, e)
{
    if (this.keys[index])
    {
        this.keys[index].setEasing(e);
        this.emitEvent("onChange", this);
    }
};

Anim.prototype.getSerialized = function ()
{
    const obj = {};
    obj.keys = [];
    obj.loop = this.loop;

    for (let i = 0; i < this.keys.length; i++)
        obj.keys.push(this.keys[i].getSerialized());

    return obj;
};

Anim.prototype.getKey = function (time)
{
    const index = this.getKeyIndex(time);
    return this.keys[index];
};

Anim.prototype.getNextKey = function (time)
{
    let index = this.getKeyIndex(time) + 1;
    if (index >= this.keys.length) index = this.keys.length - 1;

    return this.keys[index];
};

Anim.prototype.isFinished = function (time)
{
    if (this.keys.length <= 0) return true;
    return time > this.keys[this.keys.length - 1].time;
};

Anim.prototype.isStarted = function (time)
{
    if (this.keys.length <= 0) return false;
    return time >= this.keys[0].time;
};

/**
 * get value at time
 * @function getValue
 * @memberof Anim
 * @instance
 * @param {Number} [time] time
 * @returns {Number} interpolated value at time
 */
Anim.prototype.getValue = function (time)
{
    if (this.keys.length === 0)
    {
        return 0;
    }
    if (this._needsSort) this.sortKeys();

    if (!this.loop && time > this.keys[this._lastKeyIndex].time)
    {
        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();

        return this.keys[this._lastKeyIndex].value;
    }

    if (time < this.keys[0].time)
    {
        // if (this.name)console.log("A");

        return this.keys[0].value;
    }

    if (this.loop && time > this.keys[this._lastKeyIndex].time)
    {
        const currentLoop = time / this.keys[this._lastKeyIndex].time;
        if (currentLoop > this._timesLooped)
        {
            this._timesLooped++;
            if (this.onLooped) this.onLooped();
        }
        time = (time - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time);
        time += this.keys[0].time;
    }

    const index = this.getKeyIndex(time);
    if (index >= this._lastKeyIndex)
    {
        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();

        return this.keys[this._lastKeyIndex].value;
    }


    const index2 = index + 1;
    const key1 = this.keys[index];
    const key2 = this.keys[index2];

    if (key1.cb && !key1.cbTriggered) key1.trigger();

    if (!key2) return -1;

    const perc = (time - key1.time) / (key2.time - key1.time);

    if (!key1.ease) this.log._warn("has no ease", key1, key2);

    return key1.ease(perc, key2);
};

Anim.prototype._updateLastIndex = function ()
{
    this._lastKeyIndex = this.keys.length - 1;
};

Anim.prototype.addKey = function (k)
{
    if (k.time === undefined)
    {
        this.log.warn("key time undefined, ignoring!");
    }
    else
    {
        this.keys.push(k);
        if (this.onChange !== null) this.onChange();
        this.emitEvent("onChange", this);
    }
    this._updateLastIndex();
};

Anim.prototype.easingFromString = function (str)
{
    if (str == "linear") return CONSTANTS.ANIM.EASING_LINEAR;
    if (str == "absolute") return CONSTANTS.ANIM.EASING_ABSOLUTE;
    if (str == "smoothstep") return CONSTANTS.ANIM.EASING_SMOOTHSTEP;
    if (str == "smootherstep") return CONSTANTS.ANIM.EASING_SMOOTHERSTEP;

    if (str == "Cubic In") return CONSTANTS.ANIM.EASING_CUBIC_IN;
    if (str == "Cubic Out") return CONSTANTS.ANIM.EASING_CUBIC_OUT;
    if (str == "Cubic In Out") return CONSTANTS.ANIM.EASING_CUBIC_INOUT;

    if (str == "Expo In") return CONSTANTS.ANIM.EASING_EXPO_IN;
    if (str == "Expo Out") return CONSTANTS.ANIM.EASING_EXPO_OUT;
    if (str == "Expo In Out") return CONSTANTS.ANIM.EASING_EXPO_INOUT;

    if (str == "Sin In") return CONSTANTS.ANIM.EASING_SIN_IN;
    if (str == "Sin Out") return CONSTANTS.ANIM.EASING_SIN_OUT;
    if (str == "Sin In Out") return CONSTANTS.ANIM.EASING_SIN_INOUT;

    if (str == "Back In") return CONSTANTS.ANIM.EASING_BACK_IN;
    if (str == "Back Out") return CONSTANTS.ANIM.EASING_BACK_OUT;
    if (str == "Back In Out") return CONSTANTS.ANIM.EASING_BACK_INOUT;

    if (str == "Elastic In") return CONSTANTS.ANIM.EASING_ELASTIC_IN;
    if (str == "Elastic Out") return CONSTANTS.ANIM.EASING_ELASTIC_OUT;

    if (str == "Bounce In") return CONSTANTS.ANIM.EASING_BOUNCE_IN;
    if (str == "Bounce Out") return CONSTANTS.ANIM.EASING_BOUNCE_OUT;

    if (str == "Quart Out") return CONSTANTS.ANIM.EASING_QUART_OUT;
    if (str == "Quart In") return CONSTANTS.ANIM.EASING_QUART_IN;
    if (str == "Quart In Out") return CONSTANTS.ANIM.EASING_QUART_INOUT;

    if (str == "Quint Out") return CONSTANTS.ANIM.EASING_QUINT_OUT;
    if (str == "Quint In") return CONSTANTS.ANIM.EASING_QUINT_IN;
    if (str == "Quint In Out") return CONSTANTS.ANIM.EASING_QUINT_INOUT;
};

Anim.prototype.createPort = function (op, title, cb)
{
    const port = op.inDropDown(title, CONSTANTS.ANIM.EASINGS, "Cubic Out");

    // const port = op.addInPort(
    //     new Port(op, title, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
    //         "display": "dropdown",
    //         "values": CONSTANTS.ANIM.EASINGS,
    //     }),
    // );

    port.set("linear");
    port.defaultValue = "linear";

    port.onChange = function ()
    {
        this.defaultEasing = this.easingFromString(port.get());
        this.emitEvent("onChangeDefaultEasing", this);

        if (cb) cb();
    }.bind(this);

    return port;
};

// ------------------------------

Anim.slerpQuaternion = function (time, q, animx, animy, animz, animw)
{
    if (!Anim.slerpQuaternion.q1)
    {
        Anim.slerpQuaternion.q1 = quat.create();
        Anim.slerpQuaternion.q2 = quat.create();
    }

    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;

    if (i1 == i2)
    {
        quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);
    }
    else
    {
        const key1Time = animx.keys[i1].time;
        const key2Time = animx.keys[i2].time;
        const perc = (time - key1Time) / (key2Time - key1Time);

        quat.set(Anim.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);

        quat.set(Anim.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);

        quat.slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);
    }
    return q;
};

const ANIM = { "Key": Key };




;// CONCATENATED MODULE: ./src/core/core_link.js



/**
 * @namespace external:CABLES#Link
 * @param {Object} scene The patch object
 * @description a link is a connection between two ops/ports -> one input and one output port
 * @hideconstructor
 * @class
 */
const Link = function (scene)
{
    EventTarget.apply(this);

    this.id = CABLES.simpleId();
    this.portIn = null;
    this.portOut = null;
    this.scene = scene; // todo: make private and rename to patch
    this.activityCounter = 0;
    this.ignoreInSerialize = false;
};

Link.prototype.setValue = function (v)
{
    if (v === undefined) this._setValue();
    else this.portIn.set(v);
};

Link.prototype.activity = function ()
{
    this.activityCounter++;
    // if(Date.now()-this.lastTime>100)
    // {
    //     // this.lastTime=Date.now();
    //     // this.changesPerSecond=this.changesCounter*10;
    //     this.changesCounter=0;
    // }
};

Link.prototype._setValue = function ()
{
    if (!this.portOut)
    {
        this.remove();
        return;
    }
    const v = this.portOut.get();

    if (v == v) // NaN is the only JavaScript value that is treated as unequal to itself
    {
        if (this.portIn.type != CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) this.activity();

        if (this.portIn.get() !== v)
        {
            this.portIn.set(v);
        }
        else
        {
            if (this.portIn.changeAlways) this.portIn.set(v);
            if (this.portOut.forceRefChange) this.portIn.forceChange();
        }
    }
};

/**
 * @function getOtherPort
 * @memberof Link
 * @instance
 * @param {Port} p port
 * @description returns the port of the link, which is not port
 */
Link.prototype.getOtherPort = function (p)
{
    if (p == this.portIn) return this.portOut;
    return this.portIn;
};

/**
 * @function remove
 * @memberof Link
 * @instance
 * @description unlink/remove this link from all ports
 */
Link.prototype.remove = function ()
{
    if (this.portIn) this.portIn.removeLink(this);
    if (this.portOut) this.portOut.removeLink(this);
    if (this.scene)
    {
        this.scene.emitEvent("onUnLink", this.portIn, this.portOut, this);
    }

    if (this.portIn && (this.portIn.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT || this.portIn.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY))
    {
        this.portIn.set(null);
        if (this.portIn.links.length > 0) this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());
    }

    if (this.portIn) this.portIn.op._checkLinksNeededToWork();
    if (this.portOut) this.portOut.op._checkLinksNeededToWork();

    this.portIn = null;
    this.portOut = null;
    this.scene = null;
};

/**
 * @function link
 * @memberof Link
 * @instance
 * @description link those two ports
 * @param {Port} p1 port1
 * @param {Port} p2 port2
 */
Link.prototype.link = function (p1, p2)
{
    if (!Link.canLink(p1, p2))
    {
        console.warn("[core_link] cannot link ports!", p1, p2);
        return false;
    }

    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN)
    {
        this.portIn = p1;
        this.portOut = p2;
    }
    else
    {
        this.portIn = p2;
        this.portOut = p1;
    }

    p1.addLink(this);
    p2.addLink(this);

    this.setValue();

    if (p1.onLink) p1.onLink(this);
    if (p2.onLink) p2.onLink(this);

    p1.op._checkLinksNeededToWork();
    p2.op._checkLinksNeededToWork();
};

Link.prototype.getSerialized = function ()
{
    const obj = {};

    obj.portIn = this.portIn.getName();
    obj.portOut = this.portOut.getName();
    obj.objIn = this.portIn.op.id;
    obj.objOut = this.portOut.op.id;

    return obj;
};

// --------------------------------------------

/**
 * @function canLinkText
 * @memberof Link
 * @instance
 * @description return a text message with human readable reason if ports can not be linked, or can be
 * @param {Port} p1 port1
 * @param {Port} p2 port2
 */
Link.canLinkText = function (p1, p2)
{
    if (p1.direction == p2.direction)
    {
        let txt = "(out)";
        if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN) txt = "(in)";
        return "can not link: same direction " + txt;
    }
    if (p1.op == p2.op) return "can not link: same op";
    if (p1.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)
    {
        if (p1.type != p2.type) return "can not link: different type";
    }

    if (CABLES.UI && p1.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT)
    {
        if (p1.uiAttribs.objType && p2.uiAttribs.objType)
            if (p1.uiAttribs.objType != p2.uiAttribs.objType)
                return "incompatible objects";
    }


    if (!p1) return "can not link: port 1 invalid";
    if (!p2) return "can not link: port 2 invalid";

    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return "can not link: is animated";
    if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return "can not link: is animated";

    // if(p1.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p1.links.length>0)return 'input port already busy';
    // if(p2.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p2.links.length>0)return 'input port already busy';
    if (p1.isLinkedTo(p2)) return "ports already linked";

    if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1))) return "Incompatible";

    return "can link";
};

/**
 * @function canLink
 * @memberof Link
 * @instance
 * @description return true if ports can be linked
 * @param {Port} p1 port1
 * @param {Port} p2 port2
 * @returns {Boolean}
 */
Link.canLink = function (p1, p2)
{
    if (!p1) return false;
    if (!p2) return false;
    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return false;
    if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return false;

    if (p1.isHidden() || p2.isHidden()) return false;

    if (p1.isLinkedTo(p2)) return false;

    if (p1.direction == p2.direction) return false;

    if (CABLES.UI && p1.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT)
    {
        if (p1.uiAttribs.objType && p2.uiAttribs.objType)
        {
            if (p1.uiAttribs.objType.indexOf("sg_") == 0 && p2.uiAttribs.objType.indexOf("sg_") == 0) return true;
            if (p1.uiAttribs.objType != p2.uiAttribs.objType)
                return false;
        }
    }

    if (p1.type != p2.type && (p1.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)) return false;
    if (p1.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC || p2.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;

    if (p1.op == p2.op) return false;

    if (p1.canLink && !p1.canLink(p2)) return false;
    if (p2.canLink && !p2.canLink(p1)) return false;

    return true;
};



;// CONCATENATED MODULE: ./src/core/core_port.js







/**
 * data is coming into and out of ops through input and output ports
 * @namespace external:CABLES#Port
 * @class
 * @hideconstructor
 * @param ___op
 * @param name
 * @param type
 * @param uiAttribs
 * @example
 * const myPort=op.inString("String Port");
 */
const Port = function (___op, name, type, uiAttribs)
{
    EventTarget.apply(this);

    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    this._log = new Logger("core_port");
    /**
     * @type {Number}
     * @name direction
     * @instance
     * @memberof Port
     * @description direction of port (input(0) or output(1))
     */
    this.direction = CONSTANTS.PORT.PORT_DIR_IN;
    this.id = String(CABLES.simpleId());
    this._op = ___op;

    /**
     * @type {Array<Link>}
     * @name links
     * @instance
     * @memberof Port
     * @description links of port
     */
    this.links = [];
    this.value = 0.0;
    this.name = name;
    this.type = type || CONSTANTS.OP.OP_PORT_TYPE_VALUE;
    this.uiAttribs = uiAttribs || {};
    this.anim = null;
    this._oldAnimVal = -5711;
    this.defaultValue = null;


    this._uiActiveState = true;
    this.ignoreValueSerialize = false;
    this.onLinkChanged = null;
    this.crashed = false;

    this._valueBeforeLink = null;
    this._lastAnimFrame = -1;
    this._animated = false;

    this.onValueChanged = null;
    this.onTriggered = null;
    this.onUiActiveStateChange = null;
    this.changeAlways = false;
    this.forceRefChange = false;

    this._useVariableName = null;

    this.activityCounter = 0;
    this.apf = 0;
    this.activityCounterStartFrame = 0;

    this._tempLastUiValue = null;

    Object.defineProperty(this, "title", {
        get()
        {
            return this.uiAttribs.title || this.name;
        } });

    Object.defineProperty(this, "parent", {
        get()
        {
            this._log.stack("use port.op, not .parent");
            return this._op;
        } });

    Object.defineProperty(this, "op", {
        get()
        {
            return this._op;
        } });

    Object.defineProperty(this, "val", {
        get()
        {
            // this._log.warn("val getter deprecated!", this);
            // this._log.stack("val getter deprecated");
            return this.get();
        },
        set(v)
        {
            // this._log.warn("val setter deprecated!", this);
            // this._log.stack("val setter deprecated");
            this.setValue(v);
        }
    });
};


/**
 * copy over a uiattrib from an external connected port to another port
 * @function copyLinkedUiAttrib
 * @memberof Port
 * @param {string} which attrib name
 * @param {Port} port source port
 * @instance
 * @example

inArray.onLinkChanged=()=>
{
    if(inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

 */
Port.prototype.copyLinkedUiAttrib = function (which, port)
{
    if (!CABLES.UI) return;
    if (!this.isLinked()) return;

    const attr = {};
    attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);
    port.setUiAttribs(attr);
};


// TODO make extend class for ports, like for ops only for ui
Port.prototype.getValueForDisplay = function ()
{
    let str = this.value;

    if (typeof this.value === "string" || this.value instanceof String)
    {
        if (str.length > 1000)
        {
            str = str.substring(0, 999);
            str += "...";
        }
        if (this.uiAttribs && (this.uiAttribs.display == "boolnum"))
        {
            str += " - ";

            if (!this.value) str += "false";
            else str += "true";
        }

        str = str.replace(/[\u00A0-\u9999<>\&]/g, function (i)
        {
            return "&#" + i.charCodeAt(0) + ";";
        });


        if (str.length > 100) str = str.substring(0, 100);
    }
    else
    {
        str = this.value;
    }
    return str;
};

/**
 * change listener for input value ports, overwrite to react to changes
 * @function onChange
 * @memberof Port
 * @instance
 * @example
 * const myPort=op.inString("MyPort");
 * myPort.onChange=function()
 * {
 *   console.log("was changed to: ",myPort.get());
 * }
 *
 */
Port.prototype.onAnimToggle = function () {};
Port.prototype._onAnimToggle = function ()
{
    this.onAnimToggle();
};


/**
 * @function remove
 * @memberof Port
 * @instance
 * @description remove port
 */
Port.prototype.remove = function ()
{
    // this.setUiAttribs({ "hidePort": true });
    this.removeLinks();
    this._op.removePort(this);
};

/**
 * set ui attributes
 * @function setUiAttribs
 * @memberof Port
 * @instance
 * @param {Object} newAttribs
 * <pre>
 * title - overwrite title of port (by default this is portname)
 * greyout - port paramater will appear greyed out, can not be
 * hidePort - port will be hidden from op
 * hideParam - port params will be hidden from parameter panel
 * showIndex - only for dropdowns - show value index (e.g. `0 - normal` )
 * editorSyntax - set syntax highlighting theme for editor port
 * ignoreObjTypeErrors - do not auto check object types
 * </pre>
 * @example
 * myPort.setUiAttribs({greyout:true});
 */
Port.prototype.setUiAttribs = function (newAttribs)
{
    let changed = false;
    if (!this.uiAttribs) this.uiAttribs = {};

    for (const p in newAttribs)
    {
        if (newAttribs[p] === undefined)
        {
            // delete newAttribs[p];
            delete this.uiAttribs[p];
            continue;
        }
        if (this.uiAttribs[p] != newAttribs[p]) changed = true;
        this.uiAttribs[p] = newAttribs[p];

        if (p == "group" && this.indexPort) this.indexPort.setUiAttribs({ "group": newAttribs[p] });
    }

    if (newAttribs.hasOwnProperty("expose")) this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);

    if (changed) this.emitEvent("onUiAttrChange", newAttribs, this);
};

/**
 * get ui attributes
 * @function getUiAttribs
 * @memberof Port
 * @example
 * myPort.getUiAttribs();
 */
Port.prototype.getUiAttribs = function ()
{
    return this.uiAttribs;
};

/**
 * get ui attribute
 * @function getUiAttrib
 * @memberof Port
 * @instance
 * @param {String} attribName
 * <pre>
 * attribName - return value of the ui-attribute, or null on unknown attribute
 * </pre>
 * @example
 * myPort.setUiAttribs("values");
 */
Port.prototype.getUiAttrib = function (attribName)
{
    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName))
    {
        return null;
    }
    return this.uiAttribs[attribName];
};

/**
 * @function get
 * @memberof Port
 * @instance
 * @description get value of port
 */
Port.prototype.get = function ()
{
    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum())
    {
        this._lastAnimFrame = this._op.patch.getFrameNum();

        let animval = this.anim.getValue(this._op.patch.timer.getTime());

        if (this.value != animval)
        {
            this.value = animval;
            this._oldAnimVal = this.value;
            this.forceChange();
        }
    }

    return this.value;
};

Port.prototype.setRef = function (v)
{
    this.forceRefChange = true;
    this.set(v);
};

/**
 * @function setValue
 * @memberof Port
 * @instance
 * @description set value of port / will send value to all linked ports (only for output ports)
 */
Port.prototype.set = Port.prototype.setValue = function (v)
{
    if (v === undefined) v = null;


    if (CABLES.UI && CABLES.UI.showDevInfos)
        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT && this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT && v && !this.forceRefChange)
            this._log.warn("object port uses .set", this.name, this.op.objName);


    if (this._op.enabled && !this.crashed)
    {
        if (v !== this.value || this.changeAlways || this.type == CONSTANTS.OP.OP_PORT_TYPE_TEXTURE || this.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY)
        {
            if (this._animated)
            {
                this.anim.setValue(this._op.patch.timer.getTime(), v);
            }
            else
            {
                try
                {
                    this.value = v;
                    this.forceChange();
                }
                catch (ex)
                {
                    this.crashed = true;

                    this.setValue = function (_v) {};
                    this.onTriggered = function () {};

                    this._log.error("exception in ", this._op);
                    this._log.error(ex);

                    this._op.patch.emitEvent("exception", ex, this._op);
                }

                if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) gui.texturePreview().updateTexturePort(this);
            }

            if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT) for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();
        }
    }
};

Port.prototype.updateAnim = function ()
{
    if (this._animated)
    {
        this.value = this.get();

        if (this._oldAnimVal != this.value || this.changeAlways)
        {
            this._oldAnimVal = this.value;
            this.forceChange();
        }
        this._oldAnimVal = this.value;
    }
};

Port.prototype.forceChange = function ()
{
    if (this.onValueChanged || this.onChange)
    {
        // very temporary: deprecated warning!!!!!!!!!
        // if(params.length>0) this._log.warn('TOM: port has onchange params!',this._op.objName,this.name);
    }
    this._activity();
    this.emitEvent("change", this.value, this);

    // try
    // {
    if (this.onChange) this.onChange(this, this.value);
    else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated
    // }
    // catch (e)
    // {
    //     console.log(e);
    // }
};

/**
 * @function getTypeString
 * @memberof Port
 * @instance
 * @description get port type as string, e.g. "Function","Value"...
 * @return {String} type
 */
Port.prototype.getTypeString = function ()
{
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_VALUE) return "Number";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return "Trigger";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return "Object";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return "Dynamic";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return "Array";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_STRING) return "String";
    return "Unknown";
};

Port.prototype.deSerializeSettings = function (objPort)
{
    if (!objPort) return;
    if (objPort.animated) this.setAnimated(objPort.animated);
    if (objPort.useVariable) this.setVariableName(objPort.useVariable);
    if (objPort.title) this.setUiAttribs({ "title": objPort.title });
    if (objPort.expose) this.setUiAttribs({ "expose": true });
    if (objPort.order) this.setUiAttribs({ "order": objPort.order });

    if (objPort.multiPortManual) this.setUiAttribs({ "multiPortManual": objPort.multiPortManual });
    if (objPort.multiPortNum) this.setUiAttribs({ "multiPortNum": objPort.multiPortNum });

    if (objPort.anim)
    {
        if (!this.anim) this.anim = new Anim({ "name": "port " + this.name });
        this._op._hasAnimPort = true;
        this.anim.addEventListener("onChange", () =>
        {
            this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
        if (objPort.anim.loop) this.anim.loop = objPort.anim.loop;
        for (const ani in objPort.anim.keys)
        {
            this.anim.keys.push(new ANIM.Key(objPort.anim.keys[ani]));
        }
        this.anim.sortKeys();
    }
};


Port.prototype.setInitialValue = function (v)
{
    if (this.op.preservedPortLinks[this.name])
    {
        for (let i = 0; i < this.op.preservedPortLinks[this.name].length; i++)
        {
            const lobj = this.op.preservedPortLinks[this.name][i];
            this.op.patch._addLink(
                lobj.objIn,
                lobj.objOut,
                lobj.portIn,
                lobj.portOut);
        }
    }


    if (this.op.preservedPortValues && this.op.preservedPortValues.hasOwnProperty(this.name) && this.op.preservedPortValues[this.name] !== undefined)
    {
        this.set(this.op.preservedPortValues[this.name]);
    }
    else
    if (v !== undefined) this.set(v);
    if (v !== undefined) this.defaultValue = v;
};




Port.prototype.getSerialized = function ()
{
    let obj = { "name": this.getName() };


    if (!this.ignoreValueSerialize && this.links.length === 0)
    {
        if (this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT && this.value && this.value.tex) {}
        else obj.value = this.value;
    }
    if (this._useVariableName) obj.useVariable = this._useVariableName;
    if (this._animated) obj.animated = true;
    if (this.anim) obj.anim = this.anim.getSerialized();
    if (this.uiAttribs.multiPortNum) obj.multiPortNum = this.uiAttribs.multiPortNum;
    if (this.uiAttribs.multiPortManual) obj.multiPortManual = this.uiAttribs.multiPortManual;

    if (this.uiAttribs.display == "file") obj.display = this.uiAttribs.display;
    if (this.uiAttribs.expose)
    {
        obj.expose = true;
        if (this.uiAttribs.hasOwnProperty("order")) obj.order = this.uiAttribs.order;
    }
    if (this.uiAttribs.title) obj.title = this.uiAttribs.title;
    if ((this.preserveLinks || this.direction == CONSTANTS.PORT.PORT_DIR_OUT) && this.links.length > 0)
    {
        obj.links = [];
        for (const i in this.links)
        {
            if (!this.links[i].ignoreInSerialize && (this.links[i].portIn && this.links[i].portOut)) obj.links.push(this.links[i].getSerialized());
        }
    }

    if (this.direction == CONSTANTS.PORT.PORT_DIR_IN && this.links.length > 0)
    {
        for (const i in this.links)
        {
            if (!this.links[i].portIn || !this.links[i].portOut) continue;

            const otherp = this.links[i].getOtherPort(this);
            // check if functions exist, are defined in core_extend_ops code in ui
            if (otherp.op.isInBlueprint2 && this.op.isInBlueprint2)
            {
                if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2())
                {
                    obj.links = obj.links || [];
                    obj.links.push(this.links[i].getSerialized());
                }
            }
        }
    }

    if (obj.links && obj.links.length == 0) delete obj.links;
    if (this.type === CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) delete obj.value;
    if (this.type === CONSTANTS.OP.OP_PORT_TYPE_FUNCTION && this.links.length == 0) obj = null;
    if (obj && Object.keys(obj).length == 1 && obj.name)obj = null; // obj is null if there is no real information other than name

    // console.log(obj);
    cleanJson(obj);

    return obj;
};

Port.prototype.shouldLink = function ()
{
    return true;
};

/**
 * @function removeLinks
 * @memberof Port
 * @instance
 * @description remove all links from port
 */
Port.prototype.removeLinks = function ()
{
    let count = 0;
    while (this.links.length > 0)
    {
        count++;
        if (count > 5000)
        {
            this._log.warn("could not delete links... / infinite loop");
            this.links.length = 0;
            break;
        }
        this.links[0].remove();
    }
};

/**
 * @function removeLink
 * @memberof Port
 * @instance
 * @description remove all link from port
 * @param {CABLES.Link} link
 */
Port.prototype.removeLink = function (link)
{
    for (const i in this.links)
        if (this.links[i] == link)
            this.links.splice(i, 1);

    if (this.direction == CONSTANTS.PORT.PORT_DIR_IN)
    {
        if (this.type == CONSTANTS.OP.OP_PORT_TYPE_VALUE) this.setValue(this._valueBeforeLink || 0);
        else this.setValue(this._valueBeforeLink || null);
    }

    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

    try
    {
        if (this.onLinkChanged) this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this.emitEvent("onLinkRemoved");
        this._op.emitEvent("onLinkChanged");
    }
    catch (e)
    {
        this._log.error(e);
    }
};

/**
 * @function getName
 * @memberof Port
 * @instance
 * @description return port name
 */
Port.prototype.getName = function ()
{
    return this.name;
};

/**
 * @function getTitle
 * @memberof Port
 * @instance
 * @description return port name or title
 */
Port.prototype.getTitle = function ()
{
    if (this.uiAttribs.title) return this.uiAttribs.title;
    return this.name;
};

Port.prototype.addLink = function (l)
{
    this._valueBeforeLink = this.value;
    this.links.push(l);
    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

    try
    {
        if (this.onLinkChanged) this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this._op.emitEvent("onLinkChanged");
    }
    catch (e)
    {
        this._log.error(e);
    }
};

/**
 * @function getLinkTo
 * @memberof Port
 * @instance
 * @param {Port} p2 otherPort
 * @description return link, which is linked to otherPort
 */
Port.prototype.getLinkTo = function (p2)
{
    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return this.links[i];
};

/**
 * @function removeLinkTo
 * @memberof Port
 * @instance
 * @param {Port} p2 otherPort
 * @description removes link, which is linked to otherPort
 */
Port.prototype.removeLinkTo = function (p2)
{
    for (const i in this.links)
    {
        if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
        {
            this.links[i].remove();
            if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

            if (this.onLinkChanged) this.onLinkChanged();
            this.emitEvent("onLinkChanged");
            this.emitEvent("onLinkRemoved");
            return;
        }
    }
};

/**
 * @function isLinkedTo
 * @memberof Port
 * @instance
 * @param {Port} p2 otherPort
 * @description returns true if port is linked to otherPort
 */
Port.prototype.isLinkedTo = function (p2)
{
    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return true;

    return false;
};

Port.prototype._activity = function ()
{
    this.activityCounter++;
};

/**
 * @function trigger
 * @memberof Port
 * @instance
 * @description trigger the linked port (usually invoked on an output function port)
 */
Port.prototype.trigger = function ()
{
    const linksLength = this.links.length;

    this._activity();
    if (linksLength === 0) return;
    if (!this._op.enabled) return;

    let portTriggered = null;
    try
    {
        for (let i = 0; i < linksLength; ++i)
        {
            if (this.links[i].portIn)
            {
                portTriggered = this.links[i].portIn;

                portTriggered.op.patch.pushTriggerStack(portTriggered);
                portTriggered._onTriggered();

                portTriggered.op.patch.popTriggerStack();
            }
            if (this.links[i]) this.links[i].activity();
        }
    }
    catch (ex)
    {
        portTriggered.op.enabled = false;

        if (this._op.patch.isEditorMode())
        {
            // this._op.patch.emitEvent("exception", ex, portTriggered.op);
            // this._op.patch.emitEvent("opcrash", portTriggered);
            // console.log("crash", portTriggered.op.objName);

            if (portTriggered.op.onError) portTriggered.op.onError(ex);
        }
        this._log.error("exception in port: ", portTriggered.name, portTriggered.op.name, portTriggered.op);
        this._log.error(ex);
    }
};

Port.prototype.call = function ()
{
    this._log.warn("call deprecated - use trigger() ");
    this.trigger();
};

Port.prototype.execute = function ()
{
    this._log.warn("### execute port: " + this.getName(), this.goals.length);
};

Port.prototype.setVariableName = function (n)
{
    this._useVariableName = n;


    this._op.patch.on("variableRename", (oldname, newname) =>
    {
        if (oldname != this._useVariableName) return;
        this._useVariableName = newname;
    });
};

Port.prototype.getVariableName = function ()
{
    return this._useVariableName;
};

Port.prototype.setVariable = function (v)
{
    this.setAnimated(false);
    const attr = { "useVariable": false };

    if (this._variableIn && this._varChangeListenerId)
    {
        this._variableIn.off(this._varChangeListenerId);
        this._variableIn = null;
    }

    if (v)
    {
        this._variableIn = this._op.patch.getVar(v);

        if (!this._variableIn)
        {
            this._log.warn("PORT VAR NOT FOUND!!!", v);
        }
        else
        {
            if (this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT)
            {
                this._varChangeListenerId = this._variableIn.on("change", () => { this.set(null); this.set(this._variableIn.getValue()); });
            }
            else
            {
                this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this));
            }
            this.set(this._variableIn.getValue());
        }
        this._useVariableName = v;
        attr.useVariable = true;
        attr.variableName = this._useVariableName;
    }
    else
    {
        attr.variableName = this._useVariableName = null;
        attr.useVariable = false;
    }

    this.setUiAttribs(attr);
    this._op.patch.emitEvent("portSetVariable", this._op, this, v);
};

Port.prototype._handleNoTriggerOpAnimUpdates = function (a)
{
    let hasTriggerPort = false;
    for (let i = 0; i < this._op.portsIn.length; i++)
    {
        if (this._op.portsIn.type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
        {
            hasTriggerPort = true;
            break;
        }
    }

    if (!hasTriggerPort)
    {
        if (a) this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame",
            () =>
            {
                this.updateAnim();
            });
        else this._op.patch.removeEventListener(this._notriggerAnimUpdate);
    }
};

Port.prototype.setAnimated = function (a)
{
    if (this._animated != a)
    {
        this._animated = a;
        this._op._hasAnimPort = true;

        if (this._animated && !this.anim)
        {
            this.anim = new Anim({ "name": "port " + this.name });
            this.anim.addEventListener("onChange", () =>
            {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
            });
        }
        this._onAnimToggle();
    }

    this._handleNoTriggerOpAnimUpdates(a);
    if (!a)
    {
        this.anim = null;
    }

    this.setUiAttribs({ "isAnimated": this._animated });
};

Port.prototype.toggleAnim = function ()
{
    this._animated = !this._animated;
    if (this._animated && !this.anim)
    {
        this.anim = new Anim({ "name": "port " + this.name });
        this.anim.addEventListener("onChange", () =>
        {
            this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
        });
    }
    this.setAnimated(this._animated);
    this._onAnimToggle();
    this.setUiAttribs({ "isAnimated": this._animated });
};

/**
 * <pre>
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_VALUE = 0;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION = 1;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT = 2;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE = 2;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_ARRAY = 3;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC = 4;
 * CABLES.CONSTANTS.OP.OP_PORT_TYPE_STRING = 5;
 * </pre>
 * @function getType
 * @memberof Port
 * @instance
 * @return {Number} type of port
 */
Port.prototype.getType = function ()
{
    return this.type;
};

/**
 * @function isLinked
 * @memberof Port
 * @instance
 * @return {Boolean} true if port is linked
 */
Port.prototype.isLinked = function ()
{
    return this.links.length > 0 || this._animated || this._useVariableName != null;
};

Port.prototype.isBoundToVar = function ()
{
    const b = this._useVariableName != null;
    this.uiAttribs.boundToVar = b;
    return b;
};
/**
 * @function isAnimated
 * @memberof Port
 * @instance
 * @return {Boolean} true if port is animated
 */
Port.prototype.isAnimated = function ()
{
    return this._animated;
};

/**
 * @function isHidden
 * @memberof Port
 * @instance
 * @return {Boolean} true if port is hidden
 */
Port.prototype.isHidden = function ()
{
    return this.uiAttribs.hidePort;
};

/**
 * @function onTriggered
 * @memberof Port
 * @instance
 * @param {function} a onTriggeredCallback
 * @description set callback, which will be executed when port was triggered (usually output port)
 */
Port.prototype._onTriggered = function (a)
{
    this._activity();
    this._op.updateAnims();
    if (this._op.enabled && this.onTriggered) this.onTriggered(a);

    if (this._op.enabled) this.emitEvent("trigger");
};

Port.prototype._onSetProfiling = function (v)
{
    this._op.patch.profiler.add("port", this);
    this.setValue(v);
    this._op.patch.profiler.add("port", null);
};

Port.prototype._onTriggeredProfiling = function ()
{
    if (this._op.enabled && this.onTriggered)
    {
        this._op.patch.profiler.add("port", this);
        this.onTriggered();
        this._op.patch.profiler.add("port", null);
    }
};



Port.prototype.getUiActiveState = function ()
{
    return this._uiActiveState;
};

Port.prototype.setUiActiveState = function (onoff)
{
    this._uiActiveState = onoff;
    if (this.onUiActiveStateChange) this.onUiActiveStateChange();
};

/**
 * @deprecated
 * @param {function} cb
 */
Port.prototype.onValueChange = function (cb)
{
    this.onChange = cb;
};

/**
 * @deprecated
 */
Port.prototype.hidePort = function () {};


/**
 * Returns the port type string, e.g. "value" based on the port type number
 * @function portTypeNumberToString
 * @instance
 * @memberof Port
 * @param {Number} type - The port type number
 * @returns {String} - The port type as string
 */
Port.portTypeNumberToString = function (type)
{
    if (type == CONSTANTS.OP.OP_PORT_TYPE_VALUE) return "value";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return "function";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return "object";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return "array";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_STRING) return "string";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return "dynamic";
    return "unknown";
};



;// CONCATENATED MODULE: ./src/core/core_port_switch.js




class SwitchPort extends Port
{
    constructor(__parent, name, type, uiAttribs, indexPort)
    {
        super(__parent, name, type, uiAttribs);

        this.get = () =>
        {
            let s = super.get();

            if (CABLES.UI)
            {
                if (
                    s === "" ||
                    s === null ||
                    s === undefined ||
                    (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)
                )
                {
                    this.op.setUiError("invalidswitch", "Invalid Value [" + this.name + "]: \"" + s + "\"", 1);
                }
                else this.op.setUiError("invalidswitch", null);
            }

            if (s === null || s === undefined)s = "";

            return s;
        };

        this.indexPort = indexPort;
        this.indexPort.set = (value) =>
        {
            const values = uiAttribs.values;

            if (!values)
            {
                // console.log("switch port has no values", this);
                return;
            }

            let intValue = Math.floor(value);

            intValue = Math.min(intValue, values.length - 1);
            intValue = Math.max(intValue, 0);

            this.indexPort.setValue(intValue);
            this.set(values[intValue]);

            if (this.op.patch.isEditorMode() && performance.now() - (this.lastTime || 0) > 100 && window.gui && gui.patchView.isCurrentOp(this.op))
            {
                gui.opParams.show(this.op);
                this.lastTime = performance.now();
            }
        };
    }

    setUiAttribs(attribs)
    {
        const hidePort = attribs.hidePort;
        attribs.hidePort = true;
        super.setUiAttribs(attribs);
        if (typeof hidePort !== "undefined")
        {
            this.indexPort.setUiAttribs({ hidePort });
        }
    }
}



;// CONCATENATED MODULE: ./src/core/core_port_select.js




class ValueSelectPort extends SwitchPort
{
    setUiAttribs(newAttribs)
    {
        // never unhide valuePort when indexPort is linked
        if (this.indexPort.isLinked())
        {
            for (const p in newAttribs)
            {
                if (p == "greyout" && !newAttribs[p]) newAttribs[p] = "true";
            }
        }
        super.setUiAttribs(newAttribs);
    }
}





;// CONCATENATED MODULE: ./src/core/core_port_multi.js



const MIN_NUM_PORTS = 2;

class MultiPort extends Port
{
    constructor(__parent, name, type, dir, uiAttribs, uiAttribsPorts)
    {
        super(__parent, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, uiAttribs);

        this.setUiAttribs({ "multiPort": true, "group": this.name, "order": -1 });
        this.ports = [];
        this.direction = dir;
        this._uiAttribsPorts = uiAttribsPorts;

        // console.log("uiattribs", uiAttribs);

        const updateArray = () =>
        {
            const arr = [];

            let ll = 1;
            if (this.uiAttribs.multiPortManual)ll = 0;

            for (let i = 0; i < this.ports.length - ll; i++)
                arr[i] = this.ports[i];

            this.setRef(arr);
        };

        const updateUi = () =>
        {
            let grey = !this.uiAttribs.multiPortManual || undefined;

            if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT)grey = false;

            for (let i = 0; i < this.ports.length; i++)
            {
                let lp; // undefined to remove/not set it
                // let opacity;// undefined to remove/not set it
                // let grey;// undefined to remove/not set it
                let addPort = false;
                let title;
                let o = {};


                // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
                if (this.op.preservedPortTitles && this.op.preservedPortTitles[this.ports[i].name]) title = this.op.preservedPortTitles[this.ports[i].name];


                // if (!this.uiAttribs.multiPortManual)grey = true;
                if (i == 0) lp = this.ports.length;

                if (!this.uiAttribs.multiPortManual)
                    if (i == this.ports.length - 1)
                    {
                        title = "add port";
                        addPort = true;
                        grey = true;
                    }

                for (const attin in this._uiAttribsPorts)
                {
                    o[attin] = this._uiAttribsPorts[attin];
                }

                o.addPort = addPort;
                o.longPort = lp;
                o.title = title;
                o.greyout = grey;
                o.group = this.name;

                this.ports[i].setUiAttribs(o);
            }
        };

        this.removeInvalidPorts = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                if (!this.ports[i]) this.ports.splice(i, 1);
            }

            if (!this.uiAttribs.multiPortManual)
            {
                if (this.ports.length > MIN_NUM_PORTS)

                    for (let i = this.ports.length - 1; i > 1; i--)
                    {
                        if (!this.ports[i].isLinked()) this.uiAttribs.multiPortNum = i;
                        else break;
                    }
            }

            updateArray();
        };

        this.countPorts = () =>
        {
            if (CABLES.UI && !gui.isRemoteClient && gui.patchView && gui.patchView.patchRenderer && gui.patchView.patchRenderer.isDraggingPort())
            {
                clearTimeout(this.retryTo);
                this.retryTo = setTimeout(this.countPorts.bind(this));
                return;
            }
            this.retryTo = null;

            let redo = false;
            this.removeListeners();
            this.removeInvalidPorts();

            for (let i = 0; i < this.ports.length; i++)
            {
                if (this.ports[i] && this.ports[i].links.length > 1)
                {
                    const po = this.ports[i + 1];
                    const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);

                    if (!po || !otherPort)
                    {
                        this._log.warn("no port found?");
                    }
                    else
                    {
                        this.ports[i].links[0].remove();
                        this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
                        redo = true;
                    }
                    break;
                }
            }

            if (!this.uiAttribs.multiPortManual)
            {
                let foundHole = true;
                while (foundHole)
                {
                    // console.log("search holes...");
                    foundHole = false;

                    for (let i = this.ports.length - 1; i > 1; i--)
                    {
                        if (this.ports[i] && this.ports[i].links.length > 0 && this.ports[i - 1].links.length == 0)
                        {
                            // console.log("found hole!");

                            // found hole
                            const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);
                            this.ports[i].links[0].remove();

                            const po = this.ports[i - 1];

                            if (po && this.ports[i])
                            {
                                // console.log("move ", this.ports[i].name, "to", po.name);
                                this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
                                foundHole = true;
                                redo = true;
                                break;
                            }
                        }
                    }


                    // this.checkNum();
                }

                // this.removeInvalidPorts();
            }


            if (!this.uiAttribs.multiPortManual) // if auto
            {
                while (this.ports.length > MIN_NUM_PORTS && !this.ports[this.ports.length - 1].isLinked() && !this.ports[this.ports.length - 2].isLinked())
                {
                    let i = this.ports.length - 1;
                    if (!this.ports[i].isLinked() && this.ports[i - 1] && !this.ports[i - 1].isLinked())
                    {
                        this.ports[i].setUiAttribs({ "removed": true });
                        this.ports[i].remove();
                        // this.ports[i] = null;
                        this.ports.splice(i, 1);
                    }
                }
            }

            this.removeInvalidPorts();

            if (!this.uiAttribs.multiPortManual && this.ports.length > 0 && this.ports[this.ports.length - 1].isLinked()) this.newPort();

            updateArray();
            updateUi();

            if (redo) this.countPorts();
            else this.addListeners();
        };

        this.removeListeners = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                const po = this.ports[i];
                po.multiPortChangeListener = po.off(po.multiPortChangeListener);
                po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
            }
        };

        this.addListeners = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                const po = this.ports[i];
                const idx = i;

                if (po.multiPortChangeListener)po.multiPortChangeListener = po.off(po.multiPortChangeListener);
                po.multiPortChangeListener = po.on("change", updateArray.bind(this));


                if (po.multiPortTriggerListener)po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
                po.multiPortTriggerListener = po.on("trigger", () => { this._onTriggered(idx); });


                // if (po.multiPortTriggerListener)po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
                // po.multiPortTriggerListener = po.on("trigger", this.trigger());

                if (po.multiLinkChangeListener)po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
                po.multiLinkChangeListener = po.on("onLinkChanged", () =>
                {
                    this.countPorts();
                    this.emitEvent("onLinkChanged");
                });

                if (po.multiLinkRemoveListener)po.multiLinkRemoveListener = po.off(po.multiLinkRemoveListener);
                po.multiLinkRemoveListener = po.on("onLinkRemoved", () =>
                {
                    // this.removeInvalidPorts();
                    // this.checkNum();
                    // this.countPorts();
                    updateUi();
                    this.emitEvent("onLinkChanged");
                    // this.countPorts.bind(this);
                });
            }
        };

        this.newPort = () =>
        {
            const attrs = {};
            // if (type == CABLES.OP_PORT_TYPE_STRING) attrs.type = "string";
            attrs.type = type;
            const po = new Port(this.op, name + "_" + this.ports.length, type, attrs);

            po.direction = dir;
            this.ports.push(po);
            // console.log("CONSTANTS.PORT_DIR_OUT", CONSTANTS.PORT.PORT_DIR_OUT, this.direction);
            if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT) this.op.addOutPort(po);
            else this.op.addInPort(po);

            if (type == CONSTANTS.OP.OP_PORT_TYPE_NUMBER) po.setInitialValue(0);
            else if (type == CONSTANTS.OP.OP_PORT_TYPE_STRING) po.setInitialValue("");

            this.addListeners();

            updateUi();
            updateArray();
            this.emitEvent("onLinkChanged");
            // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
            if (this.op.preservedPortTitles && this.op.preservedPortTitles[po.name]) po.setUiAttribs({ "title": this.op.preservedPortTitles[po.name] });

            return po;
        };

        this.initPorts = () =>
        {
            for (let i = 0; i < MIN_NUM_PORTS; i++) this.newPort();
            updateArray();
            updateUi();
        };

        this.checkNum = () =>
        {
            this.uiAttribs.multiPortNum = Math.max(MIN_NUM_PORTS, this.uiAttribs.multiPortNum);

            while (this.ports.length < this.uiAttribs.multiPortNum) this.newPort();
            while (this.ports.length > this.uiAttribs.multiPortNum) if (this.ports[this.ports.length - 1]) this.ports.pop().remove();

            this.removeInvalidPorts();
        };

        this.incDec = (incDir) =>
        {
            this.uiAttribs.multiPortNum = this.uiAttribs.multiPortNum || MIN_NUM_PORTS;
            // console.log("this.uiAttribs.multiPortNum", this.uiAttribs.multiPortNum, this.uiAttribs.multiPortNum + incDir);
            this.setUiAttribs({ "multiPortNum": this.uiAttribs.multiPortNum + incDir });
            this.checkNum();

            updateUi();
        };

        this.toggleManual = () =>
        {
            this.setUiAttribs({ "multiPortManual": !this.uiAttribs.multiPortManual });
            this.op.refreshParams();
        };

        this.on("onUiAttrChange", (attribs) =>
        {
            if (attribs.hasOwnProperty("multiPortManual"))
            {
                updateUi();
                this.removeInvalidPorts();
                this.checkNum();
                this.countPorts();
                updateUi();
            }
        });


        this.on("onUiAttrChange", this.checkNum.bind(this));
        this.checkNum();
        this.countPorts();
        this.removeInvalidPorts();
        updateUi();
    }
}





;// CONCATENATED MODULE: ./src/core/core_op.js









/**
 * op the class of all operators
 * @namespace external:CABLES#Op
 * @hideconstructor
 */

/**
 * @type {Object}
 * @name attachments
 * @instance
 * @memberof Op
 * @description access file attachments as String values
 * @example
 * // set shader source to attached files (files are called shader.vert / shader.frag)
 * shader.setSource(attachments.shader_vert,attachments.shader_frag);
 */

const Ops = {};

const Op = function ()
{
    EventTarget.apply(this);

    this._log = new Logger("core_op");
    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    this.storage = {}; // op-specific data to be included in export
    this.__objName = "";
    this.portsOut = [];
    this.portsIn = [];
    this.portsInData = []; // original loaded patch data
    this.opId = ""; // unique op id
    this.uiAttribs = {};
    this.enabled = true;
    this.patch = arguments[0];
    this._name = arguments[1];
    this.preservedPortTitles = {};
    this.preservedPortValues = {};
    this.preservedPortLinks = {};

    this._linkTimeRules = {
        "needsLinkedToWork": [],
        "needsParentOp": null
    };

    this.shouldWork = {};
    this.hasUiErrors = false;
    this._uiErrors = {};
    this._hasAnimPort = false;

    if (arguments[1])
    {
        this._shortOpName = CABLES.getShortOpName(arguments[1]);
        this.getTitle();
    }

    this.id = arguments[2] || shortId(); // instance id
    this.onAddPort = null;
    this.onCreate = null;
    this.onResize = null;
    this.onLoaded = null;
    this.onDelete = null;
    this.onError = null;

    this._instances = null;

    /**
     * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`
     * @function preRender
     * @memberof Op
     * @instance
     */
    this.preRender = null;

    /**
     * overwrite this to initialize your op
     * @function init
     * @memberof Op
     * @instance
     */
    this.init = null;

    Object.defineProperty(this, "name", {
        get() { return this.getTitle(); },
        set(v)
        {
            this.setTitle(v);
        }
    });

    Object.defineProperty(this, "_objName", { set(on)
    {
        this.__objName = on; this._log = new Logger("op " + on);
    } });

    Object.defineProperty(this, "objName", { get() { return this.__objName; } });
    Object.defineProperty(this, "shortName", { get() { return this._shortOpName; } });

    if (this.initUi) this.initUi();
};

{
    Op.prototype.clearUiAttrib = function (name)
    {
        const obj = {};
        // obj.name = null;
        this.uiAttrib(obj);
    };

    Op.prototype.require = function (name)
    {
        if (CABLES.platform && CABLES.StandaloneElectron && !CABLES.platform.frontendOptions.isStandalone)
            this.setUiError("notstandalone", "This op will only work in cables standalone version", 3);

        return null;
    };


    Op.prototype.checkMainloopExists = function ()
    {
        if (!CABLES.UI) return;
        if (!this.patch.tempData.mainloopOp) this.setUiError("nomainloop", "patch should have a mainloop to use this op");
        else this.setUiError("nomainloop", null);
    };

    Op.prototype.getTitle = function ()
    {
        if (!this.uiAttribs) return "nouiattribs" + this._name;

        // if ((this.uiAttribs.title === undefined || this.uiAttribs.title === "") && this.objName.indexOf("Ops.Ui.") == -1)
        //     this.uiAttribs.title = this._shortOpName;

        return this.uiAttribs.title || this._shortOpName;
    };

    Op.prototype.setTitle = function (title)
    {
        // this._log.log("settitle", title);
        // this._log.log(
        //     (new Error()).stack
        // );

        if (title != this.getTitle()) this.uiAttr({ "title": title });
    };

    Op.prototype.setStorage = function (newAttribs)
    {
        if (!newAttribs) return;
        this.storage = this.storage || {};

        let changed = false;
        for (const p in newAttribs)
        {
            if (this.storage[p] != newAttribs[p]) changed = true;
            this.storage[p] = newAttribs[p];
        }

        if (changed) this.emitEvent("onStorageChange", newAttribs);
    };

    Op.prototype.isSubPatchOp = function ()
    {
        if (this.patchId && this.storage) return (this.storage.subPatchVer || this.storage.blueprintVer || 0);
        return false;
    };

    const _setUiAttrib = function (newAttribs)
    {
        if (!newAttribs) return;

        if (newAttribs.error || newAttribs.warning || newAttribs.hint)
        {
            this._log.warn("old ui error/warning attribute in " + this._name + ", use op.setUiError !", newAttribs);
        }


        if (typeof newAttribs != "object") this._log.error("op.uiAttrib attribs are not of type object");
        if (!this.uiAttribs) this.uiAttribs = {};

        let changed = false;
        let emitMove = false;
        if (
            CABLES.UI &&
            newAttribs.hasOwnProperty("translate") &&
            (
                !this.uiAttribs.translate ||
                this.uiAttribs.translate.x != newAttribs.translate.x ||
                this.uiAttribs.translate.y != newAttribs.translate.y
            )) emitMove = true;


        if (newAttribs.hasOwnProperty("title") && newAttribs.title != this.uiAttribs.title)
        {
            // const doEmitEvent = newAttribs.title != this.getTitle();
            this.uiAttribs.title = newAttribs.title;
            // if (doEmitEvent) this.emitEvent("onTitleChange", newAttribs.title);
            changed = true;
            // this.setTitle(newAttribs.title);
        }

        if (newAttribs.hasOwnProperty("disabled")) this.setEnabled(!newAttribs.disabled);

        for (const p in newAttribs)
        {
            if (this.uiAttribs[p] != newAttribs[p]) changed = true;
            this.uiAttribs[p] = newAttribs[p];
        }


        if (this.uiAttribs.hasOwnProperty("selected") && this.uiAttribs.selected == false) delete this.uiAttribs.selected;


        if (changed)
        {
            this.emitEvent("onUiAttribsChange", newAttribs);
            this.patch.emitEvent("onUiAttribsChange", this, newAttribs);
        }


        if (emitMove) this.emitEvent("move");
    };
    /**
     * setUiAttrib
     * possible values:
     * <pre>
     * warning - warning message - showing up in op parameter panel
     * error - error message - showing up in op parameter panel
     * extendTitle - op title extension, e.g. [ + ]
     * </pre>
     * @function setUiAttrib
     * @param {Object} newAttribs, e.g. {"attrib":value}
     * @memberof Op
     * @instance
     * @example
     * op.setUiAttrib({"extendTitle":str});
     */
    Op.prototype.setUiAttribs = Op.prototype.setUiAttrib = Op.prototype.uiAttr = _setUiAttrib;

    Op.prototype.getName = function ()
    {
        if (this.uiAttribs.name) return this.uiAttribs.name;
        return this._name;
    };

    Op.prototype.addOutPort = function (p)
    {
        p.direction = CONSTANTS.PORT.PORT_DIR_OUT;
        p._op = this;
        this.portsOut.push(p);
        this.emitEvent("onPortAdd", p);
        return p;
    };

    Op.prototype.hasDynamicPort = function ()
    {
        let i = 0;
        for (i = 0; i < this.portsIn.length; i++)
        {
            if (this.portsIn[i].type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;
            if (this.portsIn[i].getName() == "dyn") return true;
        }
        for (i = 0; i < this.portsOut.length; i++)
        {
            if (this.portsOut[i].type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;
            if (this.portsOut[i].getName() == "dyn") return true;
        }

        return false;
    };

    Op.prototype.addInPort = function (p)
    {
        if (!(p instanceof Port)) throw new Error("parameter is not a port!");

        p.direction = CONSTANTS.PORT.PORT_DIR_IN;
        p._op = this;

        this.portsIn.push(p);
        this.emitEvent("onPortAdd", p);

        return p;
    };

    /**
     * create a trigger input port
     * @function inTrigger
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     *
     */
    Op.prototype.inFunction = Op.prototype.inTrigger = function (name, v)
    {
        const p = this.addInPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));
        if (v !== undefined) p.set(v);
        return p;
    };

    /**
     * create multiple UI trigger buttons
     * @function inTriggerButton
     * @memberof Op
     * @instance
     * @param {String} name
     * @param {Array} names
     * @return {Port} created port
     */
    Op.prototype.inFunctionButton = Op.prototype.inTriggerButton = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {
                "display": "button"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    };

    Op.prototype.inFunctionButton = Op.prototype.inUiTriggerButtons = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {
                "display": "buttons"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    };



    /**
     * create a number value input port
     * @function inFloat
     * @memberof Op
     * @instance
     * @param {String} name
     * @param {Number} value
     * @return {Port} created port
     */
    Op.prototype.inValueFloat = Op.prototype.inValue = Op.prototype.inFloat = function (name, v)
    {
        const p = this.addInPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE));

        p.setInitialValue(v);

        return p;
    };

    /**
     * create a boolean input port, displayed as a checkbox
     * @function inBool
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Boolean} value
     * @return {Port} created port
     */
    Op.prototype.inValueBool = Op.prototype.inBool = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_NUMBER, {
                "display": "bool"
            })
        );

        if (v === true)v = 1;
        if (v === false)v = 0;
        p.setInitialValue(v);

        return p;
    };


    Op.prototype.inMultiPort = function (name, type)
    {
        const p = new MultiPort(
            this,
            name,
            type,
            CONSTANTS.PORT.PORT_DIR_IN,
            {
                "addPort": true,
                "hidePort": true
            }
        );
        p.ignoreValueSerialize = true;

        this.addInPort(p);
        p.initPorts();

        return p;
    };

    Op.prototype.outMultiPort = function (name, type, uiAttribsPort = {})
    {
        const p = new MultiPort(
            this,
            name,
            type,
            CONSTANTS.PORT.PORT_DIR_OUT,
            {
                "display": "multiport",
                "hidePort": true
            },
            uiAttribsPort
        );
        p.ignoreValueSerialize = true;

        this.addOutPort(p);
        p.initPorts();

        return p;
    };



    Op.prototype.inValueString = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "type": "string"
            })
        );
        p.value = "";

        p.setInitialValue(v);
        return p;
    };

    /**
     * create a String value input port
     * @function inString
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inString = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "type": "string"
            })
        );
        v = v || "";
        // p.value = v;

        p.setInitialValue(v);
        return p;
    };

    /**
     * create a String value input port displayed as TextArea
     * @function inValueText
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueText = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "type": "string",
                "display": "text"
            })
        );
        p.value = "";

        p.setInitialValue(v);
        // if (v !== undefined)
        // {
        //     p.set(v);
        //     p.defaultValue = v;
        // }
        return p;
    };

    Op.prototype.inTextarea = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "type": "string",
                "display": "text"
            })
        );
        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    /**
     * create a String value input port displayed as editor
     * @function inStringEditor
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    // new string
    Op.prototype.inStringEditor = function (name, v, syntax, hideFormatButton = true)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "type": "string",
                "display": "editor",
                "editShortcut": true,
                "editorSyntax": syntax,
                "hideFormatButton": hideFormatButton
            }));

        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    // old
    Op.prototype.inValueEditor = function (name, v, syntax, hideFormatButton = true)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_NUMBER, {
                "type": "string",
                "display": "editor",
                "editorSyntax": syntax,
                "hideFormatButton": hideFormatButton
            })
        );
        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    /**
     * create a string select box
     * @function inDropDown
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} values
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueSelect = Op.prototype.inDropDown = function (name, values, v, noindex)
    {
        let p = null;
        if (!noindex)
        {
            const indexPort = new Port(this, name + " index", CONSTANTS.OP.OP_PORT_TYPE_NUMBER, {
                "increment": "integer",
                "hideParam": true
            });
            const n = this.addInPort(indexPort);

            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

            const valuePort = new ValueSelectPort(
                this,
                name,
                CONSTANTS.OP.OP_PORT_TYPE_NUMBER,
                {
                    "display": "dropdown",
                    "hidePort": true,
                    "type": "string",
                    "values": values
                },
                n
            );

            valuePort.indexPort = indexPort;

            valuePort.on("change", (val, thePort) =>
            {
                if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values)
                {
                    const idx = thePort.uiAttribs.values.indexOf(val);
                    if (idx > -1) thePort.indexPort.set(idx);
                }
            });

            indexPort.onLinkChanged = function ()
            {
                valuePort.setUiAttribs({ "greyout": indexPort.isLinked() });
            };

            p = this.addInPort(valuePort);

            if (v !== undefined)
            {
                p.set(v);
                const index = values.findIndex((item) => { return item == v; });
                n.setValue(index);
                p.defaultValue = v;
                n.defaultValue = index;
            }
        }
        else
        {
            const valuePort = new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "display": "dropdown",
                "hidePort": true,
                "type": "string",
                values
            });

            p = this.addInPort(valuePort);
        }

        return p;
    };

    /**
     * create a string switch box
     * @function inSwitch
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} values
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inSwitch = function (name, values, v, noindex)
    {
        let p = null;
        if (!noindex)
        {
            if (!v)v = values[0];
            const indexPort = new Port(this, name + " index", CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "increment": "integer",
                "values": values,
                "hideParam": true
            });
            const n = this.addInPort(indexPort);

            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

            const switchPort = new SwitchPort(
                this,
                name,
                CONSTANTS.OP.OP_PORT_TYPE_STRING,
                {
                    "display": "switch",
                    "hidePort": true,
                    "type": "string",
                    "values": values
                },
                n
            );

            switchPort.indexPort = indexPort;

            switchPort.on("change", (val, thePort) =>
            {
                if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values)
                {
                    const idx = thePort.uiAttribs.values.indexOf(val);
                    if (idx > -1) thePort.indexPort.set(idx);
                }
            });

            indexPort.onLinkChanged = function ()
            {
                switchPort.setUiAttribs({ "greyout": indexPort.isLinked() });
            };
            p = this.addInPort(switchPort);

            if (v !== undefined)
            {
                p.set(v);
                const index = values.findIndex((item) => { return item == v; });
                n.setValue(index);
                p.defaultValue = v;
                n.defaultValue = index;
            }
        }
        else
        {
            const switchPort = new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "display": "switch",
                "hidePort": true,
                "type": "string",
                "values": values
            });
            p = this.addInPort(switchPort);
        }

        return p;
    };

    /**
     * create a integer input port
     * @function inInt
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueInt = Op.prototype.inInt = function (name, v)
    {
        // old
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "increment": "integer"
            })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    /**
     * create a file/URL input port
     * @function inURL
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inFile = function (name, filter, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "display": "file",
                "type": "string",
                "filter": filter
            })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    Op.prototype.inUrl = function (name, filter, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "display": "file",
                "type": "string",
                "filter": filter
            })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    /**
     * create a texture input port
     * @function inTexture
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inTexture = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
                "display": "texture",
                "objType": "texture",
                "preview": true
            })
        );
        p.ignoreValueSerialize = true;
        if (v !== undefined) p.set(v);
        return p;
    };


    /**
     * create a object input port
     * @function inObject
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inObject = function (name, v, objType)
    {
        const p = this.addInPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { "objType": objType }));
        p.ignoreValueSerialize = true;

        if (v !== undefined) p.set(v);
        return p;
    };

    Op.prototype.inGradient = function (name, v)
    {
        const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "display": "gradient"
                // "hidePort": true
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    };


    Op.prototype.getPortVisibleIndex = function (p)
    {
        let ports = this.portsIn;
        if (p.direction == CONSTANTS.PORT_DIR_OUT)ports = this.portsOut;

        let index = 0;
        for (let i = 0; i < ports.length; i++)
        {
            if (ports[i].uiAttribs.hidePort) continue;
            index++;
            if (ports[i] == p) return index;
        }
    };

    /**
     * create a array input port
     * @function inArray
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inArray = function (name, v, stride)
    {
        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;

        const p = this.addInPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { "stride": stride }));

        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

        // if (v !== undefined) p.set(v);
        return p;
    };

    /**
     * create a value slider input port
     * @function inFloatSlider
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} defaultvalue
     * @param {number} min
     * @param {number} max
     * @return {Port} created port
     */
    Op.prototype.inValueSlider = Op.prototype.inFloatSlider = function (name, v, min, max)
    {
        const uiattribs = { "display": "range" };

        if (min != undefined && max != undefined)
        {
            uiattribs.min = min;
            uiattribs.max = max;
        }

        const p = this.addInPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, uiattribs));
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    /**
     * create output trigger port
     * @function outTrigger
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outFunction = Op.prototype.outTrigger = function (name, v)
    {
        // old
        const p = this.addOutPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));
        if (v !== undefined) p.set(v);
        return p;
    };

    /**
     * create output value port
     * @function outNumber
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} default value
     * @return {Port} created port
     */
    Op.prototype.outValue = Op.prototype.outNumber = function (name, v)
    {
        // old
        const p = this.addOutPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE));
        if (v !== undefined) p.set(v);
        return p;
    };

    /**
     * deprecated create output boolean port
     * @deprecated
     * @function outBool
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outValueBool = Op.prototype.outBool = function (name, v)
    {
        // old: use outBoolNum
        const p = this.addOutPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "display": "bool"
            })
        );
        if (v !== undefined) p.set(v);
        else p.set(0);
        return p;
    };

    /**
     * create output boolean port,value will be converted to 0 or 1
     * @function outBoolNum
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outBoolNum = function (name, v)
    {
        const p = this.addOutPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "display": "boolnum"
            })
        );

        p.set = function (b)
        {
            this.setValue(b ? 1 : 0);
            // this._log.log("bool set", b, this.get());
        }.bind(p);

        if (v !== undefined) p.set(v);
        else p.set(0);
        return p;
    };

    /**
     * create output string port
     * @function outString
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outValueString = function (name, v)
    {
        const p = this.addOutPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
                "type": "string"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    };
    Op.prototype.outString = function (name, v)
    {
        const p = this.addOutPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
                "type": "string"
            })
        );
        if (v !== undefined) p.set(v);
        else p.set("");
        return p;
    };

    /**
     * create output object port
     * @function outObject
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outObject = function (name, v, objType)
    {
        const p = this.addOutPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { "objType": objType || null }));
        p.set(v || null);
        p.ignoreValueSerialize = true;
        return p;
    };

    /**
     * create output array port
     * @function outArray
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outArray = function (name, v, stride)
    {
        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;
        const p = this.addOutPort(new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { "stride": stride }));
        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

        p.ignoreValueSerialize = true;
        return p;
    };

    /**
     * create output texture port
     * @function outTexture
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outTexture = function (name, v)
    {
        const p = this.addOutPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
                "preview": true,
                "objType": "texture",
                "display": "texture"
            })
        );
        if (v !== undefined) p.setRef(v || CGL.Texture.getEmptyTexture(this.patch.cgl));

        p.ignoreValueSerialize = true;
        return p;
    };

    Op.prototype.inDynamic = function (name, filter, options, v)
    {
        const p = new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC, options);

        p.shouldLink = function (p1, p2)
        {
            if (filter && UTILS.isArray(filter))
            {
                for (let i = 0; i < filter.length; i++)
                {
                    if (p1 == this && p2.type === filter[i]) return true;
                    if (p2 == this && p1.type === filter[i]) return true;
                }
                return false; // types do not match
            }
            return true; // no filter set
        };

        this.addInPort(p);
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    };

    Op.prototype.removeLinks = function ()
    {
        for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].removeLinks();
        for (let i = 0; i < this.portsOut.length; i++) this.portsOut[i].removeLinks();
    };

    Op.prototype.getSerialized = function ()
    {
        const opObj = {};

        if (this.opId) opObj.opId = this.opId;
        if (this.patch.storeObjNames) opObj.objName = this.objName;

        opObj.id = this.id;
        opObj.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};

        if (this.storage && Object.keys(this.storage).length > 0) opObj.storage = JSON.parse(JSON.stringify(this.storage));
        if (this.uiAttribs.hasOwnProperty("working") && this.uiAttribs.working == true) delete this.uiAttribs.working;
        if (opObj.uiAttribs.hasOwnProperty("uierrors")) delete opObj.uiAttribs.uierrors;

        if (opObj.uiAttribs.title === "") delete opObj.uiAttribs.title;
        if (opObj.uiAttribs.color === null) delete opObj.uiAttribs.color;
        if (opObj.uiAttribs.comment === null) delete opObj.uiAttribs.comment;

        if (opObj.uiAttribs.title == this._shortOpName ||
            (this.uiAttribs.title || "").toLowerCase() == this._shortOpName.toLowerCase()) delete opObj.uiAttribs.title;

        opObj.portsIn = [];
        opObj.portsOut = [];

        for (let i = 0; i < this.portsIn.length; i++)
        {
            const s = this.portsIn[i].getSerialized();
            if (s) opObj.portsIn.push(s);
        }

        for (let i = 0; i < this.portsOut.length; i++)
        {
            const s = this.portsOut[i].getSerialized();
            if (s) opObj.portsOut.push(s);
        }

        if (opObj.portsIn.length == 0) delete opObj.portsIn;
        if (opObj.portsOut.length == 0) delete opObj.portsOut;
        cleanJson(opObj);

        return opObj;
    };

    Op.prototype.getFirstOutPortByType = function (type)
    {
        for (const ipo in this.portsOut) if (this.portsOut[ipo].type == type) return this.portsOut[ipo];
    };

    Op.prototype.getFirstInPortByType = function (type)
    {
        for (const ipo in this.portsIn) if (this.portsIn[ipo].type == type) return this.portsIn[ipo];
    };

    /**
     * return port by the name portName
     * @function getPort
     * @instance
     * @memberof Op
     * @param {String} portName
     * @return {Port}
     */
    Op.prototype.getPort = Op.prototype.getPortByName = function (name, lowerCase)
    {
        if (lowerCase)
        {
            for (let ipi = 0; ipi < this.portsIn.length; ipi++)
                if (this.portsIn[ipi].getName().toLowerCase() == name || this.portsIn[ipi].id.toLowerCase() == name)
                    return this.portsIn[ipi];

            for (let ipo = 0; ipo < this.portsOut.length; ipo++)
                if (this.portsOut[ipo].getName().toLowerCase() == name || this.portsOut[ipo].id.toLowerCase() == name)
                    return this.portsOut[ipo];
        }
        else
        {
            for (let ipi = 0; ipi < this.portsIn.length; ipi++)
                if (this.portsIn[ipi].getName() == name || this.portsIn[ipi].id == name)
                    return this.portsIn[ipi];

            for (let ipo = 0; ipo < this.portsOut.length; ipo++)
                if (this.portsOut[ipo].getName() == name || this.portsOut[ipo].id == name)
                    return this.portsOut[ipo];
        }
    };


    /**
     * return port by the name id
     * @function getPortById
     * @instance
     * @memberof Op
     * @param {String} id
     * @return {Port}
     */
    Op.prototype.getPortById = function (id)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++) if (this.portsIn[ipi].id == id) return this.portsIn[ipi];
        for (let ipo = 0; ipo < this.portsOut.length; ipo++) if (this.portsOut[ipo].id == id) return this.portsOut[ipo];
    };

    Op.prototype.updateAnims = function ()
    {
        if (this._hasAnimPort)
            for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].updateAnim();
    };

    Op.prototype.log = function ()
    {
        this._log.log(...arguments);
    };

    Op.prototype.error = Op.prototype.logError = function ()
    {
        // if (!this)
        // {
        //     this._log.error("no this...!!!");
        //     debugger;
        //     return;
        // }
        // const initiator = "op " + this.objName;
        // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 2 }, ...arguments)) return;

        // // if (this.patch.silent) return;
        // const args = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
        // args.push.apply(args, arguments);
        // Function.prototype.apply.apply(this._log.error, [console, args]);// eslint-disable-line
        // if (window.gui) window.gui.emitEvent("opLogEvent", this.objName, "error", arguments);
        this._log.error(...arguments);
    };

    Op.prototype.warn = Op.prototype.logWarn = function ()
    {
        this._log.warn(...arguments);

        // const initiator = "op " + this.objName;
        // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 1 }, ...arguments)) return;

        // // if (this.patch.silent) return;
        // const args = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
        // args.push.apply(args, arguments);
        // Function.prototype.apply.apply(this._log.warn, [console, args]);// eslint-disable-line
    };

    Op.prototype.verbose = Op.prototype.logVerbose = function ()
    {
        // const initiator = "op " + CABLES.getShortOpName(this.objName);
        // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 0 }, ...arguments)) return;

        // if (!CABLES.UI && this.patch.silent) return;

        // const args = ["[" + initiator + "]"];
        // args.push.apply(args, arguments);
        // Function.prototype.apply.apply(this._log.info, [console, args]);// eslint-disable-line
        this._log.verbose(...arguments);
    };


    Op.prototype.profile = function (enable)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        {
            this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;
            this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;
        }
    };

    Op.prototype.findParent = function (objName)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        {
            if (this.portsIn[ipi].isLinked())
            {
                if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)
                    return this.portsIn[ipi].links[0].portOut.parent;

                let found = null;
                found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);
                if (found) return found;
            }
        }
        return null;
    };


    // todo: check instancing stuff?
    Op.prototype.cleanUp = function ()
    {
        if (this._instances)
        {
            for (let i = 0; i < this._instances.length; i++)
            {
                if (this._instances[i].onDelete) this._instances[i].onDelete();
            }


            this._instances.length = 0;
        }
        for (let i = 0; i < this.portsIn.length; i++)
        {
            this.portsIn[i].setAnimated(false);
        }

        if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);
    };

    // todo: check instancing stuff?
    Op.prototype.instanced = function (triggerPort)
    {
        return false;
        // this._log.log("instanced", this.patch.instancing.numCycles());
        // if (this.patch.instancing.numCycles() === 0) return false;


        // let i = 0;
        // let ipi = 0;
        // if (!this._instances || this._instances.length != this.patch.instancing.numCycles())
        // {
        //     if (!this._instances) this._instances = [];
        //     this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length);
        //     this._instances.length = this.patch.instancing.numCycles();

        //     for (i = 0; i < this._instances.length; i++)
        //     {
        //         this._instances[i] = this.patch.createOp(this.objName, true);
        //         this._instances[i].instanced = function ()
        //         {
        //             return false;
        //         };
        //         this._instances[i].uiAttr(this.uiAttribs);

        //         for (let ipo = 0; ipo < this.portsOut.length; ipo++)
        //         {
        //             if (this.portsOut[ipo].type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
        //             {
        //                 this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);
        //             }
        //         }
        //     }

        //     for (ipi = 0; ipi < this.portsIn.length; ipi++)
        //     {
        //         this.portsIn[ipi].onChange = null;
        //         this.portsIn[ipi].onValueChanged = null;
        //     }
        // }

        // const theTriggerPort = null;
        // for (ipi = 0; ipi < this.portsIn.length; ipi++)
        // {
        //     if (
        //         this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_VALUE ||
        //         this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY
        //     )
        //     {
        //         this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());
        //     }
        //     if (this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
        //     {
        //         // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)
        //         // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];
        //     }
        // }

        // if (theTriggerPort) theTriggerPort.onTriggered();

        // for (ipi = 0; ipi < this.portsOut.length; ipi++)
        // {
        //     if (this.portsOut[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_VALUE)
        //     {
        //         this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());
        //     }
        // }

        // return true;
    };

    // todo: check instancing stuff?
    Op.prototype.initInstancable = function ()
    {
        //         if(this.isInstanced)
        //         {
        //             this._log.log('cancel instancing');
        //             return;
        //         }
        //         this._instances=[];
        //         for(var ipi=0;ipi<this.portsIn.length;ipi++)
        //         {
        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_VALUE)
        //             {
        //
        //             }
        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
        //             {
        //                 // var piIndex=ipi;
        //                 this.portsIn[ipi].onTriggered=function(piIndex)
        //                 {
        //
        //                     var i=0;
        // // this._log.log('trigger',this._instances.length);
        //
        //                 }.bind(this,ipi );
        //
        //             }
        // };
        // this._instances=null;
    };

    Op.prototype.setValues = function (obj)
    {
        for (const i in obj)
        {
            const port = this.getPortByName(i);
            if (port) port.set(obj[i]);
            else this._log.warn("op.setValues: port not found:", i);
        }
    };

    /**
     * return true if op has this error message id
     * @function hasUiError
     * @instance
     * @memberof Op
     * @param {id} error id
     * @returns {Boolean} - has id
     */
    Op.prototype.hasUiError = function (id)
    {
        return this._uiErrors.hasOwnProperty(id) && this._uiErrors[id];
    };

    /**
     * show op error message - set message to null to remove error message
     * @function setUiError
     * @instance
     * @memberof Op
     * @param {id} error id
     * @param {txt} text message
     * @param {level} level
     */
    Op.prototype.setUiError = function (id, txt, level)
    {
        // overwritten in ui: core_extend_op
    };

    // todo: remove
    Op.prototype.setError = function (id, txt)
    {
        this._log.warn("old error message op.error() - use op.setUiError()");
    };


    /**
     * enable/disable op
     * @function
     * @instance
     * @memberof Op
     * @param {boolean}
     */
    Op.prototype.setEnabled = function (b)
    {
        this.enabled = b;
        this.emitEvent("onEnabledChange", b);
    };

    /**
     * organize ports into a group
     * @function
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} ports
     */
    Op.prototype.setPortGroup = function (name, ports)
    {
        for (let i = 0; i < ports.length; i++)
        {
            if (ports[i])
                if (ports[i].setUiAttribs) ports[i].setUiAttribs({ "group": name });
                else
                {
                    this._log.error("setPortGroup: invalid port!");
                }
        }
    };

    /**
     * visually indicate ports that they are coordinate inputs
     * @function
     * @instance
     * @memberof Op
     * @param {Port} portX
     * @param {Port} portY
     * @param {Port} portZ
     */
    Op.prototype.setUiAxisPorts = function (px, py, pz)
    {
        if (px) px.setUiAttribs({ "axis": "X" });
        if (py) py.setUiAttribs({ "axis": "Y" });
        if (pz) pz.setUiAttribs({ "axis": "Z" });
    };

    /**
     * remove port from op
     * @function removePort
     * @instance
     * @memberof Op
     * @param {Port} port to remove
     */
    Op.prototype.removePort = function (port)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        {
            if (this.portsIn[ipi] == port)
            {
                this.portsIn.splice(ipi, 1);
                this.emitEvent("onUiAttribsChange", {});
                this.emitEvent("onPortRemoved", {});
                return;
            }
        }
        for (let ipi = 0; ipi < this.portsOut.length; ipi++)
        {
            if (this.portsOut[ipi] == port)
            {
                this.portsOut.splice(ipi, 1);
                this.emitEvent("onUiAttribsChange", {});
                this.emitEvent("onPortRemoved", {});
                return;
            }
        }
    };

    Op.prototype._checkLinksNeededToWork = function () {};

    /**
     * show a warning of this op is not a child of parentOpName
     * @function
     * @instance
     * @memberof Op
     * @param {String} parentOpName
     */
    Op.prototype.toWorkNeedsParent = function (parentOpName)
    {
        this._linkTimeRules.needsParentOp = parentOpName;
    };

    // /**
    //  * show a warning of this op is a child of parentOpName
    //  * @function
    //  * @instance
    //  * @memberof Op
    //  * @param {String} parentOpName
    //  */
    Op.prototype.toWorkShouldNotBeChild = function (parentOpName, type)
    {
        if (!this.patch.isEditorMode()) return;
        this._linkTimeRules.forbiddenParent = parentOpName;
        if (type != undefined) this._linkTimeRules.forbiddenParentType = type;
    };


    /**
     * show a small X to indicate op is not working when given ports are not linked
     * @function
     * @instance
     * @memberof Op
     * @param {Port} port1
     * @param {Port} port2
     * @param {Port} port3
     */
    Op.prototype.toWorkPortsNeedToBeLinked = function ()
    {
        if (!this.patch.isEditorMode()) return;
        for (let i = 0; i < arguments.length; i++)
            if (this._linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1) this._linkTimeRules.needsLinkedToWork.push(arguments[i]);
    };
    Op.prototype.toWorkPortsNeedToBeLinkedReset = function ()
    {
        if (!this.patch.isEditorMode()) return;
        this._linkTimeRules.needsLinkedToWork.length = 0;
        if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();
    };

    Op.prototype.initVarPorts = function ()
    {
        for (let i = 0; i < this.portsIn.length; i++)
        {
            if (this.portsIn[i].getVariableName()) this.portsIn[i].setVariable(this.portsIn[i].getVariableName());
        }
    };

    /**
     * refresh op parameters, if current op is selected
     * @function
     * @instance
     * @memberof Op
     */
    Op.prototype.refreshParams = function ()
    {
        if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp())
        {
            gui.opParams.show(this);
        }
    };

    /**
     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui
     * @function isCurrentUiOp
     * @instance
     * @memberof Op
     * @returns {Boolean} - is current ui op
     */
    Op.prototype.isCurrentUiOp = function ()
    {
        if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);
    };

    /**
     * Implement to render 2d canvas based graphics from in an op
     * @function renderVizLayer
     * @instance
     * @memberof Op
     * @param {ctx} context of canvas 2d
     * @param {Object} layer info
     * @param {number} layer.x x position on canvas
     * @param {number} layer.y y position on canvas
     * @param {number} layer.width width of canvas
     * @param {number} layer.height height of canvas
     * @param {number} layer.scale current scaling of patchfield view
     */
    Op.prototype.renderVizLayer = null; // optionaly defined in op instance
}



;// CONCATENATED MODULE: ./src/core/loadingstatus.js




/**
 * LoadingStatus class, manages asynchronous loading jobs
 *
 * @namespace external:CABLES#LoadingStatus
 * @hideconstructor
 * @class
 * @param patch
 */
const LoadingStatus = function (patch)
{
    EventTarget.apply(this);

    this._log = new Logger("LoadingStatus");
    this._loadingAssets = {};
    this._cbFinished = [];
    this._assetTasks = [];
    this._percent = 0;
    this._count = 0;
    this._countFinished = 0;
    this._order = 0;
    this._startTime = 0;
    this._patch = patch;
    this._wasFinishedPrinted = false;
    this._loadingAssetTaskCb = false;
};

LoadingStatus.prototype.setOnFinishedLoading = function (cb)
{
    this._cbFinished.push(cb);
};

LoadingStatus.prototype.getNumAssets = function ()
{
    return this._countFinished;
};

LoadingStatus.prototype.getProgress = function ()
{
    return this._percent;
};

LoadingStatus.prototype.checkStatus = function ()
{
    this._countFinished = 0;
    this._count = 0;

    for (const i in this._loadingAssets)
    {
        this._count++;
        if (!this._loadingAssets[i].finished)
        {
            this._countFinished++;
        }
    }

    this._percent = (this._count - this._countFinished) / this._count;

    if (this._countFinished === 0)
    {
        for (let j = 0; j < this._cbFinished.length; j++)
        {
            if (this._cbFinished[j])
            {
                const cb = this._cbFinished[j];
                setTimeout(() => { cb(this._patch); this.emitEvent("finishedAll"); }, 100);
            }
        }

        if (!this._wasFinishedPrinted)
        {
            this._wasFinishedPrinted = true;
            this.print();
        }
        this.emitEvent("finishedAll");
    }
};

LoadingStatus.prototype.getList = function ()
{
    let arr = [];
    for (const i in this._loadingAssets)
    {
        arr.push(this._loadingAssets[i]);
    }

    return arr;
};


LoadingStatus.prototype.getListJobs = function ()
{
    let arr = [];
    for (const i in this._loadingAssets)
    {
        if (!this._loadingAssets[i].finished)arr.push(this._loadingAssets[i].name);
    }

    return arr;
};

LoadingStatus.prototype.print = function ()
{
    if (this._patch.config.silent) return;

    const rows = [];

    for (const i in this._loadingAssets)
    {
        rows.push([
            this._loadingAssets[i].order,
            this._loadingAssets[i].type,
            this._loadingAssets[i].name,
            (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) / 1000 + "s",
        ]);
    }

    this._log.groupCollapsed("finished loading " + this._order + " assets in " + (Date.now() - this._startTime) / 1000 + "s");
    this._log.table(rows);
    this._log.groupEnd();
};

LoadingStatus.prototype.finished = function (id)
{
    const l = this._loadingAssets[id];
    if (l)
    {
        if (l.finished) this._log.warn("loading job was already finished", l);

        if (l.op) l.op.setUiAttribs({ "loading": false });
        l.finished = true;
        l.timeEnd = Date.now();
    }

    this.checkStatus();
    this.emitEvent("finishedTask");
    return null;
};

LoadingStatus.prototype._startAssetTasks = function ()
{
    for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();
    this._assetTasks.length = 0;
};

/**
 * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets
 * @function addAssetLoadingTask
 * @instance
 * @memberof LoadingStatus
 * @param {function} cb callback
 */
LoadingStatus.prototype.addAssetLoadingTask = function (cb)
{
    if (this._patch.isEditorMode() && !CABLES.UI.loaded)
    {
        this._assetTasks.push(cb);

        if (!this._loadingAssetTaskCb)window.gui.addEventListener("uiloaded", this._startAssetTasks.bind(this));
        this._loadingAssetTaskCb = true;
    }
    else
    {
        cb();
    }
    this.emitEvent("addAssetTask");
};

LoadingStatus.prototype.existByName = function (name)
{
    for (let i in this._loadingAssets)
    {
        if (this._loadingAssets[i].name == name && !this._loadingAssets[i].finished)
            return true;
    }
};

LoadingStatus.prototype.start = function (type, name, op)
{
    if (this._startTime == 0) this._startTime = Date.now();
    const id = generateUUID();

    name = name || "unknown";
    if (name.length > 100)name = name.substring(0, 100);


    if (op)op.setUiAttribs({ "loading": true });

    this._loadingAssets[id] = {
        "id": id,
        "op": op,
        "type": type,
        "name": name,
        "finished": false,
        "timeStart": Date.now(),
        "order": this._order,
    };
    this._order++;

    this.emitEvent("startTask");

    return id;
};



;// CONCATENATED MODULE: ./src/core/timer.js


/** @namespace CABLES */

const internalNow = function ()
{
    return window.performance.now();
};



/**
 * current time in milliseconds
 * @memberof CABLES
 * @function now
 * @static
 */
const now = function ()
{
    return internalNow();
};

// ----------------------------

/**
 * Measuring time
 * @namespace external:CABLES#Timer
 * @hideconstructor
 * @class
 */
const Timer = function ()
{
    EventTarget.apply(this);

    this._timeStart = internalNow();
    this._timeOffset = 0;

    this._currentTime = 0;
    this._lastTime = 0;
    this._paused = true;
    this._delay = 0;
    this.overwriteTime = -1;
};


Timer.prototype._internalNow = function ()
{
    if (this._ts) return this._ts;
    return internalNow();
};

Timer.prototype._getTime = function ()
{
    this._lastTime = (this._internalNow() - this._timeStart) / 1000;
    return this._lastTime + this._timeOffset;
};

Timer.prototype.setDelay = function (d)
{
    this._delay = d;
    this.emitEvent("timeChange");
};

/**
 * @function
 * @memberof Timer
 * @instance
 * @description returns true if timer is playing
 * @return {Boolean} value
 */
Timer.prototype.isPlaying = function ()
{
    return !this._paused;
};

/**
 * @function
 * @memberof Timer
 * @instance
 * @param ts
 * @description update timer
 * @return {Number} time
 */
Timer.prototype.update = function (ts)
{
    if (ts) this._ts = ts;
    if (this._paused) return;
    this._currentTime = this._getTime();

    return this._currentTime;
};

/**
 * @function
 * @memberof Timer
 * @instance
 * @return {Number} time in milliseconds
 */
Timer.prototype.getMillis = function ()
{
    return this.get() * 1000;
};

/**
 * @function
 * @memberof Timer
 * @instance
 * @return {Number} value time in seconds
 */
Timer.prototype.get = Timer.prototype.getTime = function ()
{
    if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;
    return this._currentTime - this._delay;
};

/**
 * toggle between play/pause state
 * @function
 * @memberof Timer
 * @instance
 */
Timer.prototype.togglePlay = function ()
{
    if (this._paused) this.play();
    else this.pause();
};

/**
 * set current time
 * @function
 * @memberof Timer
 * @instance
 * @param {Number} t
 */
Timer.prototype.setTime = function (t)
{
    if (isNaN(t) || t < 0) t = 0;
    this._timeStart = this._internalNow();
    this._timeOffset = t;
    this._currentTime = t;
    this.emitEvent("timeChange");
};

Timer.prototype.setOffset = function (val)
{
    if (this._currentTime + val < 0)
    {
        this._timeStart = this._internalNow();
        this._timeOffset = 0;
        this._currentTime = 0;
    }
    else
    {
        this._timeOffset += val;
        this._currentTime = this._lastTime + this._timeOffset;
    }
    this.emitEvent("timeChange");
};

/**
 * (re)starts the timer
 * @function
 * @memberof Timer
 * @instance
 */
Timer.prototype.play = function ()
{
    this._timeStart = this._internalNow();
    this._paused = false;
    this.emitEvent("playPause");
};

/**
 * pauses the timer
 * @function
 * @memberof Timer
 * @instance
 */
Timer.prototype.pause = function ()
{
    this._timeOffset = this._currentTime;
    this._paused = true;
    this.emitEvent("playPause");
};



;// CONCATENATED MODULE: ./src/core/core_profiler.js


class Profiler
{
    constructor(patch)
    {
        this.startFrame = patch.getFrameNum();
        this.items = {};
        this.currentId = null;
        this.currentStart = 0;
        this._patch = patch;
    }

    getItems()
    {
        return this.items;
    }

    clear()
    {
        if (this.paused) return;
        this.items = {};
    }

    togglePause()
    {
        this.paused = !this.paused;
        if (!this.paused)
        {
            this.items = {};
            this.currentStart = performance.now();
        }
    }

    add(type, object)
    {
        if (this.paused) return;

        if (this.currentId !== null)
        {
            if (!object || object.id != this.currentId)
            {
                if (this.items[this.currentId])
                {
                    this.items[this.currentId].timeUsed += performance.now() - this.currentStart;

                    if (!this.items[this.currentId].peakTime || now() - this.items[this.currentId].peakTime > 5000)
                    {
                        this.items[this.currentId].peak = 0;
                        this.items[this.currentId].peakTime = now();
                    }
                    this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart);
                }
            }
        }

        if (object !== null)
        {
            if (!this.items[object.id])
            {
                this.items[object.id] = {
                    "numTriggers": 0,
                    "timeUsed": 0,
                };
            }

            if (this.items[object.id].lastFrame != this._patch.getFrameNum()) this.items[object.id].numTriggers = 0;

            this.items[object.id].lastFrame = this._patch.getFrameNum();
            this.items[object.id].numTriggers++;
            this.items[object.id].opid = object.op.id;
            this.items[object.id].title = object.op.name + "." + object.name;
            this.items[object.id].subPatch = object.op.uiAttribs.subPatch;

            this.currentId = object.id;
            this.currentStart = performance.now();
        }
        else
        {
            this.currentId = null;
        }
    }

    print()
    {
        console.log("--------");
        for (const i in this.items)
        {
            console.log(this.items[i].title + ": " + this.items[i].numTriggers + " / " + this.items[i].timeUsed);
        }
    }
}



;// CONCATENATED MODULE: ./src/core/cgl/constants.js
const SHADER = {
    // default attributes
    "SHADERVAR_VERTEX_POSITION": "vPosition",
    "SHADERVAR_VERTEX_NUMBER": "attrVertIndex",
    "SHADERVAR_VERTEX_NORMAL": "attrVertNormal",
    "SHADERVAR_VERTEX_TEXCOORD": "attrTexCoord",
    "SHADERVAR_INSTANCE_MMATRIX": "instMat",
    "SHADERVAR_VERTEX_COLOR": "attrVertColor",

    "SHADERVAR_INSTANCE_INDEX": "instanceIndex",

    // default uniforms
    "SHADERVAR_UNI_PROJMAT": "projMatrix",
    "SHADERVAR_UNI_VIEWMAT": "viewMatrix",
    "SHADERVAR_UNI_MODELMAT": "modelMatrix",
    "SHADERVAR_UNI_NORMALMAT": "normalMatrix",
    "SHADERVAR_UNI_INVVIEWMAT": "inverseViewMatrix",
    "SHADERVAR_UNI_INVPROJMAT": "invProjMatrix",
    "SHADERVAR_UNI_MATERIALID": "materialId",
    "SHADERVAR_UNI_OBJECTID": "objectId",

    "SHADERVAR_UNI_VIEWPOS": "camPos",
};


const BLEND_MODES = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};





const RAD2DEG = 180.0 / Math.PI;
const DEG2RAD = Math.PI / 180.0;

const constants_CONSTANTS = {
    "MATH": {
        "DEG2RAD": DEG2RAD,
        "RAD2DEG": RAD2DEG,
    },
    "SHADER": SHADER,
    "BLEND_MODES": BLEND_MODES,
};




;// CONCATENATED MODULE: ./src/core/cg/cg_uniform.js



class CgUniform
{
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        this._log = new Logger("cg_uniform");
        this._type = __type;
        this._name = __name;
        this._shader = __shader;
        this._value = 0.00001;
        this._oldValue = null;
        this._port = null;
        this._structName = _structName;
        this._structUniformName = _structUniformName;
        this._propertyName = _propertyName;

        this._shader._addUniform(this);
        this.needsUpdate = true;
        this.shaderType = null;
        this.comment = null;

        if (__type == "f")
        {
            this.set = this.setValue = this.setValueF.bind(this);
            this.updateValue = this.updateValueF.bind(this);
        }
        else if (__type == "f[]")
        {
            this.set = this.setValue = this.setValueArrayF.bind(this);
            this.updateValue = this.updateValueArrayF.bind(this);
        }
        else if (__type == "2f[]")
        {
            this.set = this.setValue = this.setValueArray2F.bind(this);
            this.updateValue = this.updateValueArray2F.bind(this);
        }
        else if (__type == "3f[]")
        {
            this.set = this.setValue = this.setValueArray3F.bind(this);
            this.updateValue = this.updateValueArray3F.bind(this);
        }
        else if (__type == "4f[]")
        {
            this.set = this.setValue = this.setValueArray4F.bind(this);
            this.updateValue = this.updateValueArray4F.bind(this);
        }
        else if (__type == "i")
        {
            this.set = this.setValue = this.setValueI.bind(this);
            this.updateValue = this.updateValueI.bind(this);
        }
        else if (__type == "2i")
        {
            this.set = this.setValue = this.setValue2I.bind(this);
            this.updateValue = this.updateValue2I.bind(this);
        }
        else if (__type == "3i")
        {
            this.set = this.setValue = this.setValue3I.bind(this);
            this.updateValue = this.updateValue3I.bind(this);
        }
        else if (__type == "4i")
        {
            this.set = this.setValue = this.setValue4I.bind(this);
            this.updateValue = this.updateValue4I.bind(this);
        }
        else if (__type == "b")
        {
            this.set = this.setValue = this.setValueBool.bind(this);
            this.updateValue = this.updateValueBool.bind(this);
        }
        else if (__type == "4f")
        {
            this.set = this.setValue = this.setValue4F.bind(this);
            this.updateValue = this.updateValue4F.bind(this);
        }
        else if (__type == "3f")
        {
            this.set = this.setValue = this.setValue3F.bind(this);
            this.updateValue = this.updateValue3F.bind(this);
        }
        else if (__type == "2f")
        {
            this.set = this.setValue = this.setValue2F.bind(this);
            this.updateValue = this.updateValue2F.bind(this);
        }
        else if (__type == "t")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "sampler")
        {
            if (this.setValueAny)
            {
                this.set = this.setValue = this.setValueAny.bind(this);
                this.updateValue = this.updateValueAny.bind(this);
            }
        }
        else if (__type == "tc")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "t[]")
        {
            this.set = this.setValue = this.setValueArrayT.bind(this);
            this.updateValue = this.updateValueArrayT.bind(this);
        }
        else if (__type == "m4" || __type == "m4[]")
        {
            this.set = this.setValue = this.setValueM4.bind(this);
            this.updateValue = this.updateValueM4.bind(this);
        }
        else
        {
            // console.error("unknown");
            this._log.error("Unknown uniform type " + __type);
        }

        if (typeof _value == "object" && _value instanceof Port)
        {
            this._port = _value;
            this._value = this._port.get();


            if (_port2 && _port3 && _port4)
            {
                if (!(_port2 instanceof Port) || !(_port3 instanceof Port) || !(_port4 instanceof Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                this._port4 = _port4;

                this._port.on("change", this.updateFromPort4f.bind(this));
                this._port2.on("change", this.updateFromPort4f.bind(this));
                this._port3.on("change", this.updateFromPort4f.bind(this));
                this._port4.on("change", this.updateFromPort4f.bind(this));

                // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);
                this.updateFromPort4f();
            }
            else if (_port2 && _port3)
            {
                if (!(_port2 instanceof Port) || !(_port3 instanceof Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);
                this._port.on("change", this.updateFromPort3f.bind(this));
                this._port2.on("change", this.updateFromPort3f.bind(this));
                this._port3.on("change", this.updateFromPort3f.bind(this));

                this.updateFromPort3f();
            }
            else if (_port2)
            {
                if (!(_port2 instanceof Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0];
                this._port2 = _port2;
                // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);
                this._port.on("change", this.updateFromPort2f.bind(this));
                this._port2.on("change", this.updateFromPort2f.bind(this));

                this.updateFromPort2f();
            }
            else
            {
                // this._port.on = this.updateFromPort.bind(this);
                this._port.on("change", this.updateFromPort.bind(this));
            }
        }
        else this._value = _value;


        if (this._value == undefined)
        {
            console.log("value undefined", this);
            this._value = 0;
        }

        this.setValue(this._value);

        this.needsUpdate = true;
    }

    getType()
    {
        return this._type;
    }

    get type()
    {
        return this._type;
    }

    get name()
    {
        return this._name;
    }

    getName()
    {
        return this._name;
    }

    getValue()
    {
        return this._value;
    }

    getShaderType()
    {
        return this.shaderType;
    }

    isStructMember()
    {
        return !!this._structName;
    }


    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }
}

/* harmony default export */ const cg_uniform = (CgUniform);

;// CONCATENATED MODULE: ./src/core/cgl/cgl_shader_uniform.js




/**
 * Shader uniforms
 *
 * types:
 * <pre>
 * f    - float
 * 2f   - vec2
 * 3f   - vec3
 * 4f   - vec4
 * i    - integer
 * t    - texture
 * m4   - mat4, 4x4 float matrix
 * f[]  - array of floats
 * 2f[] - array of float vec2
 * 3f[] - array of float vec3
 * 4f[] - array of float vec4
 * </pre>
 *
 * @namespace external:CGL
 * @class
 * @param {Shader} shader
 * @param {String} [type=f]
 * @param {String} name
 * @param {Number|Port} value  can be a Number,Matrix or Port
 * @example
 * // bind float uniform called myfloat and initialize with value 1.0
 * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);
 * unir.setValue(1.0);
 *
 * // bind float uniform called myfloat and automatically set it to input port value
 * const myPort=op.inFloat("input");
 * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);
 *
 */


// export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)

class Uniform extends cg_uniform
{
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
        this._loc = -1;
        this._cgl = __shader._cgl;
    }

    get name()
    {
        return this._name;
    }

    copy(newShader)
    {
        const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
        uni.shaderType = this.shaderType;
        return uni;
    }

    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString()
    {
        return Uniform.glslTypeString(this._type);
    }

    _isValidLoc()
    {
        return this._loc != -1;// && this._loc != null;
    }

    resetLoc()
    {
        this._loc = -1;
        this.needsUpdate = true;
    }

    bindTextures() {}

    getLoc()
    {
        return this._loc;
    }

    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }

    updateValueF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1f(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueF(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    updateValueI()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue2I()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);

        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue3I()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue4I()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueI(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValue2I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue3I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue4I(v)
    {
        this.needsUpdate = true;
        this._value = v || vec4.create();
    }

    updateValueBool()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);

        this._cgl.profileData.profileUniformCount++;
    }

    setValueBool(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValueArray4F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray4F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray3F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray3F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray2F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray2F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArrayF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }


    updateValue3F()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue3F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValue2F()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue2F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }
        this._value = v;
    }

    updateValue4F()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        if (!this._value)
        {
            this._log.warn("no value for uniform", this._name, this);
            this._value = [0, 0, 0, 0];
        }

        this.needsUpdate = false;
        this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValue4F(v)
    {
        if (typeof this.value == "number") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods

        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2, 3];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValueM4()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        if (!this._value || this._value.length % 16 != 0) return console.log("this.name", this._name, this._value);

        this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueM4(v)
    {
        this.needsUpdate = true;
        this._value = v || mat4.create();
    }

    updateValueArrayT()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValueT()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._cgl.profileData.profileUniformCount++;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this.needsUpdate = false;
    }

    setValueT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }
}


Uniform.glslTypeString = (t) =>
{
    if (t == "f") return "float";
    if (t == "b") return "bool";
    if (t == "i") return "int";
    if (t == "2i") return "ivec2";
    if (t == "2f") return "vec2";
    if (t == "3f") return "vec3";
    if (t == "4f") return "vec4";
    if (t == "m4") return "mat4";

    if (t == "t") return "sampler2D";
    if (t == "tc") return "samplerCube";

    if (t == "3f[]") return null; // ignore this for now...
    if (t == "m4[]") return null; // ignore this for now...
    if (t == "f[]") return null; // ignore this for now...

    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
};


/**
 * @function setValue
 * @memberof Uniform
 * @instance
 * @param {Number|Array|Matrix|Texture} value
 */



;// CONCATENATED MODULE: ./src/core/cg/cg_texture.js
const DEFAULT_TEXTURE_SIZE = 8;

class CgTexture
{
    constructor(options = {})
    {
        this.id = CABLES.uuid();
        this.width = 0;
        this.height = 0;
        this.name = "unknown";

        options = options || {};
        this.pixelFormat = options.pixelFormat || CgTexture.PFORMATSTR_RGBA8UB;

        this.name = options.name || "unknown";

        if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;
        if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;
    }
}


CgTexture.getDefaultTextureData = (name, size, options = {}) =>
{
    if (name == "empty")
    {
        return new Uint8Array(size * size * 4).fill(0);
    }
    else
    if (name == "color")
    {
        const data = new Uint8Array(size * size * 4);
        let r = options.r || 1;
        let g = options.g || 1;
        let b = options.b || 1;

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = r;
            data[x * 4 + 1] = g;
            data[x * 4 + 2] = b;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "randomUInt")
    {
        const data = new Uint8Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = Math.random() * 255;
            data[x * 4 + 1] = Math.random() * 255;
            data[x * 4 + 2] = Math.random() * 255;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "random" || name == "randomFloat")
    {
        const data = new Float32Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 3] = 1;
        }
        return data;
    }
    else
    if (name == "stripes")
    {
        const arr = [];

        let r = options.r;
        let g = options.g;
        let b = options.b;

        if (r === undefined)r = 1;
        if (g === undefined)g = 1;
        if (b === undefined)b = 1;

        for (let y = 0; y < size; y++)
        {
            for (let x = 0; x < size; x++)
            {
                if ((x + y) % 64 < 32)
                {
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);
                }
                else
                {
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);
                }
                arr.push(255);
            }
        }

        return new Uint8Array(arr);
    }
    else
    {
        console.warn("unknown default texture", name);
        return CgTexture.getDefaultTextureData("stripes", size, { "r": 1, "g": 0, "b": 0 });
    }
};



CgTexture.FILTER_NEAREST = 0;
CgTexture.FILTER_LINEAR = 1;
CgTexture.FILTER_MIPMAP = 2;

CgTexture.WRAP_REPEAT = 0;
CgTexture.WRAP_MIRRORED_REPEAT = 1;
CgTexture.WRAP_CLAMP_TO_EDGE = 2;

CgTexture.TYPE_DEFAULT = 0;
CgTexture.TYPE_DEPTH = 1;
CgTexture.TYPE_FLOAT = 2;


CgTexture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";

CgTexture.PFORMATSTR_R8UB = "R 8bit ubyte";
CgTexture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
CgTexture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
CgTexture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";

CgTexture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";

CgTexture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";

CgTexture.PFORMATSTR_R16F = "R 16bit float";
CgTexture.PFORMATSTR_RG16F = "RG 16bit float";
CgTexture.PFORMATSTR_RGB16F = "RGB 16bit float";
CgTexture.PFORMATSTR_RGBA16F = "RGBA 16bit float";


CgTexture.PFORMATSTR_R32F = "R 32bit float";
CgTexture.PFORMATSTR_RG32F = "RG 32bit float";
CgTexture.PFORMATSTR_RGB32F = "RGB 32bit float";
CgTexture.PFORMATSTR_RGBA32F = "RGBA 32bit float";

CgTexture.PFORMATSTR_DEPTH = "DEPTH";


CgTexture.PIXELFORMATS = [

    CgTexture.PFORMATSTR_RGB565,

    CgTexture.PFORMATSTR_R8UB,
    CgTexture.PFORMATSTR_RG8UB,
    CgTexture.PFORMATSTR_RGB8UB,
    CgTexture.PFORMATSTR_RGBA8UB,

    CgTexture.PFORMATSTR_SRGBA8,

    CgTexture.PFORMATSTR_R11FG11FB10F,
    CgTexture.PFORMATSTR_R16F,
    CgTexture.PFORMATSTR_RG16F,
    CgTexture.PFORMATSTR_RGBA16F,

    CgTexture.PFORMATSTR_R32F,
    CgTexture.PFORMATSTR_RGBA32F

];

;// CONCATENATED MODULE: ./src/core/cgl/cgl_texture.js




const cgl_texture_DEFAULT_TEXTURE_SIZE = 8;

/**
 * A Texture
 * @namespace external:CGL
 * @class
 * @param {Context} __cgl cgl
 * @param {Object} options
 * @hideconstructor
 * @example
 * // generate a 256x256 pixel texture of random colors
 * const size=256;
 * const data = new Uint8Array(size*size*4);
 *
 * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;
 *
 * const tex=new CGL.Texture(cgl);
 * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);
 */
class Texture extends CgTexture
{
    constructor(__cgl, options = {})
    {
        super(options);
        if (!__cgl) throw new Error("no cgl");
        this._log = new Logger("cgl_texture");
        this._cgl = __cgl;
        this.tex = this._cgl.gl.createTexture();
        this.loading = false;
        this.flip = true;
        this.flipped = false;
        this.shadowMap = false;
        this.deleted = false;
        this.image = null;
        this.anisotropic = 0;
        this.filter = Texture.FILTER_NEAREST;
        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.texTarget = this._cgl.gl.TEXTURE_2D;
        if (options && options.type) this.texTarget = options.type;
        this.textureType = Texture.TYPE_DEFAULT;
        this.unpackAlpha = true;
        this._fromData = true;

        this._glDataType = -1;
        this._glInternalFormat = -1;
        this._glDataFormat = -1;


        if (options)
        {
            if (options.isDepthTexture) this.textureType = Texture.TYPE_DEPTH;
            if (options.isFloatingPointTexture === true) this.textureType = Texture.TYPE_FLOAT;

            if ("textureType" in options) this.textureType = options.textureType;
            if ("filter" in options) this.filter = options.filter;
            if ("wrap" in options) this.wrap = options.wrap;
            if ("unpackAlpha" in options) this.unpackAlpha = options.unpackAlpha;
            if ("flip" in options) this.flip = options.flip;
            if ("shadowMap" in options) this.shadowMap = options.shadowMap;
            if ("anisotropic" in options) this.anisotropic = options.anisotropic;
        }
        else
        {
            options = {};
        }

        if (!options.pixelFormat && options.isFloatingPointTexture) this.pixelFormat = Texture.PFORMATSTR_RGBA32F;

        if (this.textureType == Texture.TYPE_DEPTH) this.pixelFormat = Texture.PFORMATSTR_DEPTH;

        this._cgl.profileData.profileTextureNew++;


        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
        this._cgl.profileData.addHeavyEvent("texture created", this.name, options.width + "x" + options.height);

        this.setSize(options.width, options.height);
        this.getInfoOneLine();
    }



    isFloatingPoint()
    {
        return Texture.isPixelFormatFloat(this.pixelFormat);
    }

    /**
     * returns true if otherTexture has same options (width/height/filter/wrap etc)
     * @function compareSettings
     * @memberof Texture
     * @instance
     * @param {Texture} tex otherTexture
     * @returns {Boolean}
     */
    compareSettings(tex)
    {
    // if (!tex) { this._log.warn("compare: no tex"); return false; }
    // if (tex.width != this.width) this._log.warn("tex.width not equal", tex.width, this.width);
    // if (tex.height != this.height) this._log.warn("tex.height not equal", tex.height, this.height);
    // if (tex.filter != this.filter) this._log.warn("tex.filter not equal");
    // if (tex.wrap != this.wrap) this._log.warn("tex.wrap not equal");
    // if (tex.textureType != this.textureType) this._log.warn("tex.textureType not equal");
    // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn("tex.unpackAlpha not equal");
    // if (tex.anisotropic != this.anisotropic) this._log.warn("tex.anisotropic not equal");
    // if (tex.shadowMap != this.shadowMap) this._log.warn("tex.shadowMap not equal");
    // if (tex.texTarget != this.texTarget) this._log.warn("tex.texTarget not equal");
    // if (tex.flip != this.flip) this._log.warn("tex.flip not equal");

        if (!tex) return false;
        return (
            tex.width == this.width &&
            tex.height == this.height &&
            tex.filter == this.filter &&
            tex.wrap == this.wrap &&
            tex.textureType == this.textureType &&
            tex.unpackAlpha == this.unpackAlpha &&
            tex.anisotropic == this.anisotropic &&
            tex.shadowMap == this.shadowMap &&
            tex.texTarget == this.texTarget &&
            tex.flip == this.flip
        );
    }

    /**
     * returns a new texture with the same settings (does not copy texture itself)
     * @function clone
     * @memberof Texture
     * @instance
     * @returns {Texture}
     */
    clone()
    {
        const newTex = new Texture(this._cgl, {
            "name": this.name,
            "filter": this.filter,
            "anisotropic": this.anisotropic,
            "wrap": this.wrap,
            "textureType": this.textureType,
            "pixelFormat": this.pixelFormat,
            "unpackAlpha": this.unpackAlpha,
            "flip": this.flip,
            "width": this.width,
            "height": this.height,
        });

        this._cgl.profileData.addHeavyEvent("texture created", this.name, this.width + "x" + this.height);

        if (!this.compareSettings(newTex))
        {
            this._log.error("Cloned texture settings do not compare!");
            this._log.error(this);
            this._log.error(newTex);
        }

        return newTex;
    }


    setFormat(o)
    {
        this.pixelFormat = o.pixelFormat;
        this._glDataFormat = o.glDataFormat;
        this._glInternalFormat = o.glInternalFormat;
        this._glDataType = o.glDataType;
    }



    /**
     * set pixel size of texture
     * @function setSize
     * @memberof Texture
     * @instance
     * @param {Number} w width
     * @param {Number} h height
     */
    setSize(w, h)
    {
        if (this._cgl.aborted) return;
        if (w != w || w <= 0 || !w) w = cgl_texture_DEFAULT_TEXTURE_SIZE;
        if (h != h || h <= 0 || !h) h = cgl_texture_DEFAULT_TEXTURE_SIZE;

        if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize) this._log.error("texture size too big! " + w + "x" + h + " / max: " + this._cgl.maxTexSize);

        w = Math.min(w, this._cgl.maxTexSize);
        h = Math.min(h, this._cgl.maxTexSize);

        w = Math.floor(w);
        h = Math.floor(h);
        if (this.width == w && this.height == h) return;

        w = this._cgl.checkTextureSize(w);
        h = this._cgl.checkTextureSize(h);

        this.width = w;
        this.height = h;
        this.deleted = false;

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this.shortInfoString = this.getInfoOneLine();// w + "x" + h + "";

        this._cgl.gl.bindTexture(this.texTarget, this.tex);
        this._cgl.profileData.profileTextureResize++;

        const uarr = null;

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);

        this._setFilter();

        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
    }


    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap)
    {
        this.filter = filter;
        this.wrap = wrap;
        if (filter == undefined) this.filter = Texture.FILTER_LINEAR;
        if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.width = w;
        this.height = h;
        this._fromData = true;
        this.deleted = false;

        if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", this.width, this.height, this._cgl.maxTexSize);
            return;
        }

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);

        this._setFilter();
        this.updateMipMap();

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
        this._cgl.gl.bindTexture(this.texTarget, null);
    }

    updateMipMap()
    {
        if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP)
        {
            this._cgl.gl.generateMipmap(this.texTarget);
            this._cgl.profileData.profileGenMipMap++;
        }
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter)
    {
        this._cgl.printError("before initTexture");
        this._cgl.checkFrameStarted("texture inittexture");
        this._fromData = false;

        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        if (img.width || img.videoWidth) this.width = img.videoWidth || img.width;
        if (img.height || img.videoHeight) this.height = img.videoHeight || img.height;

        if (filter !== undefined) this.filter = filter; // todo: can we remove this filter param?

        if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", img.width, img.height, this._cgl.maxTexSize);
            return;
        }

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.deleted = false;
        this.flipped = !this.flip;
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);


        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);

        this._setFilter();
        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.getInfoOneLine();
        this._cgl.printError("initTexture");
    }

    /**
     * delete texture. use this when texture is no longer needed
     * @function delete
     * @memberof Texture
     * @instance
     */
    dispose()
    {
        this.delete();
    }

    delete()
    {
        if (this.loading)
        {
        // cant delete texture when still loading
        // setTimeout(this.delete.bind(this), 50);
            return;
        }

        this.deleted = true;
        this.width = 0;
        this.height = 0;
        this._cgl.profileData.profileTextureDelete++;
        this._cgl.gl.deleteTexture(this.tex);
        this.image = null;

        this.tex = null;
    }

    /**
     * @function isPowerOfTwo
     * @memberof Texture
     * @instance
     * @description return true if texture width and height are both power of two
     * @return {Boolean}
     */
    isPowerOfTwo()
    {
        return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);
    }

    printInfo()
    {
        console.log(this.getInfo());
    }

    getInfoReadable()
    {
        const info = this.getInfo();
        let html = "";

        info.name = info.name.substr(0, info.name.indexOf("?rnd="));

        for (const i in info)
        {
            html += "* " + i + ":  **" + info[i] + "**\n";
        }

        return html;
    }

    getInfoOneLine()
    {
        let txt = "" + this.width + "x" + this.height;
        txt += " ";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += this.pixelFormat;

        if (this.filter === CGL.Texture.FILTER_NEAREST) txt += " nearest";
        if (this.filter === CGL.Texture.FILTER_LINEAR) txt += " linear";
        if (this.filter === CGL.Texture.FILTER_MIPMAP) txt += " mipmap";

        if (this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE) txt += " clamp";
        if (this.wrap === CGL.Texture.WRAP_REPEAT) txt += " repeat";
        if (this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT) txt += " repeatmir";

        this.shortInfoString = txt;

        return txt;
    }

    getInfoOneLineShort()
    {
        let txt = "" + this.width + "x" + this.height;
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += " ";
        txt += this.pixelFormat;

        this.shortInfoString = txt;

        return txt;
    }


    getInfo()
    {
        return Texture.getTexInfo(this);
    }


    _setFilter()
    {
        this._cgl.printError("before _setFilter");

        if (!this._fromData)
        {
            this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        }

        if (this.shadowMap)
        {
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);
        }

        if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP)
        {
            this.filter = Texture.FILTER_LINEAR;
            this._log.stack("texture: HDR and mipmap filtering at the same time is not possible");
        }

        if (this._cgl.glVersion == 1 && !this.isPowerOfTwo())
        {
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);

            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);

            this.filter = Texture.FILTER_NEAREST;
            this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        }
        else
        {
            if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);
            }
            else if (this.wrap == Texture.WRAP_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);
            }
            else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);
            }

            if (this.filter == Texture.FILTER_NEAREST)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
            }
            else if (this.filter == Texture.FILTER_LINEAR)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
            }
            else if (this.filter == Texture.FILTER_MIPMAP)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);
            }
            else
            {
                this._log.log("unknown texture filter!", this.filter);
                throw new Error("unknown texture filter!" + this.filter);
            }

            if (this.anisotropic)
            {
                const ext = this._cgl.enableExtension("EXT_texture_filter_anisotropic");



                if (this._cgl.maxAnisotropic)
                {
                    const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
                    this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);
                }
            }
        }
        this.getInfoOneLine();
        this._cgl.printError("_setFilter");
    }
}


























/**
 * @function load
 * @static
 * @memberof Texture
 * @description load an image from an url
 * @param {Context} cgl
 * @param {String} url
 * @param {Function} finishedCallback
 * @param {Object} settings
 * @return {Texture}
 */
Texture.load = function (cgl, url, finishedCallback, settings)
{
    if (!url) return finishedCallback({ "error": true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url)) loadingId = cgl.patch.loading.start("cgl.texture", url);

    const texture = new Texture(cgl);
    texture.name = url;

    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;

    if (settings && settings.hasOwnProperty("filter")) texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip")) texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap")) texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic")) texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha")) texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat")) texture.pixelFormat = settings.pixelFormat;

    texture.image.onabort = texture.image.onerror = (e) =>
    {
        console.warn("[cgl.texture.load] error loading texture", url, e);
        texture.loading = false;
        if (loadingId) cgl.patch.loading.finished(loadingId);
        const error = { "error": true };
        if (finishedCallback) finishedCallback(error, texture);
    };

    texture.image.onload = function (e)
    {
        cgl.addNextFrameOnceCallback(() =>
        {
            texture.initTexture(texture.image);
            if (loadingId) cgl.patch.loading.finished(loadingId);
            texture.loading = false;

            if (finishedCallback) finishedCallback(null, texture);
        });
    };
    texture.image.src = url;

    return texture;
};






/**
 * @static
 * @function getTempTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 * @param {Context} cgl
 * @return {Texture}
 */
Texture.getTempTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture) cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);
    return cgl.tempTexture;
};

/**
 * @static
 * @function getErrorTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 * @param {Context} cgl
 * @return {Texture}
 */
Texture.getErrorTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture) cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);
    return cgl.errorTexture;
};


/**
 * @function getEmptyTexture
 * @memberof Texture
 * @instance
 * @param cgl
 * @param fp
 * @description returns a reference to a small empty (transparent) texture
 * @return {Texture}
 */
Texture.getEmptyTexture = function (cgl, fp)
{
    if (fp) return Texture.getEmptyTextureFloat(cgl);
    if (!cgl) console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;

    let size = 8;

    cgl.tempTextureEmpty = new Texture(cgl, { "name": "emptyTexture" });
    const data = Texture.getDefaultTextureData("empty", size);

    cgl.tempTextureEmpty.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmpty;
};

/**
 * @function getEmptyTextureFloat
 * @memberof Texture
 * @instance
 * @param cgl
 * @description returns a reference to a small empty (transparent) 32bit texture
 * @return {Texture}
 */
Texture.getEmptyTextureFloat = function (cgl)
{
    if (!cgl) console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;

    cgl.tempTextureEmptyFloat = new Texture(cgl, { "name": "emptyTexture", "isFloatingPointTexture": true });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;

    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmptyFloat;
};


/**
 * @function getRandomTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a random texture
 * @return {Texture}
 */
Texture.getRandomTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture) return cgl.randomTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomUInt", size);

    cgl.randomTexture = new Texture(cgl);
    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.randomTexture;
};

/**
 * @function getRandomFloatTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a texture containing random numbers between -1 and 1
 * @return {Texture}
 */
Texture.getRandomFloatTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomFloat", size);

    cgl.getRandomFloatTexture = new Texture(cgl, { "isFloatingPointTexture": true });
    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.getRandomFloatTexture;
};

/**
 * @function getBlackTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a black texture
 * @return {Texture}
 */
Texture.getBlackTexture = function (cgl)
{
    if (!cgl) this._log.error("[getBlackTexture] no cgl!");
    if (cgl.blackTexture) return cgl.blackTexture;

    const size = 8;
    const data = Texture.getDefaultTextureData("color", size, { "r": 0, "g": 0, "b": 0 });

    cgl.blackTexture = new Texture(cgl);
    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.blackTexture;
};


/**
 * @function getEmptyCubemapTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]
 * @return {Texture}
 */
Texture.getEmptyCubemapTexture = function (cgl)
{
    const faces = [
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];

    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture.FILTER_NEAREST;
    const wrap = Texture.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;

    cgl.profileData.profileTextureNew++;


    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;

    for (let i = 0; i < 6; i += 1)
    {
        const data = new Uint8Array(8 * 8 * 4);

        cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);

        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }


    cgl.gl.bindTexture(target, null);

    return {
        "id": CABLES.uuid(),
        "tex": tex,
        "cubemap": tex,
        "width": width,
        "height": height,
        "filter": filter,
        "wrap": wrap,
        "unpackAlpha": true,
        "flip": true,
        "_fromData": true,
        "name": "emptyCubemapTexture",
        "anisotropic": 0,
    };
};


Texture.getTempGradientTexture = function (cgl) // deprecated...
{
    if (!cgl) console.error("[getTempGradientTexture] no cgl!");
    return Texture.getTempTexture(cgl);
};

Texture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b)
{
    const data = Texture.getDefaultTextureData("stripes", 256, { "r": r, "g": g, "b": b });
    const temptex = new Texture(cgl);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
};

/**
 * @static
 * @function createFromImage
 * @memberof Texture
 * @description create texturem from image data (e.g. image or canvas)
 * @param {Context} cgl
 * @param {Object} img image
 * @param {Object} options
 */
Texture.createFromImage = function (cgl, img, options)
{
    options = options || {};
    const texture = new Texture(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap"))texture.wrap = options.wrap;

    texture.initTexture(img, options.filter);

    return texture;
};

// deprecated!
Texture.fromImage = function (cgl, img, filter, wrap)
{
    console.error("deprecated texture from image...");

    const texture = new Texture(cgl);
    texture.flip = false;
    if (filter) texture.filter = filter;
    if (wrap) texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
};

/**
 * @static
 * @function isPowerOfTwo
 * @memberof Texture
 * @description returns true if x is power of two
 * @param {Number} x
 * @return {Boolean}
 */
Texture.isPowerOfTwo = function (x)
{
    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;
};

Texture.getTexInfo = function (tex)
{
    const obj = {};

    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;

    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = "TEXTURE_2D";
    obj.target = targetString;

    obj.unpackAlpha = tex.unpackAlpha;

    if (tex.cubemap)obj.cubemap = true;

    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture.TYPE_HALF_FLOAT) obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture.TYPE_DEPTH) obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture.TYPE_DEFAULT) obj.textureType = "TYPE_DEFAULT";
    else obj.textureType = "UNKNOWN " + this.textureType;

    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT) obj.wrap = "WRAP_MIRRORED_REPEAT";
    else obj.wrap = "UNKNOWN";

    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = "FILTER_MIPMAP";
    else obj.filter = "UNKNOWN";

    obj.pixelFormat = tex.pixelFormat || "unknown";

    return obj;
};

Texture.setUpGlPixelFormat = function (cgl, pixelFormatStr)
{
    const o = {};

    if (!pixelFormatStr)
    {
        cgl._log.error("no pixelformatstr!");
        cgl._log.log(new Error());
        pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;
    }

    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;

    let floatDatatype = cgl.gl.FLOAT;

    if (cgl.glUseHalfFloatTex)
    {
        if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) pixelFormatStr = Texture.PFORMATSTR_RGBA16F;
        if (pixelFormatStr == Texture.PFORMATSTR_RG32F) pixelFormatStr = Texture.PFORMATSTR_RG16F;
        if (pixelFormatStr == Texture.PFORMATSTR_R32F) pixelFormatStr = Texture.PFORMATSTR_R16F;
    }

    if (pixelFormatStr.contains("16bit"))
    {
        if (cgl.glVersion == 2)
        {
            // cgl.enableExtension("OES_texture_half_float");
            const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");

            if (!hasExt)
            {
                console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
                // fallback to 32 bit?
                if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) pixelFormatStr = Texture.PFORMATSTR_RGBA32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RGB16F) pixelFormatStr = Texture.PFORMATSTR_RGB32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RG16F) pixelFormatStr = Texture.PFORMATSTR_RG32F;
                if (pixelFormatStr == Texture.PFORMATSTR_R16F) pixelFormatStr = Texture.PFORMATSTR_R32F;
            }
            else
            {
                floatDatatype = cgl.gl.HALF_FLOAT;
            }
        }
    }

    if (cgl.glVersion == 1)
    {
        o.glInternalFormat = cgl.gl.RGBA;

        if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F)
        {
            const ext = cgl.enableExtension("OES_texture_half_float");
            if (!ext) throw new Error("no half float texture extension");

            floatDatatype = ext.HALF_FLOAT_OES;
        }
    }


    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB)
    {
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB565)
    {
        o.glInternalFormat = cgl.gl.RGB565;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R8UB)
    {
        o.glInternalFormat = cgl.gl.R8;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB)
    {
        o.glInternalFormat = cgl.gl.RG8;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB)
    {
        o.glInternalFormat = cgl.gl.RGB8;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8)
    {
        o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    }

    else if (pixelFormatStr == Texture.PFORMATSTR_R32F)
    {
        o.glInternalFormat = cgl.gl.R32F;
        o.glDataFormat = cgl.gl.RED;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R16F)
    {
        o.glInternalFormat = cgl.gl.R16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG16F)
    {
        o.glInternalFormat = cgl.gl.RG16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA16F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA32F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH)
    {
        if (cgl.glVersion == 1)
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
            o.glDataType = cgl.gl.UNSIGNED_SHORT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
        else
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
            o.glDataType = cgl.gl.FLOAT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
    }
    else
    {
        console.log("unknown pixelformat ", pixelFormatStr);
    }

    /// //////

    if (pixelFormatStr.contains("32bit") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_color_buffer_float");
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_float_blend");

        cgl.enableExtension("OES_texture_float_linear"); // yes, i am sure, this is a webgl 1 and 2 ext
    }


    o.numColorChannels = Texture.getPixelFormatNumChannels(pixelFormatStr);


    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat) console.log("pixelformat wrong ?!", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);

    return o;
};



Texture.getPixelFormatNumChannels =
    (pxlFrmtStr) =>
    {
        if (pxlFrmtStr.startsWith("RGBA")) return 4;
        if (pxlFrmtStr.startsWith("RGB")) return 3;
        if (pxlFrmtStr.startsWith("RG")) return 2;
        return 1;
    };

Texture.isPixelFormatFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").contains("float");
    };

Texture.isPixelFormatHalfFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").contains("float") && (pxlFrmtStr || "").contains("16bit");
    };






;// CONCATENATED MODULE: ./src/core/cg/cg_boundingbox.js


/**
 * bounding box
 *
 * @namespace external:CGL
 * @param {Geometry} geometry or bounding box
 */
class BoundingBox
{
    constructor(geom)
    {
        this._init();
        this._first = true;
        this._wireMesh = null;

        if (geom) this.apply(geom);
    }

    _init()
    {
        this._max = [-0, -0, -0];
        this._min = [0, 0, 0];
        this._center = [0, 0, 0];
        this._size = [0, 0, 0];
        this._maxAxis = 0.0;
        this._first = true;
    }

    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() { return this._maxAxis || 1; }

    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() { return this._size; }

    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() { return this._center; }

    /**
     * center x
     * @type {Number}
     */
    get x() { return this._center[0]; }

    /**
     * center y
     * @type {Number}
     */
    get y() { return this._center[1]; }

    /**
     * center z
     * @type {Number}
     */
    get z() { return this._center[2]; }


    /**
     * minimum x
     * @type {Number}
     */
    get minX() { return this._min[0]; }

    /**
     * minimum y
     * @type {Number}
     */
    get minY() { return this._min[1]; }

    /**
     * minimum z
     * @type {Number}
     */
    get minZ() { return this._min[2]; }

    /**
     * maximum x
     * @type {Number}
     */
    get maxX() { return this._max[0]; }

    /**
     * maximum y
     * @type {Number}
     */
    get maxY() { return this._max[1]; }

    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() { return this._max[2]; }


    apply(geom, mat)
    {
        if (!geom)
        {
            // console.warn("[boundingbox] no geom/vertices", geom);
            return;
        }

        if (geom instanceof BoundingBox)
        {
            const bb = geom;

            this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
            this.applyPos(bb.minX, bb.minY, bb.minZ);
        }
        else
        {
            for (let i = 0; i < geom.vertices.length; i += 3)
                this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);
        }
        this.calcCenterSize();
    }

    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy()
    {
        return new BoundingBox(this);
    }

    get changed()
    {
        return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);
    }

    applyPos(x, y, z)
    {
        if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE ||
            y == Number.MAX_VALUE || y == -Number.MAX_VALUE ||
            z == Number.MAX_VALUE || z == -Number.MAX_VALUE) return;

        if (!CABLES.UTILS.isNumeric(x) || !CABLES.UTILS.isNumeric(y) || !CABLES.UTILS.isNumeric(z)) return;

        if (this._first)
        {
            this._max[0] = x;
            this._max[1] = y;
            this._max[2] = z;

            this._min[0] = x;
            this._min[1] = y;
            this._min[2] = z;
            this._first = false;
            return;
        }

        this._max[0] = Math.max(this._max[0], x);
        this._max[1] = Math.max(this._max[1], y);
        this._max[2] = Math.max(this._max[2], z);

        this._min[0] = Math.min(this._min[0], x);
        this._min[1] = Math.min(this._min[1], y);
        this._min[2] = Math.min(this._min[2], z);
    }

    calcCenterSize()
    {
        if (this._first) return;


        this._size[0] = this._max[0] - this._min[0];
        this._size[1] = this._max[1] - this._min[1];
        this._size[2] = this._max[2] - this._min[2];

        this._center[0] = (this._min[0] + this._max[0]) / 2;
        this._center[1] = (this._min[1] + this._max[1]) / 2;
        this._center[2] = (this._min[2] + this._max[2]) / 2;

        this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));
    }

    mulMat4(m)
    {
        if (this._first)
        {
            this._max[0] = 0;
            this._max[1] = 0;
            this._max[2] = 0;

            this._min[0] = 0;
            this._min[1] = 0;
            this._min[2] = 0;
            this._first = false;
        }
        vec3.transformMat4(this._max, this._max, m);
        vec3.transformMat4(this._min, this._min, m);
        this.calcCenterSize();
    }

    render(cgl, shader, op)
    {
        if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);

        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);

        if (CABLES.UI && op)
        {
            CABLES.UI.OverlayMeshes.drawCube(op, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);
        }

        cgl.popModelMatrix();
    }
}

;// CONCATENATED MODULE: ./src/core/cg/cg_geom.js
// import { vec2, vec3 } from "gl-matrix";




/**
 * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.
 * @namespace external:CGL#Geometry
 * @param {String} name
 * @class
 * @example
 * // create a triangle with all attributes
 * const geom=new Geometry("triangle"),
 *
 * geom.vertices = [
 *      0.0,           sizeH.get(),  0.0,
 *     -sizeW.get(),  -sizeH.get(),  0.0,
 *      sizeW.get(),  -sizeH.get(),  0.0 ];
 *
 * geom.vertexNormals = [
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0 ];
 *
 * geom.tangents = [
 *     1,0,0,
 *     1,0,0,
 *     1,0,0 ];
 *
 * geom.biTangents = [
 *     0,1,0,
 *     0,1,0,
 *     0,1,0 ];
 *
 * geom.texCoords = [
 *      0.5,  0.0,
 *      1.0,  1.0,
 *      0.0,  1.0, ];
 *
 * geom.verticesIndices = [
 *     0, 1, 2 ];
 *
 */
const Geometry = function (name)
{
    this.name = name || "unknown";
    this._log = new Logger("cgl_geometry");

    this.faceVertCount = 3;
    this.glPrimitive = null;
    this._attributes = {};

    this._vertices = [];
    this.verticesIndices = [];

    this.isGeometry = true;

    this.morphTargets = [];

    Object.defineProperty(this, "vertices", {
        get()
        {
            return this._vertices;
        },
        set(v)
        {
            this.setVertices(v);
        },
    });

    Object.defineProperty(this, "texCoords", {
        get()
        {
            const att = this.getAttribute("texCoords");
            if (!att) return [];
            return att.data;
        },
        set(v)
        {
            this.setAttribute("texCoords", v, 2);
        },
    });

    Object.defineProperty(this, "vertexNormals", {
        get()
        {
            const att = this.getAttribute("vertexNormals");
            if (!att) return [];
            return att.data;
        },
        set(v)
        {
            this.setAttribute("vertexNormals", v, 3);
        },
    });

    Object.defineProperty(this, "tangents", {
        get()
        {
            const att = this.getAttribute("tangents");
            if (!att) return [];
            return att.data;
        },
        set(v)
        {
            this.setAttribute("tangents", v, 3);
        },
    });

    Object.defineProperty(this, "biTangents", {
        get()
        {
            const att = this.getAttribute("biTangents");
            if (!att) return [];
            return att.data;
        },
        set(v)
        {
            this.setAttribute("biTangents", v, 3);
        },
    });

    Object.defineProperty(this, "vertexColors", {
        get()
        {
            const att = this.getAttribute("vertexColors");
            if (!att) return [];
            return att.data;
        },
        set(v)
        {
            this.setAttribute("vertexColors", v, 4);
        },
    });
};

/**
 * @function clear
 * @memberof Geometry
 * @instance
 * @description clear all buffers/set them to length 0
 */
Geometry.prototype.clear = function ()
{
    this._vertices = new Float32Array([]);
    this.verticesIndices = [];
    this.texCoords = new Float32Array([]);
    this.vertexNormals = new Float32Array([]);
    this.tangents = [];
    this.biTangents = [];
    this._attributes = {};
};



/**
 * @function getAttributes
   @memberof Geometry
 * @instance
 * @return {Array<Object>} returns array of attribute objects
 */
Geometry.prototype.getAttributes = function ()
{
    return this._attributes;
};

/**
 * @function getAttribute
 * @memberof Geometry
 * @instance
 * @param {String} name
 * @return {Object}
 */
Geometry.prototype.getAttribute = function (name)
{
    for (const i in this._attributes)
    {
        if (this._attributes[i].name == name) return this._attributes[i];
    }
    return null;
};

/**
 * @function setAttribute
 * @description create an attribute
 * @memberof Geometry
 * @instance
 * @param {String} name
 * @param {Array} arr
 * @param {Number} itemSize
 */
Geometry.prototype.setAttribute = function (name, arr, itemSize)
{
    let attrType = "";
    if (!itemSize || itemSize > 4)
    {
        console.log("itemsize wrong?", itemSize, name);
        this._log.stack("itemsize");

        itemSize = 3;
    }

    if (itemSize == 1) attrType = "float";
    else if (itemSize == 2) attrType = "vec2";
    else if (itemSize == 3) attrType = "vec3";
    else if (itemSize == 4) attrType = "vec4";


    const attr = {
        "name": name,
        "data": arr,
        "itemSize": itemSize,
        "type": attrType,
    };

    this._attributes[name] = attr;
};

Geometry.prototype.copyAttribute = function (name, newgeom)
{
    const attr = this.getAttribute(name);
    newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);
};


/**
 * @function setVertices
 * @memberof Geometry
 * @instance
 * @description set vertices
 * @param {Array|Float32Array} arr [x,y,z,x,y,z,...]
 */
Geometry.prototype.setVertices = function (arr)
{
    if (arr instanceof Float32Array) this._vertices = arr;
    else this._vertices = new Float32Array(arr);
};

/**
 * @function setTexCoords
 * @memberof Geometry
 * @instance
 * @description set texcoords
 * @param {Array|Float32Array} arr [u,v,u,v,...]
 */
Geometry.prototype.setTexCoords = function (arr)
{
    if (arr instanceof Float32Array) this.texCoords = arr;
    else this.texCoords = new Float32Array(arr);
};

// Geometry.prototype.testIndices = function ()
// {
//     var foundError = false;
//     for (var i = 0; i < this.verticesIndices.length; i++)
//     {
//         if (this.verticesIndices[i * 3 + 0] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 1] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 2] >= this._vertices.length / 3)
//         {
//             foundError = true;
//             console.log("index error!");
//         }
//     }
// };

// deprecated
Geometry.prototype.calcNormals = function (smooth)
{
    const options = { "smooth": smooth };
    this.calculateNormals(options);
};

/**
 * @function flipNormals
 * @memberof Geometry
 * @param x
 * @param y
 * @param z
 * @description flip normals
 */
Geometry.prototype.flipNormals = function (x, y, z)
{
    let vec = vec3.create();

    if (x == undefined)x = 1;
    if (y == undefined)y = 1;
    if (z == undefined)z = 1;


    for (let i = 0; i < this.vertexNormals.length; i += 3)
    {
        vec3.set(vec,
            this.vertexNormals[i + 0],
            this.vertexNormals[i + 1],
            this.vertexNormals[i + 2]);

        vec[0] *= -x;
        vec[1] *= -y;
        vec[2] *= -z;

        vec3.normalize(vec, vec);

        this.vertexNormals[i + 0] = vec[0];
        this.vertexNormals[i + 1] = vec[1];
        this.vertexNormals[i + 2] = vec[2];
    }
};

Geometry.prototype.getNumTriangles = function ()
{
    if (this.verticesIndices && this.verticesIndices.length) return this.verticesIndices.length / 3;
    return this.vertices.length / 3;
};


/**
 * @function flipVertDir
 * @memberof Geometry
 * @description flip order of vertices in geom faces
 */
Geometry.prototype.flipVertDir = function ()
{
    const newInd = [];
    newInd.length = this.verticesIndices.length;
    for (let i = 0; i < this.verticesIndices.length; i += 3)
    {
        newInd[i] = this.verticesIndices[i + 2];
        newInd[i + 1] = this.verticesIndices[i + 1];
        newInd[i + 2] = this.verticesIndices[i];
    }
    this.verticesIndices = newInd;
};


Geometry.prototype.setPointVertices = function (verts)
{
    if (verts.length % 3 !== 0)
    {
        this._log.error("SetPointVertices: Array must be multiple of three.");
        return;
    }

    if (!(verts instanceof Float32Array)) this.vertices = new Float32Array(verts);
    else this.vertices = verts;

    if (!(this.texCoords instanceof Float32Array)) this.texCoords = new Float32Array((verts.length / 3) * 2);

    // this.texCoords.length=verts.length/3*2;
    this.verticesIndices.length = verts.length / 3;
    // this.verticesIndices=[];

    for (let i = 0; i < verts.length / 3; i++)
    {
        this.verticesIndices[i] = i;
        this.texCoords[i * 2] = 0;
        this.texCoords[i * 2 + 1] = 0;
    }
};

/**
 * merge a different geometry into the this geometry
 * @function merge
 * @param {Geometry} geom
 * @memberof Geometry
 * @instance
 */
Geometry.prototype.merge = function (geom)
{
    if (!geom) return;

    if (this.isIndexed() != geom.isIndexed())
    {
        if (this.isIndexed())
        {
            this.unIndex(false, true);
        }
        if (geom.isIndexed())
        {
            const g = geom.copy();
            g.unIndex(false, true);
            geom = g;
        }
    }

    const oldIndizesLength = this.verticesIndices.length;
    const vertLength = this._vertices.length / 3;

    this.verticesIndices.length += geom.verticesIndices.length;
    for (let i = 0; i < geom.verticesIndices.length; i++)
        this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;

    this.vertices = UTILS.float32Concat(this._vertices, geom.vertices);
    this.texCoords = UTILS.float32Concat(this.texCoords, geom.texCoords);
    this.vertexNormals = UTILS.float32Concat(this.vertexNormals, geom.vertexNormals);
    this.tangents = UTILS.float32Concat(this.tangents, geom.tangents);
    this.biTangents = UTILS.float32Concat(this.biTangents, geom.biTangents);
};

/**
 *   a copy of the geometry
 * @function copy
 * @memberof Geometry
 * @instance
 */
Geometry.prototype.copy = function ()
{
    const geom = new Geometry(this.name + " copy");
    geom.faceVertCount = this.faceVertCount;
    geom.glPrimitive = this.glPrimitive;

    geom.setVertices(this._vertices.slice(0));

    if (this.verticesIndices)
    {
        geom.verticesIndices.length = this.verticesIndices.length;
        for (let i = 0; i < this.verticesIndices.length; i++) geom.verticesIndices[i] = this.verticesIndices[i];
    }

    for (let i in this._attributes) this.copyAttribute(i, geom);

    geom.morphTargets.length = this.morphTargets.length;
    for (let i = 0; i < this.morphTargets.length; i++) geom.morphTargets[i] = this.morphTargets[i];

    return geom;
};

/**
 * Calculaten normals
 * @function calculateNormals
 * @memberof Geometry
 * @param options
 * @instance
 */
Geometry.prototype.calculateNormals = function (options)
{
    // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152
    options = options || {};
    if (options.smooth === false) this.unIndex();

    const u = vec3.create();
    const v = vec3.create();
    const n = vec3.create();

    function calcNormal(triangle)
    {
        vec3.subtract(u, triangle[0], triangle[1]);
        vec3.subtract(v, triangle[0], triangle[2]);
        vec3.cross(n, u, v);
        vec3.normalize(n, n);

        if (options && options.forceZUp)
        {
            if (n[2] < 0)
            {
                n[0] *= -1;
                n[1] *= -1;
                n[2] *= -1;
            }
        }
        return n;
    }

    this.getVertexVec = function (which)
    {
        const vec = [0, 0, 0];
        vec[0] = this.vertices[which * 3 + 0];
        vec[1] = this.vertices[which * 3 + 1];
        vec[2] = this.vertices[which * 3 + 2];
        return vec;
    };

    if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length) this.vertexNormals = new Float32Array(this.vertices.length);

    for (let i = 0; i < this.vertices.length; i++)
    {
        this.vertexNormals[i] = 0;
    }

    if (!this.isIndexed())
    {
        const norms = [];
        for (let i = 0; i < this.vertices.length; i += 9)
        {
            const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];
            const nn = calcNormal(triangle);
            norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);
        }
        this.vertexNormals = norms;
    }
    else
    {
        const faceNormals = [];

        faceNormals.length = Math.floor(this.verticesIndices.length / 3);

        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];

            faceNormals[i / 3] = calcNormal(triangle);

            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];
            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];
            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];

            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];
            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];
            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];

            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];
            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];
            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];
        }


        for (let i = 0; i < this.verticesIndices.length; i += 3) // faces
        {
            for (let k = 0; k < 3; k++) // triangles
            {
                const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];
                vec3.normalize(vv, vv);
                this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
                this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
                this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
            }
        }
    }
};

/**
 * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from
 * Lengyel, Eric. Computing Tangent Space Basis Vectors for an Arbitrary Mesh.
 * Terathon Software 3D Graphics Library.
 * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf
 *
 * @function calcTangentsBitangents
 * @memberof Geometry
 * @instance
 */
Geometry.prototype.calcTangentsBitangents = function ()
{
    if (!this.vertices.length)
    {
        // this._log.error("Cannot calculate tangents/bitangents without vertices.");
        return;
    }
    if (!this.vertexNormals.length)
    {
        // this._log.error("Cannot calculate tangents/bitangents without normals.");
        return;
    }
    if (!this.texCoords.length)
    {
        // console.warn("No texcoords. Replacing with default values [0, 0].");
        const texCoordLength = (this.vertices.length / 3) * 2;
        this.texCoords = new Float32Array(texCoordLength);
        for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;
    }
    if (!this.verticesIndices || !this.verticesIndices.length)
    {
        // this._log.error("Cannot calculate tangents/bitangents without vertex indices.");
        return;
    }
    // this code assumes that we have three indices per triangle
    if (this.verticesIndices.length % 3 !== 0)
    {
        this._log.error("Vertex indices mismatch!");
        return;
    }

    const triangleCount = this.verticesIndices.length / 3;
    const vertexCount = this.vertices.length / 3;

    this.tangents = new Float32Array(this.vertexNormals.length);
    this.biTangents = new Float32Array(this.vertexNormals.length);

    // temporary buffers
    const tempVertices = [];
    tempVertices.length = vertexCount * 2;
    const v1 = vec3.create();
    const v2 = vec3.create();
    const v3 = vec3.create();

    const w1 = vec2.create();
    const w2 = vec2.create();
    const w3 = vec2.create();

    const sdir = vec3.create();
    const tdir = vec3.create();

    // for details on calculation, see article referenced above
    for (let tri = 0; tri < triangleCount; tri += 1)
    {
        // indices of the three vertices for a triangle
        const i1 = this.verticesIndices[tri * 3];
        const i2 = this.verticesIndices[tri * 3 + 1];
        const i3 = this.verticesIndices[tri * 3 + 2];

        // vertex position as vec3
        vec3.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);
        vec3.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);
        vec3.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);

        // texture coordinate as vec2
        vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
        vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
        vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);

        const x1 = v2[0] - v1[0];
        const x2 = v3[0] - v1[0];
        const y1 = v2[1] - v1[1];
        const y2 = v3[1] - v1[1];
        const z1 = v2[2] - v1[2];
        const z2 = v3[2] - v1[2];

        const s1 = w2[0] - w1[0];
        const s2 = w3[0] - w1[0];
        const t1 = w2[1] - w1[1];
        const t2 = w3[1] - w1[1];

        const r = 1.0 / (s1 * t2 - s2 * t1);

        vec3.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
        vec3.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

        tempVertices[i1] = sdir;
        tempVertices[i2] = sdir;
        tempVertices[i3] = sdir;

        tempVertices[i1 + vertexCount] = tdir;
        tempVertices[i2 + vertexCount] = tdir;
        tempVertices[i3 + vertexCount] = tdir;
    }

    const normal = vec3.create();
    const tempVert = vec3.create();
    const tan = vec3.create();
    const bitan = vec3.create();
    const temp1 = vec3.create();
    const temp2 = vec3.create();
    const crossPd = vec3.create();
    const normalized = vec3.create();

    for (let vert = 0; vert < vertexCount; vert += 1)
    {
        // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex
        if (!tempVertices[vert]) continue;

        vec3.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);
        vec3.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);

        // Gram-Schmidt orthagonalize
        const _dp = vec3.dot(normal, tempVert);
        vec3.scale(temp1, normal, _dp);
        vec3.subtract(temp2, tempVert, temp1);

        vec3.normalize(normalized, temp2);
        vec3.cross(crossPd, normal, tempVert);

        // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);
        const w = 1.0;// intermDot < 0.0 ? -1.0 : 1.0;

        vec3.scale(tan, normalized, 1 / w);
        vec3.cross(bitan, normal, tan);

        this.tangents[vert * 3 + 0] = tan[0];
        this.tangents[vert * 3 + 1] = tan[1];
        this.tangents[vert * 3 + 2] = tan[2];
        this.biTangents[vert * 3 + 0] = bitan[0];
        this.biTangents[vert * 3 + 1] = bitan[1];
        this.biTangents[vert * 3 + 2] = bitan[2];
    }
};

Geometry.prototype.isIndexed = function ()
{
    if (this._vertices.length == 0) return true;
    return this.verticesIndices.length != 0;
};

/**
 * @function unIndex
 * @memberof Geometry
 * @instance
 * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle
 * @param {boolean} reIndex
 * @param {boolean} dontCalcNormals
 */
Geometry.prototype.unIndex = function (reIndex, dontCalcNormals)
{
    const newVerts = [];
    const newIndizes = [];
    let count = 0;

    for (let j in this._attributes)
    {
        const attr = this._attributes[j];
        let na = [];

        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            for (let s = 0; s < 3; s++)
            {
                if (attr.itemSize == 3)
                    na.push(
                        attr.data[this.verticesIndices[i + s] * 3 + 0],
                        attr.data[this.verticesIndices[i + s] * 3 + 1],
                        attr.data[this.verticesIndices[i + s] * 3 + 2]);
                else if (attr.itemSize == 4)
                    na.push(
                        attr.data[this.verticesIndices[i + s] * 4 + 0],
                        attr.data[this.verticesIndices[i + s] * 4 + 1],
                        attr.data[this.verticesIndices[i + s] * 4 + 2],
                        attr.data[this.verticesIndices[i + s] * 4 + 3]);
                else if (attr.itemSize == 2)
                    na.push(
                        attr.data[this.verticesIndices[i + s] * 2 + 0],
                        attr.data[this.verticesIndices[i + s] * 2 + 1]);
                else if (attr.itemSize == 1)
                    na.push(
                        attr.data[this.verticesIndices[i + s]]);
                else console.log("unknown attr", attr);
            }
        }
        this.setAttribute(attr.name, na, attr.itemSize);
    }

    for (let i = 0; i < this.verticesIndices.length; i += 3)
    {
        newVerts.push(
            this.vertices[this.verticesIndices[i + 0] * 3 + 0],
            this.vertices[this.verticesIndices[i + 0] * 3 + 1],
            this.vertices[this.verticesIndices[i + 0] * 3 + 2]);

        newIndizes.push(count);
        count++;

        newVerts.push(
            this.vertices[this.verticesIndices[i + 1] * 3 + 0],
            this.vertices[this.verticesIndices[i + 1] * 3 + 1],
            this.vertices[this.verticesIndices[i + 1] * 3 + 2]);

        newIndizes.push(count);
        count++;

        newVerts.push(
            this.vertices[this.verticesIndices[i + 2] * 3 + 0],
            this.vertices[this.verticesIndices[i + 2] * 3 + 1],
            this.vertices[this.verticesIndices[i + 2] * 3 + 2]);

        newIndizes.push(count);
        count++;
    }

    this.vertices = newVerts;

    this.verticesIndices = [];
    if (reIndex) this.verticesIndices = newIndizes;

    if (!dontCalcNormals) this.calculateNormals();
};

Geometry.prototype.calcBarycentric = function ()
{
    let barycentrics = [];
    barycentrics.length = this.vertices.length;
    for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;

    let count = 0;
    for (let i = 0; i < this.vertices.length; i += 3)
    {
        barycentrics[i + count] = 1;
        count++;
        if (count == 3) count = 0;
    }

    this.setAttribute("attrBarycentric", barycentrics, 3);
};

Geometry.prototype.getBounds = function ()
{
    return new BoundingBox(this);
};

Geometry.prototype.center = function (x, y, z)
{
    if (x === undefined)
    {
        x = true;
        y = true;
        z = true;
    }

    let i = 0;
    const bounds = this.getBounds();
    const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];

    for (i = 0; i < this.vertices.length; i += 3)
    {
        if (this.vertices[i + 0] == this.vertices[i + 0])
        {
            if (x) this.vertices[i + 0] -= offset[0];
            if (y) this.vertices[i + 1] -= offset[1];
            if (z) this.vertices[i + 2] -= offset[2];
        }
    }

    return offset;
};

Geometry.prototype.mapTexCoords2d = function ()
{
    const bounds = this.getBounds();
    const num = this.vertices.length / 3;

    this.texCoords = new Float32Array(num * 2);

    for (let i = 0; i < num; i++)
    {
        const vertX = this.vertices[i * 3 + 0];
        const vertY = this.vertices[i * 3 + 1];
        this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
        this.texCoords[i * 2 + 1] = 1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;
    }
};


Geometry.prototype.getInfoOneLine = function ()
{
    let txt = "";
    if (this.faceVertCount == 3 && this.verticesIndices)txt += this.verticesIndices.length / 3;
    else txt += 0;

    txt += " tris ";

    if (this.vertices)txt += this.vertices.length / 3;
    else txt += 0;

    txt += " verts";

    return txt;
};

Geometry.prototype.getInfo = function ()
{
    const info = {};

    if (this.faceVertCount == 3 && this.verticesIndices)info.numFaces = this.verticesIndices.length / 3;
    else info.numFaces = 0;

    if (this.verticesIndices && this.verticesIndices.length)info.indices = this.verticesIndices.length;

    if (this.vertices)info.numVerts = this.vertices.length / 3;
    else info.numVerts = 0;

    if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;
    else info.numNormals = 0;

    if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;
    else info.numTexCoords = 0;

    if (this.tangents) info.numTangents = this.tangents.length / 3;
    else info.numTangents = 0;

    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
    else info.numBiTangents = 0;

    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
    else info.numBiTangents = 0;

    if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;
    else info.numVertexColors = 0;

    if (this.getAttributes()) info.numAttribs = Object.keys(this.getAttributes()).length;
    else info.numAttribs = 0;

    info.isIndexed = this.isIndexed();

    return info;
};

// -----------------

// TODO : rewritwe circle op
Geometry.buildFromFaces = function (arr, name, optimize)
{
    const vertices = [];
    const verticesIndices = [];

    for (let i = 0; i < arr.length; i += 3)
    {
        const a = arr[i + 0];
        const b = arr[i + 1];
        const c = arr[i + 2];
        const face = [-1, -1, -1];

        if (optimize)
            for (let iv = 0; iv < vertices.length; iv += 3)
            {
                if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2]) face[0] = iv / 3;
                if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2]) face[1] = iv / 3;
                if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2]) face[2] = iv / 3;
            }

        if (face[0] == -1)
        {
            vertices.push(a[0], a[1], a[2]);
            face[0] = (vertices.length - 1) / 3;
        }

        if (face[1] == -1)
        {
            vertices.push(b[0], b[1], b[2]);
            face[1] = (vertices.length - 1) / 3;
        }

        if (face[2] == -1)
        {
            vertices.push(c[0], c[1], c[2]);
            face[2] = (vertices.length - 1) / 3;
        }

        verticesIndices.push(parseInt(face[0], 10));
        verticesIndices.push(parseInt(face[1], 10));
        verticesIndices.push(parseInt(face[2], 10));
    }

    const geom = new Geometry(name);
    geom.name = name;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;

    return geom;
};




;// CONCATENATED MODULE: ./src/core/cgl/cgl_mesh.js




const MESH = {};
MESH.lastMesh = null;

/**
 * webgl renderable 3d object
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @param {Context} _cgl cgl
 * @param {Geometry} __geom geometry
 * @param {Number} _options glPrimitive
 * @example
 * const cgl=this._cgl
 * const mesh=new CGL.Mesh(cgl, geometry);
 *
 * function render()
 * {
 *   mesh.render(cgl.getShader());
 * }
 */
const Mesh = function (_cgl, __geom, _options)
{
    this._cgl = _cgl;

    let options = _options || {};
    if (CABLES.UTILS.isNumeric(options))options = { "glPrimitive": _options }; // old constructor fallback...
    this._log = new Logger("cgl_mesh");
    this._bufVertexAttrib = null;
    this._bufVerticesIndizes = this._cgl.gl.createBuffer();
    this._indexType = this._cgl.gl.UNSIGNED_SHORT;
    this._attributes = [];
    this._attribLocs = {};
    this._geom = null;
    this._lastShader = null;
    this._numInstances = 0;
    this._glPrimitive = options.glPrimitive;

    this.opId = options.opId || "";
    this._preWireframeGeom = null;
    this.addVertexNumbers = false;
    this._name = "unknown";

    this.feedBackAttributes = [];
    this.setGeom(__geom);

    this._feedBacks = [];
    this._feedBacksChanged = false;
    this._transformFeedBackLoc = -1;
    this._lastAttrUpdate = 0;

    this.memFreed = false;

    this._cgl.profileData.addHeavyEvent("mesh constructed", this._name);

    this._queryExt = null;

    Object.defineProperty(this, "numInstances", {
        get()
        {
            return this._numInstances;
        },
        set(v)
        {
            this.setNumInstances(v);
        },
    });
};

Mesh.prototype.freeMem = function ()
{
    this.memFreed = true;

    for (let i = 0; i < this._attributes.length; i++)
    {
        this._attributes[i].floatArray = null;
    }
};

/**
 * @function updateVertices
 * @memberof Mesh
 * @instance
 * @description update vertices only from a geometry
 * @param {Geometry} geom
 */
Mesh.prototype.updateVertices = function (geom)
{
    this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);
    this._numVerts = geom.vertices.length / 3;
};

Mesh.prototype.setAttributePointer = function (attrName, name, stride, offset)
{
    for (let i = 0; i < this._attributes.length; i++)
    {
        if (this._attributes[i].name == attrName)
        {
            if (!this._attributes[i].pointer) this._attributes[i].pointer = [];

            this._attributes[i].pointer.push(
                {
                    "loc": -1,
                    "name": name,
                    "stride": stride,
                    "offset": offset,
                    "instanced": attrName == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX,
                }
            );
        }
    }
};

Mesh.prototype.getAttribute = function (name)
{
    for (let i = 0; i < this._attributes.length; i++) if (this._attributes[i].name == name) return this._attributes[i];
};

Mesh.prototype.setAttributeRange = function (attr, array, start, end)
{
    if (!attr) return;
    if (!start && !end) return;

    if (!attr.name)
    {
        this._log.stack("no attrname?!");
    }

    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._cgl.profileData.profileMeshAttributes += (end - start) || 0;

    this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] += (end - start) || 0;

    if (attr.numItems < array.length / attr.itemSize)
    {
        this._resizeAttr(array, attr);
    }

    if (end > array.length)
    {
        if (CABLES.platform.isDevEnv())
            this._log.log(this._cgl.canvas.id + " " + attr.name + " buffersubdata out of bounds ?", array.length, end, start, attr);
        // end = array.length - 1;
        return;
    }

    if (this._cgl.glVersion == 1) this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??
    else this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, start * 4, array, start, (end - start));
};

Mesh.prototype._resizeAttr = function (array, attr)
{
    if (attr.buffer)
        this._cgl.gl.deleteBuffer(attr.buffer);

    attr.buffer = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._bufferArray(array, attr);
    attr.numItems = array.length / attr.itemSize;// numItems;
};


Mesh.prototype._bufferArray = function (array, attr)
{
    let floatArray = attr.floatArray || null;
    if (!array) return;


    if (this._cgl.debugOneFrame)
    {
        console.log("_bufferArray", array.length, attr.name); // eslint-disable-line
    }

    if (!(array instanceof Float32Array))
    {
        if (attr && floatArray && floatArray.length == array.length)
        {
            floatArray.set(array);
            // floatArray = floatArray;
        }
        else
        {
            floatArray = new Float32Array(array);

            if (this._cgl.debugOneFrame)
            {
                console.log("_bufferArray create new float32array", array.length, attr.name); // eslint-disable-line
            }

            if (array.length > 10000)
            {
                this._cgl.profileData.profileNonTypedAttrib++;
                this._cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + attr.name + ")";
            }
        }
    }
    else floatArray = array;

    attr.arrayLength = floatArray.length;
    attr.floatArray = null;// floatArray;

    this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);
};

/**
 * @function setAttribute
 * @description update attribute
 * @memberof Mesh
 * @instance
 * @param {String} attribute name
 * @param {Array} data
 * @param {Number} itemSize
 * @param {Object} options
 */
Mesh.prototype.addAttribute = Mesh.prototype.updateAttribute = Mesh.prototype.setAttribute = function (name, array, itemSize, options)
{
    if (!array)
    {
        this._log.error("mesh addAttribute - no array given! " + name);
        throw new Error();
    }
    let cb = null;
    let instanced = false;
    let i = 0;
    const numItems = array.length / itemSize;

    this._cgl.profileData.profileMeshAttributes += numItems || 0;

    if (typeof options == "function")
    {
        cb = options;
    }

    if (typeof options == "object")
    {
        if (options.cb) cb = options.cb;
        if (options.instanced) instanced = options.instanced;
    }

    if (name == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;


    for (i = 0; i < this._attributes.length; i++)
    {
        const attr = this._attributes[i];
        if (attr.name == name)
        {
            if (attr.numItems === numItems)
            {
            }
            else
            {
                // this._log.log("wrong buffer size", this._geom.name, attr.name, attr.numItems, numItems);
                this._resizeAttr(array, attr);
            }

            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
            this._bufferArray(array, attr);

            return attr;
        }
    }

    // create new buffer...

    const buffer = this._cgl.gl.createBuffer();

    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, buffer);
    // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);

    let type = this._cgl.gl.FLOAT;
    if (options && options.type) type = options.type;
    const attr = {
        "buffer": buffer,
        "name": name,
        "cb": cb,
        "itemSize": itemSize,
        "numItems": numItems,
        "startItem": 0,
        "instanced": instanced,
        "type": type
    };

    this._bufferArray(array, attr);

    if (name == constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION) this._bufVertexAttrib = attr;
    this._attributes.push(attr);
    this._attribLocs = {};

    return attr;
};

Mesh.prototype.getAttributes = function ()
{
    return this._attributes;
};

/**
 * @function updateTexCoords
 * @description update texture coordinates only from a geometry
 * @memberof Mesh
 * @instance
 * @param {Geometry} geom
 */
Mesh.prototype.updateTexCoords = function (geom)
{
    if (geom.texCoords && geom.texCoords.length > 0)
    {
        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);
    }
    else
    {
        const tcBuff = new Float32Array(Math.round((geom.vertices.length / 3) * 2));
        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);
    }
};


/**
 * @function updateNormals
 * @description update normals only from a geometry
 * @memberof Mesh
 * @instance
 * @param {Geometry} geom
 */
Mesh.prototype.updateNormals = function (geom)
{
    if (geom.vertexNormals && geom.vertexNormals.length > 0)
    {
        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);
    }
    else
    {
        const tcBuff = new Float32Array(Math.round((geom.vertices.length)));
        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);
    }
};


Mesh.prototype._setVertexNumbers = function (arr)
{
    if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr)
    {
        if (arr) this._verticesNumbers = arr;
        else
        {
            this._verticesNumbers = new Float32Array(this._numVerts);
            for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;
        }

        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (attr, geom, shader) =>
        {
            if (!shader.uniformNumVertices) shader.uniformNumVertices = new Uniform(shader, "f", "numVertices", this._numVerts);
            shader.uniformNumVertices.setValue(this._numVerts);

            // console.log("this._numVerts", this._numVerts, attr, shader.uniformNumVertices);
        });
    }
};

/**
 * @function setVertexIndices
 * @description update vertex indices / faces
 * @memberof Mesh
 * @instance
 * @param {array} vertIndices
 */
Mesh.prototype.setVertexIndices = function (vertIndices)
{
    if (!this._bufVerticesIndizes)
    {
        this._log.warn("no bufVerticesIndizes: " + this._name);
        return;
    }
    if (vertIndices.length > 0)
    {
        if (vertIndices instanceof Float32Array) this._log.warn("vertIndices float32Array: " + this._name);

        for (let i = 0; i < vertIndices.length; i++)
        {
            if (vertIndices[i] >= this._numVerts)
            {
                this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
                return;
            }
        }

        this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);

        // todo cache this ?
        // if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)

        if (vertIndices.length > 65535)
        {
            this.vertIndicesTyped = new Uint32Array(vertIndices);
            this._indexType = this._cgl.gl.UNSIGNED_INT;
        }
        else
        if (vertIndices instanceof Uint32Array)
        {
            this.vertIndicesTyped = vertIndices;
            this._indexType = this._cgl.gl.UNSIGNED_INT;
        }
        else
        if (!(vertIndices instanceof Uint16Array))
        {
            this.vertIndicesTyped = new Uint16Array(vertIndices);
            this._indexType = this._cgl.gl.UNSIGNED_SHORT;
        }
        else this.vertIndicesTyped = vertIndices;

        this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW);
        this._bufVerticesIndizes.itemSize = 1;
        this._bufVerticesIndizes.numItems = vertIndices.length;
    }
    else this._bufVerticesIndizes.numItems = 0;
};

/**
 * @function setGeom
 * @memberof Mesh
 * @instance
 * @description set geometry for mesh
 * @param {Geometry} geom
 * @param {boolean} removeRef
 */
Mesh.prototype.setGeom = function (geom, removeRef)
{
    this._geom = geom;
    if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;
    if (this._geom && this._geom.name) this._name = "mesh " + this._geom.name;

    MESH.lastMesh = null;
    this._cgl.profileData.profileMeshSetGeom++;

    this._disposeAttributes();

    this.updateVertices(this._geom);
    this.setVertexIndices(this._geom.verticesIndices);

    if (this.addVertexNumbers) this._setVertexNumbers();

    const geomAttribs = this._geom.getAttributes();

    const attribAssoc = {
        "texCoords": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
        "vertexNormals": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
        "vertexColors": constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,
        "tangents": "attrTangent",
        "biTangents": "attrBiTangent",
    };

    for (const index in geomAttribs)
        if (geomAttribs[index].data && geomAttribs[index].data.length)
            this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);


    if (removeRef)
    {
        this._geom = null;
    }
};

Mesh.prototype._preBind = function (shader)
{
    for (let i = 0; i < this._attributes.length; i++)
        if (this._attributes[i].cb)
            this._attributes[i].cb(this._attributes[i], this._geom, shader);
};

Mesh.prototype._checkAttrLengths = function ()
{
    if (this.memFreed) return;
    // check length
    for (let i = 0; i < this._attributes.length; i++)
    {
        if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize)
        {
            let name = "unknown";
            if (this._geom)name = this._geom.name;
            // this._log.warn(
            //     name + ": " + this._attributes[i].name +
            //     " wrong attr length. is:", this._attributes[i].arrayLength / this._attributes[i].itemSize,
            //     " should be:", this._attributes[0].arrayLength / this._attributes[0].itemSize,
            // );
        }
    }
};

Mesh.prototype._bind = function (shader)
{
    if (!shader.isValid()) return;

    let attrLocs = [];
    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
    else this._attribLocs[shader.id] = attrLocs;

    this._lastShader = shader;
    if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length)
    {
        this._lastAttrUpdate = shader.lastCompile;
        for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;
    }

    for (let i = 0; i < this._attributes.length; i++)
    {
        const attribute = this._attributes[i];
        if (attrLocs[i] == -1)
        {
            if (attribute._attrLocationLastShaderTime != shader.lastCompile)
            {
                attribute._attrLocationLastShaderTime = shader.lastCompile;
                attrLocs[i] = this._cgl.glGetAttribLocation(shader.getProgram(), attribute.name);
                // this._log.log('attribloc',attribute.name,attrLocs[i]);
                this._cgl.profileData.profileAttrLoc++;
            }
        }

        if (attrLocs[i] != -1)
        {
            this._cgl.gl.enableVertexAttribArray(attrLocs[i]);
            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attribute.buffer);

            if (attribute.instanced)
            {
                // todo: easier way to fill mat4 attribs...
                if (attribute.itemSize <= 4)
                {
                    if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("instanced attrib itemsize error", this._geom.name, attribute);

                    this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);
                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                }
                else if (attribute.itemSize == 16)
                {
                    const stride = 16 * 4;

                    this._cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);
                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);
                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);
                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);

                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
                }
                else
                {
                    this._log.warn("unknown instance attrib size", attribute.name);
                }
            }
            else
            {
                if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("attrib itemsize error", this._name, attribute);
                this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);

                if (attribute.pointer)
                {
                    for (let ip = 0; ip < attribute.pointer.length; ip++)
                    {
                        const pointer = attribute.pointer[ip];

                        if (pointer.loc == -1)
                            pointer.loc = this._cgl.glGetAttribLocation(shader.getProgram(), pointer.name);

                        this._cgl.profileData.profileAttrLoc++;

                        this._cgl.gl.enableVertexAttribArray(pointer.loc);
                        this._cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);
                    }
                }
                if (this.bindFeedback) this.bindFeedback(attribute);
            }
        }
    }

    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0) this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);
};

Mesh.prototype.unBind = function ()
{
    const shader = this._lastShader;
    this._lastShader = null;
    if (!shader) return;

    let attrLocs = [];
    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
    else this._attribLocs[shader.id] = attrLocs;

    MESH.lastMesh = null;

    for (let i = 0; i < this._attributes.length; i++)
    {
        if (this._attributes[i].instanced)
        {
            // todo: easier way to fill mat4 attribs...
            if (this._attributes[i].itemSize <= 4)
            {
                if (attrLocs[i] != -1) this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                if (attrLocs[i] >= 0) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
            }
            else
            {
                this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
            }
        }

        if (attrLocs[i] != -1) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
    }
};

Mesh.prototype.meshChanged = function ()
{
    return this._cgl.lastMesh && this._cgl.lastMesh != this;
};

Mesh.prototype.printDebug = function (shader)
{
    console.log("--attributes");
    for (let i = 0; i < this._attributes.length; i++)
    {
        console.log("attribute " + i + " " + this._attributes[i].name);
    }
};

Mesh.prototype.setNumVertices = function (num)
{
    this._bufVertexAttrib.numItems = num;
};

Mesh.prototype.getNumVertices = function ()
{
    return this._bufVertexAttrib.numItems;
};


/**
 * @function render
 * @memberof Mesh
 * @instance
 * @description draw mesh to screen
 * @param {Shader} shader
 */
Mesh.prototype.render = function (shader)
{
    // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh

    if (!shader || !shader.isValid() || this._cgl.aborted) return;

    this._checkAttrLengths();

    if (this._geom)
    {
        if (this._preWireframeGeom && !shader.wireframe && !this._geom.isIndexed())
        {
            this.setGeom(this._preWireframeGeom);
            this._preWireframeGeom = null;
            // console.log("remove prewireframe geom");
        }

        if (shader.wireframe)
        {
            let changed = false;

            if (this._geom.isIndexed())
            {
                if (!this._preWireframeGeom)
                {
                    this._preWireframeGeom = this._geom;
                    this._geom = this._geom.copy();
                }

                this._geom.unIndex();
                changed = true;
            }

            if (!this._geom.getAttribute("attrBarycentric"))
            {
                if (!this._preWireframeGeom)
                {
                    this._preWireframeGeom = this._geom;
                    this._geom = this._geom.copy();
                }
                changed = true;

                this._geom.calcBarycentric();
            }
            if (changed) this.setGeom(this._geom);
        }
        // if (shader.wireframe)
        // console.log(shader.wireframe, this._geom.isIndexed());
    }

    let needsBind = false;
    if (MESH.lastMesh != this)
    {
        if (MESH.lastMesh) MESH.lastMesh.unBind();
        needsBind = true;
    }


    // var needsBind=false;
    // {
    //     needsBind=true;
    // }
    if (needsBind) this._preBind(shader);

    if (!shader.bind()) return;

    // if(needsBind)
    this._bind(shader);
    if (this.addVertexNumbers) this._setVertexNumbers();

    MESH.lastMesh = this;

    let prim = this._cgl.gl.TRIANGLES;
    if (this._glPrimitive !== undefined) prim = this._glPrimitive;
    if (shader.glPrimitive !== null) prim = shader.glPrimitive;

    let elementDiv = 1;
    let doQuery = this._cgl.profileData.doProfileGlQuery;
    let queryStarted = false;
    if (doQuery)
    {
        let id = this._name + " - " + shader.getName() + " #" + shader.id;
        if (this._numInstances) id += " instanced " + this._numInstances + "x";

        let queryProfilerData = this._cgl.profileData.glQueryData[id];

        if (!queryProfilerData) queryProfilerData = { "id": id, "num": 0 };

        if (shader.opId)queryProfilerData.shaderOp = shader.opId;
        if (this.opId)queryProfilerData.meshOp = this.opId;

        this._cgl.profileData.glQueryData[id] = queryProfilerData;

        if (!this._queryExt && this._queryExt !== false) this._queryExt = this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
        if (this._queryExt)
        {
            if (queryProfilerData._drawQuery)
            {
                const available = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE);
                if (available)
                {
                    const elapsedNanos = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT);
                    const currentTimeGPU = elapsedNanos / 1000000;

                    queryProfilerData._times = queryProfilerData._times || 0;
                    queryProfilerData._times += currentTimeGPU;
                    queryProfilerData._numcount++;
                    queryProfilerData.when = performance.now();
                    queryProfilerData._drawQuery = null;
                    queryProfilerData.queryStarted = false;
                }
            }

            if (!queryProfilerData.queryStarted)
            {
                queryProfilerData._drawQuery = this._cgl.gl.createQuery();
                this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);
                queryStarted = queryProfilerData.queryStarted = true;
            }
        }
    }


    if (this.hasFeedbacks && this.hasFeedbacks()) this.drawFeedbacks(shader, prim);
    else if (!this._bufVerticesIndizes || this._bufVerticesIndizes.numItems === 0)
    {
        // for (let i = 0; i < this._attributes.length; i++)
        // {
        //     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)
        //     {
        //         this._log.warn("attrib buffer length wrong! ", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);
        //         // this._log.log(this);
        //         // debugger;
        //         return;
        //     }
        // }


        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;
        if (this._numInstances === 0) this._cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);
        else this._cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);
    }
    else
    {
        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;
        if (this._numInstances === 0)
        {
            // console.log("la", this._bufVerticesIndizes.numItems);

            this._cgl.gl.drawElements(prim, this._bufVerticesIndizes.numItems, this._indexType, 0);
        }
        else
        {
            this._cgl.gl.drawElementsInstanced(prim, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);
        }
    }

    if (this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR)
    {
        this._log.error("mesh draw gl error");
        this._log.error("mesh", this);
        this._log.error("shader", shader);

        const attribNames = [];
        for (let i = 0; i < this._cgl.gl.getProgramParameter(shader.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); i++)
        {
            const name = this._cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
            this._log.error("attrib ", name);
        }
    }

    this._cgl.profileData.profileMeshNumElements += (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);
    this._cgl.profileData.profileMeshDraw++;

    if (doQuery && queryStarted)
    {
        this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
    }

    this._cgl.printError("mesh render " + this._name);

    this.unBind();
};

Mesh.prototype.setNumInstances = function (n)
{
    n = Math.max(0, n);
    if (this._numInstances != n)
    {
        this._numInstances = n;
        const indexArr = new Float32Array(n);
        for (let i = 0; i < n; i++) indexArr[i] = i;
        this.setAttribute(constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { "instanced": true });
    }
};

Mesh.prototype._disposeAttributes = function ()
{
    if (!this._attributes) return;

    for (let i = 0; i < this._attributes.length; i++)
    {
        if (this._attributes[i].buffer)
        {
            this._cgl.gl.deleteBuffer(this._attributes[i].buffer);
            this._attributes[i].buffer = null;
        }
    }
    this._attributes.length = 0;
};

Mesh.prototype.dispose = function ()
{
    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer) this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
    if (this._bufVerticesIndizes) this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);
    this._bufVerticesIndizes = null;

    this._disposeAttributes();
};





;// CONCATENATED MODULE: ./src/core/cgl/cgl_simplerect.js




const MESHES = {};

MESHES.getSimpleRect = function (cgl, name, size = 1.0)
{
    const geom = new Geometry(name);



    geom.vertices = [1.0 * size, 1.0 * size, 0.0, -1.0 * size, 1.0 * size, 0.0, 1.0 * size, -1.0 * size, 0.0, -1.0 * size, -1.0 * size, 0.0];
    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    return cgl.createMesh(geom);
    // return new Mesh(cgl, geom);
};


MESHES.getSimpleCube = function (cgl, name)
{
    const geom = new Geometry(name);
    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];
    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,]);
    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    geom.vertexNormals = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);
    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);

    return new Mesh(cgl, geom);
};




;// CONCATENATED MODULE: ./src/core/cgl/cgl_textureeffect.js




const TextureEffect = function (cgl, options)
{
    this._cgl = cgl;
    this._log = new Logger("cgl_TextureEffect");

    if (!cgl.TextureEffectMesh) this.createMesh();

    this._textureSource = null;
    this._options = options;
    this.name = options.name || "unknown";

    // TODO: do we still need the options ?
    // var opts=options ||
    //     {
    //         isFloatingPointTexture:false,
    //         filter:CGL.Texture.FILTER_LINEAR
    //     };
    // if(options && options.fp)opts.isFloatingPointTexture=true;

    this.imgCompVer = 0;
    this.aspectRatio = 1;
    this._textureTarget = null; // new CGL.Texture(this._cgl,opts);
    this._frameBuf = this._cgl.gl.createFramebuffer();
    this._frameBuf2 = this._cgl.gl.createFramebuffer();
    this._renderbuffer = this._cgl.gl.createRenderbuffer();
    this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
    this.switched = false;
    this.depth = false;
};

TextureEffect.prototype.dispose = function ()
{
    if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);
    if (this._renderbuffer2) this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
    if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);
};

TextureEffect.prototype.getWidth = function ()
{
    return this._textureSource.width;
};

TextureEffect.prototype.getHeight = function ()
{
    return this._textureSource.height;
};

TextureEffect.prototype.setSourceTexture = function (tex)
{
    if (tex === null)
    {
        this._textureSource = new Texture(this._cgl);
        this._textureSource.setSize(16, 16);
    }
    else
    {
        this._textureSource = tex;
    }

    if (!this._textureSource.compareSettings(this._textureTarget))
    {
        if (this._textureTarget) this._textureTarget.delete();

        this._textureTarget = this._textureSource.clone();

        this._cgl.profileData.profileEffectBuffercreate++;

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);

        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);

        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);
        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);

        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);

        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }

    this.aspectRatio = this._textureSource.width / this._textureSource.height;
};
TextureEffect.prototype.continueEffect = function ()
{
    this._cgl.pushDepthTest(false);
    this._cgl.pushModelMatrix();
    this._cgl.pushPMatrix();
    // todo why two pushs?



    this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);



    mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100.0); // todo: why?

    this._cgl.pushPMatrix();
    mat4.identity(this._cgl.pMatrix);

    this._cgl.pushViewMatrix();
    mat4.identity(this._cgl.vMatrix);

    this._cgl.pushModelMatrix();
    mat4.identity(this._cgl.mMatrix);
};


TextureEffect.prototype.startEffect = function (bgTex)
{
    if (!this._textureTarget)
    {
        this._log.warn("effect has no target");
        return;
    }

    this.switched = false;

    this.continueEffect();

    if (bgTex)
    {
        this._bgTex = bgTex;
    }
    this._countEffects = 0;
};

TextureEffect.prototype.endEffect = function ()
{
    this._cgl.popDepthTest();
    this._cgl.popModelMatrix();

    this._cgl.popPMatrix();
    this._cgl.popModelMatrix();
    this._cgl.popViewMatrix();

    this._cgl.popPMatrix();
    this._cgl.popViewPort();
};

TextureEffect.prototype.bind = function ()
{
    if (this._textureSource === null)
    {
        this._log.warn("no base texture set!");
        return;
    }

    if (!this.switched)
    {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
        this._cgl.pushGlFrameBuffer(this._frameBuf);
    }
    else
    {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
        this._cgl.pushGlFrameBuffer(this._frameBuf2);
    }
};

TextureEffect.prototype.finish = function ()
{
    if (this._textureSource === null)
    {
        this._log.warn("no base texture set!");
        return;
    }

    this._cgl.TextureEffectMesh.render(this._cgl.getShader());

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());

    this._cgl.profileData.profileTextureEffect++;

    if (this._textureTarget.filter == Texture.FILTER_MIPMAP)
    {
        if (!this.switched)
        {
            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);
            this._textureTarget.updateMipMap();
        }
        else
        {
            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);
            this._textureSource.updateMipMap();
        }

        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
    }

    this.switched = !this.switched;
    this._countEffects++;
};

TextureEffect.prototype.getCurrentTargetTexture = function ()
{
    if (this.switched) return this._textureSource;
    return this._textureTarget;
};

TextureEffect.prototype.getCurrentSourceTexture = function ()
{
    if (this._countEffects == 0 && this._bgTex) return this._bgTex;

    if (this.switched) return this._textureTarget;
    return this._textureSource;
};

TextureEffect.prototype.delete = function ()
{
    if (this._textureTarget) this._textureTarget.delete();
    if (this._textureSource) this._textureSource.delete();
    this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuf);
};

TextureEffect.prototype.createMesh = function ()
{
    this._cgl.TextureEffectMesh = MESHES.getSimpleRect(this._cgl, "texEffectRect");
};

// ---------------------------------------------------------------------------------

TextureEffect.checkOpNotInTextureEffect = function (op)
{
    if (!op.patch.cgl) return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect)
    {
        op.setUiError("textureeffect", null);
        return true;
    }
    if (!op.patch.cgl.currentTextureEffect) return true;

    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error)
    {
        op.setUiError("textureeffect", "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.", 0);
        return false;
    }

    if (op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.checkOpInEffect = function (op, minver)
{
    minver = minver || 0;

    if (op.patch.cgl.currentTextureEffect)
    {
        if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver)
        {
            op.setUiError("texeffect", null);
            return true;
        }

        if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver)
        {
            op.setUiError("texeffect", "This op must be a child of an ImageCompose op with version >=" + minver + " <span class=\"button-small\" onclick=\"gui.patchView.downGradeOp('" + op.id + "','" + op.name + "')\">Downgrade</span> to previous version", 1);
        }
    }

    if (op.patch.cgl.currentTextureEffect) return true;

    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0))
    {
        op.setUiError("texeffect", "This op must be a child of an ImageCompose op! More infos <a href=\"https://cables.gl/docs/image_composition/image_composition.html\" target=\"_blank\">here</a>. ", 1);
        return false;
    }

    if (!op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.getBlendCode = function (ver)
{
    let src = "".endl()
        + "vec3 _blend(vec3 base,vec3 blend)".endl()
        + "{".endl()
        + "   vec3 colNew=blend;".endl()
        + "   #ifdef BM_MULTIPLY".endl()
        + "       colNew=base*blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_MULTIPLY_INV".endl()
        + "       colNew=base* vec3(1.0)-blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_AVERAGE".endl()
        + "       colNew=((base + blend) / 2.0);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_ADD".endl()
        + "       colNew=min(base + blend, vec3(1.0));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SUBTRACT_ONE".endl()
        + "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl()
        + "   #endif".endl()

        + "   #ifdef BM_SUBTRACT".endl()
        + "       colNew=base - blend;".endl()
        + "   #endif".endl()

        + "   #ifdef BM_DIFFERENCE".endl()
        + "       colNew=abs(base - blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_NEGATION".endl()
        + "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_EXCLUSION".endl()
        + "       colNew=(base + blend - 2.0 * base * blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_LIGHTEN".endl()
        + "       colNew=max(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_DARKEN".endl()
        + "       colNew=min(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_OVERLAY".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SCREEN".endl()
        + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'
            // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'
            .endl()
        + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SOFTLIGHT".endl()
        + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))"
            // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'
            .endl()
        + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_HARDLIGHT".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORDODGE".endl()
        + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'
            .endl()
        + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORBURN".endl()
        + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'
            .endl()
        + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl()
        + "   #endif".endl()










        + "   return colNew;".endl()
        + "}".endl();

    if (!ver)
        src += "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl()
                + "{".endl()
                    + "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl()
                    + "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl()
                    + "return col;".endl()
                + "}".endl();

    if (ver >= 3)
        src += "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() +
                "{".endl() +

                "#ifdef BM_MATH_ADD".endl() +
                "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_SUB".endl() +
                "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_MUL".endl() +
                "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_DIV".endl() +
                "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() +
                "#endif".endl() +


                    "#ifndef BM_MATH".endl() +
                        "vec3 colNew=_blend(base.rgb,col.rgb);".endl() +

                        "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() +

                        "#ifdef BM_ALPHAMASKED".endl() +
                            "newA=base.a;".endl() +
                        "#endif".endl() +

                        "return vec4(".endl() +
                            "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() +
                            "newA);".endl() +

                    "#endif".endl() +
    "}".endl();

    return src;
};

TextureEffect.onChangeBlendSelect = function (shader, blendName, maskAlpha = false)
{
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");

    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");

    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);


    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
};

TextureEffect.AddBlendSelect = function (op, name, defaultMode)
{
    const p = op.inValueSelect(name || "Blend Mode", [
        "normal", "lighten", "darken", "multiply", "multiply invert", "average", "add", "subtract", "difference", "negation", "exclusion", "overlay", "screen", "color dodge", "color burn", "softlight", "hardlight", "subtract one",
        "Math Add",
        "Math Subtract",
        "Math Multiply",
        "Math Divide",

    ], defaultMode || "normal");
    return p;
};

TextureEffect.AddBlendAlphaMask = function (op, name, defaultMode)
{
    const p = op.inSwitch(name || "Alpha Mask", ["Off", "On"], defaultMode || "Off");
    return p;
};

TextureEffect.setupBlending = function (op, shader, blendPort, amountPort, alphaMaskPort)
{
    const onChange = () =>
    {
        let maskAlpha = false;
        if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == "On";
        TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);

        let str = blendPort.get();
        if (str == "normal") str = null;
        else if (str == "multiply") str = "mul";
        else if (str == "multiply invert") str = "mulinv";
        else if (str == "lighten") str = "light";
        else if (str == "darken") str = "darken";
        else if (str == "average") str = "avg";
        else if (str == "subtract one") str = "sub one";
        else if (str == "subtract") str = "sub";
        else if (str == "difference") str = "diff";
        else if (str == "negation") str = "neg";
        else if (str == "exclusion") str = "exc";
        else if (str == "overlay") str = "ovl";
        else if (str == "color dodge") str = "dodge";
        else if (str == "color burn") str = "burn";
        else if (str == "softlight") str = "soft";
        else if (str == "hardlight") str = "hard";
        else if (str == "Math Add") str = "+";
        else if (str == "Math Subtract") str = "-";
        else if (str == "Math Multiply") str = "*";
        else if (str == "Math Divide") str = "/";

        op.setUiAttrib({ "extendTitle": str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);

    let maskAlpha = false;

    blendPort.onChange = onChange;
    if (alphaMaskPort)
    {
        alphaMaskPort.onChange = onChange;
        maskAlpha = alphaMaskPort.get() == "On";
    }

    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
};



;// CONCATENATED MODULE: ./src/core/cgl/cgl_shader_lib.js




const ShaderLibMods = {
    "CGL.BLENDMODES": function ()
    {
        this.name = "blendmodes";
        this.srcHeadFrag = TextureEffect.getBlendCode();
    },
    "CGL.BLENDMODES3": function ()
    {
        this.name = "blendmodes3";
        this.srcHeadFrag = TextureEffect.getBlendCode(3);
    },

    "CGL.LUMINANCE": function ()
    {
        this.name = "luminance";
        this.srcHeadFrag = "".endl()
            + "float cgl_luminance(vec3 c)".endl()
            + "{".endl()
            + "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl()
            + "}".endl();
    },


    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },


    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },

    // texture based random numbers
    "CGL.RANDOM_TEX": function ()
    {
        this.name = "randomNumbertex";
        this.srcHeadFrag = "".endl()
            + "UNI sampler2D CGLRNDTEX;".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).r;".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl()
            + "}";

        this.initUniforms = function (shader)
        {
            return [new Uniform(shader, "t", "CGLRNDTEX", 7)];
        };

        this.onBind = function (cgl, shader)
        {
            Texture.getRandomTexture(cgl);
            cgl.setTexture(7, Texture.getRandomTexture(cgl).tex);
        };
    },
};



;// CONCATENATED MODULE: ./src/core/cgl/cgl_utils.js
/** @namespace CGL */

/**
 * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`
 * @const {Number}
 * @memberof CGL
 * @static
 */
const cgl_utils_DEG2RAD = Math.PI / 180.0;

/**
 * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`
 * @const {number}
 * @memberof CGL
 */
const cgl_utils_RAD2DEG = 180.0 / Math.PI;

const onLoadingAssetsFinished = null; // deprecated / remove later

/**
 * get normalized mouse wheel delta (including browser specific adjustment)
 * @function getWheelDelta
 * @static
 * @memberof CGL
 * @param {MouseEvent} event
 * @return {Number} normalized delta
 */
const isWindows = window.navigator.userAgent.contains("Windows");
const getWheelDelta_ = function (event)
{
    let normalized;
    if (event.wheelDelta)
    {
        // chrome
        normalized = (event.wheelDelta % 120) - 0 == -0 ? event.wheelDelta / 120 : event.wheelDelta / 30;
        normalized *= -1.5;
        if (isWindows) normalized *= 2;
    }
    else
    {
        // firefox
        let d = event.deltaY;
        if (event.shiftKey) d = event.deltaX;
        const rawAmmount = d || event.detail;
        normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
        normalized *= -3;
    }

    if (normalized > 20) normalized = 20;
    if (normalized < -20) normalized = -20;

    return normalized;
};

const getWheelSpeed = getWheelDelta_;
const getWheelDelta = getWheelDelta_;

// from https://github.com/lodash/lodash/blob/master/escape.js

const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
    "'": "&#39;",
};

/** Used to match HTML entities and HTML characters. */
const reUnescapedHtml = /[&<>"']/g;
const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/*  eslint-disable */
const escapeHTML = function(string)
{
    return string && reHasUnescapedHtml.test(string) ?
        string.replace(reUnescapedHtml, function(chr) { return htmlEscapes[chr]; })
        : string || "";
}
/* eslint-enable */

;// CONCATENATED MODULE: ./src/core/cg/cg_shader.js



class CgShader extends EventTarget
{
    constructor()
    {
        super();
        this.id = simpleId();
        this._isValid = true;
        this._defines = [];

        this._moduleNames = [];
        this._modules = [];
        this._moduleNumId = 0;
    }

    /**
     * easily enable/disable a define without a value
     * @function toggleDefine
     * @memberof Shader
     * @instance
     * @param {name} name
     * @param {any} enabled value or port
     */
    toggleDefine(name, enabled)
    {
        if (enabled && typeof (enabled) == "object" && enabled.addEventListener) // port
        {
            if (enabled.changeListener)enabled.removeEventListener(enabled.changeListener);

            enabled.onToggleDefine = (v) =>
            {
                this.toggleDefine(name, v);
            };

            enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
            enabled = enabled.get();
        }

        if (enabled) this.define(name);
        else this.removeDefine(name);
    }

    /**
     * add a define to a shader, e.g.  #define DO_THIS_THAT 1
     * @function define
     * @memberof Shader
     * @instance
     * @param {String} name
     * @param {Any} value (can be empty)
     */
    define(name, value)
    {
        if (value === null || value === undefined) value = "";

        if (typeof (value) == "object") // port
        {
            value.removeEventListener("change", value.onDefineChange);
            value.onDefineChange = (v) =>
            {
                this.define(name, v);
            };
            value.on("change", value.onDefineChange);

            value = value.get();
        }


        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name && this._defines[i][1] == value) return;
            if (this._defines[i][0] == name)
            {
                this._defines[i][1] = value;
                this.setWhyCompile("define " + name + " " + value);

                this._needsRecompile = true;
                return;
            }
        }
        this.setWhyCompile("define " + name + " " + value);
        this._needsRecompile = true;
        this._defines.push([name, value]);
    }

    getDefines()
    {
        return this._defines;
    }

    getDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return this._defines[i][1];
        return null;
    }

    /**
     * return true if shader has define
     * @function hasDefine
     * @memberof Shader
     * @instance
     * @param {String} name
     * @return {Boolean}
     */
    hasDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return true;
    }

    /**
     * remove a define from a shader
     * @param {name} name
     * @function removeDefine
     * @memberof Shader
     * @instance
     */
    removeDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name)
            {
                this._defines.splice(i, 1);
                this._needsRecompile = true;

                this.setWhyCompile("define removed:" + name);

                return;
            }
        }
    }


    hasModule(modId)
    {
        for (let i = 0; i < this._modules.length; i++)
        {
            if (this._modules[i].id == modId) return true;
        }
        return false;
    }

    setModules(names)
    {
        this._moduleNames = names;
    }


    /**
     * remove a module from shader
     * @function removeModule
     * @memberof Shader
     * @instance
     * @param {shaderModule} mod the module to be removed
     */
    removeModule(mod)
    {
        for (let i = 0; i < this._modules.length; i++)
        {
            if (mod && mod.id)
            {
                if (this._modules[i].id == mod.id || !this._modules[i])
                {
                    let found = true;
                    while (found)
                    {
                        found = false;
                        for (let j = 0; j < this._uniforms.length; j++)
                        {
                            if (this._uniforms[j].getName().startsWith(mod.prefix))
                            {
                                this._uniforms.splice(j, 1);
                                found = true;
                                continue;
                            }
                        }
                    }

                    this._needsRecompile = true;
                    this.setWhyCompile("remove module " + mod.title);
                    this._modules.splice(i, 1);
                    break;
                }
            }
        }
    }


    getNumModules()
    {
        return this._modules.length;
    }


    getCurrentModules() { return this._modules; }


    /**
     * add a module
     * @function addModule
     * @memberof Shader
     * @instance
     * @param {shaderModule} mod the module to be added
     * @param {shaderModule} [sibling] sibling module, new module will share the same group
     */
    addModule(mod, sibling)
    {
        if (this.hasModule(mod.id)) return;
        if (!mod.id) mod.id = CABLES.simpleId();
        if (!mod.numId) mod.numId = this._moduleNumId;
        if (!mod.num)mod.num = this._modules.length;
        if (sibling && !sibling.group) sibling.group = simpleId();

        if (!mod.group)
            if (sibling) mod.group = sibling.group;
            else mod.group = simpleId();

        mod.prefix = "mod" + mod.group + "_";
        this._modules.push(mod);

        this._needsRecompile = true;
        this.setWhyCompile("add module " + mod.title);
        this._moduleNumId++;

        return mod;
    }

    getAttributeSrc(mod, srcHeadVert, srcVert)
    {
        if (mod.attributes)
            for (let k = 0; k < mod.attributes.length; k++)
            {
                const r = this._getAttrSrc(mod.attributes[k], false);
                if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                if (r.srcVert)srcVert += r.srcVert;
            }

        return { "srcHeadVert": srcHeadVert, "srcVert": srcVert };
    }

    replaceModuleSrc()
    {
        let srcHeadVert = "";

        for (let j = 0; j < this._modules.length; j++)
        {
            const mod = this._modules[j];
            if (mod.name == this._moduleNames[i])
            {
                srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";

                srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";


                if (mod.getAttributeSrc)
                {
                    const r = getAttributeSrc(mod, srcHeadVert, srcVert);
                    if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                    if (r.srcVert)srcVert += r.srcVert;
                }


                srcHeadVert += mod.srcHeadVert || "";
                srcVert += mod.srcBodyVert || "";

                srcHeadVert += "\n//---- end mod ------\n";

                srcVert += "\n//---- end mod ------\n";

                srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
                srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);

                srcVert = srcVert.replace(/MOD_/g, mod.prefix);
                srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
            }
        }


        vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
    }
}



;// CONCATENATED MODULE: ./src/core/cgl/cgl_shader_default_glsl.vert
/* harmony default export */ const cgl_shader_default_glsl = ("{{MODULES_HEAD}}\nIN vec3 vPosition; //!@\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    gl_PointSize=10.0;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n    {{MODULE_VERTEX_MODELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n");
;// CONCATENATED MODULE: ./src/core/cgl/cgl_shader.js









// ---------------------------------------------------------------------------


/*

proposal default shader variable names:

attrVertex - currently: vPosition
attrVertexIndex - currently: attrVertIndex
attrTexCoord
attrInstMat - currently: instMat
attrVertColor
attrTangent
attrBiTangent

uProjMatrix - currently: projMatrix
uModelMatrix - currently: modelMatrix
uNormalMatrix - currently: normalMatrix
uCamPosition - currently: camPos

*/


// ---------------------------------------------------------------------------

let materialIdCounter = 0;




function getDefaultVertexShader()
{
    return cgl_shader_default_glsl;
}


function getDefaultFragmentShader(r, g, b)
{
    if (r == undefined)
    {
        r = 0.5;
        g = 0.5;
        b = 0.5;
    }
    return ""
        .endl() + "IN vec2 texCoord;"
        .endl() + "{{MODULES_HEAD}}"
        .endl() + "void main()"
        .endl() + "{"
        .endl() + "    vec4 col=vec4(" + r + "," + g + "," + b + ",1.0);"
        .endl() + "    {{MODULE_COLOR}}"
        .endl() + "    outColor = col;"
        .endl() + "}";
};


/**
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @param _cgl
 * @param _name
 * @param _op
 * @example
 * var shader=new CGL.Shader(cgl,'MinimalMaterial');
 * shader.setSource(attachments.shader_vert,attachments.shader_frag);
 */
class Shader extends CgShader
{
    constructor (_cgl, _name, _op)
    {
        super();
        if (!_cgl) throw new Error("shader constructed without cgl " + _name);

        this._log = new Logger("cgl_shader");
        this._cgl = _cgl;

        if (!_name) this._log.stack("no shader name given");
        this._name = _name || "unknown";

        if (_op) this.opId = _op.id;
        this.glslVersion = 0;
        if (_cgl.glVersion > 1) this.glslVersion = 300;

        this._materialId = ++materialIdCounter;

        this._program = null;
        this._uniforms = [];
        this._drawBuffers = [true];

        this._needsRecompile = true;
        this._compileReason = "initial";

        this.ignoreMissingUniforms = false;
        this._projMatrixUniform = null;
        this._mvMatrixUniform = null;
        this._mMatrixUniform = null;
        this._vMatrixUniform = null;
        this._camPosUniform = null;
        this._normalMatrixUniform = null;
        this._inverseViewMatrixUniform = null;
        this._fromUserInteraction = false;

        this._attrVertexPos = -1;
        this.precision = _cgl.patch.config.glslPrecision || "highp";

        this._pMatrixState = -1;
        this._vMatrixState = -1;

        this._countMissingUniforms = 0;
        this._modGroupCount = 0; // not needed anymore...
        this._feedBackNames = [];
        this._attributes = [];

        this.glPrimitive = null;
        this.offScreenPass = false;
        this._extensions = [];
        this.srcVert = getDefaultVertexShader();
        this.srcFrag = getDefaultFragmentShader();
        this.lastCompile = 0;


        this._libs = [];
        this._structNames = [];
        this._structUniformNames = [];
        this._textureStackUni = [];
        this._textureStackTex = [];
        this._textureStackType = [];
        this._textureStackTexCgl = [];

        this._tempNormalMatrix = mat4.create();
        this._tempCamPosMatrix = mat4.create();
        this._tempInverseViewMatrix = mat4.create();
        this._tempInverseProjMatrix = mat4.create();

        this.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
    };







    isValid()
    {
        return this._isValid;
    };

    getCgl()
    {
        return this._cgl;
    };

    getName()
    {
        return this._name;
    };

    /**
     * enable an extension for the shader
     * @function enableExtension
     * @memberof Shader
     * @instance
     * @param name extension name
     */
    enableExtension(name)
    {
        this.setWhyCompile("enable extension " + name);
        this._needsRecompile = true;
        this._extensions.push(name);
    };

    getAttrVertexPos()
    {
        return this._attrVertexPos;
    };

    hasTextureUniforms()
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getType() == "t") return true;
        return false;
    };

    setWhyCompile(why)
    {
        this._compileReason = why;
    };

    /**
     * copy all uniform values from another shader
     * @function copyUniforms
     * @memberof Shader
     * @instance
     * @param origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader)
    {
        // console.log(origShader._uniforms);
        for (let i = 0; i < origShader._uniforms.length; i++)
        {
            if (!this._uniforms[i])
            {
                this._log.log("unknown uniform?!");
                continue;
            }

            // this._log.log(origShader._uniforms[i].getName());
            // this.getUniform(origShader._uniforms[i].)
            // this._uniforms[i].set(origShader._uniforms[i].getValue());


            // if (origShader._uniforms[i].getName().contains("pathPoints"))
            //     console.log("copyUniformValues", origShader._uniforms[i].getName(), origShader._uniforms[i].getValue());

            this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());
        }

        this.popTextures();
        for (let i = 0; i < origShader._textureStackUni.length; i++)
        {
            this._textureStackUni[i] = origShader._textureStackUni[i];
            this._textureStackTex[i] = origShader._textureStackTex[i];
            this._textureStackType[i] = origShader._textureStackType[i];
            this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
        }

        // this._textureStackUni = [];
        // this._textureStackTex = [];
        // this._textureStackType = [];
        // this._textureStackTexCgl = [];
    };

    /**
     * copy current shader
     * @function copy
     * @memberof Shader
     * @instance
     * @returns newShader
     */
    copy()
    {
        const shader = new Shader(this._cgl, this._name + " copy");
        shader.setSource(this.srcVert, this.srcFrag);

        shader._modules = JSON.parse(JSON.stringify(this._modules));
        shader._defines = JSON.parse(JSON.stringify(this._defines));

        shader._modGroupCount = this._modGroupCount;
        shader._moduleNames = this._moduleNames;
        shader.glPrimitive = this.glPrimitive;
        shader.offScreenPass = this.offScreenPass;
        shader._extensions = this._extensions;
        shader.wireframe = this.wireframe;
        shader._attributes = this._attributes;

        for (let i = 0; i < this._uniforms.length; i++)
        {
            const u = this._uniforms[i].copy(shader);
            u.resetLoc();
        }

        this.setWhyCompile("copy");
        shader._needsRecompile = true;
        return shader;
    };


    /**
     * set shader source code
     * @function setSource
     * @memberof Shader
     * @instance
     * @param {String} srcVert
     * @param {String} srcFrag
     * @param {Bool} fromUserInteraction
     */
    setSource(srcVert, srcFrag, fromUserInteraction)
    {
        this._fromUserInteraction = fromUserInteraction;
        this.srcVert = srcVert;
        this.srcFrag = srcFrag;
        this.setWhyCompile("Source changed");
        this._needsRecompile = true;
        this._isValid = true;
    };

    _addLibs(src)
    {
        for (const id in ShaderLibMods)
        {
            if (src.contains(id))
            {
                const lib = new ShaderLibMods[id]();
                src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
                this._libs.push(lib);
                if (lib.initUniforms)lib.initUniforms(this);
            }
        }

        return src;
    };

    createStructUniforms()
    {
        // * create structs
        let structStrFrag = "";
        let structStrVert = ""; // TODO: not used yet

        this._structNames = [];
        // * reset the arrays holding the value each recompile so we don't skip structs
        // * key value mapping so the same struct can be added twice (two times the same modifier)
        this._injectedStringsFrag = {};
        this._injectedStringsVert = {};

        this._structUniformNamesIndicesFrag = [];
        this._structUniformNamesIndicesVert = [];

        for (let i = 0; i < this._uniforms.length; i++)
        {
            // * only add uniforms to struct that are a member of a struct
            if (this._uniforms[i].isStructMember())
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";

                // * check if struct is not already part of shader
                if (!this._structNames.includes(this._uniforms[i]._structName))
                {
                    // * create struct definition with placeholder string to inject
                    const structDefinition = "struct "
                        + this._uniforms[i]._structName + " {".endl()
                        + injectionString
                        + "};".endl().endl();

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "frag")
                        structStrFrag = structStrFrag.concat(structDefinition);

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "vert")
                        structStrVert = structStrVert.concat(structDefinition);

                    this._structNames.push(this._uniforms[i]._structName);
                    this._injectedStringsFrag[this._uniforms[i]._structName] = [];
                    this._injectedStringsVert[this._uniforms[i]._structName] = [];
                }

                // * create member & comment
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                let stringToInsert = "";
                if (this._uniforms[i].getGlslTypeString() == undefined)stringToInsert += "//";
                stringToInsert += "  " + this._uniforms[i].getGlslTypeString()
                        + " " + this._uniforms[i]._propertyName + ";"
                        + comment;

                if (this._uniforms[i].getShaderType() === "both")
                {
                    // * inject member before {injectionString}
                    if (
                        !this._injectedStringsFrag[this._uniforms[i]._structName].contains(stringToInsert)
                    && !this._injectedStringsVert[this._uniforms[i]._structName].contains(stringToInsert))
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "frag")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)) //
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "vert")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))
                    {
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
            }
        }

        // * dedupe injected uni declarations
        this._uniDeclarationsFrag = [];
        this._uniDeclarationsVert = [];

        // * remove struct injection points and add uniform in fragment
        for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1)
        {
            const index = this._structUniformNamesIndicesFrag[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";".endl();

            if (!this._uniDeclarationsFrag.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrFrag = structStrFrag.replace(injectionString, "");
                structStrFrag += uniDeclarationString;

                this._uniDeclarationsFrag.push(uniDeclarationString);
            }
        }

        // * remove struct injection points and add uniform in vertex
        for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1)
        {
            const index = this._structUniformNamesIndicesVert[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";".endl();

            if (!this._uniDeclarationsVert.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrVert = structStrVert.replace(injectionString, "");
                structStrVert += uniDeclarationString;
                this._uniDeclarationsVert.push(uniDeclarationString);
            }
        }

        return [structStrVert, structStrFrag];
    };

    _getAttrSrc(attr, firstLevel)
    {
        const r = {};
        if (attr.name && attr.type)
        {
            r.srcHeadVert = "";
            if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.name.endl();
            r.srcHeadVert += "#define ATTRIB_" + attr.name.endl();
            r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";".endl();
            if (!firstLevel) r.srcHeadVert += "#endif".endl();

            if (attr.nameFrag)
            {
                r.srcHeadVert += "";
                if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag.endl();
                r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag.endl();
                r.srcHeadVert += "OUT " + attr.type + " " + attr.nameFrag + ";".endl();
                if (!firstLevel) r.srcHeadVert += "#endif".endl();

                r.srcVert = "".endl() + attr.nameFrag + "=" + attr.name + ";";

                r.srcHeadFrag = "";
                if (!firstLevel) r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag.endl();
                r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag.endl();
                r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";".endl();
                if (!firstLevel) r.srcHeadFrag += "#endif".endl();
            }
        }
        return r;
    };

    compile()
    {
        if (this._cgl.aborted) return;
        const startTime = performance.now();



        this._cgl.profileData.profileShaderCompiles++;
        this._cgl.profileData.profileShaderCompileName = this._name + " [" + this._compileReason + "]";

        let extensionString = "";
        if (this._extensions)
            for (let i = 0; i < this._extensions.length; i++)
                extensionString += "#extension " + this._extensions[i] + " : enable".endl();

        let definesStr = "";
        if (this._defines.length) definesStr = "\n// cgl generated".endl();
        for (let i = 0; i < this._defines.length; i++)
            definesStr += "#define " + this._defines[i][0] + " " + this._defines[i][1] + "".endl();

        const structStrings = this.createStructUniforms();
        this._cgl.profileData.addHeavyEvent("shader compile", this._name + " [" + this._compileReason + "]");
        this._compileReason = "";



        if (this._uniforms)
        {
            // * we create an array of the uniform names to check our indices & an array to save them
            const uniNames = this._uniforms.map((uni) => { return uni._name; });
            const indicesToRemove = [];

            // * we go through our uniforms and check if the same name is contained somewhere further in the array
            // * if so, we add the current index to be removed later
            for (let i = 0; i < this._uniforms.length; i++)
            {
                const uni = this._uniforms[i];
                const nextIndex = uniNames.indexOf(uni._name, i + 1);
                if (nextIndex > -1) indicesToRemove.push(i);
            }

            // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices
            // * also, we reset the locations of all the other valid uniforms
            for (let j = this._uniforms.length - 1; j >= 0; j -= 1)
            {
                if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);
                else this._uniforms[j].resetLoc();
            }
        }

        this._cgl.printError("uniform resets");

        if (this.hasTextureUniforms()) definesStr += "#define HAS_TEXTURES".endl();

        let vs = "";
        let fs = "";

        if (!this.srcFrag)
        {
            this._log.warn("[cgl shader] has no fragment source!", this._name, this);
            this.srcVert = getDefaultVertexShader();
            this.srcFrag = getDefaultFragmentShader();
            // return;
        }

        if (this.glslVersion == 300)
        {
            vs = "#version 300 es"
                .endl() + "// "
                .endl() + "// vertex shader " + this._name
                .endl() + "// "
                .endl() + "precision " + this.precision + " float;"
                .endl() + "precision " + this.precision + " sampler2D;"
                .endl() + ""
                .endl() + "#define WEBGL2"
                .endl() + "#define texture2D texture"
                .endl() + "#define UNI uniform"
                .endl() + "#define IN in"
                .endl() + "#define OUT out"
                .endl();

            fs = "#version 300 es"
                .endl() + "// "
                .endl() + "// fragment shader " + this._name
                .endl() + "// "
                .endl() + "precision " + this.precision + " float;"
                .endl() + "precision " + this.precision + " sampler2D;"
                .endl() + ""
                .endl() + "#define WEBGL2"
                .endl() + "#define texture2D texture"
                .endl() + "#define IN in"
                .endl() + "#define OUT out"
                .endl() + "#define UNI uniform"
                .endl() + "{{DRAWBUFFER}}"

                .endl();
        }
        else
        {
            fs = ""
                .endl() + "// "
                .endl() + "// fragment shader " + this._name
                .endl() + "// "
                .endl() + "#define WEBGL1"
                .endl() + "#define texture texture2D"
                .endl() + "#define outColor gl_FragColor"
                .endl() + "#define IN varying"
                .endl() + "#define UNI uniform"
                .endl();

            vs = ""
                .endl() + "// "
                .endl() + "// vertex shader " + this._name
                .endl() + "// "
                .endl() + "#define WEBGL1"
                .endl() + "#define texture texture2D"
                .endl() + "#define OUT varying"
                .endl() + "#define IN attribute"
                .endl() + "#define UNI uniform"
                .endl();
        }

        let uniformsStrVert = "\n// cgl generated".endl();
        let uniformsStrFrag = "\n// cgl generated".endl();


        fs += "\n// active mods: --------------- ";
        vs += "\n// active mods: --------------- ";

        let foundModsFrag = false;
        let foundModsVert = false;
        for (let i = 0; i < this._moduleNames.length; i++)
        {
            for (let j = 0; j < this._modules.length; j++)
            {
                if (this._modules[j].name == this._moduleNames[i])
                {
                    if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag)
                    {
                        foundModsFrag = true;
                        fs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                    }
                    if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert)
                    {
                        vs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                        foundModsVert = true;
                    }
                }
            }
        }
        if (!foundModsVert)fs += "\n// no mods used...";
        if (!foundModsFrag)fs += "\n// no mods used...";
        fs += "\n";
        vs += "\n";

        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                let uniStr = "";
                if (!this._uniforms[i].getGlslTypeString())uniStr += "// ";
                uniStr += "UNI " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName();
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both")
                    if (!this.srcVert.contains(uniStr) && !this.srcVert.contains("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrVert += uniStr + ";" + comment.endl();

                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both")
                    if (!this.srcFrag.contains(uniStr) && !this.srcFrag.contains("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrFrag += uniStr + ";" + comment.endl();
            }
        }


        let countUniFrag = 0;
        let countUniVert = 0;
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both") countUniVert++;
                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both") countUniFrag++;
            }
        }
        if (countUniFrag >= this._cgl.maxUniformsFrag) this._log.warn("[cgl_shader] num uniforms frag: " + countUniFrag + " / " + this._cgl.maxUniformsFrag);
        if (countUniVert >= this._cgl.maxUniformsVert) this._log.warn("[cgl_shader] num uniforms vert: " + countUniVert + " / " + this._cgl.maxUniformsVert);


        if (!fs.contains("precision")) fs = "precision " + this.precision + " float;".endl() + fs;
        if (!vs.contains("precision")) vs = "precision " + this.precision + " float;".endl() + vs;
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
        {
            fs += "#define MOBILE".endl();
            vs += "#define MOBILE".endl();
        }
        vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + "\n// -- \n" + this.srcVert;
        fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + "\n// -- \n" + this.srcFrag;


        let srcHeadVert = "";
        let srcHeadFrag = "";

        // testing if this breaks things...
        // this._modules.sort(function (a, b)
        // {
        //     return a.group - b.group;
        // });

        this._modules.sort(function (a, b)
        {
            return a.priority || 0 - b.priority || 0;
        });


        let addedAttribs = false;

        for (let i = 0; i < this._moduleNames.length; i++)
        {
            let srcVert = "";
            let srcFrag = "";

            if (!addedAttribs)
            {
                addedAttribs = true;

                for (let k = 0; k < this._attributes.length; k++)
                {
                    const r = this._getAttrSrc(this._attributes[k], true);
                    if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                    if (r.srcVert)srcVert += r.srcVert;
                    if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                }
            }

            for (let j = 0; j < this._modules.length; j++)
            {
                const mod = this._modules[j];
                if (mod.name == this._moduleNames[i])
                {
                    srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";
                    srcHeadFrag += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";

                    srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
                    srcFrag += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

                    if (mod.attributes)
                        for (let k = 0; k < mod.attributes.length; k++)
                        {
                            const r = this._getAttrSrc(mod.attributes[k], false);
                            if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                            if (r.srcVert)srcVert += r.srcVert;
                            if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                        }

                    srcHeadVert += mod.srcHeadVert || "";
                    srcHeadFrag += mod.srcHeadFrag || "";
                    srcVert += mod.srcBodyVert || "";
                    srcFrag += mod.srcBodyFrag || "";

                    srcHeadVert += "\n//---- end mod ------\n";
                    srcHeadFrag += "\n//---- end mod ------\n";

                    srcVert += "\n//---- end mod ------\n";
                    srcFrag += "\n//---- end mod ------\n";

                    srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
                    srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);

                    srcVert = srcVert.replace(/MOD_/g, mod.prefix);
                    srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
                }
            }


            vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
            fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
        }


        vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
        fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);


        vs = this._addLibs(vs);
        fs = this._addLibs(fs);


        // SETUP draw buffers / multi texture render targets

        let drawBufferStr = "";
        for (let i = 0; i < 16; i++)
            if (fs.contains("outColor" + i)) this._drawBuffers[i] = true;

        if (this._drawBuffers.length == 1)
        {
            drawBufferStr = "out vec4 outColor;".endl();
            drawBufferStr += "#define gl_FragColor outColor".endl();
        }
        else
        {
            drawBufferStr += "#define MULTI_COLORTARGETS".endl();
            drawBufferStr += "vec4 outColor;".endl();

            let count = 0;
            for (let i = 0; i < this._drawBuffers.length; i++)
            {
                if (count == 0) drawBufferStr += "#define gl_FragColor outColor" + i + "".endl();
                drawBufferStr += "layout(location = " + i + ") out vec4 outColor" + i + ";".endl();
                count++;
            }
        }

        fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
        // //////


        if (!this._program)
        {
            this._program = this._createProgram(vs, fs);
        }
        else
        {
            // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );
            // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );
            // linkProgram(program);
            this._program = this._createProgram(vs, fs);

            this._projMatrixUniform = null;

            for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].resetLoc();
        }

        this.finalShaderFrag = fs;
        this.finalShaderVert = vs;


        MESH.lastMesh = null;
        MESH.lastShader = null;

        this._countMissingUniforms = 0;
        this._needsRecompile = false;
        this.lastCompile = now();

        // this._cgl.printError("shader compile");

        this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
    };

    hasChanged()
    {
        return this._needsRecompile;
    }


    bind()
    {
        if (!this._isValid || this._cgl.aborted) return;

        MESH.lastShader = this;

        if (!this._program || this._needsRecompile) this.compile();
        if (!this._isValid) return;

        if (!this._projMatrixUniform && !this.ignoreMissingUniforms)
        {
            this._countMissingUniforms++;
            // if (this._countMissingUniforms == 10)console.log("stopping getlocation of missing uniforms...", this._name);
            if (this._countMissingUniforms < 10)
            {
                this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT);
                this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION);
                this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, "mvMatrix");
                this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT);
                this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT);
                this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS);
                this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT);
                this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT);
                this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT);
                this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID);
                this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, constants_CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID);

                for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].needsUpdate = true;
            }
        }


        if (this._cgl.currentProgram != this._program)
        {
            this._cgl.profileData.profileShaderBinds++;
            this._cgl.gl.useProgram(this._program);
            this._cgl.currentProgram = this._program;
        }

        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();

        if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount())
        {
            this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
            this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._objectIdUniform)
            this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.tempData.objectIdCounter);

        if (this._materialIdUniform)
            this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);

        if (this._vMatrixUniform)
        {
            if (this._vMatrixState != this._cgl.getViewMatrixStateCount())
            {
                this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);
                this._cgl.profileData.profileMVPMatrixCount++;
                this._vMatrixState = this._cgl.getViewMatrixStateCount();

                if (this._inverseViewMatrixUniform)
                {
                    mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
                if (this._inverseProjMatrixUniform)
                {
                    mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
            }
            this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;

            if (this._camPosUniform)
            {
                mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);
                this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);
                this._cgl.profileData.profileMVPMatrixCount++;
            }
        }
        else
        {
            // mvmatrix deprecated....
            const tempmv = mat4.create();

            mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
            this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._normalMatrixUniform)
        {
            // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);
            mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);
            mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

            this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        for (let i = 0; i < this._libs.length; i++)
        {
            if (this._libs[i].onBind) this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
        }

        this._bindTextures();

        return this._isValid;
    };

    unBind()
    {
    };


    dispose()
    {
        this._cgl.gl.deleteProgram(this._program);
    };

    needsRecompile()
    {
        return this._needsRecompile;
    };

    setDrawBuffers(arr)
    {
        console.log("useless drawbuffers...?!");
        // if (this._drawBuffers.length !== arr.length)
        // {
        //     this._drawBuffers = arr;
        //     this._needsRecompile = true;
        //     this.setWhyCompile("setDrawBuffers");
        //     return;
        // }
        // for (let i = 0; i < arr.length; i++)
        // {
        //     if (arr[i] !== this._drawBuffers[i])
        //     {
        //         this._drawBuffers = arr;
        //         this._needsRecompile = true;
        //         this.setWhyCompile("setDrawBuffers");
        //         return;
        //     }
        // }
    };

    getUniforms()
    {
        return this._uniforms;
    };

    getUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getName() == name)
                return this._uniforms[i];
        return null;
    };

    removeAllUniforms()
    {
        this._uniforms = [];
        // for (let i = 0; i < this._uniforms.length; i++)
        //     this.removeUniform(this._uniforms[i].name);
    };

    removeUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].getName() == name)
            {
                this._uniforms.splice(i, 1);
            }
        }
        this._needsRecompile = true;
        this.setWhyCompile("remove uniform " + name);
    };


    _addUniform(uni)
    {
        this._uniforms.push(uni);
        this.setWhyCompile("add uniform " + name);
        this._needsRecompile = true;
    };

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformFrag
     * @returns {CGL.Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "frag";
        return uni;
    };

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformVert
     * @returns {CGL.Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "vert";
        return uni;
    };
    /**
     * add a uniform to both shaders
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformBoth
     * @returns {CGL.Uniform}
     */
    addUniformBoth(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "both";
        return uni;
    };

    /**
     * add a struct & its uniforms to the fragment shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructFrag
     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructFrag("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructFrag(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "frag";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    };

    /**
     * add a struct & its uniforms to the vertex shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructVert
     * @returns {CGL.Uniform}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructVert("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructVert(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "vert";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    };

    /**
     * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructBoth
     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructBoth("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructBoth(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if ((member.type === "2i" || member.type === "i" || member.type === "3i"))
                this._log.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new CGL.Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "both";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    };

    hasUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].getName() == name) return true;
        }
        return false;
    };

    _createProgram(vstr, fstr)
    {
        this._cgl.printError("before _createprogram");

        const program = this._cgl.gl.createProgram();

        this.vshader = Shader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);
        this.fshader = Shader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);


        if (this.vshader && this.fshader)
        {
            this._cgl.gl.attachShader(program, this.vshader);
            this._cgl.gl.attachShader(program, this.fshader);

            this._linkProgram(program, vstr, fstr);
        }
        else
        {
            this._isValid = false;
            this._cgl.printError("shader _createProgram");
            this._log.error("could not link shaderprogram");
            return null;
        }

        this._cgl.printError("shader _createProgram");
        return program;
    };

    hasErrors()
    {
        return this._hasErrors;
    };

    _linkProgram(program, vstr, fstr)
    {
        this._cgl.printError("before _linkprogram");

        if (this._feedBackNames.length > 0)
        {
            this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);
            // INTERLEAVED_ATTRIBS
            // SEPARATE_ATTRIBS
        }

        this._cgl.gl.linkProgram(program);
        this._cgl.printError("gl.linkprogram");
        this._isValid = true;

        this._hasErrors = false;

        if (this._cgl.patch.config.glValidateShader !== false)
        {
            this._cgl.gl.validateProgram(program);

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS))
            {
                // validation failed
                console.log("shaderprogram validation failed...");
                console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(program));
            }

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS))
            {
                this._hasErrors = true;

                const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
                const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);

                if (infoLogFrag) this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
                if (infoLogVert) this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));

                this._log.error(this._name + " shader linking fail...");

                console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(program));
                console.log(this);
                this._isValid = false;

                this._name = "errorshader";
                this.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());
                this._cgl.printError("shader link err");
            }
        }
    };

    getProgram()
    {
        return this._program;
    };

    setFeedbackNames(names)
    {
        this.setWhyCompile("setFeedbackNames");
        this._needsRecompile = true;
        this._feedBackNames = names;
    };

    // getDefaultVertexShader()
    // {
    //     return defaultShaderSrcVert;
    // }

    // getDefaultFragmentShader()
    // {
    //     return this.getDefaultFragmentShader()
    // }


    /**
      * adds attribute definition to shader header without colliding with other shader modules...
     * when attrFrag is defined, vertex shader will output this attribute to the fragment shader
     * @function
     * @memberof Shader
     * @instance
     * @param {Object} attr {type:x,name:x,[nameFrag:x]}
     * @return {Object}
     */
    addAttribute = function (attr)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;
        }
        this._attributes.push(attr);
        this._needsRecompile = true;
        this.setWhyCompile("addAttribute");
    };

    bindTextures()
    {
        this._bindTextures();
    }
    _bindTextures()
    {
        if (this._textureStackTex.length > this._cgl.maxTextureUnits)
        {
            this._log.warn("[shader._bindTextures] too many textures bound", this._textureStackTex.length + "/" + this._cgl.maxTextureUnits);
        }

        // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);

        for (let i = 0; i < this._textureStackTex.length; i++)
        {
            // console.log(this._textureStackTex.length, i);
            if (!this._textureStackTex[i] && !this._textureStackTexCgl[i])
            {
                this._log.warn("no texture for pushtexture", this._name);
            }
            else
            {
                let t = this._textureStackTex[i];
                if (this._textureStackTexCgl[i])
                {
                    t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;
                }

                let bindOk = true;

                if (!this._textureStackUni[i])
                {
                    // throw(new Error('no uniform given to texturestack'));
                    this._log.warn("no uniform for pushtexture", this._name);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
                }
                else
                {
                    this._textureStackUni[i].setValue(i);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);

                    // console.log(bindOk, i, t, this._textureStackType[i]);
                }
                if (!bindOk) console.warn("tex bind failed", this.getName(), this._textureStackUni[i]);
            }
        }
    };

    setUniformTexture = function (uni, tex)
    {
        tex = tex || CGL.Texture.getTempTexture(this._cgl);
        for (let i = 0; i < this._textureStackUni.length; i++)
            if (this._textureStackUni[i] == uni)
            {
                const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
                if (tex.hasOwnProperty("tex"))
                {
                    this._textureStackTexCgl[i] = tex;
                    this._textureStackTex[i] = null;
                }
                else
                {
                    this._textureStackTexCgl[i] = null;
                    this._textureStackTex[i] = tex;
                }

                // this._textureStackTex[i] = tex;
                // this._cgl.setTexture(i, tex, this._textureStackType[i]);
                return old;
            }
        return null;
    };

    /**
     * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set
     * @param {uniform} uniform texture uniform
     * @param {texture} t texture
     * @param {type} type texture type, can be ignored when TEXTURE_2D
     * @function pushTexture
     * @memberof Shader
     * @instance
     */
    pushTexture = function (uniform, t, type)
    {
        if (!uniform)
        {
            // console.log("pushtexture: no uniform given to texturestack", "shader:"+this._name,uniform,t,type);
            return;
        }
        if (!t)
        {
            // if(uniform)this._log.warn("pushtexture: no tex","shader:"+this._name," uniform:"+uniform.name);
            return;
        }
        if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture))
        {
            this._log.warn(new Error("invalid texture").stack);

            this._log.warn("[cgl_shader] invalid texture...", t);
            return;
        }

        this._textureStackUni.push(uniform);

        if (t.hasOwnProperty("tex"))
        {
            this._textureStackTexCgl.push(t);
            this._textureStackTex.push(null);
        }
        else
        {
            this._textureStackTexCgl.push(null);
            this._textureStackTex.push(t);
        }

        this._textureStackType.push(type);
    };

    /**
     * pop last texture
     * @function popTexture
     * @memberof Shader
     * @instance
     */
    popTexture = function ()
    {
        this._textureStackUni.pop();
        this._textureStackTex.pop();
        this._textureStackTexCgl.pop();
        this._textureStackType.pop();
    };

    /**
     * pop all textures
     * @function popTextures
     * @memberof Shader
     * @instance
     */
    popTextures = function ()
    {
        this._textureStackTex.length =
        this._textureStackTexCgl.length =
        this._textureStackType.length =
        this._textureStackUni.length = 0;
    };

    getMaterialId()
    {
        return this._materialId;
    };

    getInfo()
    {
        const info = {};
        info.name = this._name;
        // info.modules = JSON.parse(JSON.stringify(this._modules));
        // info.defines = JSON.parse(JSON.stringify(this._defines));
        info.defines = this.getDefines();
        info.hasErrors = this.hasErrors();

        return info;
    };


    getDefaultFragmentShader=function(r,g,b,a)
    {
        return getDefaultFragmentShader(r,g,b,a);
    }

    getDefaultVertexShader=function()
    {
        return getDefaultVertexShader();
    }


}

























// --------------------------

Shader.getDefaultVertexShader=getDefaultVertexShader;
Shader.getDefaultFragmentShader=getDefaultFragmentShader;


Shader.getErrorFragmentShader = function ()
{
    return ""
        .endl() + "void main()"
        .endl() + "{"
        .endl() + "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;"
        .endl() + "   g= step(0.1,g);"
        .endl() + "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);"
        .endl() + "}";
};

Shader.createShader = function (cgl, str, type, cglShader)
{
    if (cgl.aborted) return;

    // cgl.printError("[Shader.createShader] ", cglShader._name);

    function getBadLines(infoLog)
    {
        const basLines = [];
        const lines = infoLog.split("\n");
        for (const i in lines)
        {
            const divide = lines[i].split(":");
            if (parseInt(divide[2], 10)) basLines.push(parseInt(divide[2], 10));
        }
        return basLines;
    }


    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);

    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS))
    {
        let infoLog = cgl.gl.getShaderInfoLog(shader);
        if (!infoLog)
        {
            console.warn("empty shader info log", this._name);
            return;
        }


        const badLines = getBadLines(infoLog);
        let htmlWarning = "<pre style=\"margin-bottom:0px;\"><code class=\"shaderErrorCode language-glsl\" style=\"padding-bottom:0px;max-height: initial;max-width: initial;\">";
        const lines = str.match(/^.*((\r\n|\n|\r)|$)/gm);

        if (!cgl.aborted && infoLog)
        {
            if (type == cgl.gl.VERTEX_SHADER) console.log("VERTEX_SHADER");
            if (type == cgl.gl.FRAGMENT_SHADER) console.log("FRAGMENT_SHADER");

            for (const i in lines)
            {
                const j = parseInt(i, 10) + 1;
                const line = j + ": " + lines[i];

                let isBadLine = false;
                for (const bj in badLines)
                    if (badLines[bj] == j) isBadLine = true;

                if (isBadLine)
                {
                    htmlWarning += "</code></pre>";
                    htmlWarning += "<pre style=\"margin:0\"><code class=\"language-glsl\" style=\"background-color:#660000;padding-top:0px;padding-bottom:0px\">";

                    cglShader._log.log("bad line: `" + line + "`");
                }
                htmlWarning += escapeHTML(line);

                if (isBadLine)
                {
                    htmlWarning += "</code></pre>";
                    htmlWarning += "<pre style=\"margin:0\"><code class=\"language-glsl\" style=\";padding-top:0px;padding-bottom:0px\">";
                }
            }
        }

        infoLog = infoLog.replace(/\n/g, "<br/>");
        if (cgl.patch.isEditorMode())console.log("Shader error ", cglShader._name, infoLog, this);

        htmlWarning = infoLog + "<br/>" + htmlWarning + "<br/><br/>";
        htmlWarning += "</code></pre>";

        if (this._fromUserInteraction)
        {
            // console.log("todo show modal?");
            // cgl.patch.emitEvent("criticalError", { "title": "Shader error " + cglShader._name, "text": htmlWarning, "exception": { "message": infoLog } });
        }

        cglShader.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());
    }
    else
    {
        // console.log(name+' shader compiled...');
    }
    // cgl.printError("shader create2");
    return shader;
};













;// CONCATENATED MODULE: ./src/core/cgl/cgl_profiledata.js
class ProfileData
{
    constructor(cgl)
    {
        this._cgl = cgl;
        this._lastTime = 0;
        this.pause = false;
        this.profileUniformCount = 0;
        this.profileShaderBinds = 0;
        this.profileUniformCount = 0;
        this.profileShaderCompiles = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileEffectBuffercreate = 0;
        this.profileShaderGetUniform = 0;
        this.profileFrameBuffercreate = 0;
        this.profileMeshSetGeom = 0;
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileOnAnimFrameOps = 0;

        this.profileFencedPixelRead = 0;
        this.profileMainloopMs = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.shaderCompileTime = 0;
        this.profileMeshNumElements = 0;
        this.profileMeshAttributes = 0;
        this.profileSingleMeshAttribute = [];
        this.heavyEvents = [];

        this.doProfileGlQuery = false;
        this.glQueryData = {};
    }

    clear()
    {
        this.profileSingleMeshAttribute = {};
        this.profileMeshAttributes = 0;
        this.profileUniformCount = 0;
        this.profileShaderGetUniform = 0;
        this.profileShaderCompiles = 0;
        this.profileShaderBinds = 0;
        this.profileTextureResize = 0;
        this.profileFrameBuffercreate = 0;
        this.profileEffectBuffercreate = 0;
        this.profileTextureDelete = 0;
        this.profileMeshSetGeom = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileNonTypedAttrib = 0;
        this.profileNonTypedAttribNames = "";
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileFramebuffer = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.profileMeshNumElements = 0;
        this.profileFencedPixelRead = 0;
    }

    clearGlQuery()
    {
        for (let i in this.glQueryData)
        {
            if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1000)
            {
                this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;
                this.glQueryData[i].num = this.glQueryData[i]._numcount;

                this.glQueryData[i]._times = 0;
                this.glQueryData[i]._numcount = 0;
                this.glQueryData[i].lastClear = performance.now();
            }
        }
    }

    addHeavyEvent(event, name, info)
    {
        const e = { "event": event, "name": name, "info": info, "date": performance.now() };
        this.heavyEvents.push(e);
        this._cgl.emitEvent("heavyEvent", e);
    }
}




;// CONCATENATED MODULE: ../shared/client/src/helper.js
/**
 * Shared helper methods for cables uis
 */
class Helper
{
    constructor()
    {
        this._simpleIdCounter = 0;
    }


    /**
     * generate a random v4 uuid
     *
     * @return {string}
     */
    uuid()
    {
        let d = new Date().getTime();
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
        {
            const r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
        });
    }

    /**
     * checks value for !isNan and isFinite
     *
     * @param n
     * @return {boolean}
     */
    isNumeric(n)
    {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * generate a simple ID using an internal counter
     *
     * @return {Number} new id
     * @static
     */
    simpleId()
    {
        this._simpleIdCounter++;
        return this._simpleIdCounter;
    }

    deletePropertyByPath(obj, path)
    {
        if (!obj || !path)
        {
            return;
        }

        if (typeof path === "string")
        {
            path = path.split(".");
        }

        for (let i = 0; i < path.length - 1; i++)
        {
            obj = obj[path[i]];

            if (typeof obj === "undefined")
            {
                return;
            }
        }

        delete obj[path.pop()];
    }
}
/* harmony default export */ const helper = (new Helper());

;// CONCATENATED MODULE: ../shared/client/src/eventtarget.js



/**
 * add eventlistener functionality to classes
 */
class Events
{
    constructor()
    {
        this._log = new Logger("eventtarget");
        this._eventCallbacks = {};
        this._logName = "";
        this._logEvents = false;
        this._listeners = {};

        this.on = this.addEventListener;
        this.off = this.removeEventListener;
    }

    /**
     * add event listener
     * @param which event name
     * @param cb callback
     * @param {string} idPrefix prefix for id, default empty
     * @return {string} event id
     */
    addEventListener(which, cb, idPrefix = "")
    {
        const event =
            {
                "id": (idPrefix || "") + helper.simpleId(),
                "name": which,
                "cb": cb,
            };
        if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];
        else this._eventCallbacks[which].push(event);

        this._listeners[event.id] = event;

        return event.id;
    }

    /**
     * check event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return {boolean}
     */
    hasEventListener(id, cb = null)
    {
        if (id && !cb)
        {
            // check by id
            return !!this._listeners[id];
        }
        else
        {
            this._log.warn("old eventtarget function haseventlistener!");
            if (id && cb)
            {
                if (this._eventCallbacks[id])
                {
                    const idx = this._eventCallbacks[id].indexOf(cb);
                    return idx !== -1;
                }
            }
        }
    }

    /**
     * check event listener by name
     * @param eventName event name
     * @return {boolean}
     */
    hasListenerForEventName(eventName)
    {
        return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;
    }

    /**
     * rempve event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return
     */
    removeEventListener(id, cb = null)
    {
        if (id === null || id === undefined) return;

        if (!cb) // new style, remove by id, not by name/callback
        {
            const event = this._listeners[id];
            if (!event)
            {
                this._log.log("could not find event...", id, this);
                return;
            }

            let found = true;
            while (found)
            {
                found = false;
                let index = -1;
                for (let i = 0; i < this._eventCallbacks[event.name].length; i++)
                {
                    if (this._eventCallbacks[event.name][i].id.indexOf(id) === 0) // this._eventCallbacks[event.name][i].id == which ||
                    {
                        found = true;
                        index = i;
                    }
                }

                if (index !== -1)
                {
                    this._eventCallbacks[event.name].splice(index, 1);
                    delete this._listeners[id];
                }
            }

            return;
        }

        this._log.info("[eventtaget] ", "old function signature: removeEventListener! use listener id");
        this._log.log((new Error()).stack);

        let index = null;
        for (let i = 0; i < this._eventCallbacks[id].length; i++)
            if (this._eventCallbacks[id][i].cb === cb)
                index = i;

        if (index !== null)
        {
            delete this._eventCallbacks[index];
        }
        else this._log.warn("removeEventListener not found " + id);
    }

    /**
     * enable/disable logging of events for the class
     *
     * @param {boolean} enabled
     * @param {string} logName
     */
    logEvents(enabled, logName)
    {
        this._logEvents = enabled;
        this._logName = logName;
    }

    /**
     * emit event
     *
     * @param {string} which event name
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @param {*} param5
     * @param {*} param6
     */
    emitEvent(which, param1 = null, param2 = null, param3 = null, param4 = null, param5 = null, param6 = null)
    {
        if (this._logEvents) this._log.log("[event] ", this._logName, which, this._eventCallbacks);

        if (this._eventCallbacks[which])
        {
            for (let i = 0; i < this._eventCallbacks[which].length; i++)
            {
                if (this._eventCallbacks[which][i])
                {
                    this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);
                }
            }
        }
        else
        {
            if (this._logEvents) this._log.log("[event] has no event callback", which, this._eventCallbacks);
        }
    }
}


;// CONCATENATED MODULE: ./src/core/cg/cg_canvas.js
class CgCanvas
{
    constructor(options)
    {
        if (!options)
        {
            console.error("CgCanvas no options");
        }
        else
        {
            this._canvasEle = options.canvasEle;
        }

        if (!options.cg)console.error("CgCanvas options has no cg");
        if (!options.canvasEle)console.error("CgCanvas options has no canvasEle");

        this._cg = options.cg;
        this.pixelDensity = 1;
        this.canvasWidth = this.canvasEle.clientWidth;
        this.canvasHeight = this.canvasEle.clientHeight;

        this._oldWidthRp = -1;
        this._oldHeightRp = -1;

        this.setSize(this.canvasWidth, this.canvasHeight);
    }

    get canvasEle() { return this._canvasEle; }


    setSize(w, h, ignorestyle)
    {
        if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity)
        {
            this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
            this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;

            if (!ignorestyle)
            {
                this.canvasEle.style.width = w + "px";
                this.canvasEle.style.height = h + "px";
            }

            this.updateSize();

            this._cg.emitEvent("resize");
        }
    }

    updateSize()
    {
        this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;
        this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;
    }

    dispose()
    {
        this._canvasEle.remove();
        this._canvasEle = null;
    }
}



;// CONCATENATED MODULE: ./src/core/cg/cg_matrixstack.js

const MatrixStack = function ()
{
    this._arr = [mat4.create()];
    this._index = 0;
    this.stateCounter = 0;
};

MatrixStack.prototype.push = function (m)
{
    this._index++;
    this.stateCounter++;

    if (this._index == this._arr.length)
    {
        const copy = mat4.create();
        this._arr.push(copy);
    }

    mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);

    return this._arr[this._index];
};

MatrixStack.prototype.pop = function ()
{
    this.stateCounter++;

    this._index--;
    if (this._index < 0) this._index = 0;

    return this._arr[this._index];
};

MatrixStack.prototype.length = function ()
{
    return this._index;
};



;// CONCATENATED MODULE: ./src/core/cg/cg_state.js




class CGState extends Events
{
    constructor(_patch)
    {
        super();
        this.tempData = this.frameStore = this.frameStore || {};
        // this.canvas = null;

        this.fpsCounter = new CABLES.CG.FpsCounter();
        this._identView = vec3.create();
        this._ident = vec3.create();
        vec3.set(this._identView, 0, 0, -2);
        vec3.set(this._ident, 0, 0, 0);

        this.patch = _patch;
        this.autoReSize = true;

        this.DEPTH_COMPARE_FUNC_NEVER = 0;
        this.DEPTH_COMPARE_FUNC_LESS = 1;
        this.DEPTH_COMPARE_FUNC_EQUAL = 2;
        this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
        this.DEPTH_COMPARE_FUNC_GREATER = 4;
        this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
        this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
        this.DEPTH_COMPARE_FUNC_ALWAYS = 7;


        /**
         * Current projection matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.pMatrix = mat4.create();

        /**
         * Current model matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.mMatrix = mat4.create();

        /**
         * Current view matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.vMatrix = mat4.create();
        this._textureslots = [];

        this._pMatrixStack = new MatrixStack();
        this._mMatrixStack = new MatrixStack();
        this._vMatrixStack = new MatrixStack();

        this.canvasScale = 1;

        mat4.identity(this.mMatrix);
        mat4.identity(this.vMatrix);


        window.matchMedia("screen and (min-resolution: 2dppx)")
            .addEventListener("change", (e) =>
            {
                this.emitEvent("resize");
            });
    }

    get canvasWidth()
    {
        return this.cgCanvas.canvasWidth;
    }

    get canvasHeight()
    {
        return this.cgCanvas.canvasHeight;
    }

    set pixelDensity(p)
    {
        if (this.cgCanvas.pixelDensity != p)
        {
            this.cgCanvas.pixelDensity = p;
            this.cgCanvas.updateSize();
            this.emitEvent("resize");
        }
    }

    get pixelDensity()
    {
        return this.cgCanvas.pixelDensity;
    }


    getGApiName()
    {
        return ["WebGL", "WebGPU"][this.gApi];
    }

    get canvas()
    {
        return this.cgCanvas.canvasEle;
    }



    setCanvas(canvEle)
    {
        if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;
        if (typeof canvEle === "string") canvEle = document.getElementById(canvEle);

        this.cgCanvas = new CgCanvas({ "canvasEle": canvEle, "cg": this });

        canvEle.parentElement.classList.add("cablesContainer");
        if (this._setCanvas) this._setCanvas(canvEle);

        this.updateSize();
    }

    updateSize()
    {
        this.cgCanvas.updateSize();
    }

    setSize(w, h, ignorestyle)
    {
        this.cgCanvas.setSize(w, h, ignorestyle);
    }

    _resizeToWindowSize()
    {
        if (this.autoReSize)
        {
            this.setSize(window.innerWidth, window.innerHeight);
            this.updateSize();
        }
    }

    _resizeToParentSize()
    {
        if (this.autoReSize)
        {
            const p = this.canvas.parentElement;
            if (!p)
            {
                this._log.error("cables: can not resize to container element");
                return;
            }

            this.setSize(p.clientWidth, p.clientHeight);
            this.updateSize();
        }
    }

    setAutoResize(parent)
    {
        window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
        window.removeEventListener("resize", this._resizeToParentSize.bind(this));

        if (parent == "window")
        {
            window.addEventListener("resize", this._resizeToWindowSize.bind(this));
            window.addEventListener("orientationchange", this._resizeToWindowSize.bind(this));
            this._resizeToWindowSize();
        }
        if (parent == "parent")
        {
            window.addEventListener("resize", this._resizeToParentSize.bind(this));
            this._resizeToParentSize();
        }
    }

    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix()
    {
        this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }

    /**
      * pop projection matrix stack
      * @function popPMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current projectionmatrix
      */
    popPMatrix()
    {
        this.pMatrix = this._pMatrixStack.pop();
        return this.pMatrix;
    }

    getProjectionMatrixStateCount()
    {
        return this._pMatrixStack.stateCounter;
    }

    /**
      * push a matrix to the model matrix stack
      * @function pushModelMatrix
      * @memberof Context
      * @instance
      * @example
      * // see source code of translate op:
      * cgl.pushModelMatrix();
      * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
      * trigger.trigger();
      * cgl.popModelMatrix();
      */
    pushModelMatrix()
    {
        this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }

    /**
      * pop model matrix stack
      * @function popModelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    popModelMatrix()
    {
        // todo: DEPRECATE
        // if (this._mMatrixStack.length === 0) throw "Invalid modelview popMatrix!";
        this.mMatrix = this._mMatrixStack.pop();
        return this.mMatrix;
    }

    /**
      * get model matrix
      * @function modelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    modelMatrix()
    {
        return this.mMatrix;
    }


    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }

    /**
      * pop view matrix stack
      * @function popViewMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current viewmatrix
      * @function
      */
    popViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.pop();
    }

    getViewMatrixStateCount()
    {
        return this._vMatrixStack.stateCounter;
    }

    _startMatrixStacks(identTranslate, identTranslateView)
    {
        identTranslate = identTranslate || this._ident;
        identTranslateView = identTranslateView || this._identView;

        mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1000.0);

        mat4.identity(this.mMatrix);
        mat4.identity(this.vMatrix);
        mat4.translate(this.mMatrix, this.mMatrix, identTranslate);
        mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);

        this.pushPMatrix();
        this.pushModelMatrix();
        this.pushViewMatrix();
    }

    _endMatrixStacks()
    {
        this.popViewMatrix();
        this.popModelMatrix();
        this.popPMatrix();
    }

    dispose()
    {
        this.aborted = true;
        if (this.cgCanvas) this.cgCanvas.dispose();
        if (this._dispose) this._dispose();
    }

    shouldDrawHelpers()
    {
        return false;
    }
}





;// CONCATENATED MODULE: ./src/core/cg/sg_fpscounter.js


class FpsCounter extends Events
{
    constructor()
    {
        super();
        this._timeStartFrame = 0;
        this._timeStartSecond = 0;
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._frameCount = 0;

        this.stats = { "ms": 0, "fps": 0 };
    }

    get frameCount()
    {
        return this._frameCount;
    }

    startFrame()
    {
        this._timeStartFrame = CABLES.now();
    }

    endFrame()
    {
        this._frameCount++;
        this._fpsCounter++;

        const timeFrame = CABLES.now() - this._timeStartFrame;
        this._msCounter += timeFrame;

        if (CABLES.now() - this._timeStartSecond > 1000)
        {
            this.endSecond();
        }
    }

    endSecond()
    {
        this.stats.fps = this._fpsCounter;
        this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;

        this.emitEvent("performance", this.stats);

        // reset
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._timeStartSecond = CABLES.now();
    }
}

;// CONCATENATED MODULE: ./src/core/cg/cg_constants.js





const CG = {

    "GAPI_WEBGL": 0,
    "GAPI_WEBGPU": 1,

    "DEPTH_COMPARE_NEVER": 0,
    "DEPTH_COMPARE_LESS": 1,
    "DEPTH_COMPARE_EQUAL": 2,
    "DEPTH_COMPARE_LESSEQUAL": 3,
    "DEPTH_COMPARE_GREATER": 4,
    "DEPTH_COMPARE_NOTEQUAL": 5,
    "DEPTH_COMPARE_GREATEREQUAL": 6,
    "DEPTH_COMPARE_ALWAYS": 7,

    "CULL_NONE": 0,
    "CULL_BACK": 1,
    "CULL_FRONT": 2,
    "CULL_BOTH": 3,


    "Geometry": Geometry,
    "BoundingBox": BoundingBox,
    "FpsCounter": FpsCounter,

    "CgCanvas": CgCanvas
};




;// CONCATENATED MODULE: ./src/core/cgl/cgl_state.js








/**
 * cables gl context/state manager
 * @class
 * @namespace external:CGL
 * @hideconstructor
 */
// const Context(_patch)
class Context extends CGState
{
    constructor(_patch)
    {
        super(_patch);

        this.gApi = CG.GAPI_WEBGL;
        this.aborted = false;

        this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??
        this.popMvMatrix = this.popmMatrix = this.popModelMatrix;// deprecated and wrong... still used??

        this.profileData = new ProfileData(this);
        this._log = new Logger("cgl_context", { "onError": _patch.config.onError });
        this._viewPort = [0, 0, 0, 0];
        this.glVersion = 0;
        this.glUseHalfFloatTex = false;
        this.clearCanvasTransparent = true;
        this.clearCanvasDepth = true;
        this.debugOneFrame = false;
        this.checkGlErrors = false; // true is slow // false should be default...
        this.maxTextureUnits = 0;
        this.maxVaryingVectors = 0;
        this.currentProgram = null;
        this._hadStackError = false;
        this.glSlowRenderer = false;
        this._isSafariCrap = false;

        this.temporaryTexture = null;
        this._onetimeCallbacks = [];
        this.gl = null;

        this._cursor = "auto";
        this._currentCursor = "";

        this._viewPortStack = [];
        this._glFrameBufferStack = [];
        this._frameBufferStack = [];
        this._shaderStack = [];
        this._stackDepthTest = [];
        this.mainloopOp = null;

        this._simpleShader = new Shader(this, "simpleshader");
        this._simpleShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
        this._simpleShader.setSource(Shader.getDefaultVertexShader(), Shader.getDefaultFragmentShader());

        this._currentShader = this._simpleShader;


        this._oldCanvasWidth = -1;
        this._oldCanvasHeight = -1;
        this._enabledExtensions = {};
    }

    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }

    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }



    get viewPort()
    {
        if (this._viewPortStack.length > 3)
        {
            const l = this._viewPortStack.length;

            return [
                this._viewPortStack[l - 4],
                this._viewPortStack[l - 3],
                this._viewPortStack[l - 2],
                this._viewPortStack[l - 1]
            ];
        }
        else
        {
            // workaround pre viewport stack times / or+and initial value...

            return this._viewPort;
        }
    }



    get mvMatrix() // deprecate
    {
        return this.mMatrix;
    }

    set mvMatrix(m) // deprecate
    {
        this.mMatrix = m;
    }

    _setCanvas(canv)
    {
        if (!canv) this._log.stack("_setCanvas undef");

        if (!this.patch.config.canvas) this.patch.config.canvas = {};
        if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer")) this.patch.config.canvas.preserveDrawingBuffer = false;
        if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha")) this.patch.config.canvas.premultipliedAlpha = false;
        if (!this.patch.config.canvas.hasOwnProperty("alpha")) this.patch.config.canvas.alpha = false;

        this.patch.config.canvas.stencil = true;

        if (this.patch.config.hasOwnProperty("clearCanvasColor")) this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
        if (this.patch.config.hasOwnProperty("clearCanvasDepth")) this.clearCanvasDepth = this.patch.config.clearCanvasDepth;

        // safari stuff..........
        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
        {
            this._isSafariCrap = true;
            this.glUseHalfFloatTex = true;
        }

        if (!this.patch.config.canvas.forceWebGl1) this.gl = canv.getContext("webgl2", this.patch.config.canvas);


        if (!this.gl || this.gl.isContextLost())
        {
            this.aborted = true;
            this._log.error("NO_WEBGL", "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.");
            return;
        }

        if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0")
        {
            this.glVersion = 2;
        }
        else
        {
            this.gl = canv.getContext("webgl", this.patch.config.canvas) || canv.getContext("experimental-webgl", this.patch.config.canvas);
            this.glVersion = 1;

            // safari
            // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
            // {
            //     this.glUseHalfFloatTex = true;
            // }

            // ios
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream)
            {
                if (!this.patch.config.canvas.hasOwnProperty("powerPreference")) this.patch.config.canvas.powerPreference = "high-performance";
            }

            this.enableExtension("OES_standard_derivatives");
            // this.enableExtension("GL_OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
        if (dbgRenderInfo)
        {
            this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);
            if (this.glRenderer === "Google SwiftShader") this.glSlowRenderer = true;
        }

        this.canvas.addEventListener("webglcontextlost", (event) =>
        {
            if (this.aborted) return this._log.warn("[cgl_state] aborted context lost... can be ignored...");
            this._log.error("canvas lost...", event);
            this.emitEvent("webglcontextlost");
            this.aborted = true;
        });


        this.maxAnisotropic = 0;
        if (this.enableExtension("EXT_texture_filter_anisotropic"))
            this.maxAnisotropic = this.gl.getParameter(this.enableExtension("EXT_texture_filter_anisotropic").MAX_TEXTURE_MAX_ANISOTROPY_EXT);


        this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
        this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
        this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
        this.maxSamples = 0;
        if (this.gl.MAX_SAMPLES) this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);

        if (this.glVersion == 1)
        {
            this.enableExtension("OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;

            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        this.DEPTH_FUNCS = [
            this.gl.NEVER,
            this.gl.ALWAYS,
            this.gl.LESS,
            this.gl.LEQUAL,
            this.gl.GREATER,
            this.gl.GEQUAL,
            this.gl.EQUAL,
            this.gl.NOTEQUAL
        ];
        this.CULL_MODES = [
            null,
            this.gl.BACK,
            this.gl.FRONT,
            this.gl.FRONT_AND_BACK
        ];
    }

    getInfo()
    {
        return {
            "glVersion": this.glVersion,
            "glRenderer": this.glRenderer,
            "glUseHalfFloatTex": this.glUseHalfFloatTex,
            "maxVaryingVectors": this.maxVaryingVectors,
            "maxTextureUnits": this.maxTextureUnits,
            "maxTexSize": this.maxTexSize,
            "maxUniformsFrag": this.maxUniformsFrag,
            "maxUniformsVert": this.maxUniformsVert,
            "maxSamples": this.maxSamples
        };
    }





    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */


    popViewPort()
    {
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();

        if (this._viewPortStack.length == 0)
        {
            this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
            // this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
            // this.setViewPort(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
        }
        else
        {
            // this.viewPort = [this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]];
            // this.gl.viewport(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
            this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
        }
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h)
    {
        this._viewPortStack.push(x, y, w, h);
        this.setViewPort(x, y, w, h);
    }


    // old
    getViewPort()
    {
        return this._viewPort;
    }

    // old
    resetViewPort()
    {
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }

    // old
    setViewPort(x, y, w, h)
    {
        this._viewPort[0] = Math.round(x);
        this._viewPort[1] = Math.round(y);
        this._viewPort[2] = Math.round(w);
        this._viewPort[3] = Math.round(h);
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }


    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)
    {
        if (doScreenshotClearAlpha)
        {
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.colorMask(false, false, false, true);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this.gl.colorMask(true, true, true, true);
        }

        if (this.canvas && this.canvas.toBlob)
        {
            this.canvas.toBlob((blob) =>
            {
                if (cb) cb(blob);
                else this._log.log("no screenshot callback...");
            }, mimeType, quality);
        }
    }

    endFrame()
    {
        if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);

        this.setPreviousShader();

        if (this._vMatrixStack.length() > 0) this.logStackError("view matrix stack length !=0 at end of rendering...");
        if (this._mMatrixStack.length() > 0) this.logStackError("mvmatrix stack length !=0 at end of rendering...");
        if (this._pMatrixStack.length() > 0) this.logStackError("pmatrix stack length !=0 at end of rendering...");
        if (this._glFrameBufferStack.length > 0) this.logStackError("glFrameBuffer stack length !=0 at end of rendering...");
        if (this._stackDepthTest.length > 0) this.logStackError("depthtest stack length !=0 at end of rendering...");
        if (this._stackDepthWrite.length > 0) this.logStackError("depthwrite stack length !=0 at end of rendering...");
        if (this._stackDepthFunc.length > 0) this.logStackError("depthfunc stack length !=0 at end of rendering...");
        if (this._stackBlend.length > 0) this.logStackError("blend stack length !=0 at end of rendering...");
        if (this._stackBlendMode.length > 0) this.logStackError("blendMode stack length !=0 at end of rendering...");
        if (this._shaderStack.length > 0) this.logStackError("this._shaderStack length !=0 at end of rendering...");
        if (this._stackCullFace.length > 0) this.logStackError("this._stackCullFace length !=0 at end of rendering...");
        if (this._stackCullFaceFacing.length > 0) this.logStackError("this._stackCullFaceFacing length !=0 at end of rendering...");
        if (this._viewPortStack.length > 0) this.logStackError("viewport stack length !=0 at end of rendering...");

        this._frameStarted = false;

        if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight)
        {
            this._oldCanvasWidth = this.canvasWidth;
            this._oldCanvasHeight = this.canvasHeight;
            this.emitEvent("resize");
        }

        if (this._cursor != this._currentCursor)
        {
            this._currentCursor = this.canvas.style.cursor = this._cursor;
        }

        this.emitEvent("endframe");

        this.fpsCounter.endFrame();
    }

    logStackError(str)
    {
        if (!this._hadStackError)
        {
            this._hadStackError = true;
            this._log.warn("[" + this.canvas.id + "]: ", str);
        }
    }

    // shader stack
    getShader()
    {
        if (this._currentShader) if (!this.tempData || ((this.tempData.renderOffscreen === true) == this._currentShader.offScreenPass) === true) return this._currentShader;

        for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.tempData.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];
    }

    getDefaultShader()
    {
        return this._simpleShader;
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
     */

    pushShader(shader)
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // if (!currentShader.forcedMod && currentShader != this.tempData.forceShaderMods[i])
                // {
                //     currentShader.forcedMod = this.tempData.forceShaderMods[i];
                shader = this.tempData.forceShaderMods[i].bind(shader, false);
                // }
                // return currentShader;
                // if (this.tempData.forceShaderMods[i].currentShader() && shader != this.tempData.forceShaderMods[i].currentShader().shader)
            }
        }

        this._shaderStack.push(shader);
        this._currentShader = shader;
    }


    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader()
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // const a =
                this.tempData.forceShaderMods[i].unbind(false);
                // if (a) return;
                // this.popShader();
            }
        }

        if (this._shaderStack.length === 0) throw new Error("Invalid shader stack pop!");
        this._shaderStack.pop();
        this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb)
    {
        this._glFrameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length == 0) return null;
        this._glFrameBufferStack.pop();
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length === 0) return null;
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer} fb framebuffer
     */
    pushFrameBuffer(fb)
    {
        this._frameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    popFrameBuffer()
    {
        if (this._frameBufferStack.length == 0) return null;
        this._frameBufferStack.pop();
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    getCurrentFrameBuffer()
    {
        if (this._frameBufferStack.length === 0) return null;
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }


    renderStart(cgl, identTranslate, identTranslateView)
    {
        this.fpsCounter.startFrame();
        this.pushDepthTest(true);
        this.pushDepthWrite(true);
        this.pushDepthFunc(cgl.gl.LEQUAL);
        this.pushCullFaceFacing(cgl.gl.BACK);
        this.pushCullFace(false);

        // if (this.clearCanvasTransparent)
        // {
        //     cgl.gl.clearColor(0, 0, 0, 0);
        //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        // }
        // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

        cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);

        this._startMatrixStacks(identTranslate, identTranslateView);

        cgl.pushBlendMode(constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);

        for (let i = 0; i < this._textureslots.length; i++) this._textureslots[i] = null;

        this.pushShader(this._simpleShader);

        this._frameStarted = true;

        if (this._onetimeCallbacks.length > 0)
        {
            for (let i = 0; i < this._onetimeCallbacks.length; i++) this._onetimeCallbacks[i]();
            this._onetimeCallbacks.length = 0;
        }

        for (let i = 0; i < this._textureslots.length; i++)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + i);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this._textureslots[i] = null;
        }

        this.emitEvent("beginFrame");
    }

    renderEnd(cgl)
    {
        this._endMatrixStacks();

        this.popDepthTest();
        this.popDepthWrite();
        this.popDepthFunc();
        this.popCullFaceFacing();
        this.popCullFace();
        this.popBlend();
        this.popBlendMode();

        cgl.endFrame();

        this.emitEvent("endFrame");
    }

    getTexture(slot)
    {
        return this._textureslots[slot];
    }

    hasFrameStarted()
    {
        return this._frameStarted;
    }

    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param string
     * @instance
     */
    checkFrameStarted(string)
    {
        if (!this._frameStarted)
        {
            this._log.warn("frame not started " + string);
            this.patch.printTriggerStack();
        }
    }


    setTexture(slot, t, type)
    {
        this.checkFrameStarted("cgl setTexture");

        if (t === null) t = CGL.Texture.getEmptyTexture(this).tex;

        if (this._textureslots[slot] != t)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + slot);
            this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
            this._textureslots[slot] = t;
        }


        return true;
    }

    fullScreen()
    {
        if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();
        else if (this.canvas.mozRequestFullScreen) this.canvas.mozRequestFullScreen();
        else if (this.canvas.webkitRequestFullscreen) this.canvas.webkitRequestFullscreen();
        else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();
    }


    printError(str)
    {
        if (!this.checkGlErrors) return;
        let found = false;
        let error = this.gl.getError();

        if (error != this.gl.NO_ERROR)
        {
            let errStr = "";
            if (error == this.gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
            if (error == this.gl.INVALID_ENUM) errStr = "INVALID_ENUM";
            if (error == this.gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
            if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION) errStr = "INVALID_FRAMEBUFFER_OPERATION";
            if (error == this.gl.INVALID_VALUE) errStr = "INVALID_VALUE";
            if (error == this.gl.CONTEXT_LOST_WEBGL)
            {
                this.aborted = true;
                errStr = "CONTEXT_LOST_WEBGL";
            }
            if (error == this.gl.NO_ERROR) errStr = "NO_ERROR";

            found = true;


            this._log.warn("gl error [" + this.canvas.id + "]: ", str, error, errStr);

            if (this.canvas.id.contains("glGuiCanvas"))
                if (!this._loggedGlError)
                {
                    this.patch.printTriggerStack();
                    this._log.stack("glerror");
                    this._loggedGlError = true;
                }
        }
        error = this.gl.getError();

        return found;
    }

    saveScreenshot(filename, cb, pw, ph, noclearalpha)
    {
        this.patch.renderOneFrame();

        let w = this.canvas.clientWidth * this.pixelDensity;
        let h = this.canvas.clientHeight * this.pixelDensity;

        if (pw)
        {
            this.canvas.width = pw;
            w = pw;
        }
        if (ph)
        {
            this.canvas.height = ph;
            h = ph;
        }

        function padLeft(nr, n, str)
        {
            return Array(n - String(nr).length + 1).join(str || "0") + nr;
        }

        const d = new Date();

        const dateStr = "".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), "_").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));

        if (!filename) filename = "cables_" + dateStr + ".png";
        else filename += ".png";

        this.patch.cgl.screenShot(function (blob)
        {
            this.canvas.width = w;
            this.canvas.height = h;

            if (blob)
            {
                const anchor = document.createElement("a");

                anchor.download = filename;
                anchor.href = URL.createObjectURL(blob);

                setTimeout(function ()
                {
                    anchor.click();
                    if (cb) cb(blob);
                }, 100);
            }
            else
            {
                this._log.log("screenshot: no blob");
            }
        }.bind(this), noclearalpha);
    }

    _dispose()
    {
        this._simpleShader.dispose();
        this.gl = null;
    }
}


Context.prototype.popShader = Context.prototype.setPreviousShader;
Context.prototype.setShader = Context.prototype.pushShader;

/**
 * execute the callback next frame, once
 * @function addNextFrameOnceCallback
 * @memberof Context
 * @instance
 * @param {function} cb
 */
Context.prototype.addNextFrameOnceCallback = function (cb)
{
    if (cb && this._onetimeCallbacks.indexOf(cb) == -1) this._onetimeCallbacks.push(cb);
};

// state depthtest

/**
 * push depth testing enabled state
 * @function pushDepthTest
 * @param {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype._stackDepthTest = [];
Context.prototype.pushDepthTest = function (b)
{
    this._stackDepthTest.push(b);
    if (!b) this.gl.disable(this.gl.DEPTH_TEST);
    else this.gl.enable(this.gl.DEPTH_TEST);
};
/**
 * current state of depth testing
 * @function stateCullFace
 * @returns {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype.stateDepthTest = function ()
{
    return this._stackDepthTest[this._stackDepthTest.length - 1];
};

/**
 * pop depth testing state
 * @function popCullFace
 * @memberof Context
 * @instance
 */
Context.prototype.popDepthTest = function ()
{
    this._stackDepthTest.pop();

    if (!this._stackDepthTest[this._stackDepthTest.length - 1]) this.gl.disable(this.gl.DEPTH_TEST);
    else this.gl.enable(this.gl.DEPTH_TEST);
};

// --------------------------------------
// state depthwrite

/**
 * push depth write enabled state
 * @function pushDepthTest
 * @param {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype._stackDepthWrite = [];
Context.prototype.pushDepthWrite = function (b)
{
    b = b || false;
    this._stackDepthWrite.push(b);
    this.gl.depthMask(b);
};

/**
 * current state of depth writing
 * @function stateDepthWrite
 * @returns {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype.stateDepthWrite = function ()
{
    return this._stackDepthWrite[this._stackDepthWrite.length - 1];
};

/**
 * pop depth writing state
 * @function popDepthWrite
 * @memberof Context
 * @instance
 */
Context.prototype.popDepthWrite = function ()
{
    this._stackDepthWrite.pop();
    this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);
};


// --------------------------------------
// state CullFace

Context.prototype._stackCullFace = [];

/**
 * push face culling face enabled state
 * @function pushCullFace
 * @param {Boolean} b enabled
 * @memberof Context
 * @instance
 */
Context.prototype.pushCullFace = function (b)
{
    this._stackCullFace.push(b);

    if (b) this.gl.enable(this.gl.CULL_FACE);
    else this.gl.disable(this.gl.CULL_FACE);
};

/**
 * current state of face culling
 * @function stateCullFace
 * @returns {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype.stateCullFace = function ()
{
    return this._stackCullFace[this._stackCullFace.length - 1];
};

/**
 * pop face culling enabled state
 * @function popCullFace
 * @memberof Context
 * @instance
 */
Context.prototype.popCullFace = function ()
{
    this._stackCullFace.pop();

    if (this._stackCullFace[this._stackCullFace.length - 1]) this.gl.enable(this.gl.CULL_FACE);
    else this.gl.disable(this.gl.CULL_FACE);
};


// --------------------------------------
// state CullFace Facing


/**
 * push face culling face side
 * @function pushCullFaceFacing
 * @param {Number} cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT
 * @memberof Context
 * @instance
 */
Context.prototype._stackCullFaceFacing = [];
Context.prototype.pushCullFaceFacing = function (b)
{
    this._stackCullFaceFacing.push(b);
    this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
};

/**
 * current state of face culling side
 * @function stateCullFaceFacing
 * @returns {Boolean} enabled
 * @memberof Context
 * @instance
 */
Context.prototype.stateCullFaceFacing = function ()
{
    return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
};

/**
 * pop face culling face side
 * @function popCullFaceFacing
 * @memberof Context
 * @instance
 */
Context.prototype.popCullFaceFacing = function ()
{
    this._stackCullFaceFacing.pop();
    if (this._stackCullFaceFacing.length > 0) this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
};


// --------------------------------------
// state depthfunc

Context.prototype._stackDepthFunc = [];

/**
 * enable / disable depth testing
 * like `gl.depthFunc(boolean);`
 * @function pushDepthFunc
 * @memberof Context
 * @instance
 * @param {Boolean} f depthtesting
 */
Context.prototype.pushDepthFunc = function (f)
{
    this._stackDepthFunc.push(f);
    this.gl.depthFunc(f);
};

/**
 * current state of blend
 * @function stateDepthFunc
 * @memberof Context
 * @instance
 * @returns {Boolean} depth testing enabled/disabled
 */
Context.prototype.stateDepthFunc = function ()
{
    if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];
    return false;
};

/**
 * pop depth testing and set the previous state
 * @function popDepthFunc
 * @memberof Context
 * @instance
 */
Context.prototype.popDepthFunc = function ()
{
    this._stackDepthFunc.pop();
    if (this._stackDepthFunc.length > 0) this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
};

// --------------------------------------
// state blending

Context.prototype._stackBlend = [];

/**
 * enable / disable blend
 * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);
 * @function pushBlend
 * @memberof Context
 * @instance
 * @param {boolean} b blending
 */
Context.prototype.pushBlend = function (b)
{
    this._stackBlend.push(b);
    if (!b) this.gl.disable(this.gl.BLEND);
    else this.gl.enable(this.gl.BLEND);
};

/**
 * pop blend state and set the previous state
 * @function popBlend
 * @memberof Context
 * @instance
 */
Context.prototype.popBlend = function ()
{
    this._stackBlend.pop();

    if (!this._stackBlend[this._stackBlend.length - 1]) this.gl.disable(this.gl.BLEND);
    else this.gl.enable(this.gl.BLEND);
};

/**
 * current state of blend
 * @function stateBlend
 * @returns {boolean} blending enabled/disabled
 * @memberof Context
 * @instance
 */
Context.prototype.stateBlend = function ()
{
    return this._stackBlend[this._stackBlend.length - 1];
};

const BLENDS = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};

Context.prototype._stackBlendMode = [];
Context.prototype._stackBlendModePremul = [];

/**
 * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)
 * @function pushBlendMode
 * @memberof Context
 * @instance
 * @param {Number} blendMode
 * @param {Boolean} premul premultiplied mode
 */
Context.prototype.pushBlendMode = function (blendMode, premul)
{
    this._stackBlendMode.push(blendMode);
    this._stackBlendModePremul.push(premul);

    const n = this._stackBlendMode.length - 1;

    this.pushBlend(this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE);
    this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
};

/**
 * pop predefined blendmode / switch back to previous blendmode
 * @function popBlendMode
 * @memberof Context
 * @instance
 */
Context.prototype.popBlendMode = function ()
{
    this._stackBlendMode.pop();
    this._stackBlendModePremul.pop();

    const n = this._stackBlendMode.length - 1;

    this.popBlend(this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE);

    if (n >= 0) this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
};


// --------------------------------------
// state stencil

Context.prototype._stackStencil = [];

/**
 * enable / disable stencil testing

* @function pushStencil
 * @memberof Context
 * @instance
 * @param {Boolean} b enable
 */
Context.prototype.pushStencil = function (b)
{
    this._stackStencil.push(b);
    if (!b) this.gl.disable(this.gl.STENCIL_TEST);
    else this.gl.enable(this.gl.STENCIL_TEST);
};

/**
 * pop stencil test state and set the previous state
 * @function popStencil
 * @memberof Context
 * @instance
 */
Context.prototype.popStencil = function ()
{
    this._stackStencil.pop();

    if (!this._stackStencil[this._stackStencil.length - 1]) this.gl.disable(this.gl.STENCIL_TEST);
    else this.gl.enable(this.gl.STENCIL_TEST);
};

// --------------------------------------


Context.prototype.glGetAttribLocation = function (prog, name)
{
    const l = this.gl.getAttribLocation(prog, name);
    // if (l == -1)
    // {
    //     this._log.warn("get attr loc -1 ", name);
    // }
    return l;
};


/**
 * should an op now draw helpermeshes
 * @function shouldDrawHelpers
 * @memberof Context
 * @param op
 * @instance
 */
Context.prototype.shouldDrawHelpers = function (op)
{
    if (this.tempData.shadowPass) return false;
    if (!op.patch.isEditorMode()) return false;

    // const fb = this.getCurrentFrameBuffer();
    // if (fb && fb.getWidth)
    // {
    //     const fbshould = this.canvasWidth / this.canvasHeight == fb.getWidth() / fb.getHeight();
    //     if (!fbshould) return false;
    // }

    return gui.shouldDrawOverlay;// || (CABLES.UI.renderHelperCurrent && op.isCurrentUiOp());
};

Context.prototype._setBlendMode = function (blendMode, premul)
{
    const gl = this.gl;

    if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NONE)
    {
        // this.gl.disable(this.gl.BLEND);
    }
    else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_ADD)
    {
        if (premul)
        {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        }
        else
        {
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        }
    }
    else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_SUB)
    {
        if (premul)
        {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        }
        else
        {
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
        }
    }
    else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_MUL)
    {
        if (premul)
        {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
        }
        else
        {
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
        }
    }
    else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL)
    {
        if (premul)
        {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }
        else
        {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }
    }
    else
    {
        this._log.log("setblendmode: unknown blendmode");
    }
};

Context.prototype.createMesh = function (geom, options)
{
    if (CABLES.UTILS.isNumeric(options))options = { "glPrimitive": options }; // old constructor fallback...
    return new CGL.Mesh(this, geom, options);
};


/**
 * set cursor
 * @function setCursor
 * @memberof Context
 * @instance
 * @param {String} str css cursor string
 */
Context.prototype.setCursor = function (str)
{
    this._cursor = str;
};

/**
 * enable a webgl extension
 * @function enableExtension
 * @memberof Context
 * @instance
 * @param {String} name extension name
 * @returns {Object} extension object or null
 */
Context.prototype.enableExtension = function (name)
{
    if (!this.gl) return null;

    if (this._enabledExtensions.hasOwnProperty(name))
        return this._enabledExtensions[name];

    const o = this.gl.getExtension(name);
    this._enabledExtensions[name] = o;

    if (!o)
        this._log.warn("[cgl_state] extension not available " + name);
    // else
        // this._log.log("enabled extension", name);

    return o;
};

Context.prototype.checkTextureSize = function (x)
{
    x = x || 1;
    x = Math.floor(x);
    x = Math.min(x, this.maxTexSize);
    x = Math.max(x, 1);
    return x;
};





;// CONCATENATED MODULE: ./src/core/core_variable.js


/**
 * @type {Object}
 * @name PatchVariable
 * @param {String} name
 * @param {String|Number} value
 * @memberof Patch
 * @constructor
 */
class PatchVariable extends Events
{
    constructor(name, val, type)
    {
        super();
        this._name = name;
        this.type = type;
        this.setValue(val);
    }

    /**
     * keeping this for backwards compatibility in older
     * exports before using eventtarget
     *
     * @param cb
     */
    addListener(cb)
    {
        this.on("change", cb, "var");
    }

    /**
     * @function Variable.getValue
     * @memberof PatchVariable
     * @returns {String|Number|Boolean}
     */
    getValue()
    {
        return this._v;
    }

    /**
     * @function getName
     * @memberof PatchVariable
     * @instance
     * @returns {String|Number|Boolean}
     * @function
     */
    getName()
    {
        return this._name;
    }

    /**
     * @function setValue
     * @memberof PatchVariable
     * @instance
     * @param v
     * @returns {String|Number|Boolean}
     * @function
     */
    setValue(v)
    {
        this._v = v;
        this.emitEvent("change", v, this);
    }
}

/* harmony default export */ const core_variable = (PatchVariable);

;// CONCATENATED MODULE: ./src/core/core_patch.js












/**
 * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch
 *
 * see {@link PatchConfig}
 *
 * @namespace external:CABLES#Patch
 * @hideconstructor
 * @param {PatchConfig} cfg The configuration object.
 * @class
 * @example
 * CABLES.patch=new CABLES.Patch(
 * {
 *     patch:pStr,
 *     glCanvasId:'glcanvas',
 *     glCanvasResizeToWindow:true,
 *     canvas:{powerPreference:"high-performance"},
 *     prefixAssetPath:'/assets/',
 *     prefixJsPath:'/js/',
 *     onError:function(e){console.log(e);}
 *     glslPrecision:'highp'
 * });
 */

class Patch extends EventTarget
{
// const Patch(cfg)
    constructor(cfg)
    {
        super();
        // EventTarget.apply(this);

        this._log = new Logger("core_patch", { "onError": cfg.onError });
        this.ops = [];
        this.settings = {};
        this.config = cfg ||
        {
            "glCanvasResizeToWindow": false,
            "prefixAssetPath": "",
            "prefixJsPath": "",
            "silent": true,
            "onError": null,
            "onFinishedLoading": null,
            "onFirstFrameRendered": null,
            "onPatchLoaded": null,
            "fpsLimit": 0
        };
        this.timer = new Timer();
        this.freeTimer = new Timer();
        this.animFrameOps = [];
        this.animFrameCallbacks = [];
        this.gui = false;
        CABLES.logSilent = this.silent = true;
        this.profiler = null;
        this.aborted = false;
        this._crashedOps = [];
        this._renderOneFrame = false;
        this._animReq = null;
        this._opIdCache = {};
        this._triggerStack = [];
        this.storeObjNames = false; // remove after may release

        this.loading = new LoadingStatus(this);

        this._volumeListeners = [];
        this._paused = false;
        this._frameNum = 0;
        this.onOneFrameRendered = null;
        this.namedTriggers = {};

        this._origData = null;
        this._frameNext = 0;
        this._frameInterval = 0;
        this._lastFrameTime = 0;
        this._frameWasdelayed = true;
        this.tempData = this.frameStore = {};
        this.deSerialized = false;
        this.reqAnimTimeStamp = 0;

        this.cgCanvas = null;

        if (!(function () { return !this; }())) console.log("not in strict mode: core patch");

        this._isLocal = document.location.href.indexOf("file:") === 0;

        if (this.config.hasOwnProperty("silent")) this.silent = CABLES.logSilent = this.config.silent;
        if (!this.config.hasOwnProperty("doRequestAnimation")) this.config.doRequestAnimation = true;

        if (!this.config.prefixAssetPath) this.config.prefixAssetPath = "";
        if (!this.config.prefixJsPath) this.config.prefixJsPath = "";
        if (!this.config.masterVolume) this.config.masterVolume = 1.0;

        this._variables = {};
        this._variableListeners = [];
        this.vars = {};
        if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!

        this.cgl = new Context(this);
        this.cgp = null;

        this._subpatchOpCache = {};

        this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || "glcanvas");
        if (this.config.glCanvasResizeToWindow === true) this.cgl.setAutoResize("window");
        if (this.config.glCanvasResizeToParent === true) this.cgl.setAutoResize("parent");
        this.loading.setOnFinishedLoading(this.config.onFinishedLoading);

        if (this.cgl.aborted) this.aborted = true;
        if (this.cgl.silent) this.silent = true;

        this.freeTimer.play();
        this.exec();

        if (!this.aborted)
        {
            if (this.config.patch)
            {
                this.deSerialize(this.config.patch);
            }
            else if (this.config.patchFile)
            {
                ajax(
                    this.config.patchFile,
                    (err, _data) =>
                    {
                        try
                        {
                            const data = JSON.parse(_data);
                            if (err)
                            {
                                const txt = "";
                                this._log.error("err", err);
                                this._log.error("data", data);
                                this._log.error("data", data.msg);
                                return;
                            }
                            this.deSerialize(data);
                        }
                        catch (e)
                        {
                            this._log.error("could not load/parse patch ", e);
                        }
                    }
                );
            }
            this.timer.play();
        }

    console.log("made with https://cables.gl"); // eslint-disable-line
    }

    isPlaying()
    {
        return !this._paused;
    }

    isRenderingOneFrame()
    {
        return this._renderOneFrame;
    }


    renderOneFrame()
    {
        this._paused = true;
        this._renderOneFrame = true;
        this.exec();
        this._renderOneFrame = false;
    }

    /**
 * current number of frames per second
 * @function getFPS
 * @memberof Patch
 * @instance
 * @return {Number} fps
 */
    getFPS()
    {
        this._log.error("deprecated getfps");
        return 0;
    }

    /**
 * returns true if patch is opened in editor/gui mode
 * @function isEditorMode
 * @memberof Patch
 * @instance
 * @return {Boolean} editor mode
 */
    isEditorMode()
    {
        return this.config.editorMode === true;
    }

    /**
 * pauses patch execution
 * @function pause
 * @memberof Patch
 * @instance
 */
    pause()
    {
        cancelAnimationFrame(this._animReq);
        this.emitEvent("pause");
        this._animReq = null;
        this._paused = true;
        this.freeTimer.pause();
    }

    /**
 * resumes patch execution
 * @function resume
 * @memberof Patch
 * @instance
 */
    resume()
    {
        if (this._paused)
        {
            cancelAnimationFrame(this._animReq);
            this._paused = false;
            this.freeTimer.play();
            this.emitEvent("resume");
            this.exec();
        }
    }

    /**
 * set volume [0-1]
 * @function setVolume
 * @param {Number} v volume
 * @memberof Patch
 * @instance
 */
    setVolume(v)
    {
        this.config.masterVolume = v;
        for (let i = 0; i < this._volumeListeners.length; i++) this._volumeListeners[i].onMasterVolumeChanged(v);
    }


    /**
 * get asset path
 * @function getAssetPath
 * @memberof Patch
 * @param patchId
 * @instance
 */
    getAssetPath(patchId = null)
    {
        if (this.config.hasOwnProperty("assetPath"))
        {
            return this.config.assetPath;
        }
        else if (this.isEditorMode())
        {
            let id = patchId || gui.project()._id;
            return "/assets/" + id + "/";
        }
        else if (document.location.href.indexOf("cables.gl") > 0 || document.location.href.indexOf("cables.local") > 0)
        {
            const parts = document.location.pathname.split("/");
            let id = patchId || parts[parts.length - 1];
            return "/assets/" + id + "/";
        }
        else
        {
            return "assets/";
        }
    }

    /**
 * get js path
 * @function getJsPath
 * @memberof Patch
 * @instance
 */
    getJsPath()
    {
        if (this.config.hasOwnProperty("jsPath"))
        {
            return this.config.jsPath;
        }
        else
        {
            return "js/";
        }
    }

    /**
 * get url/filepath for a filename
 * this uses prefixAssetpath in exported patches
 * @function getFilePath
 * @memberof Patch
 * @instance
 * @param {String} filename
 * @return {String} url
 */
    getFilePath(filename)
    {
        if (!filename) return filename;
        filename = String(filename);
        if (filename.indexOf("https:") === 0 || filename.indexOf("http:") === 0) return filename;
        if (filename.indexOf("data:") === 0) return filename;
        if (filename.indexOf("file:") === 0) return filename;
        filename = filename.replace("//", "/");
        if (filename.startsWith(this.config.prefixAssetPath)) filename = filename.replace(this.config.prefixAssetPath, "");
        return this.config.prefixAssetPath + filename + (this.config.suffixAssetPath || "");
    }

    clear()
    {
        this.emitEvent("patchClearStart");
        this.cgl.TextureEffectMesh = null;
        this.animFrameOps.length = 0;
        this.timer = new Timer();
        while (this.ops.length > 0) this.deleteOp(this.ops[0].id);

        this._opIdCache = {};
        this.emitEvent("patchClearEnd");
    }




    createOp(identifier, id, opName = null)
    {
        let op = null;
        let objName = "";

        try
        {
            if (!identifier)
            {
                console.error("createop identifier false", identifier);
                console.log((new Error()).stack);
                return;
            }
            if (identifier.indexOf("Ops.") === -1)
            {
                // this should be a uuid, not a namespace
                // creating ops by id should be the default way from now on!
                const opId = identifier;



                if (CABLES.OPS[opId])
                {
                    objName = CABLES.OPS[opId].objName;
                    op = new CABLES.OPS[opId].f(this, objName, id, opId);
                    op.opId = opId;
                }
                else
                {
                    if (opName)
                    {
                        identifier = opName;
                        this._log.warn("could not find op by id: " + opId);
                    }
                    else
                    {
                        throw new Error("could not find op by id: " + opId, { "cause": "opId:" + opId });
                    }
                }
            }

            if (!op)
            {
                // fallback: create by objname!
                objName = identifier;
                const parts = identifier.split(".");
                const opObj = Patch.getOpClass(objName);

                if (!opObj)
                {
                    this.emitEvent("criticalError", { "title": "unknown op" + objName, "text": "unknown op: " + objName });

                    this._log.error("unknown op: " + objName);
                    throw new Error("unknown op: " + objName);
                }
                else
                {
                    if (parts.length == 2) op = new window[parts[0]][parts[1]](this, objName, id);
                    else if (parts.length == 3) op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);
                    else if (parts.length == 4) op = new window[parts[0]][parts[1]][parts[2]][parts[3]](this, objName, id);
                    else if (parts.length == 5) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](this, objName, id);
                    else if (parts.length == 6) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]](this, objName, id);
                    else if (parts.length == 7) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]](this, objName, id);
                    else if (parts.length == 8) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]](this, objName, id);
                    else if (parts.length == 9) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]](this, objName, id);
                    else if (parts.length == 10) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);
                    else console.log("parts.length", parts.length);
                }

                if (op)
                {
                    op.opId = null;
                    for (const i in CABLES.OPS)
                    {
                        if (CABLES.OPS[i].objName == objName) op.opId = i;
                    }
                }
            }
        }
        catch (e)
        {
            this._crashedOps.push(objName);

            this._log.error("[instancing error] " + objName, e);

            if (!this.isEditorMode())
            {
                this._log.error("INSTANCE_ERR", "Instancing Error: " + objName, e);
                // throw new Error("instancing error 1" + objName);
            }
        }

        if (op)
        {
            op._objName = objName;
            op.patch = this;
        }
        else
        {
            this._log.log("no op was created!?", identifier, id);
        }
        return op;
    }

    /**
     * create a new op in patch
     * @function addOp
     * @memberof Patch
     * @instance
     * @param {string} opIdentifier uuid or name, e.g. Ops.Math.Sum
     * @param {Object} uiAttribs Attributes
     * @param {string} id
     * @param {boolean} fromDeserialize
     * @param {string} opName e.g. Ops.Math.Sum
     * @example
     * // add invisible op
     * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });
     */
    addOp(opIdentifier, uiAttribs, id, fromDeserialize, opName)
    {
        const op = this.createOp(opIdentifier, id, opName);

        if (op)
        {
            uiAttribs = uiAttribs || {};
            if (uiAttribs.hasOwnProperty("errors")) delete uiAttribs.errors;
            if (uiAttribs.hasOwnProperty("error")) delete uiAttribs.error;
            uiAttribs.subPatch = uiAttribs.subPatch || 0;

            op.setUiAttribs(uiAttribs);
            if (op.onCreate) op.onCreate();

            if (op.hasOwnProperty("onAnimFrame")) this.addOnAnimFrame(op);
            if (op.hasOwnProperty("onMasterVolumeChanged")) this._volumeListeners.push(op);

            if (this._opIdCache[op.id])
            {
                this._log.warn("opid with id " + op.id + " already exists in patch!");
                this.deleteOp(op.id); // strange with subpatch ops: why is this needed, somehow ops get added twice ???.....
                // return;
            }

            this.ops.push(op);
            this._opIdCache[op.id] = op;

            if (this._subPatchCacheAdd) this._subPatchCacheAdd(uiAttribs.subPatch, op);
            this.emitEvent("onOpAdd", op, fromDeserialize);

            if (op.init) op.init();

            op.emitEvent("init", fromDeserialize);
        }
        else
        {
            this._log.error("addop: op could not be created: ", opIdentifier);
        }

        return op;
    }

    addOnAnimFrame(op)
    {
        for (let i = 0; i < this.animFrameOps.length; i++) if (this.animFrameOps[i] == op) { return; }

        this.animFrameOps.push(op);
    }

    removeOnAnimFrame(op)
    {
        for (let i = 0; i < this.animFrameOps.length; i++)
        {
            if (this.animFrameOps[i] == op)
            {
                this.animFrameOps.splice(i, 1);
                return;
            }
        }
    }

    addOnAnimFrameCallback(cb)
    {
        this.animFrameCallbacks.push(cb);
    }

    removeOnAnimCallback(cb)
    {
        for (let i = 0; i < this.animFrameCallbacks.length; i++)
        {
            if (this.animFrameCallbacks[i] == cb)
            {
                this.animFrameCallbacks.splice(i, 1);
                return;
            }
        }
    }

    deleteOp(opid, tryRelink, reloadingOp)
    {
        let found = false;
        for (const i in this.ops)
        {
            if (this.ops[i].id == opid)
            {
                const op = this.ops[i];
                let reLinkP1 = null;
                let reLinkP2 = null;

                if (op)
                {
                    found = true;
                    if (tryRelink)
                    {
                        if (op.portsIn.length > 0 && op.portsIn[0].isLinked() && (op.portsOut.length > 0 && op.portsOut[0].isLinked()))
                        {
                            if (op.portsIn[0].getType() == op.portsOut[0].getType() && op.portsIn[0].links[0])
                            {
                                reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);
                                reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);
                            }
                        }
                    }

                    const opToDelete = this.ops[i];
                    opToDelete.removeLinks();

                    if (this.onDelete)
                    {
                        // todo: remove
                        this._log.warn("deprecated this.onDelete", this.onDelete);
                        this.onDelete(opToDelete);
                    }

                    this.ops.splice(i, 1);
                    opToDelete.emitEvent("delete", opToDelete);
                    this.emitEvent("onOpDelete", opToDelete, reloadingOp);

                    if (this.clearSubPatchCache) this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);

                    if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);
                    opToDelete.cleanUp();

                    if (reLinkP1 !== null && reLinkP2 !== null)
                    {
                        this.link(reLinkP1.op, reLinkP1.getName(), reLinkP2.op, reLinkP2.getName());
                    }

                    delete this._opIdCache[opid];
                    break;
                }
            }
        }

        if (!found) this._log.warn("core patch deleteop: not found...", opid);
    }

    getFrameNum()
    {
        return this._frameNum;
    }

    emitOnAnimFrameEvent(time, delta)
    {
        time = time || this.timer.getTime();

        for (let i = 0; i < this.animFrameCallbacks.length; ++i)
            if (this.animFrameCallbacks[i])
                this.animFrameCallbacks[i](time, this._frameNum, delta);

        for (let i = 0; i < this.animFrameOps.length; ++i)
            if (this.animFrameOps[i].onAnimFrame)
                this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);
    }

    renderFrame(timestamp)
    {
        this.timer.update(this.reqAnimTimeStamp);
        this.freeTimer.update(this.reqAnimTimeStamp);
        const time = this.timer.getTime();
        const startTime = performance.now();
        this.cgl.frameStartTime = this.timer.getTime();

        const delta = timestamp - this.reqAnimTimeStamp || timestamp;

        this.emitOnAnimFrameEvent(null, delta);

        this.cgl.profileData.profileFrameDelta = delta;
        this.reqAnimTimeStamp = timestamp;
        this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;

        this.emitEvent("onRenderFrame", time);

        this._frameNum++;
        if (this._frameNum == 1)
        {
            if (this.config.onFirstFrameRendered) this.config.onFirstFrameRendered();
        }
    }

    exec(timestamp)
    {
        if (!this._renderOneFrame && (this._paused || this.aborted)) return;
        this.emitEvent("reqAnimFrame");
        cancelAnimationFrame(this._animReq);

        this.config.fpsLimit = this.config.fpsLimit || 0;
        if (this.config.fpsLimit)
        {
            this._frameInterval = 1000 / this.config.fpsLimit;
        }

        const now = CABLES.now();
        const frameDelta = now - this._frameNext;

        if (this.isEditorMode())
        {
            if (!this._renderOneFrame)
            {
                if (now - this._lastFrameTime >= 500 && this._lastFrameTime !== 0 && !this._frameWasdelayed)
                {
                    this._lastFrameTime = 0;
                    setTimeout(this.exec.bind(this), 500);
                    this.emitEvent("renderDelayStart");
                    this._frameWasdelayed = true;
                    return;
                }
            }
        }

        if (this._renderOneFrame || this.config.fpsLimit === 0 || frameDelta > this._frameInterval || this._frameWasdelayed)
        {
            this.renderFrame(timestamp);

            if (this._frameInterval) this._frameNext = now - (frameDelta % this._frameInterval);
        }

        if (this._frameWasdelayed)
        {
            this.emitEvent("renderDelayEnd");
            this._frameWasdelayed = false;
        }

        if (this._renderOneFrame)
        {
            if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...
            this.emitEvent("renderedOneFrame");
            this._renderOneFrame = false;
        }


        if (this.config.doRequestAnimation) this._animReq = this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(this.exec.bind(this));
    }

    /**
     * link two ops/ports
     * @function link
     * @memberof Patch
     * @instance
     * @param {Op} op1
     * @param {String} port1Name
     * @param {Op} op2
     * @param {String} port2Name
     * @param {boolean} lowerCase
     * @param {boolean} fromDeserialize
     */
    link(op1, port1Name, op2, port2Name, lowerCase, fromDeserialize)
    {
        if (!op1) return this._log.warn("link: op1 is null ");
        if (!op2) return this._log.warn("link: op2 is null");

        const port1 = op1.getPort(port1Name, lowerCase);
        const port2 = op2.getPort(port2Name, lowerCase);

        if (!port1) return op1._log.warn("port1 not found! " + port1Name + " (" + op1.objName + ")");
        if (!port2) return op1._log.warn("port2 not found! " + port2Name + " of " + op2.name + "(" + op2.objName + ")", op2);

        if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2)) return false;

        if (Link.canLink(port1, port2))
        {
            const link = new Link(this);
            link.link(port1, port2);

            this.emitEvent("onLink", port1, port2, link, fromDeserialize);
            return link;
        }
    }

    serialize(options)
    {
        const obj = {};

        options = options || {};
        obj.ops = [];
        obj.settings = this.settings;
        for (const i in this.ops)
        {
            const op = this.ops[i];
            if (op && op.getSerialized)obj.ops.push(op.getSerialized());
        }

        cleanJson(obj);

        if (options.asObject) return obj;
        return JSON.stringify(obj);
    }

    getOpsByRefId(refId)
    {
        const perf = CABLES.UI.uiProfiler.start("[corepatchetend] getOpsByRefId");
        const refOps = [];
        const ops = gui.corePatch().ops;
        for (let i = 0; i < ops.length; i++)
            if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);
        perf.finish();
        return refOps;
    }

    getOpById(opid)
    {
        return this._opIdCache[opid];
    }

    getOpsByName(name)
    {
        // TODO: is this still needed ? unclear behaviour....
        const arr = [];
        for (const i in this.ops)
            if (this.ops[i].name == name) arr.push(this.ops[i]);
        return arr;
    }

    getOpsByObjName(name)
    {
        const arr = [];
        for (const i in this.ops)
            if (this.ops[i].objName == name) arr.push(this.ops[i]);
        return arr;
    }

    getOpsByOpId(opid)
    {
        const arr = [];
        for (const i in this.ops)
            if (this.ops[i].opId == opid) arr.push(this.ops[i]);
        return arr;
    }

    loadLib(which)
    {
        ajaxSync(
            "/ui/libs/" + which + ".js",
            (err, res) =>
            {
                const se = document.createElement("script");
                se.type = "text/javascript";
                se.text = res;
                document.getElementsByTagName("head")[0].appendChild(se);
            },
            "GET",
        );
    }

    getSubPatchOpsByName(patchId, objName)
    {
        const arr = [];
        for (const i in this.ops)
            if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)
                arr.push(this.ops[i]);

        return arr;
    }

    getSubPatchOp(patchId, objName)
    {
        return this.getFirstSubPatchOpByName(patchId, objName);
    }

    getFirstSubPatchOpByName(patchId, objName)
    {
        for (const i in this.ops)
            if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)
                return this.ops[i];

        return false;
    }

    _addLink(opinid, opoutid, inName, outName)
    {
        return this.link(this.getOpById(opinid), inName, this.getOpById(opoutid), outName, false, true);
    }

    deSerialize(obj, options)
    {
        options = options || { "genIds": false, "createRef": false };
        if (this.aborted) return;
        const newOps = [];
        const loadingId = this.loading.start("core", "deserialize");

        this.namespace = obj.namespace || "";
        this.name = obj.name || "";

        if (typeof obj === "string") obj = JSON.parse(obj);

        this.settings = obj.settings;

        this.emitEvent("patchLoadStart");

        obj.ops = obj.ops || [];

        if (window.logStartup)logStartup("add " + obj.ops.length + " ops... ");

        const addedOps = [];

        // add ops...
        for (let iop = 0; iop < obj.ops.length; iop++)
        {
            const start = CABLES.now();
            const opData = obj.ops[iop];
            let op = null;

            try
            {
                if (opData.opId) op = this.addOp(opData.opId, opData.uiAttribs, opData.id, true, opData.objName);
                else op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);
            }
            catch (e)
            {
                this._log.error("[instancing error] op data:", opData, e);
                // throw new Error("could not create op by id: <b>" + (opData.objName || opData.opId) + "</b> (" + opData.id + ")");
            }

            if (op)
            {
                addedOps.push(op);
                if (options.genIds) op.id = shortId();
                op.portsInData = opData.portsIn;
                op._origData = JSON.parse(JSON.stringify(opData));
                op.storage = opData.storage;
                // if (opData.hasOwnProperty("disabled"))op.setEnabled(!opData.disabled);

                for (const ipi in opData.portsIn)
                {
                    const objPort = opData.portsIn[ipi];
                    if (objPort && objPort.hasOwnProperty("name"))
                    {
                        const port = op.getPort(objPort.name);

                        if (port && (port.uiAttribs.display == "bool" || port.uiAttribs.type == "bool") && !isNaN(objPort.value)) objPort.value = objPort.value == true ? 1 : 0;
                        if (port && objPort.value !== undefined && port.type != CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) port.set(objPort.value);

                        if (port)
                        {
                            port.deSerializeSettings(objPort);
                        }
                        else
                        {
                            // if (port.uiAttribs.hasOwnProperty("title"))
                            // {
                            //     op.preservedPortTitles = op.preservedPortTitles || {};
                            //     op.preservedPortTitles[port.name] = port.uiAttribs.title;
                            // }
                            op.preservedPortValues = op.preservedPortValues || {};
                            op.preservedPortValues[objPort.name] = objPort.value;
                        }
                    }
                }

                for (const ipo in opData.portsOut)
                {
                    const objPort = opData.portsOut[ipo];
                    if (objPort && objPort.hasOwnProperty("name"))
                    {
                        const port2 = op.getPort(objPort.name);

                        if (port2)
                        {
                            port2.deSerializeSettings(objPort);

                            if (port2.uiAttribs.hasOwnProperty("title"))
                            {
                                op.preservedPortTitles = op.preservedPortTitles || {};
                                op.preservedPortTitles[port2.name] = port2.uiAttribs.title;
                            }


                            if (port2.type != CONSTANTS.OP.OP_PORT_TYPE_TEXTURE && objPort.hasOwnProperty("value"))
                                port2.set(obj.ops[iop].portsOut[ipo].value);

                            if (objPort.expose) port2.setUiAttribs({ "expose": true });
                        }
                    }
                }
                newOps.push(op);
            }

            const timeused = Math.round(100 * (CABLES.now() - start)) / 100;
            if (!this.silent && timeused > 5) console.log("long op init ", obj.ops[iop].objName, timeused);
        }
        if (window.logStartup)logStartup("add ops done");

        for (const i in this.ops)
        {
            if (this.ops[i].onLoadedValueSet)
            {
                this.ops[i].onLoadedValueSet(this.ops[i]._origData);
                this.ops[i].onLoadedValueSet = null;
                this.ops[i]._origData = null;
            }
            this.ops[i].emitEvent("loadedValueSet");
        }

        if (window.logStartup)logStartup("creating links");

        if (options.opsCreated)options.opsCreated(addedOps);
        // create links...
        if (obj.ops)
        {
            for (let iop = 0; iop < obj.ops.length; iop++)
            {
                if (obj.ops[iop].portsIn)
                {
                    for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++)
                    {
                        if (obj.ops[iop].portsIn[ipi2] && obj.ops[iop].portsIn[ipi2].links)
                        {
                            for (let ili = 0; ili < obj.ops[iop].portsIn[ipi2].links.length; ili++)
                            {
                                const l = this._addLink(
                                    obj.ops[iop].portsIn[ipi2].links[ili].objIn,
                                    obj.ops[iop].portsIn[ipi2].links[ili].objOut,
                                    obj.ops[iop].portsIn[ipi2].links[ili].portIn,
                                    obj.ops[iop].portsIn[ipi2].links[ili].portOut);

                                // const took = performance.now - startTime;
                                // if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);
                            }
                        }
                    }
                }
                if (obj.ops[iop].portsOut)
                    for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)
                        if (obj.ops[iop].portsOut[ipi2] && obj.ops[iop].portsOut[ipi2].links)
                        {
                            for (let ili = 0; ili < obj.ops[iop].portsOut[ipi2].links.length; ili++)
                            {
                                if (obj.ops[iop].portsOut[ipi2].links[ili])
                                {
                                    if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef)
                                    {
                                        // lost link
                                        const outOp = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);
                                        let dstOp = null;
                                        let theSubPatch = 0;

                                        for (let i = 0; i < this.ops.length; i++)
                                        {
                                            if (
                                                this.ops[i].storage &&
                                                this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&
                                                outOp.uiAttribs.subPatch == this.ops[i].uiAttribs.subPatch
                                            )
                                            {
                                                theSubPatch = this.ops[i].patchId.get();
                                                break;
                                            }
                                        }

                                        for (let i = 0; i < this.ops.length; i++)
                                        {
                                            if (
                                                this.ops[i].storage &&
                                                this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].refOp &&
                                                this.ops[i].uiAttribs.subPatch == theSubPatch)
                                            {
                                                dstOp = this.ops[i];
                                                break;
                                            }
                                        }

                                        if (!dstOp) this._log.warn("could not find op for lost link");
                                        else
                                        {
                                            const l = this._addLink(
                                                dstOp.id,
                                                obj.ops[iop].portsOut[ipi2].links[ili].objOut,

                                                obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                                                obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                                        }
                                    }
                                    else
                                    {
                                        const l = this._addLink(obj.ops[iop].portsOut[ipi2].links[ili].objIn, obj.ops[iop].portsOut[ipi2].links[ili].objOut, obj.ops[iop].portsOut[ipi2].links[ili].portIn, obj.ops[iop].portsOut[ipi2].links[ili].portOut);

                                        if (!l)
                                        {
                                            const op1 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objIn);
                                            const op2 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);

                                            if (!op1)console.log("could not find link op1");
                                            if (!op2)console.log("could not find link op2");

                                            const p1Name = obj.ops[iop].portsOut[ipi2].links[ili].portIn;

                                            if (op1 && !op1.getPort(p1Name))
                                            {
                                                // console.log("PRESERVE port 1 not found", p1Name);

                                                op1.preservedPortLinks[p1Name] = op1.preservedPortLinks[p1Name] || [];
                                                op1.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                                            }

                                            const p2Name = obj.ops[iop].portsOut[ipi2].links[ili].portOut;
                                            if (op2 && !op2.getPort(p2Name))
                                            {
                                                // console.log("PRESERVE port 2 not found", obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                                                op2.preservedPortLinks[p1Name] = op2.preservedPortLinks[p1Name] || [];
                                                op2.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
            }
        }

        if (window.logStartup)logStartup("calling ops onloaded");

        for (const i in this.ops)
        {
            if (this.ops[i].onLoaded)
            {
                // TODO: deprecate!!!
                this.ops[i].onLoaded();
                this.ops[i].onLoaded = null;
            }
        }

        if (window.logStartup)logStartup("initializing ops...");
        for (const i in this.ops)
        {
            if (this.ops[i].init)
            {
                try
                {
                    this.ops[i].init();
                    this.ops[i].init = null;
                }
                catch (e)
                {
                    console.error("op.init crash", e);
                }
            }
        }

        if (window.logStartup)logStartup("initializing vars...");

        if (this.config.variables)
            for (const varName in this.config.variables)
                this.setVarValue(varName, this.config.variables[varName]);

        if (window.logStartup)logStartup("initializing var ports");

        for (const i in this.ops)
        {
            this.ops[i].initVarPorts();
            delete this.ops[i].uiAttribs.pasted;
        }

        setTimeout(() => { this.loading.finished(loadingId); }, 100);

        if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);

        this.deSerialized = true;
        this.emitEvent("patchLoadEnd", newOps, obj, options.genIds);
    }

    profile(enable)
    {
        this.profiler = new Profiler(this);
        for (const i in this.ops)
        {
            this.ops[i].profile(enable);
        }
    }

    // ----------------------

    /**
     * set variable value
     * @function setVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     * @param {Number|String|Boolean} val value
     */
    setVariable(name, val)
    {
        // if (this._variables.hasOwnProperty(name))
        if (this._variables[name] !== undefined)
        {
            this._variables[name].setValue(val);
        }
        else
        {
            this._log.warn("variable " + name + " not found!");
        }
    }

    _sortVars()
    {
        if (!this.isEditorMode()) return;
        const ordered = {};
        Object.keys(this._variables).sort(
            (a, b) =>
            { return a.localeCompare(b, "en", { "sensitivity": "base" }); }
        ).forEach((key) =>
        {
            ordered[key] = this._variables[key];
        });
        this._variables = ordered;
    }

    /**
     * has variable
     * @function hasVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     */
    hasVar(name)
    {
        return this._variables[name] !== undefined;

        // return this._variables.hasOwnProperty(name);
    }

    // used internally
    setVarValue(name, val, type)
    {
        if (this.hasVar(name))
        {
            this._variables[name].setValue(val);
        }
        else
        {
            this._variables[name] = new core_variable(name, val, type);
            this._sortVars();
            this.emitEvent("variablesChanged");
        }
        return this._variables[name];
    }

    // old?
    getVarValue(name, val)
    {
        if (this._variables.hasOwnProperty(name)) return this._variables[name].getValue();
    }

    /**
     * @function getVar
     * @memberof Patch
     * @instance
     * @param {String} name
     * @return {Variable} variable
     */
    getVar(name)
    {
        if (this._variables.hasOwnProperty(name)) return this._variables[name];
    }


    deleteVar(name)
    {
        for (let i = 0; i < this.ops.length; i++)
            for (let j = 0; j < this.ops[i].portsIn.length; j++)
                if (this.ops[i].portsIn[j].getVariableName() == name)
                    this.ops[i].portsIn[j].setVariable(null);

        delete this._variables[name];
        this.emitEvent("variableDeleted", name);
        this.emitEvent("variablesChanged");
    }

    /**
     * @function getVars
     * @memberof Patch
     * @instance
     * @param t
     * @return {Array<Variable>} variables
     * @function
     */
    getVars(t)
    {
        if (t === undefined) return this._variables;

        const vars = [];
        if (t == CABLES.OP_PORT_TYPE_STRING) t = "string";
        if (t == CABLES.OP_PORT_TYPE_VALUE) t = "number";
        if (t == CABLES.OP_PORT_TYPE_ARRAY) t = "array";
        if (t == CABLES.OP_PORT_TYPE_OBJECT) t = "object";

        for (const i in this._variables)
        {
            if (!this._variables[i].type || this._variables[i].type == t) vars.push(this._variables[i]);
        }
        return vars;
    }


    /**
     * @function preRenderOps
     * @memberof Patch
     * @instance
     * @description invoke pre rendering of ops
     * @function
     */
    preRenderOps()
    {
        this._log.log("prerendering...");

        for (let i = 0; i < this.ops.length; i++)
        {
            if (this.ops[i].preRender)
            {
                this.ops[i].preRender();
                this._log.log("prerender " + this.ops[i].objName);
            }
        }
    }

    /**
     * @function dispose
     * @memberof Patch
     * @instance
     * @description stop, dispose and cleanup patch
     */
    dispose()
    {
        this.pause();
        this.clear();
        this.cgl.dispose();
    }

    pushTriggerStack(p)
    {
        this._triggerStack.push(p);
    }

    popTriggerStack()
    {
        this._triggerStack.pop();
    }

    printTriggerStack()
    {
        if (this._triggerStack.length == 0)
        {
            // console.log("stack length", this._triggerStack.length); // eslint-disable-line
            return;
        }
        console.groupCollapsed( // eslint-disable-line
            "trigger port stack " + this._triggerStack[this._triggerStack.length - 1].op.objName + "." + this._triggerStack[this._triggerStack.length - 1].name,
        );

        const rows = [];
        for (let i = 0; i < this._triggerStack.length; i++)
        {
            rows.push(i + ". " + this._triggerStack[i].op.objName + " " + this._triggerStack[i].name);
        }

        console.table(rows); // eslint-disable-line
        console.groupEnd(); // eslint-disable-line
    }

    /**
     * returns document object of the patch could be != global document object when opening canvas ina popout window
     * @function getDocument
     * @memberof Patch
     * @instance
     * @return {Object} document
     */
    getDocument()
    {
        return this.cgl.canvas.ownerDocument;
    }
}

Patch.getOpClass = function (objName)
{
    const parts = objName.split(".");
    let opObj = null;

    try
    {
        if (parts.length == 2) opObj = window[parts[0]][parts[1]];
        else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];
        else if (parts.length == 4) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];
        else if (parts.length == 5) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];
        else if (parts.length == 6) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];
        else if (parts.length == 7) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]];
        else if (parts.length == 8) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]];
        else if (parts.length == 9) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]];
        else if (parts.length == 10) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]];
        return opObj;
    }
    catch (e)
    {
        return null;
    }
};



Patch.replaceOpIds = function (json, options)
{
    const opids = {};
    for (const i in json.ops)
    {
        opids[json.ops[i].id] = json.ops[i];
    }

    for (const j in json.ops)
    {
        for (const k in json.ops[j].portsOut)
        {
            const links = json.ops[j].portsOut[k].links;
            if (links)
            {
                let l = links.length;

                while (l--)
                {
                    if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut]))
                    {
                        if (!options.doNotUnlinkLostLinks)
                        {
                            links.splice(l, 1);
                        }
                        else
                        {
                            if (options.fixLostLinks)
                            {
                                // console.log("lost link...?", links[l]);
                                const op = gui.corePatch().getOpById(links[l].objIn);
                                if (!op) console.log("op not found!");
                                else
                                {
                                    const outerOp = gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);
                                    if (outerOp)
                                    {
                                        op.storage = op.storage || {};
                                        op.storage.ref = op.storage.ref || CABLES.shortId();
                                        links[l].refOp = op.storage.ref;
                                        links[l].subOpRef = outerOp.storage.ref;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }



    for (const i in json.ops)
    {
        const op = json.ops[i];
        const oldId = op.id;
        let newId = CABLES.shortId();

        if (options.prefixHash) newId = prefixedHash(options.prefixHash + oldId);

        else if (options.prefixId) newId = options.prefixId + oldId;
        else if (options.refAsId) // when saving json
        {
            if (op.storage && op.storage.ref)
            {
                newId = op.storage.ref;
                delete op.storage.ref;
            }
            else
            {
                op.storage = op.storage || {};
                op.storage.ref = newId = CABLES.shortId();
            }
        }

        const newID = op.id = newId;

        if (options.oldIdAsRef) // when loading json
        {
            op.storage = op.storage || {};
            op.storage.ref = oldId;
        }

        for (const j in json.ops)
        {
            if (json.ops[j].portsIn)
                for (const k in json.ops[j].portsIn)
                {
                    if (json.ops[j].portsIn[k].links)
                    {
                        let l = json.ops[j].portsIn[k].links.length;

                        while (l--) if (json.ops[j].portsIn[k].links[l] === null) json.ops[j].portsIn[k].links.splice(l, 1);

                        for (l in json.ops[j].portsIn[k].links)
                        {
                            if (json.ops[j].portsIn[k].links[l].objIn === oldId) json.ops[j].portsIn[k].links[l].objIn = newID;
                            if (json.ops[j].portsIn[k].links[l].objOut === oldId) json.ops[j].portsIn[k].links[l].objOut = newID;
                        }
                    }
                }

            if (json.ops[j].portsOut)
                for (const k in json.ops[j].portsOut)
                {
                    if (json.ops[j].portsOut[k].links)
                    {
                        let l = json.ops[j].portsOut[k].links.length;

                        while (l--) if (json.ops[j].portsOut[k].links[l] === null) json.ops[j].portsOut[k].links.splice(l, 1);

                        for (l in json.ops[j].portsOut[k].links)
                        {
                            if (json.ops[j].portsOut[k].links[l].objIn === oldId) json.ops[j].portsOut[k].links[l].objIn = newID;
                            if (json.ops[j].portsOut[k].links[l].objOut === oldId) json.ops[j].portsOut[k].links[l].objOut = newID;
                        }
                    }
                }
        }
    }

    // set correct subpatch
    const subpatchIds = [];
    const fixedSubPatches = [];

    for (let i = 0; i < json.ops.length; i++)
    {
        // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))
        if (json.ops[i].storage && json.ops[i].storage.subPatchVer)
        {
            for (const k in json.ops[i].portsIn)
            {
                if (json.ops[i].portsIn[k].name === "patchId")
                {
                    let newId = shortId();

                    if (options.prefixHash) newId = prefixedHash(options.prefixHash + json.ops[i].portsIn[k].value);

                    const oldSubPatchId = json.ops[i].portsIn[k].value;
                    const newSubPatchId = json.ops[i].portsIn[k].value = newId;

                    subpatchIds.push(newSubPatchId);

                    for (let j = 0; j < json.ops.length; j++)
                    {
                        // op has no uiAttribs in export, we don't care about subpatches in export though
                        if (json.ops[j].uiAttribs)
                        {
                            if (json.ops[j].uiAttribs.subPatch === oldSubPatchId)
                            {
                                json.ops[j].uiAttribs.subPatch = newSubPatchId;
                                fixedSubPatches.push(json.ops[j].id);
                            }
                        }
                    }
                }
            }
        }
    }

    for (const kk in json.ops)
    {
        let found = false;
        for (let j = 0; j < fixedSubPatches.length; j++)
        {
            if (json.ops[kk].id === fixedSubPatches[j])
            {
                found = true;
                break;
            }
        }
        // op has no uiAttribs in export, we don't care about subpatches in export though
        if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)
            json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;
    }

    return json;
};
/**
 * remove an eventlistener
 * @instance
 * @function addEventListener
 * @param {String} name of event
 * @param {function} callback
 */

/**
 * remove an eventlistener
 * @instance
 * @function removeEventListener
 * @param {String} name of event
 * @param {function} callback
 */

/**
 * op added to patch event
 * @event onOpAdd
 *
 * @memberof Patch
 * @type {Object}
 * @property {Op} op new op
 */

/**
 * op deleted from patch
 * @event onOpDelete
 * @memberof Patch
 * @type {Object}
 * @property {Op} op that will be deleted
 */

/**
 * link event - two ports will be linked
 * @event onLink
 * @memberof Patch
 * @type {Object}
 * @property {Port} port1
 * @property {Port} port2
 */

/**
 * unlink event - a link was deleted
 * @event onUnLink
 * @memberof Patch
 * @type {Object}
 */

/**
 * variables has been changed / a variable has been added to the patch
 * @event variablesChanged
 * @memberof Patch
 * @type {Object}
 * @property {Port} port1
 * @property {Port} port2
 */

/**
 * configuration object for loading a patch
 * @typedef {Object} PatchConfig
 * @hideconstructor
 * @property {String} [prefixAssetPath=''] prefix for path to assets
 * @property {String} [assetPath=''] path to assets
 * @property {String} [jsPath=''] path to javascript files
 * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element
 * @property {Function} [onError=null] called when an error occurs
 * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets
 * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame
 * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size
 * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)
 * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame
 * @property {Boolean} [clearCanvasDepth=true] clear depth every frame
 * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *
 * @property {Boolean} [silent=false]
 * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second
 * @property {String} [glslPrecision='mediump'] default precision for glsl shader
 *
 */

/* harmony default export */ const core_patch = (Patch);

;// CONCATENATED MODULE: ./src/core/embedding.js



const EMBED = {};

/**
 * add patch into html element (will create canvas and set size to fill containerElement)
 * @name CABLES.EMBED#addPatch
 * @param {object|string} _element containerElement dom element or id of element
 * @param {object} options patch options
 * @function
 */
EMBED.addPatch = function (_element, options)
{
    let el = _element;
    let id = generateUUID();
    if (typeof _element == "string")
    {
        id = _element;
        el = document.getElementById(id);

        if (!el)
        {
            console.error(id + " Polyshape Container Element not found!");
            return;
        }
    }

    const canvEl = document.createElement("canvas");
    canvEl.id = "glcanvas_" + id;
    canvEl.width = el.clientWidth;
    canvEl.height = el.clientHeight;

    window.addEventListener(
        "resize",
        function ()
        {
            this.setAttribute("width", el.clientWidth);
            this.height = el.clientHeight;
        }.bind(canvEl),
    );

    el.appendChild(canvEl);

    options = options || {};
    options.glCanvasId = canvEl.id;

    if (!options.onError)
    {
        options.onError = function (err)
        {
            console.error(err);
        };
    }

    CABLES.patch = new core_patch(options);
    return canvEl;
};



;// CONCATENATED MODULE: ./src/core/webaudio.js
/** @namespace WEBAUDIO */



const WEBAUDIO = {};

WEBAUDIO.toneJsInitialized = false;

/*
 * External JSDoc definitions
 */

/**
 * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}
 */

/**
 * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}
 */

/**
 * The AudioContext interface represents an audio-processing graph built from audio modules linked together
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}
 */

/**
 * Checks if a global audio context has been created and creates
 * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.
 * Associates the audio context with Tone.js if it is being used
 * @param {CABLES.Op} op - The operator which needs the Audio Context
 */
WEBAUDIO.createAudioContext = function (op)
{
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (window.AudioContext)
    {
        if (!window.audioContext)
        {
            window.audioContext = new AudioContext();
        }
        // check if tone.js lib is being used
        if (window.Tone && !WEBAUDIO.toneJsInitialized)
        {
            // set current audio context in tone.js
            Tone.setContext(window.audioContext);
            WEBAUDIO.toneJsInitialized = true;
        }
    }
    else
    {
        if (op.patch.config.onError)op.logError("NO_WEBAUDIO", "Web Audio is not supported in this browser.");
        return;
    }
    return window.audioContext;
};

/**
 * Returns the audio context.
 * Before `createAudioContext` must have been called at least once.
 * It most cases you should use `createAudioContext`, which just returns the audio context
 * when it has been created already.
 */
WEBAUDIO.getAudioContext = function ()
{
    return window.audioContext;
};

/**
 * Creates an audio in port for the op with name `portName`
 * When disconnected it will disconnect the previous connected audio node
 * from the op's audio node.
 * @param {CABLES.Op} op - The operator to create the audio port in
 * @param {string} portName - The name of the port
 * @param {AudioNode} audioNode - The audionode incoming connections should connect to
 * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to
 * @returns {CABLES.Port|undefined} - The newly created audio in port or `undefined` if there was an error
 */
WEBAUDIO.createAudioInPort = function (op, portName, audioNode, inputChannelIndex)
{
    if (!op || !portName || !audioNode)
    {
        const msg = "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
        op.log(msg);
        throw new Error(msg);
        // return;
    }
    if (!inputChannelIndex)
    {
        inputChannelIndex = 0;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    const port = op.inObject(portName);
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    port.onChange = function ()
    {
        const audioInNode = port.get();
        // when port disconnected, disconnect audio nodes
        if (!audioInNode)
        {
            if (port.webAudio.previousAudioInNode)
            {
                try
                {
                    if (port.webAudio.previousAudioInNode.disconnect) port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode, 0, inputChannelIndex);
                    op.setUiError("audioCtx", null);
                }
                catch (e)
                {
                    try
                    {
                        port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode);
                    }
                    catch (er)
                    {
                        op.log(
                            "Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ",
                            e,
                        );
                        if (e.printStackTrace)
                        {
                            e.printStackTrace();
                        }
                        throw e;
                    }
                }
            }
        }
        else
        {
            try
            {
                if (audioInNode.connect)
                {
                    audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);
                    op.setUiError("audioCtx", null);
                }
                else op.setUiError("audioCtx", "The passed input is not an audio context. Please make sure you connect an audio context to the input.", 2);
            }
            catch (e)
            {
                op.log("Error: Failed to connect web audio node!", e);
                op.log("port.webAudio.audioNode", port.webAudio.audioNode);
                op.log("audioInNode: ", audioInNode);
                op.log("inputChannelIndex:", inputChannelIndex);
                op.log("audioInNode.connect: ", audioInNode.connect);
                throw e;
            }
        }
        port.webAudio.previousAudioInNode = audioInNode;
    };
    // TODO: Maybe add subtype to audio-node-object?
    return port;
};

/**
 * Sometimes it is necessary to replace a node of a port, if so all
 * connections to this node must be disconnected and connections to the new
 * node must be made.
 * Can be used for both Audio ports as well as AudioParam ports
 * if used with an AudioParam pass e.g. `synth.frequency` as newNode
 * @param {CABLES.Port} port - The port where the audio node needs to be replaced
 * @param oldNode
 * @param newNode
 */
WEBAUDIO.replaceNodeInPort = function (port, oldNode, newNode)
{
    const connectedNode = port.webAudio.previousAudioInNode;
    // check if connected
    if (connectedNode && connectedNode.disconnect)
    {
        try
        {
            connectedNode.disconnect(oldNode);
        }
        catch (e)
        {
            if (e.printStackTrace)
            {
                e.printStackTrace();
            }
            throw new Error("replaceNodeInPort: Could not disconnect old audio node. " + e.name + " " + e.message);
        }
        port.webAudio.audioNode = newNode;
        try
        {
            connectedNode.connect(newNode);
        }
        catch (e)
        {
            if (e.printStackTrace)
            {
                e.printStackTrace();
            }
            throw new Error("replaceNodeInPort: Could not connect to new node. " + e.name + " " + e.message);
        }
    }
};

/**
 * Creates an audio out port which takes care of (dis-)connecting on its own
 * @param {CABLES.op} op - The op to create an audio out port for
 * @param {string} portName - The name of the port to be created
 * @param {AudioNode} audioNode - The audio node to link to the port
 * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error
 */
WEBAUDIO.createAudioOutPort = function (op, portName, audioNode)
{
    if (!op || !portName || !audioNode)
    {
        const msg = "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
        op.log(msg);
        throw new Error(msg);
    }

    const port = op.outObject(portName);
    // TODO: Maybe add subtype to audio-node-object?
    port.set(audioNode);
    return port;
};

/**
 * Creates an audio param in port for the op with name portName.
 * The port accepts other audio nodes as signals as well as values (numbers)
 * When the port is disconnected it will disconnect the previous connected audio node
 * from the op's audio node and restore the number value set before.
 * @param {CABLES.Op} op - The operator to create an audio param input port for
 * @param {string} portName - The name of the port to create
 * @param audioNode
 * @param options
 * @param defaultValue
 * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error
 */
WEBAUDIO.createAudioParamInPort = function (op, portName, audioNode, options, defaultValue)
{
    if (!op || !portName || !audioNode)
    {
        op.log("ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode");
        if (op && op.name) op.log("opname: ", op.name);
        op.log("portName", portName);
        op.log("audioNode: ", audioNode);
        return;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    // var port = op.inObject(portName);
    const port = op.inDynamic(
        portName,
        [CONSTANTS.OP.OP_PORT_TYPE_VALUE, CONSTANTS.OP.OP_PORT_TYPE_OBJECT],
        options,
        defaultValue,
    );
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    // port.onLinkChanged = function() {
    //   op.log("onLinkChanged");
    //   if(port.isLinked()) {
    //
    //       if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_) { // value
    //
    //       } else if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) { // object
    //
    //       }
    //   } else { // unlinked
    //
    //   }
    // };

    port.onChange = function ()
    {
        const audioInNode = port.get();
        const node = port.webAudio.audioNode;
        const audioCtx = WEBAUDIO.getAudioContext();

        if (audioInNode != undefined)
        {
            if (typeof audioInNode === "object" && audioInNode.connect)
            {
                try
                {
                    audioInNode.connect(node);
                }
                catch (e)
                {
                    op.log("Could not connect audio node: ", e);
                    if (e.printStackTrace)
                    {
                        e.printStackTrace();
                    }
                    throw e;
                }
                port.webAudio.previousAudioInNode = audioInNode;
            }
            else
            {
                // tone.js audio param
                if (node._param && node._param.minValue && node._param.maxValue)
                {
                    if (audioInNode >= node._param.minValue && audioInNode <= node._param.maxValue)
                    {
                        try
                        {
                            if (node.setValueAtTime)
                            {
                                node.setValueAtTime(audioInNode, audioCtx.currentTime);
                            }
                            else
                            {
                                node.value = audioInNode;
                            }
                        }
                        catch (e)
                        {
                            op.log("Possible AudioParam problem with tone.js op: ", e);
                            if (e.printStackTrace)
                            {
                                e.printStackTrace();
                            }
                            throw e;
                        }
                    }
                    else
                    {
                        op.log("Warning: The value for an audio parameter is out of range!");
                    }
                } // native Web Audio param
                else if (node.minValue && node.maxValue)
                {
                    if (audioInNode >= node.minValue && audioInNode <= node.maxValue)
                    {
                        try
                        {
                            if (node.setValueAtTime)
                            {
                                node.setValueAtTime(audioInNode, audioCtx.currentTime);
                            }
                            else
                            {
                                node.value = audioInNode;
                            }
                        }
                        catch (e)
                        {
                            op.log(
                                "AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ",
                                e,
                            );
                            if (e.printStackTrace)
                            {
                                e.printStackTrace();
                            }
                            throw e;
                        }
                    }
                    else
                    {
                        op.log("Warning: The value for an audio parameter is out of range!");
                    }
                } // no min-max values, try anyway
                else
                {
                    try
                    {
                        if (node.setValueAtTime)
                        {
                            node.setValueAtTime(audioInNode, audioCtx.currentTime);
                        }
                        else
                        {
                            node.value = audioInNode;
                        }
                    }
                    catch (e)
                    {
                        op.log("Possible AudioParam problem (without minValue / maxValue): ", e);
                        if (e.printStackTrace)
                        {
                            e.printStackTrace();
                        }
                        throw e;
                    }
                }

                if (port.webAudio.previousAudioInNode && port.webAudio.previousAudioInNode.disconnect)
                {
                    try
                    {
                        port.webAudio.previousAudioInNode.disconnect(node);
                    }
                    catch (e)
                    {
                        op.log("Could not disconnect previous audio node: ", e);
                        throw e;
                    }
                    port.webAudio.previousAudioInNode = undefined;
                }
            }
        }
        else
        {
            // disconnected
            if (port.webAudio.previousAudioInNode)
            {
            }
        }
    };
    return port;
};


/**
 * Loads an audio file and updates the loading indicators when cables is run in the editor.
 * @param {CABLES.Patch} patch - The cables patch, when called from inside an op this is `op.patch`
 * @param {string} url - The url of the audio file to load
 * @param {function} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer
 * @param {function} onError - The callback when there was an error loading the file, the rror message is passed
 * @param loadingTask
 * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}
 */
WEBAUDIO.loadAudioFile = function (patch, url, onFinished, onError, loadingTask)
{
    const audioContext = WEBAUDIO.createAudioContext();

    if (!audioContext) onError(new Error("No Audiocontext"));

    let loadingId = null;
    if (loadingTask || loadingTask === undefined)
    {
        loadingId = patch.loading.start("audio", url);
        if (patch.isEditorMode()) gui.jobs().start({ "id": "loadaudio" + loadingId, "title": " loading audio (" + url + ")" });
    }
    const request = new XMLHttpRequest();

    if (!url) return;

    request.open("GET", url, true);
    request.responseType = "arraybuffer";

    request.onload = function ()
    {
        patch.loading.finished(loadingId);
        if (patch.isEditorMode()) gui.jobs().finish("loadaudio" + loadingId);

        audioContext.decodeAudioData(request.response, onFinished, onError).catch((e) =>
        {
            onError(e);
        });
    };
    request.send();
};

/**
 * Checks if the passed time is a valid time to be used in any of the Tone.js ops.
 * @param {(string|number)} t - The time to check
 * @returns {boolean} - True if time is valid, false if not
 */
WEBAUDIO.isValidToneTime = function (t)
{
    try
    {
        const time = new Tone.Time(t);
    }
    catch (e)
    {
        return false;
    }
    return true;
};

/**
 * Checks if the passed note is a valid note to be used with Tone.js
 * @param {string} note - The note to be checked, e.g. `"C4"`
 * @returns {boolean} - True if the note is a valid note, false otherwise
 */
WEBAUDIO.isValidToneNote = function (note)
{
    try
    {
        Tone.Frequency(note);
    }
    catch (e)
    {
        return false;
    }
    return true;
};



;// CONCATENATED MODULE: ./src/core/sessionvar.js
// todo: old... remove this from ops...

/**
 * todo: old... remove this from ops...
 *
 * @class
 */
const Variable = function ()
{
    let value = null;
    const changedCallbacks = [];

    this.onChanged = function (f)
    {
        changedCallbacks.push(f);
    };

    this.getValue = function ()
    {
        return value;
    };

    this.setValue = function (v)
    {
        value = v;
        this.emitChanged();
    };

    this.emitChanged = function ()
    {
        for (let i = 0; i < changedCallbacks.length; i++)
        {
            changedCallbacks[i]();
        }
    };
};



;// CONCATENATED MODULE: ./src/core/cgp/cgp_uniform.js



class cgp_uniform_Uniform extends cg_uniform
{
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
        this._cgp = __shader._cgp;

        if (!_value)
        {
            // if (this.getType() == "m4") this._value = mat4.create();
            if (this.getType() == "t") this._value = this._cgp.getEmptyTexture();
            // else if (this.getType() == "2f") this._value = [0, 0];
            // else if (this.getType() == "4f") this._value = [0, 1, 0, 1];
            // else if (this.getType() == "3f") this._value = [0, 1, 0];
        }

        this.gpuBuffer = null;
    }


    updateValueF() { }

    updateValueArrayF() {}

    setValueArrayF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    setValueF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue2F() { }

    setValue2F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue3F() { }

    setValue3F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue4F() { }

    setValue4F(v)
    {
        if (v[0] == undefined)
        {
            this._log.stack("uniform value undefined");
            console.error("uniform value undefined");
        }
        this.needsUpdate = true;
        this._value = v;
    }

    setValueT(v)
    {
        if (this._value != v)
            this._shader.needsPipelineUpdate = "texture changed"; // todo really needed ? change binding instead?

        this.needsUpdate = true;
        this._value = v;
    }

    updateValueM4(v) {}

    setValueM4(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    setValueAny(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueAny() {}

    updateValueT() {}


    setGpuBuffer(b)
    {
        this.gpuBuffer = b;
    }

    copyToBuffer(buff, pos = 0)
    {
        if (this._type == "f")
        {
            buff[pos] = this._value;
        }
        else if (this._type == "t")
        {
        }
        else if (this._type == "4f")
        {
            buff[pos] = this._value[0];
            buff[pos + 1] = this._value[1];
            buff[pos + 2] = this._value[2];
            buff[pos + 3] = this._value[3];
        }
        else if (this._type == "f[]")
        {
            for (let i = 0; i < this._value.length; i++)
                buff[pos + i] = this._value[i];
        }
        else if (this._type == "m4")
        {
            for (let i = 0; i < 16; i++)
                buff[pos + i] = this._value[i];
        }
        else
        {
            this._log.warn("uniform copy to buffer unknown", this._type);
        }
    }

    getWgslTypeStr()
    {
        if (this._type == "m4") return "mat4x4f";
        if (this._type == "4f") return "vec4f";
        if (this._type == "3f") return "vec3f";
        if (this._type == "2f") return "vec2f";
        if (this._type == "f") return "float";
        if (this._type == "f[]") return "array<vec4f>";
        if (this._type == "i") return "int";
        if (this._type == "sampler") return "sampler";
        if (this._type == "t") return "texture_2d<f32>";
        this._log.warn("unknown type getWgslTypeStr", this._type);
        return "???";
    }

    getSizeBytes()
    {
        const bytesPerFloat = 4;
        const bytesPerInt = 4;
        if (this._type == "t") return 4;
        if (this._type == "sampler") return 4;
        if (this._type == "f") return 1 * bytesPerFloat;
        if (this._type == "2f") return 2 * bytesPerFloat;
        if (this._type == "3f") return 3 * bytesPerFloat;
        if (this._type == "4f") return 4 * bytesPerFloat;
        if (this._type == "f[]") return this._value.length * bytesPerFloat;

        if (this._type == "m4") return 4 * 4 * bytesPerFloat;

        if (this._type == "i") return 1 * bytesPerInt;
        if (this._type == "2i") return 2 * bytesPerInt;

        this._log.warn("unknown type getSizeBytes", this._type);
        return 4;
    }

    copy(newShader)
    {
        const uni = new cgp_uniform_Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
        uni.shaderType = this.shaderType;

        console.log(this._name, this._value, uni._value);


        return uni;
    }
}

;// CONCATENATED MODULE: ./src/core/cg/preproc.js
function preproc(str, vars)
{
    const lines = str.split("\n");
    const outLines = [];
    let stack = [];

    for (let i = 0; i < lines.length; i++)
    {
        let line = lines[i].trim();
        let parts = line.split(" ");

        if (line.startsWith("#ifdef "))
        {
            const s = vars[parts[1]];
            stack.push({ "state": s });
            continue;
        }
        if (line.startsWith("#ifndef "))
        {
            const s = vars[parts[1]];
            stack.push({ "state": !s });
            continue;
        }
        if (line.startsWith("#endif"))
        {
            stack.pop();
            continue;
        }
        const state = stack[stack.length - 1];

        if (line.startsWith("#else"))
        {
            state.state = !state.state;
            continue;
        }

        if (!state || state.state)
        {
            outLines.push(lines[i]);
        }
    }

    return outLines.join("\n");
}

;// CONCATENATED MODULE: ./src/core/cgp/cgp_gpubuffer.js


class GPUBuffer extends EventTarget
{
    constructor(cgp, name, data = null, options = {})
    {
        super();

        this.id = CABLES.shortId();

        this._name = name;
        this.floatArr = null;
        this._gpuBuffer = null;

        this.setData([0, 0, 0, 0]);
        this.needsUpdate = true;
        this._length = 0;

        if (options.buffCfg)
        {
            this._buffCfg = options.buffCfg;
        }

        if (data)
            this.setData(data);

        if (options.length) this.setLength(options.length);

        this.updateGpuBuffer(cgp);
    }

    setData(d)
    {
        // console.log((new Error()).stack);

        this.floatArr = new Float32Array(d);
        this.setLength(this.floatArr.length);

        // console.log(this.name, this.floatArr);
        this.needsUpdate = true;
    }

    setLength(s)
    {
        this._length = s;
        if (!this.floatArr || s != this.floatArr.length)
        {
            this.floatArr = new Float32Array(this._length);
            this.needsUpdate = true;
        }
    }

    updateGpuBuffer(cgp)
    {
        if (cgp) this._cgp = cgp;
        if (!this._cgp || !this._cgp.device)
        {
            console.log("no cgp...", this._name, this._cgp);
            return;
        }

        this._cgp.pushErrorScope("updateGpuBuffer");
        if (!this._gpuBuffer)
        {
            this._buffCfg = this._buffCfg || {};
            this._buffCfg.label = "gpuBuffer-" + this._name;
            if (!this._buffCfg.hasOwnProperty("size") && this.floatArr) this._buffCfg.size = this.floatArr.length * 4;
            this._buffCfg.usage = this._buffCfg.usage || (GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

            this._gpuBuffer = this._cgp.device.createBuffer(this._buffCfg);
        }

        // if (!isNaN(this.floatArr[0]))console.log("shit", this._name);

        if (this.floatArr)
            this._cgp.device.queue.writeBuffer(
                this._gpuBuffer,
                0,
                this.floatArr.buffer,
                this.floatArr.byteOffset,
                this.floatArr.byteLength
            );

        // this._gpuBuffer.unmap();

        this._cgp.popErrorScope();

        this.needsUpdate = false;
    }

    get name()
    {
        return this._name;
    }

    get gpuBuffer()
    {
        if (!this._gpuBuffer || this.needsUpdate) this.updateGpuBuffer();

        return this._gpuBuffer;
    }

    get length()
    {
        return this._length;
    }

    getSizeBytes()
    {
        return this.floatArr.length * 4;
    }

    dispose()
    {
        // setTimeout(() =>
        // {
        //     if (this._gpuBuffer) this._gpuBuffer.destroy();
        // }, 100);
    }
}

;// CONCATENATED MODULE: ./src/core/cgp/cgp_binding.js



class Binding
{
    /**
     * Description
     * @param {any} cgp
     * @param {any} idx
     * @param {string} name
     * @param {any} options={}
     */
    constructor(cgp, name, options = {})
    {
        if (typeof options != "object") this._log.error("binding options is not an object");
        this._index = -1;

        this._name = name;
        this._cgp = cgp;
        this._log = new Logger("cgp_binding");
        this.uniforms = [];
        this.cGpuBuffers = [];
        this._options = options;
        this.shader = null;
        this.bindingInstances = [];
        this.stageStr = options.stage;
        this.bindingType = options.bindingType || "uniform"; // "uniform", "storage", "read-only-storage",

        if (this.stageStr == "frag") this.stage = GPUShaderStage.FRAGMENT;
        else this.stage = GPUShaderStage.VERTEX;
        if (options.hasOwnProperty("index")) this._index = options.index;

        if (options.shader) this.shader = options.shader;

        this._buffer = null;
        this.isValid = true;
        this.changed = 0;

        if (this.shader)
        {
            if (this.stageStr == "frag") this.shader.bindingsFrag.push(this);
            if (this.stageStr == "vert") this.shader.bindingsVert.push(this);
            if (this._index == -1) this._index = this.shader.getNewBindingIndex();
        }

        if (this._index == -1) this._log.warn("binding could not get an index", this._name);

        this._cgp.on("deviceChange", () =>
        {
            // this.reInit();
        });
    }

    isStruct()
    {
        if (this.uniforms.length == 0) return false;

        if (this.uniforms.length == 1)
        {
            if (this.uniforms[0].type == "t" || this.uniforms[0].type == "sampler") return false;
            if (this.bindingType != "uniform") return false;
        }

        return true;
    }

    copy(newShader)
    {
        console.log("copy binding...");
        const options = {};

        for (const i in this._options)
            options[i] = this._options[i];

        options.shader = newShader;

        let binding = new Binding(this._cgp, this._name, options);

        for (let i = 0; i < this.uniforms.length; i++)
        {
            binding.addUniform(newShader.getUniform(this.uniforms[i].name)); // .copy(newShader)
        }




        return binding;
    }

    addUniform(uni)
    {
        this.uniforms.push(uni);
    }

    getSizeBytes()
    {
        let size = 0;
        for (let i = 0; i < this.uniforms.length; i++)
        {
            // console.log("UNIFORM!!!", i, this.uniforms[i], this.uniforms[i].getSizeBytes());
            // console.log("getSizeBytes", this.uniforms[i], this.uniforms[i].getSizeBytes);
            size += this.uniforms[i].getSizeBytes();
        }
        // if (this.uniforms.length == 0)console.log("NO UNIFORMS!!!");
        return size;
    }

    getShaderHeaderCode()
    {
        let str = "";

        let typeStr = "strct_" + this._name;
        let name = this._name;

        if (this.uniforms.length === 0) return "// no uniforms in bindinggroup...?\n";


        str += "// " + this.uniforms.length + " uniforms\n";

        if (this.isStruct())
        {
            str += "struct " + typeStr + "\n";
            str += "{\n";
            for (let i = 0; i < this.uniforms.length; i++)
            {
                str += "    " + this.uniforms[i].name + ": " + this.uniforms[i].getWgslTypeStr();
                if (i != this.uniforms.length - 1)str += ",";
                str += "\n";
            }
            str += "};\n";
        }
        else
        {
            typeStr = this.uniforms[0].getWgslTypeStr();
            name = this.uniforms[0].name;
        }

        str += "@group(0) ";
        str += "@binding(" + this._index + ") ";

        if (this.isStruct())
        {
            str += "var<" + this.bindingType + "> ";
        }
        else if (this.bindingType == "read-only-storage")str += "var<storage,read> ";
        else str += "var ";

        str += name + ": " + typeStr + ";\n";

        return str;
    }


    getBindingGroupLayoutEntry()
    {
        let label = "layout " + this._name + " [";
        for (let i = 0; i < this.uniforms.length; i++) label += this.uniforms[i].getName() + ",";
        label += "]";

        const o = {
            "label": label,
            "binding": this._index,
            "visibility": this.stage,
            "size": this.getSizeBytes()
        };

        if (this.uniforms.length == 1 && this.uniforms[0].getType() == "t")
        {
            o.texture = {};
        }
        else if (this.uniforms.length == 1 && this.uniforms[0].getType() == "sampler")
        {
            o.sampler = {};
        }
        else
        {
            o.buffer = {};
            o.buffer.type = this.bindingType;
        }

        return o;
    }

    getBindingGroupEntry(gpuDevice, inst)
    {
        this.isValid = false;

        const o = {
            "label": this._name + " binding",
            "binding": this._index,
            "size": this.getSizeBytes(),
            "visibility": this.stage,
        };

        if (this.uniforms.length == 0)
        {
            console.log("binding uniforms length 0");
            return;
        }

        if (this.uniforms.length == 1 && this.uniforms[0].getType() == "t")
        {
            if (this.uniforms[0].getValue() && this.uniforms[0].getValue().gpuTexture) o.resource = this.uniforms[0].getValue().gpuTexture.createView();
            else o.resource = this._cgp.getEmptyTexture().createView();// CABLES.emptyCglTexture.createView();
        }
        else if (this.uniforms.length == 1 && this.uniforms[0].getType() == "sampler")
        {
            let smplDesc = {
                "addressModeU": "mirror-repeat",
                "addressModeV": "mirror-repeat",
                "magFilter": "linear",
                "minFilter": "linear",
                "mipmapFilter": "linear",
            };

            if (this.uniforms[0].getValue()) smplDesc = this.uniforms[0].getValue().getSampler();

            const sampler = this.uniforms[0]._cgp.device.createSampler(smplDesc);
            o.resource = sampler;
        }
        else
        {
            this._createCgpuBuffer(inst);

            o.resource = {
                "buffer": this.cGpuBuffers[inst].gpuBuffer,
                "minBindingSize": this.getSizeBytes(),
                "hasDynamicOffset": 0
            };
        }

        this.isValid = true;
        this.bindingInstances[inst] = o;

        return o;
    }

    _createCgpuBuffer(inst)
    {
        let buffCfg = {
            "label": this._name,
            "size": this.getSizeBytes(),
            "usage": GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        };

        if (this.bindingType == "read-only-storage" || this.bindingType == "storage") buffCfg.usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;

        if (this.cGpuBuffers[inst]) this.cGpuBuffers[inst].dispose();
        this.cGpuBuffers[inst] = new GPUBuffer(this._cgp, this._name + " buff", null, { "buffCfg": buffCfg });

        if (this.uniforms.length > 0 && this.uniforms[0].gpuBuffer) this.cGpuBuffers[inst] = this.uniforms[0].gpuBuffer;
    }



    update(cgp, inst)
    {
        let b = this.bindingInstances[inst];
        if (!b) b = this.getBindingGroupEntry(cgp.device, inst);

        if (this.uniforms.length == 1 && this.uniforms[0].gpuBuffer)
        {
            if (this.uniforms[0].gpuBuffer != this.cGpuBuffers[inst])
            {
                console.log("changed?!");
                this.shader._needsRecompile = true; // TODO this should actually just rebuild the bindinggroup i guess ?
            }

            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("extern uni bind", [this.uniforms[0].getName(), this.cGpuBuffers[inst].floatArr]);
            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();
        }
        else
        if (this.uniforms.length == 1 && this.uniforms[0].getType() == "t")
        {
            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("uni texture");
            if (this.uniforms[0].getValue())
                if (this.uniforms[0].getValue().gpuTexture)
                {
                    this.bindingInstances[inst] = this.getBindingGroupEntry(this.uniforms[0]._cgp.device, inst);
                }
                else
                {
                    console.log("uni t has no gputexture");
                    b.resource = this._cgp.getErrorTexture().createView();
                }

            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();
        }
        else if (this.uniforms.length == 1 && this.uniforms[0].getType() == "sampler")
        {
            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("uni sampler");
            b.resource = this.uniforms[0].getValue();
            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();
        }
        else
        {
            let info = ["stage " + this.stageStr + " / inst " + inst];

            // console.log("B",this.);
            // update uniform values to buffer
            const s = this.getSizeBytes() / 4;

            // if (!this.cGpuBuffers[inst])
            // this._createCgpuBuffer(inst);
            // this.cGpuBuffers[inst] = new GPUBuffer(this._cgp, "buff", null, { "buffCfg": buffCfg });

            this.cGpuBuffers[inst].setLength(s);

            let off = 0;
            for (let i = 0; i < this.uniforms.length; i++)
            {
                info.push(this.uniforms[i].getName() + " " + this.uniforms[i].getValue());
                this.uniforms[i].copyToBuffer(this.cGpuBuffers[inst].floatArr, off); // todo: check if uniform changed?

                // if (isNaN(this.cGpuBuffers[inst].floatArr[0]))
                // {
                // console.log("shitttttttt", this.cGpuBuffers[inst].floatArr[0], this.uniforms[i].getName(), this.cGpuBuffers[inst].name, this.uniforms[i]);
                // }

                off += this.uniforms[i].getSizeBytes() / 4;
            }
            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("uni buff", info);

            // console.log("upodate", inst);

            this.cGpuBuffers[inst].updateGpuBuffer();
            // todo: only if changed...
            // cgp.device.queue.writeBuffer(
            //     b.resource.buffer,
            //     0,
            //     this._buffer.buffer,
            //     this._buffer.byteOffset,
            //     this._buffer.byteLength
            // );

            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();
        }
    }
}

;// CONCATENATED MODULE: ./src/core/cgp/cgp_shader.js






class cgp_shader_Shader extends CgShader
{
    constructor(_cgp, _name, options = {})
    {
        super();
        if (!_cgp) throw new Error("shader constructed without cgp " + _name);
        this._log = new Logger("cgp_shader");
        this._cgp = _cgp;
        this._name = _name;
        this._uniforms = [];
        this.compute = options.compute || false;

        if (!_name) this._log.stack("no shader name given");
        this._name = _name || "unknown";
        this._compileReason = "";
        this.gpuShaderModule = null;
        this._needsRecompile = true;
        this.bindingCounter = 0;
        this.bindCountlastFrame = -1;
        this._bindingIndexCount = 0;

        this.defaultBindingVert = new Binding(_cgp, "vsUniforms", { "stage": "vert", "bindingType": "uniform", "index": this._bindingIndexCount++ });
        this.defaultBindingFrag = new Binding(_cgp, "fsUniforms", { "stage": "frag", "bindingType": "uniform", "index": this._bindingIndexCount++ });
        this.defaultBindingComp = new Binding(_cgp, "computeUniforms", { "bindingType": "uniform", "index": this._bindingIndexCount++ });
        this.bindingsFrag = [this.defaultBindingFrag];
        this.bindingsVert = [this.defaultBindingVert];
        this.bindingsComp = [this.defaultBindingComp];

        if (!this.compute)
        {
            this.uniModelMatrix = this.addUniformVert("m4", "modelMatrix");
            this.uniViewMatrix = this.addUniformVert("m4", "viewMatrix");
            this.uniProjMatrix = this.addUniformVert("m4", "projMatrix");
            this.uniNormalMatrix = this.addUniformVert("m4", "normalMatrix");
            this.uniModelViewMatrix = this.addUniformVert("m4", "modelViewMatrix");
            this._tempNormalMatrix = mat4.create();
            this._tempModelViewMatrix = mat4.create();
        }


        this._src = "";

        this._cgp.on("deviceChange", () =>
        {
            this.gpuShaderModule = null;
            this._needsRecompile = "device changed";
        });
    }

    incBindingCounter()
    {
        if (this.bindCountlastFrame != this._cgp.frame) this.bindingCounter = 0;
        else this.bindingCounter++;
        this.bindCountlastFrame = this._cgp.frame;
    }

    reInit()
    {

    }

    get isValid()
    {
        return this._isValid;
    }

    get uniforms()
    {
        return this._uniforms;
    }

    getName()
    {
        return this._name;
    }

    setWhyCompile(why)
    {
        this._compileReason = why;
    }

    getNewBindingIndex()
    {
        return ++this._bindingIndexCount;
    }


    setSource(src)
    {
        this._src = src;
        this.setWhyCompile("Source changed");
        this._needsRecompile = true;
    }

    _replaceMods(vs)
    {
        let srcHeadVert = "";
        for (let i = 0; i < this._moduleNames.length; i++)
        {
            let srcVert = "";

            for (let j = 0; j < this._modules.length; j++)
            {
                const mod = this._modules[j];
                if (mod.name == this._moduleNames[i])
                {
                    srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";

                    srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

                    if (mod.attributes)
                        for (let k = 0; k < mod.attributes.length; k++)
                        {
                            const r = this._getAttrSrc(mod.attributes[k], false);
                            if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                            if (r.srcVert)srcVert += r.srcVert;
                        }

                    srcHeadVert += mod.srcHead || "";
                    srcVert += mod.srcBody || "";

                    srcHeadVert += "\n//---- end mod ------\n";

                    srcVert += "\n//---- end mod ------\n";

                    srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);

                    srcVert = srcVert.replace(/MOD_/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
                }
            }

            vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
        }

        vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
        return vs;
    }

    getProcessedSource()
    {
        const defs = {};
        for (let i = 0; i < this._defines.length; i++)
            defs[this._defines[i][0]] = this._defines[i][1] || true;


        let src = preproc(this._src, defs);

        let bindingsHeadVert = "";
        for (let i = 0; i < this.bindingsFrag.length; i++)
            bindingsHeadVert += this.bindingsFrag[i].getShaderHeaderCode();

        let bindingsHeadFrag = "";
        for (let i = 0; i < this.bindingsVert.length; i++)
            bindingsHeadFrag += this.bindingsVert[i].getShaderHeaderCode();



        src = bindingsHeadFrag + "\n\n////////////////\n\n" + bindingsHeadVert + "\n\n////////////////\n\n" + src;
        src = this._replaceMods(src);

        return src;
        // console.log("----------------\n", src, "\n----------------------------");
    }

    compile()
    {
        console.log("compile", this._compileReason);
        this._isValid = true;
        this._cgp.pushErrorScope("cgp_shader " + this._name);
        // console.log(this.getProcessedSource());
        this.gpuShaderModule = this._cgp.device.createShaderModule({ "code": this.getProcessedSource(), "label": this._name });
        this._cgp.popErrorScope(this.error.bind(this));
        this._needsRecompile = false;

        this.emitEvent("compiled");
    }

    error(e)
    {
        this._isValid = false;
    }

    bind()
    {
        if (!this.compute)
        {
            this.uniModelMatrix.setValue(this._cgp.mMatrix);
            this.uniViewMatrix.setValue(this._cgp.vMatrix);
            this.uniProjMatrix.setValue(this._cgp.pMatrix);

            // mat4.invert(this._tempNormalMatrix, this._cgp.mMatrix);
            // mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);
            mat4.mul(this._tempModelViewMatrix, this._cgp.vMatrix, this._cgp.mMatrix);



            // mat4.set(this._tempNormalMatrix, this._tempModelViewMatrix);
            mat4.invert(this._tempNormalMatrix, this._tempModelViewMatrix);
            mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);


            // cpu billboarding?
            // this._tempModelViewMatrix[0 * 4 + 0] = 1.0;
            // this._tempModelViewMatrix[0 * 4 + 1] = 0.0;
            // this._tempModelViewMatrix[0 * 4 + 2] = 0.0;

            // // #ifndef BILLBOARDING_CYLINDRIC
            // this._tempModelViewMatrix[1 * 4 + 0] = 0.0;
            // this._tempModelViewMatrix[1 * 4 + 1] = 1.0;
            // this._tempModelViewMatrix[1 * 4 + 2] = 0.0;
            // // #endif

            // this._tempModelViewMatrix[2 * 4 + 0] = 0.0;
            // this._tempModelViewMatrix[2 * 4 + 1] = 0.0;
            // this._tempModelViewMatrix[2 * 4 + 2] = 1.0;

            this.uniModelViewMatrix.setValue(this._tempModelViewMatrix);
            this.uniNormalMatrix.setValue(this._tempNormalMatrix);
        }

        if (this._needsRecompile) this.compile();
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformFrag
     * @returns {Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new cgp_uniform_Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "frag";

        this.defaultBindingFrag.addUniform(uni);
        this.needsPipelineUpdate = "add frag uniform";

        return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformVert
     * @returns {Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new cgp_uniform_Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "vert";

        this.defaultBindingVert.addUniform(uni);
        this.needsPipelineUpdate = "add ver uniform";

        return uni;
    }

    /**
     * add a uniform to all shader programs
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniform
     * @returns {Uniform}
     */
    addUniform(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new cgp_uniform_Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "both";
        return uni;
    }

    _addUniform(uni)
    {
        this._uniforms.push(uni);
        this.setWhyCompile("add uniform " + name);
        this._needsRecompile = true;
    }

    getUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].getName() == name) return this._uniforms[i];
        }
    }

    /**
     * copy current shader
     * @function copy
     * @memberof Shader
     * @instance
     * @returns newShader
     */
    copy()
    {
        const shader = new cgp_shader_Shader(this._cgp, this._name + " copy");
        shader.setSource(this._src);

        shader._modules = JSON.parse(JSON.stringify(this._modules));
        shader._defines = JSON.parse(JSON.stringify(this._defines));

        shader._modGroupCount = this._modGroupCount;
        shader._moduleNames = this._moduleNames;

        // shader.glPrimitive = this.glPrimitive;
        // shader.offScreenPass = this.offScreenPass;
        // shader._extensions = this._extensions;
        // shader.wireframe = this.wireframe;
        // shader._attributes = this._attributes;

        for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].copy(shader);

        shader.bindingsFrag = [];
        for (let i = 0; i < this.bindingsFrag.length; i++) this.bindingsFrag[i].copy(shader);
        shader.defaultBindingFrag = this.bindingsFrag[0];

        shader.bindingsVert = [];
        for (let i = 0; i < this.bindingsVert.length; i++) this.bindingsVert[i].copy(shader);
        shader.defaultBindingVert = this.bindingsVert[0];

        shader.bindingsComp = [];
        for (let i = 0; i < this.bindingsComp.length; i++) this.bindingsComp[i].copy(shader);
        shader.defaultBindingComp = this.bindingsComp[0];

        console.log("copyyyyyyyyyy", shader.bindingsVert, this.bindingsVert);

        this.setWhyCompile("copy");
        shader._needsRecompile = true;
        return shader;
    }


    /**
     * copy all uniform values from another shader
     * @function copyUniforms
     * @memberof Shader
     * @instance
     * @param origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader)
    {
        for (let i = 0; i < origShader._uniforms.length; i++)
        {
            if (!this._uniforms[i])
            {
                this._log.log("unknown uniform?!");
                continue;
            }
            this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());
        }

        // this.popTextures();
        // for (let i = 0; i < origShader._textureStackUni.length; i++)
        // {
        //     this._textureStackUni[i] = origShader._textureStackUni[i];
        //     this._textureStackTex[i] = origShader._textureStackTex[i];
        //     this._textureStackType[i] = origShader._textureStackType[i];
        //     this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
        // }
    }
}

;// CONCATENATED MODULE: ./src/core/cgp/cgl_shader_default.wgsl
/* harmony default export */ const cgl_shader_default = ("\nstruct MyVSInput\n{\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) texcoord: vec2<f32>,\n};\n\nstruct MyVSOutput\n{\n    @builtin(position) position: vec4<f32>,\n    @location(0) normal: vec3<f32>,\n    @location(1) texcoord: vec2<f32>,\n};\n\n@vertex\nfn myVSMain(v: MyVSInput) -> MyVSOutput\n{\n    var vsOut: MyVSOutput;\n    var pos =vec4<f32>(v.position, 1.0);\n\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\n\n    vsOut.normal = v.normal;\n    vsOut.texcoord = v.texcoord;\n    return vsOut;\n}\n\n@fragment\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\n{\n    return fsUniforms.color+vec4<f32>(.5,.5,.5,1.0);\n}\n\n");
;// CONCATENATED MODULE: ./src/core/cgp/cgp_texture.js



class cgp_texture_Texture extends CgTexture
{
    constructor(_cgp, options = {})
    {
        super(options);
        if (!_cgp) throw new Error("no cgp");
        this._log = new Logger("cgp_texture");
        this._cgp = _cgp;
        // this.id = CABLES.uuid();
        this.gpuTexture = null;
        this.gpuTextureDescriptor = null;

        options = options || {};

        this.name = options.name || "unknown";

        this.samplerDesc = {
            "addressModeU": options.wrap || options.addressModeU || "clamp-to-edge",
            "addressModeV": options.wrap || options.addressModeV || "clamp-to-edge",
            "magFilter": options.magFilter || options.filter || "linear",
            "minFilter": options.minFilter || options.filter || "linear",
        };


        this._cgp.on("deviceChange", () =>
        {
            // this.reInit();
        });
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter)
    {
        this.width = img.width;
        this.height = img.height;

        const textureType = "rgba8unorm";

        this._cgp.pushErrorScope("inittexture", { "logger": this._log });

        this.gpuTextureDescriptor = {

            "size": { "width": img.width, "height": img.height },
            "format": textureType,
            "usage": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };

        this.gpuTexture = this._cgp.device.createTexture(this.gpuTextureDescriptor);
        this._cgp.device.queue.copyExternalImageToTexture({ "source": img }, { "texture": this.gpuTexture }, this.gpuTextureDescriptor.size);

        this._cgp.popErrorScope();

        return this.gpuTexture;
    }

    dispose()
    {
        console.log("todo dispose");
    }

    getInfo()
    {
        const tex = this;
        const obj = {};

        obj.name = tex.name;
        obj.size = tex.width + " x " + tex.height;

        obj.textureType = tex.textureType;

        return obj;
    }

    createView()
    {
        if (!this.gpuTexture)
        {
            console.log("no gputexture...");
            return null;
        }
        return this.gpuTexture.createView();
    }

    getSampler()
    {
        // "clamp-to-edge"
        // "repeat"
        // "mirror-repeat"

        return this.samplerDesc;
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap)
    {
        if (!w || !h) this._log.error("texture size is 0");
        this.width = w;
        this.height = h;
        this.gpuTexture = this._cgp.device.createTexture(
            {
                "size": [w, h],
                "format": "rgba8unorm",
                "usage": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
            });

        this._cgp.device.queue.writeTexture(
            { "texture": this.gpuTexture },
            data,
            { "bytesPerRow": w * 4 },
            { "width": w, "height": h });
    }


    setWrap(v)
    {
        this.samplerDesc.addressModeU = this.samplerDesc.addressModeV = v;
    }

    setFilter(v)
    {
        this.samplerDesc.minFilter = this.samplerDesc.magFilter = v;
    }
}


/**
 * @function load
 * @static
 * @memberof Texture
 * @description load an image from an url
 * @param {Context} cgp
 * @param {String} url
 * @param {Function} onFinished
 * @param {Object} settings
 * @return {Texture}
 */
cgp_texture_Texture.load = function (cgp, url, onFinished, settings)
{
    fetch(url).then((response) =>
    {
        const texture = new cgp_texture_Texture(cgp, { "name": url });

        response.blob().then((blob) =>
        {
            createImageBitmap(blob).then((imgBitmap) =>
            {
                texture.initTexture(imgBitmap);
                if (onFinished)onFinished(texture);
                else console.log("Texture.load no onFinished callback");
            }).catch((err) =>
            {
                if (onFinished)onFinished(cgp.getErrorTexture());
            });
        });
    });
};

;// CONCATENATED MODULE: ./src/core/cgp/cgp_state.js








// https://github.com/greggman/webgpu-utils
// https://developer.chrome.com/blog/from-webgl-to-webgpu/
// https://gpuweb.github.io/gpuweb/explainer/


/**
 * cables webgpu context/state manager
 * @class
 * @namespace external:CGP
 * @hideconstructor
 */
// const Context = function (_patch)
class WebGpuContext extends CGState
{
    constructor(_patch)
    {
        super();

        this.patch = _patch;

        this.lastErrorMsg = "";

        this._log = new Logger("WebGpuContext");
        this.gApi = CG.GAPI_WEBGPU;
        this._viewport = [0, 0, 256, 256];
        this._shaderStack = [];
        this._simpleShader = null;
        this.frame = 0;
        this.catchErrors = false;

        this._stackCullFaceFacing = [];
        this._stackDepthTest = [];
        this._stackCullFace = [];
        this._stackDepthFunc = [];
        this._stackDepthWrite = [];
        this._stackErrorScope = [];
        this._stackBlend = [];
        this._stackErrorScopeLogs = [];

        this._defaultBlend = {
            "color": {
                "operation": "add",
                "srcFactor": "one",
                "dstFactor": "zero",
            },
            "alpha": {
                "operation": "add",
                "srcFactor": "one",
                "dstFactor": "zero",
            },
        };

        this.DEPTH_FUNCS = [
            "never",
            "always",
            "less",
            "less-equal",
            "greater",
            "greater-equal",
            "equal",
            "not-equal"
        ];

        this.CULL_MODES = [
            "none",
            "back",
            "front",
            "none" // both does not exist in webgpu
        ];
    }


    /// ////////////////////

    // getViewPort()
    // {
    //     return [0, 0, this.canvasWidth, this.canvasHeight];
    // }

    renderStart(cgp, identTranslate, identTranslateView)
    {
        this.frame++;
        this.pushErrorScope("cgpstate internal", "internal");
        this.pushErrorScope("cgpstate out-of-memory", "out-of-memory");

        if (!this._simpleShader)
        {
            this._simpleShader = new cgp_shader_Shader(this, "simple default shader");
            this._simpleShader.setSource(cgl_shader_default);
            this._simpleShader.addUniformFrag("4f", "color", [1, 1, 0, 1]);
        }

        this.fpsCounter.startFrame();

        this._startMatrixStacks(identTranslate, identTranslateView);
        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);

        this.pushShader(this._simpleShader);
        this.pushDepthTest(true);
        this.pushDepthWrite(true);
        this.pushDepthFunc("less-equal");


        this.pushBlend(this._defaultBlend);

        this.emitEvent("beginFrame");
    }

    renderEnd()
    {
        this._endMatrixStacks();

        this.popShader();
        this.popDepthFunc();
        this.popDepthWrite();
        this.popDepthTest();

        this.popErrorScope();
        this.popErrorScope();

        if (this._stackErrorScope.length > 0)console.log("scope stack length invalid...");

        this.emitEvent("endFrame");
        this.fpsCounter.endFrame();
    }


    setViewPort(x, y, w, h)
    {
        this._viewport = [x, y, w, h];
    }

    /**
     * @function getViewPort
     * @memberof Context
     * @instance
     * @description get current gl viewport
     * @returns {Array} array [x,y,w,h]
     */
    getViewPort()
    {
        return this._viewPort;
    }

    createMesh(geom, glPrimitive)
    {
        return new CGP.Mesh(this, geom, glPrimitive);
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
    */
    pushShader(shader)
    {
        this._shaderStack.push(shader);
        // currentShader = shader;
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    popShader()
    {
        if (this._shaderStack.length === 0) throw new Error("Invalid shader stack pop!");
        this._shaderStack.pop();
        // currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    getShader()
    {
        return this._shaderStack[this._shaderStack.length - 1];
        // if (currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == currentShader.offScreenPass) === true) return currentShader;
        // for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];
    }

    setDevice(device)
    {
        this.device = device;


        if (this._emptyTexture) this._emptyTexture = this._emptyTexture.dispose();
        if (this._defaultTexture) this._defaultTexture = this._defaultTexture.dispose();
        if (this._errorTexture) this._errorTexture = this._errorTexture.dispose();

        this.emitEvent("deviceChange");
    }

    pushErrorScope(name, options = {})
    {
        if (this.catchErrors)
        {
            this._stackErrorScope.push(name);
            this._stackErrorScopeLogs.push(options.logger || null);
            this.device.pushErrorScope(options.scope || "validation");
        }
    }

    popErrorScope(cb)
    {
        if (this.catchErrors)
        {
            const name = this._stackErrorScope.pop();
            const logger = this._stackErrorScopeLogs.pop();
            this.device.popErrorScope().then((error) =>
            {
                if (error)
                {
                    if (this.lastErrorMsg == error.message)
                    {
                        // this._log.warn("last error once more...");
                    }
                    else
                    {
                        (logger || this._log).error(error.constructor.name, "in", name);
                        (logger || this._log).error(error.message);
                    }
                    this.lastErrorMsg = error.message;

                    if (cb)cb(error);
                }
            });
        }
    }

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthTest(b)
    {
        this._stackDepthTest.push(b);
    }

    /**
     * current state of depth testing
     * @function stateDepthTest
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest()
    {
        return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popDepthTest
     * @memberof Context
     * @instance
     */
    popDepthTest()
    {
        this._stackDepthTest.pop();
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthWrite
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(b)
    {
        b = b || false;
        this._stackDepthWrite.push(b);
    }

    /**
     * current state of depth writing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite()
    {
        return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthWrite()
    {
        this._stackDepthWrite.pop();
    }

    // --------------------------------------
    // state depthfunc

    /**
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {string} f depth compare func
     */
    pushDepthFunc(f)
    {
        this._stackDepthFunc.push(f);
    }

    /**
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {string}
     */
    stateDepthFunc()
    {
        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];
        return false;
    }

    /**
     * pop depth compare func
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc()
    {
        this._stackDepthFunc.pop();
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(b)
    {
        this._stackCullFace.push(b);
    }

    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace()
    {
        return this._stackCullFace[this._stackCullFace.length - 1];
    }

    /**
     * pop face culling enabled state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popCullFace()
    {
        this._stackCullFace.pop();
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @memberof Context
     * @param b
     * @instance
     */
    pushCullFaceFacing(b)
    {
        this._stackCullFaceFacing.push(b);
    }

    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing()
    {
        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing()
    {
        this._stackCullFaceFacing.pop();
    }

    pushBlend(b)
    {
        this._stackBlend.push(b);
    }

    popBlend()
    {
        this._stackBlend.pop();
    }

    stateBlend()
    {
        return this._stackBlend[this._stackBlend.length - 1];
    }

    getEmptyTexture()
    {
        if (this._emptyTexture) return this._emptyTexture;
        const size = 8;
        this._emptyTexture = new cgp_texture_Texture(this, {});
        this._emptyTexture.initFromData(CgTexture.getDefaultTextureData("empty", size), size, size);
        return this._emptyTexture;
    }

    getErrorTexture()
    {
        // if (this._errorTexture) return this._errorTexture;
        const size = 256;
        this._errorTexture = new cgp_texture_Texture(this, {});
        this._errorTexture.initFromData(CgTexture.getDefaultTextureData("stripes", size, { "r": 1, "g": 0, "b": 0 }), size, size);
        return this._errorTexture;
    }

    getDefaultTexture()
    {
        if (this._defaultTexture) return this._defaultTexture;
        const size = 256;
        this._defaultTexture = new cgp_texture_Texture(this, {});
        this._defaultTexture.initFromData(CgTexture.getDefaultTextureData("stripes", size), size, size);
        return this._defaultTexture;
    }
}


;// CONCATENATED MODULE: ./src/core/cgp/cgp_pipeline.js



class Pipeline
{
    constructor(_cgp, name)
    {
        if (!_cgp) throw new Error("Pipeline constructed without cgp " + name);
        this._name = name;
        this._cgp = _cgp;
        this._isValid = true;
        this._log = new Logger("pipeline");

        this._pipeCfg = null;
        this._renderPipeline = null;

        this._bindGroups = [];

        this._shaderListeners = [];
        this.shaderNeedsPipelineUpdate = false;

        this._old = {};

        this.DEPTH_COMPARE_FUNCS_STRINGS = ["never", "less", "equal", "lessequal", "greater", "notequal", "greaterequal", "always"];

        this._cgp.on("deviceChange", () =>
        {
            this._renderPipeline = null;
        });
    }

    get isValid() { return this._isValid; }

    setName(name)
    {
        this._name = name;
    }

    setShaderListener(oldShader, newShader)
    {
        for (let i = 0; i < this._shaderListeners.length; i++) oldShader.off(this._shaderListeners[i]);

        this._shaderListeners.push(
            newShader.on("compiled", () =>
            {
                // console.log("pipe update shader compileeeeeee");
                // this.needsRebuildReason = "shader changed";
                this.shaderNeedsPipelineUpdate = "shader compiled";
            }));
    }


    getInfo()
    {
        // console.log(this.bindingGroupLayoutEntries);

        const arr = [
            "name: " + this._name,
            "bindgroups: " + this._bindGroups.length

        ];

        if (this.bindingGroupLayoutEntries)arr.push("layouts: " + this.bindingGroupLayoutEntries.length);

        // if (this.bindingGroupLayoutEntries)
        //     for (let i = 0; i < this.bindingGroupLayoutEntries.length; i++)
        //     {
        //         // const lines = JSON.stringify(this.bindingGroupLayoutEntries, 4, true).split(",");
        //         arr.push(...lines);
        //     }

        return arr;
    }

    setPipeline(shader, mesh)
    {
        if (!mesh || !shader)
        {
            console.log("pipeline unknown shader/mesh");
            return;
        }

        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("setPipeline", this.getInfo());

        let needsRebuildReason = "";
        if (!this._renderPipeline) needsRebuildReason = "no renderpipeline";
        if (!this._pipeCfg)needsRebuildReason = "no pipecfg";
        if (this._old.mesh != mesh)needsRebuildReason = "no mesh";
        if (this._old.shader != shader)
        {
            this.setShaderListener(this._old.shader, shader);
            needsRebuildReason = "shader changed";
        }

        if (shader.needsPipelineUpdate)
        {
            needsRebuildReason = "mesh needs update: " + shader.needsPipelineUpdate;
            shader.needsPipelineUpdate = false;
        }
        if (mesh.needsPipelineUpdate)needsRebuildReason = "mesh needs update";
        if (this.shaderNeedsPipelineUpdate)needsRebuildReason = "shader was recompiled: " + this.shaderNeedsPipelineUpdate;

        if (this._pipeCfg)
        {
            if (this._pipeCfg.depthStencil.depthWriteEnabled != this._cgp.stateDepthWrite())
            {
                needsRebuildReason = "depth changed";
                this._pipeCfg.depthStencil.depthWriteEnabled = this._cgp.stateDepthWrite();
            }

            if (this._pipeCfg.fragment.targets[0].blend != this._cgp.stateBlend())
            {
                needsRebuildReason = "blend changed";
                this._pipeCfg.fragment.targets[0].blend = this._cgp.stateBlend();
            }

            // "fragment": {
            //     "module": shader.gpuShaderModule,
            //     "entryPoint": "myFSMain",
            //     "targets": [
            //         {
            //             "format": this._cgp.presentationFormat,
            //             "blend":
            //         },


            if (this._cgp.stateDepthTest() === false)
            {
                if (this._pipeCfg.depthStencil.depthCompare != "never")
                {
                    this._pipeCfg.depthStencil.depthCompare = "never";
                    needsRebuildReason = "depth compare changed";
                }
            }
            else
            if (this._pipeCfg.depthStencil.depthCompare != this._cgp.stateDepthFunc())
            {
                needsRebuildReason = "depth state ";
                this._pipeCfg.depthStencil.depthCompare = this._cgp.stateDepththis._cgp.stateDepthFunc();
            }

            // console.log(this._pipeCfg.primitive.cullMode, this._cgp.stateCullFaceFacing());
            if (this._pipeCfg.primitive.cullMode != this._cgp.stateCullFaceFacing())
            {
                needsRebuildReason = "cullmode change";
                this._pipeCfg.primitive.cullMode = this._cgp.stateCullFaceFacing();
            }
        }

        this._cgp.currentPipeDebug =
        {
            "cfg": this._pipeCfg,
            "bindingGroupEntries": this.bindingGroupEntries,
            "bindingGroupLayoutEntries": this.bindingGroupLayoutEntries
        };


        if (needsRebuildReason != "")
        {
            console.log("rebuild pipe", needsRebuildReason);
            this._cgp.pushErrorScope("createPipeline", { "logger": this._log });

            this._bindGroups = [];

            this._pipeCfg = this.getPipelineObject(shader, mesh);
            this._old.device = this._cgp.device;
            this._old.shader = shader;
            this._old.mesh = mesh;
            this._renderPipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);

            this._cgp.popErrorScope();
        }


        if (this._renderPipeline && this._isValid)
        {
            this._cgp.pushErrorScope("setpipeline", { "logger": this._log });


            this._cgp.passEncoder.setPipeline(this._renderPipeline);

            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("updateUniforms");

            shader.incBindingCounter();

            if (!this._bindGroups[shader.bindingCounter])
            {
                const bindingGroupEntries = [];

                for (let i = 0; i < shader.bindingsVert.length; i++)
                {
                    if (shader.bindingsVert[i].getSizeBytes() > 0)
                    {
                        bindingGroupEntries.push(shader.bindingsVert[i].getBindingGroupEntry(this._cgp.device, shader.bindingCounter));
                    }
                    else console.log("shader defaultBindingVert size 0");
                }
                for (let i = 0; i < shader.bindingsFrag.length; i++)
                {
                    if (shader.bindingsFrag[i].getSizeBytes() > 0)
                    {
                        bindingGroupEntries.push(shader.bindingsFrag[i].getBindingGroupEntry(this._cgp.device, shader.bindingCounter));
                    }
                    else console.log("shader defaultBindingFrag size 0");
                }

                const bg = {
                    "label": "label2",
                    "layout": this.bindGroupLayout,
                    "entries": bindingGroupEntries
                };

                this._bindGroups[shader.bindingCounter] = this._cgp.device.createBindGroup(bg);
            }

            this._bindUniforms(shader, shader.bindingCounter);

            if (this._bindGroups[shader.bindingCounter]) this._cgp.passEncoder.setBindGroup(0, this._bindGroups[shader.bindingCounter]);


            // shader.bindingCounter++;

            if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();

            this._cgp.popErrorScope();
        }
        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();


        this.shaderNeedsPipelineUpdate = false;
    }

    getPipelineObject(shader, mesh)
    {
        this.bindingGroupLayoutEntries = [];

        for (let i = 0; i < shader.bindingsVert.length; i++)
        {
            if (shader.bindingsVert[i].getSizeBytes() > 0)
            {
                this.bindingGroupLayoutEntries.push(shader.bindingsVert[i].getBindingGroupLayoutEntry());
            }
            else console.log("shader defaultBindingVert size 0");
        }

        for (let i = 0; i < shader.bindingsFrag.length; i++)
        {
            if (shader.bindingsFrag[i].getSizeBytes() > 0)
            {
                this.bindingGroupLayoutEntries.push(shader.bindingsFrag[i].getBindingGroupLayoutEntry());
            }
            else console.log("shader defaultBindingFrag size 0");
        }
        // //////////

        this.bindGroupLayout = this._cgp.device.createBindGroupLayout(
            {
                "label": "bg layout " + this._name,
                "entries": this.bindingGroupLayoutEntries,
            });

        const pipelineLayout = this._cgp.device.createPipelineLayout({
            "label": "pipe layout " + this._name,
            "bindGroupLayouts": [this.bindGroupLayout]
        });


        let buffers = [
            // position
            {
                "arrayStride": 3 * 4, // 3 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 0, "offset": 0, "format": "float32x3" },
                ],
            },
            // texcoords
            {
                "arrayStride": 2 * 4, // 2 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 2, "offset": 0, "format": "float32x2", },
                ],
            },
            // normals
            {
                "arrayStride": 3 * 4, // 3 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 1, "offset": 0, "format": "float32x3" },
                ],
            }];



        const pipeCfg = {
            // "layout": "auto",
            "label": this._name,
            "layout": pipelineLayout,
            "vertex": {
                "module": shader.gpuShaderModule,
                "entryPoint": "myVSMain",
                "buffers": buffers

            },
            "fragment": {
                "module": shader.gpuShaderModule,
                "entryPoint": "myFSMain",
                "targets": [
                    {
                        "format": this._cgp.presentationFormat,
                        "blend": this._cgp.stateBlend()
                    },
                ],
            },
            "primitive": {
                "topology": "triangle-list",
                "cullMode": this._cgp.stateCullFaceFacing(), // back/none/front

                // "point-list",
                // "line-list",
                // "line-strip",
                // "triangle-list",
                // "triangle-strip"
            },
            "depthStencil": {
                "depthWriteEnabled": this._cgp.stateDepthTest(),
                "depthCompare": this._cgp.stateDepthFunc(),
                "format": "depth24plus",
            },

        };

        return pipeCfg;
    }


    _bindUniforms(shader, inst)
    {
        // this._cgp.pushErrorScope("pipeline bind uniforms", { "logger": this._log });

        shader.bind();

        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("bind uniforms vert", ["num:" + shader.bindingsVert.length]);
        for (let i = 0; i < shader.bindingsVert.length; i++) shader.bindingsVert[i].update(this._cgp, inst);
        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();

        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("bind uniforms frag", ["num:" + shader.bindingsFrag.length]);
        for (let i = 0; i < shader.bindingsFrag.length; i++) shader.bindingsFrag[i].update(this._cgp, inst);
        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();



        // shader.defaultBindingVert.update(this._cgp);

        // this._cgp.popErrorScope((e) =>
        // {
        //     this._isValid = false;
        // });
    }
}

;// CONCATENATED MODULE: ./src/core/cgp/cgp_mesh.js



class cgp_mesh_Mesh
{
    constructor(_cgp, __geom)
    {
        this._log = new Logger("cgl_mesh");
        this._cgp = _cgp;
        this._geom = null;
        this.numIndex = 0;
        this.instances = 1;

        this._pipe = new Pipeline(this._cgp, "new mesh");
        this._numNonIndexed = 0;
        this._positionBuffer = null;
        this._bufVerticesIndizes = null;
        this._attributes = [];
        this._needsPipelineUpdate = false;

        if (__geom) this.setGeom(__geom);
    }

    _createBuffer(device, data, usage)
    {
        let bo = {
            "size": data.byteLength,
            "usage": usage,
            "mappedAtCreation": true,
        };
        // ifbo.stepMode = "instance";
        const buffer = device.createBuffer(bo);
        const dst = new data.constructor(buffer.getMappedRange());
        dst.set(data);
        buffer.unmap();
        return buffer;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom geometry
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef)
    {
        this._needsPipelineUpdate = true;
        this._geom = geom;
        this._disposeAttributes();

        this._positionBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

        let vi = geom.verticesIndices;
        if (!geom.isIndexed()) vi = Array.from(Array(geom.vertices.length / 3).keys());
        this._numIndices = vi.length;
        this._indicesBuffer = this._createBuffer(this._cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);

        if (geom.texCoords && geom.texCoords.length) this.setAttribute("texCoords", geom.texCoords, 2);
        if (geom.vertexNormals && geom.vertexNormals.length) this.setAttribute("normals", geom.vertexNormals, 3);

        this.setAttribute("normals", geom.vertexNormals, 3);
    }


    _disposeAttributes()
    {
        this._needsPipelineUpdate = true;
        for (let i = 0; i < this._attributes.length; i++)
        {
            this._attributes[i].buffer.destroy();
        }
        this._attributes.length = 0;
    }

    dispose()
    {
        this._disposeAttributes();
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name attribute name
     * @param {Array} array data
     * @param {Number} itemSize
     * @param {Object} options
     */
    setAttribute(name, array, itemSize, options = {})
    {
        if (!array)
        {
            this._log.error("mesh addAttribute - no array given! " + name);
            throw new Error();
        }

        let instanced = false;
        if (options.instanced) instanced = options.instanced;

        const buffer = this._createBuffer(this._cgp.device, new Float32Array(array), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

        const attr = {
            "buffer": buffer,
            "name": name,
            "instanced": instanced,
        };
        this._attributes.push(attr);

        return attr;
    }


    render()
    {
        if (!this._positionBuffer) return;
        if (this.instances <= 0) return;

        const shader = this._cgp.getShader();
        if (shader)shader.bind();

        if (!this._cgp.getShader() || !this._cgp.getShader().isValid)
        {
            // this.status = "shader invalid";
            return;
        }

        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.push("mesh", ["geom " + this._geom.name, "shader " + this._cgp.getShader().getName()]);

        this._pipe.setName("mesh " + this._geom.name + " " + this._cgp.getShader().getName());
        this._pipe.setPipeline(this._cgp.getShader(), this);


        if (this._pipe.isValid)
        {
            this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
            for (let i = 0; i < this._attributes.length; i++)
            {
                this._cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);
            }

            this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32");

            if (this._numNonIndexed)
                this._cgp.passEncoder.draw(this._numIndices, this.instances);
            else
                this._cgp.passEncoder.drawIndexed(this._numIndices, this.instances);
        }

        if (this._cgp.frameStore.branchProfiler) this._cgp.frameStore.branchStack.pop();

        // if (shader)shader.unbind();
    }
}

;// CONCATENATED MODULE: ./src/core/cgp/index.js










const cgp_CGP = {
    "Context": WebGpuContext,
    "Shader": cgp_shader_Shader,
    "Mesh": cgp_mesh_Mesh,
    "Pipeline": Pipeline,
    "Texture": cgp_texture_Texture,
    "Binding": Binding,
    "Uniform": cgp_uniform_Uniform,
    "MESHES": MESHES,
    "GPUBuffer": GPUBuffer
};

window.CABLES = window.CABLES || {};
window.CABLES.CGP = cgp_CGP;
window.CGP = cgp_CGP;




;// CONCATENATED MODULE: ./src/core/cgl/cgl_framebuffer.js



// todo: convert to prototyped...

/**
 * a framebuffer
 * @constructor
 * @class
 * @constructs Framebuffer
 * @param {Context} _cgl cgl
 * @param {Number} _w width
 * @param {Number} _h height
 * @param {Object} options
 */
const Framebuffer = function (_cgl, _w, _h, options)
{
    const cgl = _cgl;
    this._log = new Logger("Framebuffer");
    this.valid = true;

    let depthTextureExt = cgl.gl.DEPTH_TEXTURE;
    if (!depthTextureExt) depthTextureExt = cgl.enableExtension("WEBGL_depth_texture");
    if (!depthTextureExt) depthTextureExt = cgl.enableExtension("WEBKIT_WEBGL_depth_texture");
    if (!depthTextureExt) depthTextureExt = cgl.enableExtension("MOZ_WEBGL_depth_texture");

    if (!depthTextureExt)
    {
        this._log.error("NO_DEPTH_TEXTURE", "no depth texture support");
        return;
    }

    let width = _w || 512;
    let height = _h || 512;

    options = options || {
        "isFloatingPointTexture": false,
    };

    if (!options.hasOwnProperty("clear")) options.clear = true;
    if (!options.hasOwnProperty("filter")) options.filter = Texture.FILTER_LINEAR;

    const texture = new Texture(cgl, {
        "isFloatingPointTexture": options.isFloatingPointTexture,
        "filter": options.filter,
        "wrap": options.wrap || Texture.CLAMP_TO_EDGE
    });

    let textureDepth = null;
    if (depthTextureExt)
    {
        textureDepth = new Texture(cgl, {
            "isDepthTexture": true,
        });
    }
    this._options = options;

    const frameBuf = cgl.gl.createFramebuffer();
    const depthBuffer = cgl.gl.createRenderbuffer();

    this.getWidth = function ()
    {
        return width;
    };
    this.getHeight = function ()
    {
        return height;
    };

    /**
     * get native gl framebuffer
     * @function getGlFrameBuffer
     * @memberof Framebuffer
     * @returns {Object} framebuffer
     */
    this.getGlFrameBuffer = function ()
    {
        return frameBuf;
    };

    /**
     * get depth renderbuffer
     * @function getDepthRenderBuffer
     * @memberof Framebuffer
     * @returns {Object} renderbuffer
     */
    this.getDepthRenderBuffer = function ()
    {
        return depthBuffer;
    };

    /**
     * get color texture
     * @function getTextureColor
     * @memberof Framebuffer
     * @returns {Texture} rgba texture
     */
    this.getTextureColor = function ()
    {
        return texture;
    };

    /**
     * get depth texture
     * @function getTextureDepth
     * @memberof Framebuffer
     * @returns {Texture} depth texture
     */
    this.getTextureDepth = function ()
    {
        return textureDepth;
    };

    this.setFilter = function (f)
    {
        texture.filter = f;
        texture.setSize(width, height);
    };

    this.setSize = function (w, h)
    {
        if (w < 2) w = 2;
        if (h < 2) h = 2;

        width = Math.ceil(w);
        height = Math.ceil(h);

        cgl.profileData.profileFrameBuffercreate++;

        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, depthBuffer);

        texture.setSize(width, height);
        if (textureDepth) textureDepth.setSize(width, height);

        // if(depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width,height);
        if (depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width, height);

        cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, texture.tex, 0);

        if (depthTextureExt)
        {
            cgl.gl.framebufferRenderbuffer(cgl.gl.FRAMEBUFFER, cgl.gl.DEPTH_ATTACHMENT, cgl.gl.RENDERBUFFER, depthBuffer);
            cgl.gl.framebufferTexture2D(
                cgl.gl.FRAMEBUFFER,
                cgl.gl.DEPTH_ATTACHMENT, // safari needs DEPTH_ATTACHMENT NOT DEPTH_ATTACHMENT16
                // cgl.gl.DEPTH_COMPONENT16,
                cgl.gl.TEXTURE_2D,
                textureDepth.tex,
                0,
            );
        }

        if (!cgl.gl.isFramebuffer(frameBuf)) throw new Error("Invalid framebuffer");
        const status = cgl.gl.checkFramebufferStatus(cgl.gl.FRAMEBUFFER);

        switch (status)
        {
        case cgl.gl.FRAMEBUFFER_COMPLETE:
            break;
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", width, height, texture.tex, depthBuffer);
            this.valid = false;
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            this.valid = false;
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            this.valid = false;
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        case cgl.gl.FRAMEBUFFER_UNSUPPORTED:
            this._log.warn("FRAMEBUFFER_UNSUPPORTED");
            this.valid = false;
            this._log.warn(width, height, options);

            throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        case 0x8CDB:
            this._log.warn("Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour.");
            this.valid = false;
            break;
        default:
            this._log.warn("incomplete framebuffer", status);
            this.valid = false;
            throw new Error("Incomplete framebuffer: " + status);
        }

        cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);
        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);
        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);
    };

    this.renderStart = function ()
    {
        cgl.pushModelMatrix();
        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
        cgl.pushGlFrameBuffer(frameBuf);
        cgl.pushFrameBuffer(this);

        cgl.pushPMatrix();
        cgl.gl.viewport(0, 0, width, height);

        if (this._options.clear)
        {
            cgl.gl.clearColor(0, 0, 0, 0);
            cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
        }
    };

    this.renderEnd = function ()
    {
        cgl.popPMatrix();
        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());
        cgl.popFrameBuffer();

        cgl.popModelMatrix();
        cgl.resetViewPort();
    };


    this.delete = function ()
    {
        texture.delete();
        this.valid = false;
        if (textureDepth) textureDepth.delete();
        cgl.gl.deleteRenderbuffer(depthBuffer);
        cgl.gl.deleteFramebuffer(frameBuf);
    };

    this.dispose = this.delete;

    this.setSize(width, height);
};



;// CONCATENATED MODULE: ./src/core/cgl/cgl_framebuffer2.js
// * see framebuffer1






const Framebuffer2 = function (cgl, w, h, options)
{
    this._log = new Logger("cgl_framebuffer2");
    if (cgl.glVersion == 1) return this._log.error("framebuffer2 used on webgl1");
    this.Framebuffer2DrawTargetsDefault = null;
    this.Framebuffer2BlittingFramebuffer = null;
    this.Framebuffer2FinalFramebuffer = null;
    this._cgl = cgl;

    this._cgl.printError("before framebuffer2 constructor");

    this._width = 0;
    this._height = 0;
    this.valid = true;

    this._depthRenderbuffer = null;
    this._frameBuffer = null;
    this._textureFrameBuffer = null;
    this._colorRenderbuffers = [];
    this._drawTargetArray = [];
    this._disposed = false;

    if (!this.Framebuffer2BlittingFramebuffer) this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
    if (!this.Framebuffer2FinalFramebuffer) this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();

    if (!this.Framebuffer2DrawTargetsDefault) this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];

    this._options = options || {
        "isFloatingPointTexture": false,
    };

    // this._cgl.printError("fb2 before");

    this.name = this._options.name || "unknown";

    this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);

    if (!this._options.hasOwnProperty("numRenderBuffers")) this._options.numRenderBuffers = 1;
    if (!this._options.hasOwnProperty("depth")) this._options.depth = true;
    if (!this._options.hasOwnProperty("clear")) this._options.clear = true;
    if (!this._options.hasOwnProperty("multisampling"))
    {
        this._options.multisampling = false;
        this._options.multisamplingSamples = 0;
    }

    if (this._options.multisamplingSamples)
    {
        if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;
        if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;
        else this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);
    }

    if (!this._options.hasOwnProperty("filter")) this._options.filter = Texture.FILTER_LINEAR;
    if (!this._options.hasOwnProperty("wrap")) this._options.wrap = Texture.WRAP_REPEAT;

    this._numRenderBuffers = this._options.numRenderBuffers;
    this._colorTextures = [];

    this.clearColors = [];
    for (let i = 0; i < this._numRenderBuffers; i++) this.clearColors.push([0, 0, 0, 1]);


    if (!options.pixelFormat)
    {
        if (options.isFloatingPointTexture) this._options.pixelFormat = Texture.PFORMATSTR_RGBA32F;
        else this._options.pixelFormat = Texture.PFORMATSTR_RGBA8UB;
    }

    for (let i = 0; i < this._numRenderBuffers; i++)
    {
        this._colorTextures[i] = new Texture(cgl, {
            "name": "fb2 " + this.name + " " + i,
            "isFloatingPointTexture": this._options.isFloatingPointTexture,
            "anisotropic": this._options.anisotropic || 0,
            "pixelFormat": this._options.pixelFormat,
            "filter": this._options.filter,
            "wrap": this._options.wrap,
        });
    }



    let fil = Texture.FILTER_NEAREST;
    if (this._options.shadowMap) fil = Texture.FILTER_LINEAR;

    const defaultTexSize = 512;

    if (this._options.depth)
    {
        this._textureDepth = new Texture(cgl,
            {
                "name": "fb2 depth " + this.name,
                "isDepthTexture": true,
                "filter": fil,
                "shadowMap": this._options.shadowMap || false,
                "width": w || defaultTexSize,
                "height": h || defaultTexSize,
            });
    }

    if (cgl.aborted) return;

    this.setSize(w || defaultTexSize, h || defaultTexSize);

    this._cgl.printError("framebuffer2 constructor");
};

Framebuffer2.prototype.getWidth = function ()
{
    return this._width;
};
Framebuffer2.prototype.getHeight = function ()
{
    return this._height;
};

Framebuffer2.prototype.getGlFrameBuffer = function ()
{
    return this._frameBuffer;
};

Framebuffer2.prototype.getDepthRenderBuffer = function ()
{
    return this._depthRenderbuffer;
};

Framebuffer2.prototype.getTextureColor = function ()
{
    return this._colorTextures[0];
};

Framebuffer2.prototype.getTextureColorNum = function (i)
{
    return this._colorTextures[i];
};

Framebuffer2.prototype.getTextureDepth = function ()
{
    return this._textureDepth;
};

Framebuffer2.prototype.setFilter = function (f)
{
    for (let i = 0; i < this._numRenderBuffers; i++)
    {
        this._colorTextures[i].filter = f;
        this._colorTextures[i].setSize(this._width, this._height);
    }
};

Framebuffer2.prototype.delete = Framebuffer2.prototype.dispose = function ()
{
    this._disposed = true;
    let i = 0;
    for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].delete();
    // this._texture.delete();
    if (this._textureDepth) this._textureDepth.delete();
    for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
    this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuffer);
    this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
};

Framebuffer2.prototype.setSize = function (w, h)
{
    if (this._disposed) return this._log.warn("disposed framebuffer setsize...");
    this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);

    let i = 0;

    this._width = this._cgl.checkTextureSize(w);
    this._height = this._cgl.checkTextureSize(h);

    this._cgl.profileData.profileFrameBuffercreate++;

    if (this._frameBuffer)
    {
        for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
        // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);
        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuffer);
        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }

    this._frameBuffer = this._cgl.gl.createFramebuffer();
    this._textureFrameBuffer = this._cgl.gl.createFramebuffer();

    const depth = this._options.depth;

    for (i = 0; i < this._numRenderBuffers; i++)
    {
        this._colorTextures[i].setSize(this._width, this._height);
    }

    for (i = 0; i < this._numRenderBuffers; i++)
    {
        const renderBuffer = this._cgl.gl.createRenderbuffer();

        // color renderbuffer

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);

        const info = Texture.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);
        let internFormat = info.glInternalFormat;

        // if (this._options.isFloatingPointTexture)
        // {
        if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat))
        {
            if (!this._cgl.enableExtension("OES_texture_float_linear"))
            {
                this._options.filter = Texture.FILTER_NEAREST;
                this.setFilter(this._options.filter);
            }
        }
        else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat))
        {
            if (!this._cgl.enableExtension("OES_texture_float_linear"))
            {
                this._log.warn("no linear pixelformat,using nearest");
                this._options.filter = Texture.FILTER_NEAREST;
                this.setFilter(this._options.filter);
            }
        }
        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
        // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)
        // {
        //     const extcb = this._cgl.enableExtension("EXT_color_buffer_float");

        //     if (!this._cgl.enableExtension("OES_texture_float_linear"))
        //     {
        //         console.log("no linear pixelformat,switching to nearest");
        //         this._options.filter = Texture.FILTER_NEAREST;
        //         this.setFilter(this._options.filter);
        //     }
        // }
        // }

        if (this._options.multisampling && this._options.multisamplingSamples)
        {
            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);
        }
        else
        {
            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);
        }



        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);
        this._colorRenderbuffers[i] = renderBuffer;
    }

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

    for (i = 0; i < this._numRenderBuffers; i++)
    {
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
    }

    if (this._options.depth)
    {
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
    }

    // depth renderbuffer

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);


    let depthType = this._cgl.gl.DEPTH_COMPONENT32F;

    if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;
    if (depth)
    {
        this._textureDepth.setSize(this._width, this._height);
        this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();

        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
        if (this._options.isFloatingPointTexture)
        {
            if (this._options.multisampling) this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
            else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
        }
        else if (this._options.multisampling)
        {
            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
            // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);
        }
        else
        {
            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
        }

        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
    }

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

    this._drawTargetArray.length = 0;
    for (i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);


    if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer)) this._log.warn("invalid framebuffer");// throw new Error("Invalid framebuffer");
    const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);

    if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE)
    {
        this._log.error("framebuffer incomplete: " + this.name, this);
        this._log.log("options", this._options);
        this._log.log("options pixelformat", this._options.pixelFormat);

        switch (status)
        {
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
            this._log.warn("FRAMEBUFFER_UNSUPPORTED");
            throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        default:
            this.valid = false;
            this._log.error("incomplete framebuffer", status, this._frameBuffer);
            this._cgl.printError();

            this._frameBuffer = null;
            // debugger;
            throw new Error("Incomplete framebuffer: " + status);

        // throw("Incomplete framebuffer: " + status);
        }
    }

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);

    // this._cgl.printError("fb setsize");
};

Framebuffer2.prototype.renderStart = function ()
{
    if (this._disposed) return this._log.warn("disposed framebuffer renderStart...");
    this._cgl.checkFrameStarted("fb2 renderstart");
    this._cgl.pushModelMatrix(); // needed ??

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
    this._cgl.pushGlFrameBuffer(this._frameBuffer);
    this._cgl.pushFrameBuffer(this);

    this._cgl.pushPMatrix();
    this._cgl.pushViewPort(0, 0, this._width, this._height);

    this._cgl.gl.drawBuffers(this._drawTargetArray);

    if (this._options.clear)
    {
        this._cgl.gl.clearColor(0, 0, 0, 0);
        this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);
    }
};

Framebuffer2.prototype.clear = function ()
{
    if (this._numRenderBuffers <= 1)
    {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
    }
    else this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

    this._cgl.gl.drawBuffers(this._drawTargetArray);

    for (let i = 0; i < this._numRenderBuffers; i++)
    {
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
};

Framebuffer2.prototype.renderEnd = function ()
{
    if (this._disposed) return this._log.warn("disposed framebuffer renderEnd...");
    this._cgl.popPMatrix();

    this._cgl.profileData.profileFramebuffer++;


    if (this._numRenderBuffers <= 1)
    {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);

        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
        this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);
    }
    else
    {
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);

        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);


            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);

            // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);



            let flags = this._cgl.gl.COLOR_BUFFER_BIT;
            if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;

            this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);
        }
    }

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());
    this._cgl.popFrameBuffer();

    this._cgl.popModelMatrix();
    // this._cgl.resetViewPort();
    this._cgl.popViewPort();


    if (this._colorTextures[0].filter == Texture.FILTER_MIPMAP)
    {
        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);
            this._colorTextures[i].updateMipMap();
            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        }
    }
};



/// ///////

;// CONCATENATED MODULE: ./src/core/cgl/cgl_marker.js
const Marker = function (_cgl) // deprecated...
{
    this.draw = function (cgl, _size, depthTest) {};
};

const WirePoint = function (cgl) // deprecated...
{
    this.render = function (_cgl, _size) {};
};

const WireCube = function (cgl) // deprecated...
{
    this.render = function (_cgl, sizeX, sizeY, sizeZ) {};
};

;// CONCATENATED MODULE: ./src/core/cgl/cgl_unicolorshader.js


class UniColorShader
{
    constructor(_cgl)
    {
        this.shader = new CGL.Shader(_cgl, "markermaterial");

        const frag = ""
            .endl() + "void main()"
            .endl() + "{"
            .endl() + "    outColor = vec4(color.rgb,1.0);"
            .endl() + "}";


        const vert = ""
            .endl() + "IN vec3 vPosition;"
            .endl() + "UNI mat4 projMatrix;"
            .endl() + "UNI mat4 mvMatrix;"

            .endl() + "void main()"
            .endl() + "{"
            .endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);"
            .endl() + "}";

        this.shader.setSource(vert, frag);
        this.coloruni = this.shader.addUniformFrag("4f", "color", [1, 0.777, 1, 1]);
    }

    setColor(r, g, b, a)
    {
        this.coloruni.set(r, g, b, a);
    }
}

;// CONCATENATED MODULE: ./src/core/cgl/index.js






















const cgl_CGL = {
    "Framebuffer": Framebuffer,
    "Framebuffer2": Framebuffer2,
    "Geometry": Geometry,
    "BoundingBox": BoundingBox,
    "Marker": Marker,
    "WirePoint": WirePoint,
    "WireCube": WireCube,
    "MatrixStack": MatrixStack,
    "Mesh": Mesh,
    "MESH": MESH,
    "ShaderLibMods": ShaderLibMods,
    "Shader": Shader,
    "Uniform": Uniform,
    "MESHES": MESHES,
    "Context": Context,
    "Texture": Texture,
    "TextureEffect": TextureEffect,
    "isWindows": isWindows,
    "getWheelSpeed": getWheelSpeed,
    "getWheelDelta": getWheelDelta,
    "onLoadingAssetsFinished": onLoadingAssetsFinished,
    "ProfileData": ProfileData,
    "UniColorShader": UniColorShader,
    ...constants_CONSTANTS.BLEND_MODES,
    ...constants_CONSTANTS.SHADER,
    ...constants_CONSTANTS.MATH,
    ...constants_CONSTANTS.BLEND_MODES,
};

window.CGL = cgl_CGL;





;// CONCATENATED MODULE: ./src/core/index.js

















window.CABLES = window.CABLES || {};

CABLES.CGL = cgl_CGL;
CABLES.CG = CG;
CABLES.CGP = cgp_CGP;
CABLES.EMBED = EMBED;
CABLES.Link = Link;
CABLES.Port = Port;
CABLES.Op = Op;
CABLES.Profiler = Profiler;
CABLES.Patch = core_patch;
CABLES.Timer = Timer;
CABLES.WEBAUDIO = WEBAUDIO;
CABLES.Variable = Variable;
CABLES.LoadingStatus = LoadingStatus;
CABLES.now = now;
CABLES.internalNow = internalNow;



CABLES = Object.assign(CABLES,
    utils_namespaceObject,
    anim_namespaceObject,
    CONSTANTS.PORT,
    CONSTANTS.PACO,
    CONSTANTS.ANIM,
    CONSTANTS.OP
);

/* harmony default export */ const core = (CABLES);

if (!(function () { return !this; }())) console.warn("not in strict mode: index core"); // eslint-disable-line

CABLES = __webpack_exports__["default"];
/******/ })()
;


var CABLES = CABLES || {}; CABLES.build = {"timestamp":1736760273867,"created":"2025-01-13T09:24:33.867Z","git":{"branch":"master","commit":"0e07848fd62e35a0a77f09c4c90a3fcbd6cb9f8f","date":"1736756567","message":"canvasinfo"}};
(()=>{"use strict";var t={d:(n,a)=>{for(var r in a)t.o(a,r)&&!t.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:a[r]})},o:(t,n)=>Object.prototype.hasOwnProperty.call(t,n),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},n={};t.r(n),t.d(n,{ARRAY_TYPE:()=>f,EPSILON:()=>M,RANDOM:()=>l,equals:()=>d,setMatrixArrayType:()=>v,toRadian:()=>m});var a={};t.r(a),t.d(a,{LDU:()=>j,add:()=>z,adjoint:()=>S,clone:()=>y,copy:()=>p,create:()=>x,determinant:()=>R,equals:()=>Y,exactEquals:()=>Q,frob:()=>V,fromRotation:()=>D,fromScaling:()=>F,fromValues:()=>w,identity:()=>q,invert:()=>P,mul:()=>_,multiply:()=>T,multiplyScalar:()=>X,multiplyScalarAndAdd:()=>Z,rotate:()=>I,scale:()=>E,set:()=>g,str:()=>L,sub:()=>B,subtract:()=>O,transpose:()=>A});var r={};t.r(r),t.d(r,{add:()=>it,clone:()=>k,copy:()=>U,create:()=>N,determinant:()=>J,equals:()=>ft,exactEquals:()=>Mt,frob:()=>ot,fromRotation:()=>at,fromScaling:()=>rt,fromTranslation:()=>ut,fromValues:()=>C,identity:()=>W,invert:()=>H,mul:()=>lt,multiply:()=>K,multiplyScalar:()=>ct,multiplyScalarAndAdd:()=>st,rotate:()=>$,scale:()=>tt,set:()=>G,str:()=>et,sub:()=>vt,subtract:()=>ht,translate:()=>nt});var u={};t.r(u),t.d(u,{add:()=>Yt,adjoint:()=>At,clone:()=>dt,copy:()=>xt,create:()=>bt,determinant:()=>Pt,equals:()=>Nt,exactEquals:()=>Bt,frob:()=>Qt,fromMat2d:()=>Lt,fromMat4:()=>mt,fromQuat:()=>Vt,fromRotation:()=>Dt,fromScaling:()=>Ft,fromTranslation:()=>Et,fromValues:()=>yt,identity:()=>qt,invert:()=>gt,mul:()=>kt,multiply:()=>St,multiplyScalar:()=>Zt,multiplyScalarAndAdd:()=>_t,normalFromMat4:()=>jt,projection:()=>zt,rotate:()=>Tt,scale:()=>It,set:()=>pt,str:()=>Ot,sub:()=>Ut,subtract:()=>Xt,translate:()=>Rt,transpose:()=>wt});var e={};t.r(e),t.d(e,{add:()=>Ln,adjoint:()=>nn,clone:()=>Ct,copy:()=>Gt,create:()=>Wt,determinant:()=>an,equals:()=>Qn,exactEquals:()=>On,frob:()=>Fn,fromQuat:()=>An,fromQuat2:()=>xn,fromRotation:()=>ln,fromRotationTranslation:()=>dn,fromRotationTranslationScale:()=>wn,fromRotationTranslationScaleOrigin:()=>gn,fromScaling:()=>fn,fromTranslation:()=>Mn,fromValues:()=>Ht,fromXRotation:()=>vn,fromYRotation:()=>bn,fromZRotation:()=>mn,frustum:()=>Pn,getRotation:()=>qn,getScaling:()=>pn,getTranslation:()=>yn,identity:()=>Kt,invert:()=>tn,lookAt:()=>In,mul:()=>Yn,multiply:()=>rn,multiplyScalar:()=>jn,multiplyScalarAndAdd:()=>zn,ortho:()=>Tn,perspective:()=>Sn,perspectiveFromFieldOfView:()=>Rn,rotate:()=>on,rotateX:()=>hn,rotateY:()=>cn,rotateZ:()=>sn,scale:()=>en,set:()=>Jt,str:()=>Dn,sub:()=>Xn,subtract:()=>Vn,targetTo:()=>En,translate:()=>un,transpose:()=>$t});var o={};t.r(o),t.d(o,{add:()=>Wn,angle:()=>wa,bezier:()=>va,ceil:()=>Jn,clone:()=>_n,copy:()=>kn,create:()=>Zn,cross:()=>Ma,dist:()=>Da,distance:()=>ua,div:()=>Ea,divide:()=>Hn,dot:()=>sa,equals:()=>Sa,exactEquals:()=>Pa,floor:()=>Kn,forEach:()=>ja,fromValues:()=>Nn,hermite:()=>la,inverse:()=>ha,len:()=>La,length:()=>Bn,lerp:()=>fa,max:()=>ta,min:()=>$n,mul:()=>Ia,multiply:()=>Gn,negate:()=>ia,normalize:()=>ca,random:()=>ba,rotateX:()=>ya,rotateY:()=>pa,rotateZ:()=>qa,round:()=>na,scale:()=>aa,scaleAndAdd:()=>ra,set:()=>Un,sqrDist:()=>Fa,sqrLen:()=>Va,squaredDistance:()=>ea,squaredLength:()=>oa,str:()=>Aa,sub:()=>Ta,subtract:()=>Cn,transformMat3:()=>da,transformMat4:()=>ma,transformQuat:()=>xa,zero:()=>ga});var i={};t.r(i),t.d(i,{add:()=>Za,ceil:()=>ka,clone:()=>Oa,copy:()=>Ya,create:()=>za,cross:()=>or,dist:()=>xr,distance:()=>Ka,div:()=>dr,divide:()=>Na,dot:()=>er,equals:()=>vr,exactEquals:()=>lr,floor:()=>Ua,forEach:()=>wr,fromValues:()=>Qa,inverse:()=>rr,len:()=>pr,length:()=>tr,lerp:()=>ir,max:()=>Ca,min:()=>Wa,mul:()=>mr,multiply:()=>Ba,negate:()=>ar,normalize:()=>ur,random:()=>hr,round:()=>Ga,scale:()=>Ha,scaleAndAdd:()=>Ja,set:()=>Xa,sqrDist:()=>yr,sqrLen:()=>qr,squaredDistance:()=>$a,squaredLength:()=>nr,str:()=>fr,sub:()=>br,subtract:()=>_a,transformMat4:()=>cr,transformQuat:()=>sr,zero:()=>Mr});var h={};t.r(h),t.d(h,{add:()=>$r,calculateW:()=>Fr,clone:()=>Gr,conjugate:()=>Yr,copy:()=>Jr,create:()=>gr,dot:()=>au,equals:()=>su,exactEquals:()=>cu,exp:()=>Lr,fromEuler:()=>Zr,fromMat3:()=>Xr,fromValues:()=>Hr,getAngle:()=>Rr,getAxisAngle:()=>Sr,identity:()=>Ar,invert:()=>Qr,len:()=>eu,length:()=>uu,lerp:()=>ru,ln:()=>Vr,mul:()=>tu,multiply:()=>Tr,normalize:()=>hu,pow:()=>jr,random:()=>Or,rotateX:()=>Ir,rotateY:()=>Er,rotateZ:()=>Dr,rotationTo:()=>Mu,scale:()=>nu,set:()=>Kr,setAxes:()=>lu,setAxisAngle:()=>Pr,slerp:()=>zr,sqlerp:()=>fu,sqrLen:()=>iu,squaredLength:()=>ou,str:()=>_r});var c={};t.r(c),t.d(c,{add:()=>Ou,clone:()=>bu,conjugate:()=>Nu,copy:()=>wu,create:()=>vu,dot:()=>Zu,equals:()=>Ku,exactEquals:()=>Ju,fromMat4:()=>qu,fromRotation:()=>pu,fromRotationTranslation:()=>xu,fromRotationTranslationValues:()=>du,fromTranslation:()=>yu,fromValues:()=>mu,getDual:()=>Su,getReal:()=>Pu,getTranslation:()=>Iu,identity:()=>gu,invert:()=>Bu,len:()=>Uu,length:()=>ku,lerp:()=>_u,mul:()=>Yu,multiply:()=>Qu,normalize:()=>Gu,rotateAroundAxis:()=>zu,rotateByQuatAppend:()=>Vu,rotateByQuatPrepend:()=>ju,rotateX:()=>Du,rotateY:()=>Fu,rotateZ:()=>Lu,scale:()=>Xu,set:()=>Au,setDual:()=>Tu,setReal:()=>Ru,sqrLen:()=>Cu,squaredLength:()=>Wu,str:()=>Hu,translate:()=>Eu});var s={};t.r(s),t.d(s,{add:()=>ue,angle:()=>De,ceil:()=>he,clone:()=>te,copy:()=>ae,create:()=>$u,cross:()=>ge,dist:()=>Xe,distance:()=>be,div:()=>Ye,divide:()=>ie,dot:()=>we,equals:()=>je,exactEquals:()=>Ve,floor:()=>ce,forEach:()=>Be,fromValues:()=>ne,inverse:()=>pe,len:()=>ze,length:()=>de,lerp:()=>Ae,max:()=>Me,min:()=>se,mul:()=>Qe,multiply:()=>oe,negate:()=>ye,normalize:()=>qe,random:()=>Pe,rotate:()=>Ee,round:()=>fe,scale:()=>le,scaleAndAdd:()=>ve,set:()=>re,sqrDist:()=>Ze,sqrLen:()=>_e,squaredDistance:()=>me,squaredLength:()=>xe,str:()=>Le,sub:()=>Oe,subtract:()=>ee,transformMat2:()=>Se,transformMat2d:()=>Re,transformMat3:()=>Te,transformMat4:()=>Ie,zero:()=>Fe});var M=1e-6,f="undefined"!=typeof Float32Array?Float32Array:Array,l=Math.random;function v(t){f=t}var b=Math.PI/180;function m(t){return t*b}function d(t,n){return Math.abs(t-n)<=M*Math.max(1,Math.abs(t),Math.abs(n))}function x(){var t=new f(4);return f!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t}function y(t){var n=new f(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function p(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function q(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function w(t,n,a,r){var u=new f(4);return u[0]=t,u[1]=n,u[2]=a,u[3]=r,u}function g(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t}function A(t,n){if(t===n){var a=n[1];t[1]=n[2],t[2]=a}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t}function P(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*e-u*r;return o?(o=1/o,t[0]=e*o,t[1]=-r*o,t[2]=-u*o,t[3]=a*o,t):null}function S(t,n){var a=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=a,t}function R(t){return t[0]*t[3]-t[2]*t[1]}function T(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],h=a[1],c=a[2],s=a[3];return t[0]=r*i+e*h,t[1]=u*i+o*h,t[2]=r*c+e*s,t[3]=u*c+o*s,t}function I(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),h=Math.cos(a);return t[0]=r*h+e*i,t[1]=u*h+o*i,t[2]=r*-i+e*h,t[3]=u*-i+o*h,t}function E(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],h=a[1];return t[0]=r*i,t[1]=u*i,t[2]=e*h,t[3]=o*h,t}function D(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t}function F(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t}function L(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function V(t){return Math.hypot(t[0],t[1],t[2],t[3])}function j(t,n,a,r){return t[2]=r[2]/r[0],a[0]=r[0],a[1]=r[1],a[3]=r[3]-t[2]*a[1],[t,n,a]}function z(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t}function O(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}function Q(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function Y(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=n[0],i=n[1],h=n[2],c=n[3];return Math.abs(a-o)<=M*Math.max(1,Math.abs(a),Math.abs(o))&&Math.abs(r-i)<=M*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-h)<=M*Math.max(1,Math.abs(u),Math.abs(h))&&Math.abs(e-c)<=M*Math.max(1,Math.abs(e),Math.abs(c))}function X(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t}function Z(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t}Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var _=T,B=O;function N(){var t=new f(6);return f!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t}function k(t){var n=new f(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n}function U(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t}function W(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function C(t,n,a,r,u,e){var o=new f(6);return o[0]=t,o[1]=n,o[2]=a,o[3]=r,o[4]=u,o[5]=e,o}function G(t,n,a,r,u,e,o){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t}function H(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=a*e-r*u;return h?(h=1/h,t[0]=e*h,t[1]=-r*h,t[2]=-u*h,t[3]=a*h,t[4]=(u*i-e*o)*h,t[5]=(r*o-a*i)*h,t):null}function J(t){return t[0]*t[3]-t[1]*t[2]}function K(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=a[0],s=a[1],M=a[2],f=a[3],l=a[4],v=a[5];return t[0]=r*c+e*s,t[1]=u*c+o*s,t[2]=r*M+e*f,t[3]=u*M+o*f,t[4]=r*l+e*v+i,t[5]=u*l+o*v+h,t}function $(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=Math.sin(a),s=Math.cos(a);return t[0]=r*s+e*c,t[1]=u*s+o*c,t[2]=r*-c+e*s,t[3]=u*-c+o*s,t[4]=i,t[5]=h,t}function tt(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=a[0],s=a[1];return t[0]=r*c,t[1]=u*c,t[2]=e*s,t[3]=o*s,t[4]=i,t[5]=h,t}function nt(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=a[0],s=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=r*c+e*s+i,t[5]=u*c+o*s+h,t}function at(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t[4]=0,t[5]=0,t}function rt(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t}function ut(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t}function et(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"}function ot(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],1)}function it(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t}function ht(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t}function ct(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t}function st(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t}function Mt(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]}function ft(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=t[4],i=t[5],h=n[0],c=n[1],s=n[2],f=n[3],l=n[4],v=n[5];return Math.abs(a-h)<=M*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(r-c)<=M*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(u-s)<=M*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(e-f)<=M*Math.max(1,Math.abs(e),Math.abs(f))&&Math.abs(o-l)<=M*Math.max(1,Math.abs(o),Math.abs(l))&&Math.abs(i-v)<=M*Math.max(1,Math.abs(i),Math.abs(v))}var lt=K,vt=ht;function bt(){var t=new f(9);return f!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function mt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t}function dt(t){var n=new f(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n}function xt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function yt(t,n,a,r,u,e,o,i,h){var c=new f(9);return c[0]=t,c[1]=n,c[2]=a,c[3]=r,c[4]=u,c[5]=e,c[6]=o,c[7]=i,c[8]=h,c}function pt(t,n,a,r,u,e,o,i,h,c){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=h,t[8]=c,t}function qt(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function wt(t,n){if(t===n){var a=n[1],r=n[2],u=n[5];t[1]=n[3],t[2]=n[6],t[3]=a,t[5]=n[7],t[6]=r,t[7]=u}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t}function gt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=n[6],c=n[7],s=n[8],M=s*o-i*c,f=-s*e+i*h,l=c*e-o*h,v=a*M+r*f+u*l;return v?(v=1/v,t[0]=M*v,t[1]=(-s*r+u*c)*v,t[2]=(i*r-u*o)*v,t[3]=f*v,t[4]=(s*a-u*h)*v,t[5]=(-i*a+u*e)*v,t[6]=l*v,t[7]=(-c*a+r*h)*v,t[8]=(o*a-r*e)*v,t):null}function At(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=n[6],c=n[7],s=n[8];return t[0]=o*s-i*c,t[1]=u*c-r*s,t[2]=r*i-u*o,t[3]=i*h-e*s,t[4]=a*s-u*h,t[5]=u*e-a*i,t[6]=e*c-o*h,t[7]=r*h-a*c,t[8]=a*o-r*e,t}function Pt(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],h=t[7],c=t[8];return n*(c*e-o*h)+a*(-c*u+o*i)+r*(h*u-e*i)}function St(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=n[8],f=a[0],l=a[1],v=a[2],b=a[3],m=a[4],d=a[5],x=a[6],y=a[7],p=a[8];return t[0]=f*r+l*o+v*c,t[1]=f*u+l*i+v*s,t[2]=f*e+l*h+v*M,t[3]=b*r+m*o+d*c,t[4]=b*u+m*i+d*s,t[5]=b*e+m*h+d*M,t[6]=x*r+y*o+p*c,t[7]=x*u+y*i+p*s,t[8]=x*e+y*h+p*M,t}function Rt(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=n[8],f=a[0],l=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=h,t[6]=f*r+l*o+c,t[7]=f*u+l*i+s,t[8]=f*e+l*h+M,t}function Tt(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=n[8],f=Math.sin(a),l=Math.cos(a);return t[0]=l*r+f*o,t[1]=l*u+f*i,t[2]=l*e+f*h,t[3]=l*o-f*r,t[4]=l*i-f*u,t[5]=l*h-f*e,t[6]=c,t[7]=s,t[8]=M,t}function It(t,n,a){var r=a[0],u=a[1];return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=u*n[3],t[4]=u*n[4],t[5]=u*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t}function Et(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t}function Dt(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=-a,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function Ft(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function Lt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t}function Vt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,h=u+u,c=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*h,b=e*o,m=e*i,d=e*h;return t[0]=1-M-v,t[3]=s-d,t[6]=f+m,t[1]=s+d,t[4]=1-c-v,t[7]=l-b,t[2]=f-m,t[5]=l+b,t[8]=1-c-M,t}function jt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=n[6],c=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,y=a*h-u*o,p=a*c-e*o,q=r*h-u*i,w=r*c-e*i,g=u*c-e*h,A=s*b-M*v,P=s*m-f*v,S=s*d-l*v,R=M*m-f*b,T=M*d-l*b,I=f*d-l*m,E=x*I-y*T+p*R+q*S-w*P+g*A;return E?(E=1/E,t[0]=(i*I-h*T+c*R)*E,t[1]=(h*S-o*I-c*P)*E,t[2]=(o*T-i*S+c*A)*E,t[3]=(u*T-r*I-e*R)*E,t[4]=(a*I-u*S+e*P)*E,t[5]=(r*S-a*T-e*A)*E,t[6]=(b*g-m*w+d*q)*E,t[7]=(m*p-v*g-d*y)*E,t[8]=(v*w-b*p+d*x)*E,t):null}function zt(t,n,a){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/a,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}function Ot(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"}function Qt(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])}function Yt(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t}function Xt(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t}function Zt(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t}function _t(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t}function Bt(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]}function Nt(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=t[4],i=t[5],h=t[6],c=t[7],s=t[8],f=n[0],l=n[1],v=n[2],b=n[3],m=n[4],d=n[5],x=n[6],y=n[7],p=n[8];return Math.abs(a-f)<=M*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(r-l)<=M*Math.max(1,Math.abs(r),Math.abs(l))&&Math.abs(u-v)<=M*Math.max(1,Math.abs(u),Math.abs(v))&&Math.abs(e-b)<=M*Math.max(1,Math.abs(e),Math.abs(b))&&Math.abs(o-m)<=M*Math.max(1,Math.abs(o),Math.abs(m))&&Math.abs(i-d)<=M*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(h-x)<=M*Math.max(1,Math.abs(h),Math.abs(x))&&Math.abs(c-y)<=M*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(s-p)<=M*Math.max(1,Math.abs(s),Math.abs(p))}var kt=St,Ut=Xt;function Wt(){var t=new f(16);return f!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function Ct(t){var n=new f(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function Gt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function Ht(t,n,a,r,u,e,o,i,h,c,s,M,l,v,b,m){var d=new f(16);return d[0]=t,d[1]=n,d[2]=a,d[3]=r,d[4]=u,d[5]=e,d[6]=o,d[7]=i,d[8]=h,d[9]=c,d[10]=s,d[11]=M,d[12]=l,d[13]=v,d[14]=b,d[15]=m,d}function Jt(t,n,a,r,u,e,o,i,h,c,s,M,f,l,v,b,m){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=h,t[8]=c,t[9]=s,t[10]=M,t[11]=f,t[12]=l,t[13]=v,t[14]=b,t[15]=m,t}function Kt(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function $t(t,n){if(t===n){var a=n[1],r=n[2],u=n[3],e=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=a,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=e,t[11]=n[14],t[12]=u,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t}function tn(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=n[6],c=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,y=a*h-u*o,p=a*c-e*o,q=r*h-u*i,w=r*c-e*i,g=u*c-e*h,A=s*b-M*v,P=s*m-f*v,S=s*d-l*v,R=M*m-f*b,T=M*d-l*b,I=f*d-l*m,E=x*I-y*T+p*R+q*S-w*P+g*A;return E?(E=1/E,t[0]=(i*I-h*T+c*R)*E,t[1]=(u*T-r*I-e*R)*E,t[2]=(b*g-m*w+d*q)*E,t[3]=(f*w-M*g-l*q)*E,t[4]=(h*S-o*I-c*P)*E,t[5]=(a*I-u*S+e*P)*E,t[6]=(m*p-v*g-d*y)*E,t[7]=(s*g-f*p+l*y)*E,t[8]=(o*T-i*S+c*A)*E,t[9]=(r*S-a*T-e*A)*E,t[10]=(v*w-b*p+d*x)*E,t[11]=(M*p-s*w-l*x)*E,t[12]=(i*P-o*R-h*A)*E,t[13]=(a*R-r*P+u*A)*E,t[14]=(b*y-v*q-m*x)*E,t[15]=(s*q-M*y+f*x)*E,t):null}function nn(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],h=n[6],c=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15];return t[0]=i*(f*d-l*m)-M*(h*d-c*m)+b*(h*l-c*f),t[1]=-(r*(f*d-l*m)-M*(u*d-e*m)+b*(u*l-e*f)),t[2]=r*(h*d-c*m)-i*(u*d-e*m)+b*(u*c-e*h),t[3]=-(r*(h*l-c*f)-i*(u*l-e*f)+M*(u*c-e*h)),t[4]=-(o*(f*d-l*m)-s*(h*d-c*m)+v*(h*l-c*f)),t[5]=a*(f*d-l*m)-s*(u*d-e*m)+v*(u*l-e*f),t[6]=-(a*(h*d-c*m)-o*(u*d-e*m)+v*(u*c-e*h)),t[7]=a*(h*l-c*f)-o*(u*l-e*f)+s*(u*c-e*h),t[8]=o*(M*d-l*b)-s*(i*d-c*b)+v*(i*l-c*M),t[9]=-(a*(M*d-l*b)-s*(r*d-e*b)+v*(r*l-e*M)),t[10]=a*(i*d-c*b)-o*(r*d-e*b)+v*(r*c-e*i),t[11]=-(a*(i*l-c*M)-o*(r*l-e*M)+s*(r*c-e*i)),t[12]=-(o*(M*m-f*b)-s*(i*m-h*b)+v*(i*f-h*M)),t[13]=a*(M*m-f*b)-s*(r*m-u*b)+v*(r*f-u*M),t[14]=-(a*(i*m-h*b)-o*(r*m-u*b)+v*(r*h-u*i)),t[15]=a*(i*f-h*M)-o*(r*f-u*M)+s*(r*h-u*i),t}function an(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],h=t[7],c=t[8],s=t[9],M=t[10],f=t[11],l=t[12],v=t[13],b=t[14],m=t[15];return(n*o-a*e)*(M*m-f*b)-(n*i-r*e)*(s*m-f*v)+(n*h-u*e)*(s*b-M*v)+(a*i-r*o)*(c*m-f*l)-(a*h-u*o)*(c*b-M*l)+(r*h-u*i)*(c*v-s*l)}function rn(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],b=n[12],m=n[13],d=n[14],x=n[15],y=a[0],p=a[1],q=a[2],w=a[3];return t[0]=y*r+p*i+q*M+w*b,t[1]=y*u+p*h+q*f+w*m,t[2]=y*e+p*c+q*l+w*d,t[3]=y*o+p*s+q*v+w*x,y=a[4],p=a[5],q=a[6],w=a[7],t[4]=y*r+p*i+q*M+w*b,t[5]=y*u+p*h+q*f+w*m,t[6]=y*e+p*c+q*l+w*d,t[7]=y*o+p*s+q*v+w*x,y=a[8],p=a[9],q=a[10],w=a[11],t[8]=y*r+p*i+q*M+w*b,t[9]=y*u+p*h+q*f+w*m,t[10]=y*e+p*c+q*l+w*d,t[11]=y*o+p*s+q*v+w*x,y=a[12],p=a[13],q=a[14],w=a[15],t[12]=y*r+p*i+q*M+w*b,t[13]=y*u+p*h+q*f+w*m,t[14]=y*e+p*c+q*l+w*d,t[15]=y*o+p*s+q*v+w*x,t}function un(t,n,a){var r,u,e,o,i,h,c,s,M,f,l,v,b=a[0],m=a[1],d=a[2];return n===t?(t[12]=n[0]*b+n[4]*m+n[8]*d+n[12],t[13]=n[1]*b+n[5]*m+n[9]*d+n[13],t[14]=n[2]*b+n[6]*m+n[10]*d+n[14],t[15]=n[3]*b+n[7]*m+n[11]*d+n[15]):(r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=h,t[6]=c,t[7]=s,t[8]=M,t[9]=f,t[10]=l,t[11]=v,t[12]=r*b+i*m+M*d+n[12],t[13]=u*b+h*m+f*d+n[13],t[14]=e*b+c*m+l*d+n[14],t[15]=o*b+s*m+v*d+n[15]),t}function en(t,n,a){var r=a[0],u=a[1],e=a[2];return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*u,t[5]=n[5]*u,t[6]=n[6]*u,t[7]=n[7]*u,t[8]=n[8]*e,t[9]=n[9]*e,t[10]=n[10]*e,t[11]=n[11]*e,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t}function on(t,n,a,r){var u,e,o,i,h,c,s,f,l,v,b,m,d,x,y,p,q,w,g,A,P,S,R,T,I=r[0],E=r[1],D=r[2],F=Math.hypot(I,E,D);return F<M?null:(I*=F=1/F,E*=F,D*=F,u=Math.sin(a),o=1-(e=Math.cos(a)),i=n[0],h=n[1],c=n[2],s=n[3],f=n[4],l=n[5],v=n[6],b=n[7],m=n[8],d=n[9],x=n[10],y=n[11],p=I*I*o+e,q=E*I*o+D*u,w=D*I*o-E*u,g=I*E*o-D*u,A=E*E*o+e,P=D*E*o+I*u,S=I*D*o+E*u,R=E*D*o-I*u,T=D*D*o+e,t[0]=i*p+f*q+m*w,t[1]=h*p+l*q+d*w,t[2]=c*p+v*q+x*w,t[3]=s*p+b*q+y*w,t[4]=i*g+f*A+m*P,t[5]=h*g+l*A+d*P,t[6]=c*g+v*A+x*P,t[7]=s*g+b*A+y*P,t[8]=i*S+f*R+m*T,t[9]=h*S+l*R+d*T,t[10]=c*S+v*R+x*T,t[11]=s*S+b*R+y*T,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t)}function hn(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[4],o=n[5],i=n[6],h=n[7],c=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=e*u+c*r,t[5]=o*u+s*r,t[6]=i*u+M*r,t[7]=h*u+f*r,t[8]=c*u-e*r,t[9]=s*u-o*r,t[10]=M*u-i*r,t[11]=f*u-h*r,t}function cn(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],h=n[3],c=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u-c*r,t[1]=o*u-s*r,t[2]=i*u-M*r,t[3]=h*u-f*r,t[8]=e*r+c*u,t[9]=o*r+s*u,t[10]=i*r+M*u,t[11]=h*r+f*u,t}function sn(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],h=n[3],c=n[4],s=n[5],M=n[6],f=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u+c*r,t[1]=o*u+s*r,t[2]=i*u+M*r,t[3]=h*u+f*r,t[4]=c*u-e*r,t[5]=s*u-o*r,t[6]=M*u-i*r,t[7]=f*u-h*r,t}function Mn(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}function fn(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function ln(t,n,a){var r,u,e,o=a[0],i=a[1],h=a[2],c=Math.hypot(o,i,h);return c<M?null:(o*=c=1/c,i*=c,h*=c,r=Math.sin(n),e=1-(u=Math.cos(n)),t[0]=o*o*e+u,t[1]=i*o*e+h*r,t[2]=h*o*e-i*r,t[3]=0,t[4]=o*i*e-h*r,t[5]=i*i*e+u,t[6]=h*i*e+o*r,t[7]=0,t[8]=o*h*e+i*r,t[9]=i*h*e-o*r,t[10]=h*h*e+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function vn(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=a,t[7]=0,t[8]=0,t[9]=-a,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function bn(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=0,t[2]=-a,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=a,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function mn(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=0,t[4]=-a,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function dn(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=r+r,h=u+u,c=e+e,s=r*i,M=r*h,f=r*c,l=u*h,v=u*c,b=e*c,m=o*i,d=o*h,x=o*c;return t[0]=1-(l+b),t[1]=M+x,t[2]=f-d,t[3]=0,t[4]=M-x,t[5]=1-(s+b),t[6]=v+m,t[7]=0,t[8]=f+d,t[9]=v-m,t[10]=1-(s+l),t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t}function xn(t,n){var a=new f(3),r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=r*r+u*u+e*e+o*o;return M>0?(a[0]=2*(i*o+s*r+h*e-c*u)/M,a[1]=2*(h*o+s*u+c*r-i*e)/M,a[2]=2*(c*o+s*e+i*u-h*r)/M):(a[0]=2*(i*o+s*r+h*e-c*u),a[1]=2*(h*o+s*u+c*r-i*e),a[2]=2*(c*o+s*e+i*u-h*r)),dn(t,n,a),t}function yn(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function pn(t,n){var a=n[0],r=n[1],u=n[2],e=n[4],o=n[5],i=n[6],h=n[8],c=n[9],s=n[10];return t[0]=Math.hypot(a,r,u),t[1]=Math.hypot(e,o,i),t[2]=Math.hypot(h,c,s),t}function qn(t,n){var a=new f(3);pn(a,n);var r=1/a[0],u=1/a[1],e=1/a[2],o=n[0]*r,i=n[1]*u,h=n[2]*e,c=n[4]*r,s=n[5]*u,M=n[6]*e,l=n[8]*r,v=n[9]*u,b=n[10]*e,m=o+s+b,d=0;return m>0?(d=2*Math.sqrt(m+1),t[3]=.25*d,t[0]=(M-v)/d,t[1]=(l-h)/d,t[2]=(i-c)/d):o>s&&o>b?(d=2*Math.sqrt(1+o-s-b),t[3]=(M-v)/d,t[0]=.25*d,t[1]=(i+c)/d,t[2]=(l+h)/d):s>b?(d=2*Math.sqrt(1+s-o-b),t[3]=(l-h)/d,t[0]=(i+c)/d,t[1]=.25*d,t[2]=(M+v)/d):(d=2*Math.sqrt(1+b-o-s),t[3]=(i-c)/d,t[0]=(l+h)/d,t[1]=(M+v)/d,t[2]=.25*d),t}function wn(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3],h=u+u,c=e+e,s=o+o,M=u*h,f=u*c,l=u*s,v=e*c,b=e*s,m=o*s,d=i*h,x=i*c,y=i*s,p=r[0],q=r[1],w=r[2];return t[0]=(1-(v+m))*p,t[1]=(f+y)*p,t[2]=(l-x)*p,t[3]=0,t[4]=(f-y)*q,t[5]=(1-(M+m))*q,t[6]=(b+d)*q,t[7]=0,t[8]=(l+x)*w,t[9]=(b-d)*w,t[10]=(1-(M+v))*w,t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t}function gn(t,n,a,r,u){var e=n[0],o=n[1],i=n[2],h=n[3],c=e+e,s=o+o,M=i+i,f=e*c,l=e*s,v=e*M,b=o*s,m=o*M,d=i*M,x=h*c,y=h*s,p=h*M,q=r[0],w=r[1],g=r[2],A=u[0],P=u[1],S=u[2],R=(1-(b+d))*q,T=(l+p)*q,I=(v-y)*q,E=(l-p)*w,D=(1-(f+d))*w,F=(m+x)*w,L=(v+y)*g,V=(m-x)*g,j=(1-(f+b))*g;return t[0]=R,t[1]=T,t[2]=I,t[3]=0,t[4]=E,t[5]=D,t[6]=F,t[7]=0,t[8]=L,t[9]=V,t[10]=j,t[11]=0,t[12]=a[0]+A-(R*A+E*P+L*S),t[13]=a[1]+P-(T*A+D*P+V*S),t[14]=a[2]+S-(I*A+F*P+j*S),t[15]=1,t}function An(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,h=u+u,c=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*h,b=e*o,m=e*i,d=e*h;return t[0]=1-M-v,t[1]=s+d,t[2]=f-m,t[3]=0,t[4]=s-d,t[5]=1-c-v,t[6]=l+b,t[7]=0,t[8]=f+m,t[9]=l-b,t[10]=1-c-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Pn(t,n,a,r,u,e,o){var i=1/(a-n),h=1/(u-r),c=1/(e-o);return t[0]=2*e*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*e*h,t[6]=0,t[7]=0,t[8]=(a+n)*i,t[9]=(u+r)*h,t[10]=(o+e)*c,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*e*2*c,t[15]=0,t}function Sn(t,n,a,r,u){var e,o=1/Math.tan(n/2);return t[0]=o/a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=u&&u!==1/0?(e=1/(r-u),t[10]=(u+r)*e,t[14]=2*u*r*e):(t[10]=-1,t[14]=-2*r),t}function Rn(t,n,a,r){var u=Math.tan(n.upDegrees*Math.PI/180),e=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),h=2/(o+i),c=2/(u+e);return t[0]=h,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=-(o-i)*h*.5,t[9]=(u-e)*c*.5,t[10]=r/(a-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*a/(a-r),t[15]=0,t}function Tn(t,n,a,r,u,e,o){var i=1/(n-a),h=1/(r-u),c=1/(e-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(n+a)*i,t[13]=(u+r)*h,t[14]=(o+e)*c,t[15]=1,t}function In(t,n,a,r){var u,e,o,i,h,c,s,f,l,v,b=n[0],m=n[1],d=n[2],x=r[0],y=r[1],p=r[2],q=a[0],w=a[1],g=a[2];return Math.abs(b-q)<M&&Math.abs(m-w)<M&&Math.abs(d-g)<M?Kt(t):(s=b-q,f=m-w,l=d-g,u=y*(l*=v=1/Math.hypot(s,f,l))-p*(f*=v),e=p*(s*=v)-x*l,o=x*f-y*s,(v=Math.hypot(u,e,o))?(u*=v=1/v,e*=v,o*=v):(u=0,e=0,o=0),i=f*o-l*e,h=l*u-s*o,c=s*e-f*u,(v=Math.hypot(i,h,c))?(i*=v=1/v,h*=v,c*=v):(i=0,h=0,c=0),t[0]=u,t[1]=i,t[2]=s,t[3]=0,t[4]=e,t[5]=h,t[6]=f,t[7]=0,t[8]=o,t[9]=c,t[10]=l,t[11]=0,t[12]=-(u*b+e*m+o*d),t[13]=-(i*b+h*m+c*d),t[14]=-(s*b+f*m+l*d),t[15]=1,t)}function En(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=r[0],h=r[1],c=r[2],s=u-a[0],M=e-a[1],f=o-a[2],l=s*s+M*M+f*f;l>0&&(s*=l=1/Math.sqrt(l),M*=l,f*=l);var v=h*f-c*M,b=c*s-i*f,m=i*M-h*s;return(l=v*v+b*b+m*m)>0&&(v*=l=1/Math.sqrt(l),b*=l,m*=l),t[0]=v,t[1]=b,t[2]=m,t[3]=0,t[4]=M*m-f*b,t[5]=f*v-s*m,t[6]=s*b-M*v,t[7]=0,t[8]=s,t[9]=M,t[10]=f,t[11]=0,t[12]=u,t[13]=e,t[14]=o,t[15]=1,t}function Dn(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"}function Fn(t){return Math.hypot(t[0],t[1],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}function Ln(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t[9]=n[9]+a[9],t[10]=n[10]+a[10],t[11]=n[11]+a[11],t[12]=n[12]+a[12],t[13]=n[13]+a[13],t[14]=n[14]+a[14],t[15]=n[15]+a[15],t}function Vn(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t[9]=n[9]-a[9],t[10]=n[10]-a[10],t[11]=n[11]-a[11],t[12]=n[12]-a[12],t[13]=n[13]-a[13],t[14]=n[14]-a[14],t[15]=n[15]-a[15],t}function jn(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=n[11]*a,t[12]=n[12]*a,t[13]=n[13]*a,t[14]=n[14]*a,t[15]=n[15]*a,t}function zn(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t[9]=n[9]+a[9]*r,t[10]=n[10]+a[10]*r,t[11]=n[11]+a[11]*r,t[12]=n[12]+a[12]*r,t[13]=n[13]+a[13]*r,t[14]=n[14]+a[14]*r,t[15]=n[15]+a[15]*r,t}function On(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]}function Qn(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=t[4],i=t[5],h=t[6],c=t[7],s=t[8],f=t[9],l=t[10],v=t[11],b=t[12],m=t[13],d=t[14],x=t[15],y=n[0],p=n[1],q=n[2],w=n[3],g=n[4],A=n[5],P=n[6],S=n[7],R=n[8],T=n[9],I=n[10],E=n[11],D=n[12],F=n[13],L=n[14],V=n[15];return Math.abs(a-y)<=M*Math.max(1,Math.abs(a),Math.abs(y))&&Math.abs(r-p)<=M*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(u-q)<=M*Math.max(1,Math.abs(u),Math.abs(q))&&Math.abs(e-w)<=M*Math.max(1,Math.abs(e),Math.abs(w))&&Math.abs(o-g)<=M*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-A)<=M*Math.max(1,Math.abs(i),Math.abs(A))&&Math.abs(h-P)<=M*Math.max(1,Math.abs(h),Math.abs(P))&&Math.abs(c-S)<=M*Math.max(1,Math.abs(c),Math.abs(S))&&Math.abs(s-R)<=M*Math.max(1,Math.abs(s),Math.abs(R))&&Math.abs(f-T)<=M*Math.max(1,Math.abs(f),Math.abs(T))&&Math.abs(l-I)<=M*Math.max(1,Math.abs(l),Math.abs(I))&&Math.abs(v-E)<=M*Math.max(1,Math.abs(v),Math.abs(E))&&Math.abs(b-D)<=M*Math.max(1,Math.abs(b),Math.abs(D))&&Math.abs(m-F)<=M*Math.max(1,Math.abs(m),Math.abs(F))&&Math.abs(d-L)<=M*Math.max(1,Math.abs(d),Math.abs(L))&&Math.abs(x-V)<=M*Math.max(1,Math.abs(x),Math.abs(V))}var Yn=rn,Xn=Vn;function Zn(){var t=new f(3);return f!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function _n(t){var n=new f(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n}function Bn(t){var n=t[0],a=t[1],r=t[2];return Math.hypot(n,a,r)}function Nn(t,n,a){var r=new f(3);return r[0]=t,r[1]=n,r[2]=a,r}function kn(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function Un(t,n,a,r){return t[0]=n,t[1]=a,t[2]=r,t}function Wn(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t}function Cn(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t}function Gn(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t}function Hn(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t}function Jn(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t}function Kn(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t}function $n(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t}function ta(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t}function na(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t}function aa(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t}function ra(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t}function ua(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return Math.hypot(a,r,u)}function ea(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return a*a+r*r+u*u}function oa(t){var n=t[0],a=t[1],r=t[2];return n*n+a*a+r*r}function ia(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t}function ha(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t}function ca(t,n){var a=n[0],r=n[1],u=n[2],e=a*a+r*r+u*u;return e>0&&(e=1/Math.sqrt(e)),t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function sa(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function Ma(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],h=a[2];return t[0]=u*h-e*i,t[1]=e*o-r*h,t[2]=r*i-u*o,t}function fa(t,n,a,r){var u=n[0],e=n[1],o=n[2];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t}function la(t,n,a,r,u,e){var o=e*e,i=o*(2*e-3)+1,h=o*(e-2)+e,c=o*(e-1),s=o*(3-2*e);return t[0]=n[0]*i+a[0]*h+r[0]*c+u[0]*s,t[1]=n[1]*i+a[1]*h+r[1]*c+u[1]*s,t[2]=n[2]*i+a[2]*h+r[2]*c+u[2]*s,t}function va(t,n,a,r,u,e){var o=1-e,i=o*o,h=e*e,c=i*o,s=3*e*i,M=3*h*o,f=h*e;return t[0]=n[0]*c+a[0]*s+r[0]*M+u[0]*f,t[1]=n[1]*c+a[1]*s+r[1]*M+u[1]*f,t[2]=n[2]*c+a[2]*s+r[2]*M+u[2]*f,t}function ba(t,n){n=n||1;var a=2*l()*Math.PI,r=2*l()-1,u=Math.sqrt(1-r*r)*n;return t[0]=Math.cos(a)*u,t[1]=Math.sin(a)*u,t[2]=r*n,t}function ma(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[3]*r+a[7]*u+a[11]*e+a[15];return o=o||1,t[0]=(a[0]*r+a[4]*u+a[8]*e+a[12])/o,t[1]=(a[1]*r+a[5]*u+a[9]*e+a[13])/o,t[2]=(a[2]*r+a[6]*u+a[10]*e+a[14])/o,t}function da(t,n,a){var r=n[0],u=n[1],e=n[2];return t[0]=r*a[0]+u*a[3]+e*a[6],t[1]=r*a[1]+u*a[4]+e*a[7],t[2]=r*a[2]+u*a[5]+e*a[8],t}function xa(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],h=n[1],c=n[2],s=u*c-e*h,M=e*i-r*c,f=r*h-u*i,l=u*f-e*M,v=e*s-r*f,b=r*M-u*s,m=2*o;return s*=m,M*=m,f*=m,l*=2,v*=2,b*=2,t[0]=i+s+l,t[1]=h+M+v,t[2]=c+f+b,t}function ya(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0],e[1]=u[1]*Math.cos(r)-u[2]*Math.sin(r),e[2]=u[1]*Math.sin(r)+u[2]*Math.cos(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t}function pa(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[2]*Math.sin(r)+u[0]*Math.cos(r),e[1]=u[1],e[2]=u[2]*Math.cos(r)-u[0]*Math.sin(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t}function qa(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0]*Math.cos(r)-u[1]*Math.sin(r),e[1]=u[0]*Math.sin(r)+u[1]*Math.cos(r),e[2]=u[2],t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t}function wa(t,n){var a=Nn(t[0],t[1],t[2]),r=Nn(n[0],n[1],n[2]);ca(a,a),ca(r,r);var u=sa(a,r);return u>1?0:u<-1?Math.PI:Math.acos(u)}function ga(t){return t[0]=0,t[1]=0,t[2]=0,t}function Aa(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"}function Pa(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}function Sa(t,n){var a=t[0],r=t[1],u=t[2],e=n[0],o=n[1],i=n[2];return Math.abs(a-e)<=M*Math.max(1,Math.abs(a),Math.abs(e))&&Math.abs(r-o)<=M*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(u-i)<=M*Math.max(1,Math.abs(u),Math.abs(i))}var Ra,Ta=Cn,Ia=Gn,Ea=Hn,Da=ua,Fa=ea,La=Bn,Va=oa,ja=(Ra=Zn(),function(t,n,a,r,u,e){var o,i;for(n||(n=3),a||(a=0),i=r?Math.min(r*n+a,t.length):t.length,o=a;o<i;o+=n)Ra[0]=t[o],Ra[1]=t[o+1],Ra[2]=t[o+2],u(Ra,Ra,e),t[o]=Ra[0],t[o+1]=Ra[1],t[o+2]=Ra[2];return t});function za(){var t=new f(4);return f!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function Oa(t){var n=new f(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function Qa(t,n,a,r){var u=new f(4);return u[0]=t,u[1]=n,u[2]=a,u[3]=r,u}function Ya(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function Xa(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t}function Za(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t}function _a(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}function Ba(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t[3]=n[3]*a[3],t}function Na(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t[3]=n[3]/a[3],t}function ka(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t}function Ua(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t}function Wa(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t[3]=Math.min(n[3],a[3]),t}function Ca(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t[3]=Math.max(n[3],a[3]),t}function Ga(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t}function Ha(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t}function Ja(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t}function Ka(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return Math.hypot(a,r,u,e)}function $a(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return a*a+r*r+u*u+e*e}function tr(t){var n=t[0],a=t[1],r=t[2],u=t[3];return Math.hypot(n,a,r,u)}function nr(t){var n=t[0],a=t[1],r=t[2],u=t[3];return n*n+a*a+r*r+u*u}function ar(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t}function rr(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t}function ur(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e;return o>0&&(o=1/Math.sqrt(o)),t[0]=a*o,t[1]=r*o,t[2]=u*o,t[3]=e*o,t}function er(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function or(t,n,a,r){var u=a[0]*r[1]-a[1]*r[0],e=a[0]*r[2]-a[2]*r[0],o=a[0]*r[3]-a[3]*r[0],i=a[1]*r[2]-a[2]*r[1],h=a[1]*r[3]-a[3]*r[1],c=a[2]*r[3]-a[3]*r[2],s=n[0],M=n[1],f=n[2],l=n[3];return t[0]=M*c-f*h+l*i,t[1]=-s*c+f*o-l*e,t[2]=s*h-M*o+l*u,t[3]=-s*i+M*e-f*u,t}function ir(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t[3]=i+r*(a[3]-i),t}function hr(t,n){var a,r,u,e,o,i;n=n||1;do{o=(a=2*l()-1)*a+(r=2*l()-1)*r}while(o>=1);do{i=(u=2*l()-1)*u+(e=2*l()-1)*e}while(i>=1);var h=Math.sqrt((1-o)/i);return t[0]=n*a,t[1]=n*r,t[2]=n*u*h,t[3]=n*e*h,t}function cr(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3];return t[0]=a[0]*r+a[4]*u+a[8]*e+a[12]*o,t[1]=a[1]*r+a[5]*u+a[9]*e+a[13]*o,t[2]=a[2]*r+a[6]*u+a[10]*e+a[14]*o,t[3]=a[3]*r+a[7]*u+a[11]*e+a[15]*o,t}function sr(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],h=a[2],c=a[3],s=c*r+i*e-h*u,M=c*u+h*r-o*e,f=c*e+o*u-i*r,l=-o*r-i*u-h*e;return t[0]=s*c+l*-o+M*-h-f*-i,t[1]=M*c+l*-i+f*-o-s*-h,t[2]=f*c+l*-h+s*-i-M*-o,t[3]=n[3],t}function Mr(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function fr(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function lr(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function vr(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=n[0],i=n[1],h=n[2],c=n[3];return Math.abs(a-o)<=M*Math.max(1,Math.abs(a),Math.abs(o))&&Math.abs(r-i)<=M*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-h)<=M*Math.max(1,Math.abs(u),Math.abs(h))&&Math.abs(e-c)<=M*Math.max(1,Math.abs(e),Math.abs(c))}var br=_a,mr=Ba,dr=Na,xr=Ka,yr=$a,pr=tr,qr=nr,wr=function(){var t=za();return function(n,a,r,u,e,o){var i,h;for(a||(a=4),r||(r=0),h=u?Math.min(u*a+r,n.length):n.length,i=r;i<h;i+=a)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],e(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}();function gr(){var t=new f(4);return f!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function Ar(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function Pr(t,n,a){a*=.5;var r=Math.sin(a);return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=Math.cos(a),t}function Sr(t,n){var a=2*Math.acos(n[3]),r=Math.sin(a/2);return r>M?(t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r):(t[0]=1,t[1]=0,t[2]=0),a}function Rr(t,n){var a=au(t,n);return Math.acos(2*a*a-1)}function Tr(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],h=a[1],c=a[2],s=a[3];return t[0]=r*s+o*i+u*c-e*h,t[1]=u*s+o*h+e*i-r*c,t[2]=e*s+o*c+r*h-u*i,t[3]=o*s-r*i-u*h-e*c,t}function Ir(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),h=Math.cos(a);return t[0]=r*h+o*i,t[1]=u*h+e*i,t[2]=e*h-u*i,t[3]=o*h-r*i,t}function Er(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),h=Math.cos(a);return t[0]=r*h-e*i,t[1]=u*h+o*i,t[2]=e*h+r*i,t[3]=o*h-u*i,t}function Dr(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),h=Math.cos(a);return t[0]=r*h+u*i,t[1]=u*h-r*i,t[2]=e*h+o*i,t[3]=o*h-e*i,t}function Fr(t,n){var a=n[0],r=n[1],u=n[2];return t[0]=a,t[1]=r,t[2]=u,t[3]=Math.sqrt(Math.abs(1-a*a-r*r-u*u)),t}function Lr(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=Math.exp(e),h=o>0?i*Math.sin(o)/o:0;return t[0]=a*h,t[1]=r*h,t[2]=u*h,t[3]=i*Math.cos(o),t}function Vr(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=o>0?Math.atan2(o,e)/o:0;return t[0]=a*i,t[1]=r*i,t[2]=u*i,t[3]=.5*Math.log(a*a+r*r+u*u+e*e),t}function jr(t,n,a){return Vr(t,n),nu(t,t,a),Lr(t,t),t}function zr(t,n,a,r){var u,e,o,i,h,c=n[0],s=n[1],f=n[2],l=n[3],v=a[0],b=a[1],m=a[2],d=a[3];return(e=c*v+s*b+f*m+l*d)<0&&(e=-e,v=-v,b=-b,m=-m,d=-d),1-e>M?(u=Math.acos(e),o=Math.sin(u),i=Math.sin((1-r)*u)/o,h=Math.sin(r*u)/o):(i=1-r,h=r),t[0]=i*c+h*v,t[1]=i*s+h*b,t[2]=i*f+h*m,t[3]=i*l+h*d,t}function Or(t){var n=l(),a=l(),r=l(),u=Math.sqrt(1-n),e=Math.sqrt(n);return t[0]=u*Math.sin(2*Math.PI*a),t[1]=u*Math.cos(2*Math.PI*a),t[2]=e*Math.sin(2*Math.PI*r),t[3]=e*Math.cos(2*Math.PI*r),t}function Qr(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e,i=o?1/o:0;return t[0]=-a*i,t[1]=-r*i,t[2]=-u*i,t[3]=e*i,t}function Yr(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t}function Xr(t,n){var a,r=n[0]+n[4]+n[8];if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var u=0;n[4]>n[0]&&(u=1),n[8]>n[3*u+u]&&(u=2);var e=(u+1)%3,o=(u+2)%3;a=Math.sqrt(n[3*u+u]-n[3*e+e]-n[3*o+o]+1),t[u]=.5*a,a=.5/a,t[3]=(n[3*e+o]-n[3*o+e])*a,t[e]=(n[3*e+u]+n[3*u+e])*a,t[o]=(n[3*o+u]+n[3*u+o])*a}return t}function Zr(t,n,a,r){var u=.5*Math.PI/180;n*=u,a*=u,r*=u;var e=Math.sin(n),o=Math.cos(n),i=Math.sin(a),h=Math.cos(a),c=Math.sin(r),s=Math.cos(r);return t[0]=e*h*s-o*i*c,t[1]=o*i*s+e*h*c,t[2]=o*h*c-e*i*s,t[3]=o*h*s+e*i*c,t}function _r(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}var Br,Nr,kr,Ur,Wr,Cr,Gr=Oa,Hr=Qa,Jr=Ya,Kr=Xa,$r=Za,tu=Tr,nu=Ha,au=er,ru=ir,uu=tr,eu=uu,ou=nr,iu=ou,hu=ur,cu=lr,su=vr,Mu=(Br=Zn(),Nr=Nn(1,0,0),kr=Nn(0,1,0),function(t,n,a){var r=sa(n,a);return r<-.999999?(Ma(Br,Nr,n),La(Br)<1e-6&&Ma(Br,kr,n),ca(Br,Br),Pr(t,Br,Math.PI),t):r>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(Ma(Br,n,a),t[0]=Br[0],t[1]=Br[1],t[2]=Br[2],t[3]=1+r,hu(t,t))}),fu=(Ur=gr(),Wr=gr(),function(t,n,a,r,u,e){return zr(Ur,n,u,e),zr(Wr,a,r,e),zr(t,Ur,Wr,2*e*(1-e)),t}),lu=(Cr=bt(),function(t,n,a,r){return Cr[0]=a[0],Cr[3]=a[1],Cr[6]=a[2],Cr[1]=r[0],Cr[4]=r[1],Cr[7]=r[2],Cr[2]=-n[0],Cr[5]=-n[1],Cr[8]=-n[2],hu(t,Xr(t,Cr))});function vu(){var t=new f(8);return f!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0),t[3]=1,t}function bu(t){var n=new f(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n}function mu(t,n,a,r,u,e,o,i){var h=new f(8);return h[0]=t,h[1]=n,h[2]=a,h[3]=r,h[4]=u,h[5]=e,h[6]=o,h[7]=i,h}function du(t,n,a,r,u,e,o){var i=new f(8);i[0]=t,i[1]=n,i[2]=a,i[3]=r;var h=.5*u,c=.5*e,s=.5*o;return i[4]=h*r+c*a-s*n,i[5]=c*r+s*t-h*a,i[6]=s*r+h*n-c*t,i[7]=-h*t-c*n-s*a,i}function xu(t,n,a){var r=.5*a[0],u=.5*a[1],e=.5*a[2],o=n[0],i=n[1],h=n[2],c=n[3];return t[0]=o,t[1]=i,t[2]=h,t[3]=c,t[4]=r*c+u*h-e*i,t[5]=u*c+e*o-r*h,t[6]=e*c+r*i-u*o,t[7]=-r*o-u*i-e*h,t}function yu(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t}function pu(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t}function qu(t,n){var a=gr();qn(a,n);var r=new f(3);return yn(r,n),xu(t,a,r),t}function wu(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}function gu(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t}function Au(t,n,a,r,u,e,o,i,h){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=h,t}var Pu=Jr;function Su(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t}var Ru=Jr;function Tu(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t}function Iu(t,n){var a=n[4],r=n[5],u=n[6],e=n[7],o=-n[0],i=-n[1],h=-n[2],c=n[3];return t[0]=2*(a*c+e*o+r*h-u*i),t[1]=2*(r*c+e*i+u*o-a*h),t[2]=2*(u*c+e*h+a*i-r*o),t}function Eu(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=.5*a[0],h=.5*a[1],c=.5*a[2],s=n[4],M=n[5],f=n[6],l=n[7];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=o*i+u*c-e*h+s,t[5]=o*h+e*i-r*c+M,t[6]=o*c+r*h-u*i+f,t[7]=-r*i-u*h-e*c+l,t}function Du(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=i*o+s*r+h*e-c*u,f=h*o+s*u+c*r-i*e,l=c*o+s*e+i*u-h*r,v=s*o-i*r-h*u-c*e;return Ir(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t}function Fu(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=i*o+s*r+h*e-c*u,f=h*o+s*u+c*r-i*e,l=c*o+s*e+i*u-h*r,v=s*o-i*r-h*u-c*e;return Er(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t}function Lu(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],h=n[5],c=n[6],s=n[7],M=i*o+s*r+h*e-c*u,f=h*o+s*u+c*r-i*e,l=c*o+s*e+i*u-h*r,v=s*o-i*r-h*u-c*e;return Dr(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t}function Vu(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],h=n[1],c=n[2],s=n[3];return t[0]=i*o+s*r+h*e-c*u,t[1]=h*o+s*u+c*r-i*e,t[2]=c*o+s*e+i*u-h*r,t[3]=s*o-i*r-h*u-c*e,i=n[4],h=n[5],c=n[6],s=n[7],t[4]=i*o+s*r+h*e-c*u,t[5]=h*o+s*u+c*r-i*e,t[6]=c*o+s*e+i*u-h*r,t[7]=s*o-i*r-h*u-c*e,t}function ju(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],h=a[1],c=a[2],s=a[3];return t[0]=r*s+o*i+u*c-e*h,t[1]=u*s+o*h+e*i-r*c,t[2]=e*s+o*c+r*h-u*i,t[3]=o*s-r*i-u*h-e*c,i=a[4],h=a[5],c=a[6],s=a[7],t[4]=r*s+o*i+u*c-e*h,t[5]=u*s+o*h+e*i-r*c,t[6]=e*s+o*c+r*h-u*i,t[7]=o*s-r*i-u*h-e*c,t}function zu(t,n,a,r){if(Math.abs(r)<M)return wu(t,n);var u=Math.hypot(a[0],a[1],a[2]);r*=.5;var e=Math.sin(r),o=e*a[0]/u,i=e*a[1]/u,h=e*a[2]/u,c=Math.cos(r),s=n[0],f=n[1],l=n[2],v=n[3];t[0]=s*c+v*o+f*h-l*i,t[1]=f*c+v*i+l*o-s*h,t[2]=l*c+v*h+s*i-f*o,t[3]=v*c-s*o-f*i-l*h;var b=n[4],m=n[5],d=n[6],x=n[7];return t[4]=b*c+x*o+m*h-d*i,t[5]=m*c+x*i+d*o-b*h,t[6]=d*c+x*h+b*i-m*o,t[7]=x*c-b*o-m*i-d*h,t}function Ou(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t}function Qu(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[4],h=a[5],c=a[6],s=a[7],M=n[4],f=n[5],l=n[6],v=n[7],b=a[0],m=a[1],d=a[2],x=a[3];return t[0]=r*x+o*b+u*d-e*m,t[1]=u*x+o*m+e*b-r*d,t[2]=e*x+o*d+r*m-u*b,t[3]=o*x-r*b-u*m-e*d,t[4]=r*s+o*i+u*c-e*h+M*x+v*b+f*d-l*m,t[5]=u*s+o*h+e*i-r*c+f*x+v*m+l*b-M*d,t[6]=e*s+o*c+r*h-u*i+l*x+v*d+M*m-f*b,t[7]=o*s-r*i-u*h-e*c+v*x-M*b-f*m-l*d,t}var Yu=Qu;function Xu(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t}var Zu=au;function _u(t,n,a,r){var u=1-r;return Zu(n,a)<0&&(r=-r),t[0]=n[0]*u+a[0]*r,t[1]=n[1]*u+a[1]*r,t[2]=n[2]*u+a[2]*r,t[3]=n[3]*u+a[3]*r,t[4]=n[4]*u+a[4]*r,t[5]=n[5]*u+a[5]*r,t[6]=n[6]*u+a[6]*r,t[7]=n[7]*u+a[7]*r,t}function Bu(t,n){var a=Wu(n);return t[0]=-n[0]/a,t[1]=-n[1]/a,t[2]=-n[2]/a,t[3]=n[3]/a,t[4]=-n[4]/a,t[5]=-n[5]/a,t[6]=-n[6]/a,t[7]=n[7]/a,t}function Nu(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t}var ku=uu,Uu=ku,Wu=ou,Cu=Wu;function Gu(t,n){var a=Wu(n);if(a>0){a=Math.sqrt(a);var r=n[0]/a,u=n[1]/a,e=n[2]/a,o=n[3]/a,i=n[4],h=n[5],c=n[6],s=n[7],M=r*i+u*h+e*c+o*s;t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=(i-r*M)/a,t[5]=(h-u*M)/a,t[6]=(c-e*M)/a,t[7]=(s-o*M)/a}return t}function Hu(t){return"quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"}function Ju(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]}function Ku(t,n){var a=t[0],r=t[1],u=t[2],e=t[3],o=t[4],i=t[5],h=t[6],c=t[7],s=n[0],f=n[1],l=n[2],v=n[3],b=n[4],m=n[5],d=n[6],x=n[7];return Math.abs(a-s)<=M*Math.max(1,Math.abs(a),Math.abs(s))&&Math.abs(r-f)<=M*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(u-l)<=M*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(e-v)<=M*Math.max(1,Math.abs(e),Math.abs(v))&&Math.abs(o-b)<=M*Math.max(1,Math.abs(o),Math.abs(b))&&Math.abs(i-m)<=M*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(h-d)<=M*Math.max(1,Math.abs(h),Math.abs(d))&&Math.abs(c-x)<=M*Math.max(1,Math.abs(c),Math.abs(x))}function $u(){var t=new f(2);return f!=Float32Array&&(t[0]=0,t[1]=0),t}function te(t){var n=new f(2);return n[0]=t[0],n[1]=t[1],n}function ne(t,n){var a=new f(2);return a[0]=t,a[1]=n,a}function ae(t,n){return t[0]=n[0],t[1]=n[1],t}function re(t,n,a){return t[0]=n,t[1]=a,t}function ue(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t}function ee(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t}function oe(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t}function ie(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t}function he(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t}function ce(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t}function se(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t}function Me(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t}function fe(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t}function le(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t}function ve(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t}function be(t,n){var a=n[0]-t[0],r=n[1]-t[1];return Math.hypot(a,r)}function me(t,n){var a=n[0]-t[0],r=n[1]-t[1];return a*a+r*r}function de(t){var n=t[0],a=t[1];return Math.hypot(n,a)}function xe(t){var n=t[0],a=t[1];return n*n+a*a}function ye(t,n){return t[0]=-n[0],t[1]=-n[1],t}function pe(t,n){return t[0]=1/n[0],t[1]=1/n[1],t}function qe(t,n){var a=n[0],r=n[1],u=a*a+r*r;return u>0&&(u=1/Math.sqrt(u)),t[0]=n[0]*u,t[1]=n[1]*u,t}function we(t,n){return t[0]*n[0]+t[1]*n[1]}function ge(t,n,a){var r=n[0]*a[1]-n[1]*a[0];return t[0]=t[1]=0,t[2]=r,t}function Ae(t,n,a,r){var u=n[0],e=n[1];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t}function Pe(t,n){n=n||1;var a=2*l()*Math.PI;return t[0]=Math.cos(a)*n,t[1]=Math.sin(a)*n,t}function Se(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u,t[1]=a[1]*r+a[3]*u,t}function Re(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u+a[4],t[1]=a[1]*r+a[3]*u+a[5],t}function Te(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[3]*u+a[6],t[1]=a[1]*r+a[4]*u+a[7],t}function Ie(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[4]*u+a[12],t[1]=a[1]*r+a[5]*u+a[13],t}function Ee(t,n,a,r){var u=n[0]-a[0],e=n[1]-a[1],o=Math.sin(r),i=Math.cos(r);return t[0]=u*i-e*o+a[0],t[1]=u*o+e*i+a[1],t}function De(t,n){var a=t[0],r=t[1],u=n[0],e=n[1],o=a*a+r*r;o>0&&(o=1/Math.sqrt(o));var i=u*u+e*e;i>0&&(i=1/Math.sqrt(i));var h=(a*u+r*e)*o*i;return h>1?0:h<-1?Math.PI:Math.acos(h)}function Fe(t){return t[0]=0,t[1]=0,t}function Le(t){return"vec2("+t[0]+", "+t[1]+")"}function Ve(t,n){return t[0]===n[0]&&t[1]===n[1]}function je(t,n){var a=t[0],r=t[1],u=n[0],e=n[1];return Math.abs(a-u)<=M*Math.max(1,Math.abs(a),Math.abs(u))&&Math.abs(r-e)<=M*Math.max(1,Math.abs(r),Math.abs(e))}var ze=de,Oe=ee,Qe=oe,Ye=ie,Xe=be,Ze=me,_e=xe,Be=function(){var t=$u();return function(n,a,r,u,e,o){var i,h;for(a||(a=2),r||(r=0),h=u?Math.min(u*a+r,n.length):n.length,i=r;i<h;i+=a)t[0]=n[i],t[1]=n[i+1],e(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}();window.glMatrix=n,window.mat2=a,window.mat2d=r,window.mat3=u,window.mat4=e,window.quat=h,window.quat2=c,window.vec2=s,window.vec3=o,window.vec4=i})();
//# sourceMappingURL=libs.core.js.map
if(!CABLES.exportedPatches)CABLES.exportedPatches={};CABLES.exportedPatches["LfVxtG"]={_id:"67e2de1dccab331699637565",ops:[{id:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8",uiAttribs:{},portsIn:[{name:"FPS Limit",value:0},{name:"Reduce FPS not focussed",value:0},{name:"Reduce FPS loading",value:0},{name:"Clear",value:1},{name:"ClearAlpha",value:1},{name:"Fullscreen Button",value:0},{name:"Active",value:1},{name:"Hires Displays",value:0},{name:"Pixel Unit index",value:0},{name:"Pixel Unit",value:"Display"}],portsOut:[{name:"trigger",links:[{portIn:"Update",portOut:"trigger",objIn:"0mj4u6hzu",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"Trigger In",portOut:"trigger",objIn:"4o7b5nrno",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"dwgm6n0y5",portOut:"trigger",objIn:"149yrcktx",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"uudck28ir",portOut:"trigger",objIn:"149yrcktx",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"y8uhtij81",portOut:"trigger",objIn:"149yrcktx",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"j5vhorqrp",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"nr9rrqtfa",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"nnfq9vmao",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"doyptzzik",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"7l0lw83tn",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"8d5nev7xy",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"hq25ppvb5",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"},{portIn:"render",portOut:"trigger",objIn:"aag27it09",objOut:"d23e0c23-9f7e-4ceb-a633-9d552bde74c8"}]},{name:"width",value:699},{name:"height",value:396}],objName:"Ops.Gl.MainLoop"},{id:"fced37fe-5305-4dc5-8fdd-c3fd239d824e",uiAttribs:{},portsIn:[{name:"Num",value:10},{name:"Spacing",value:1},{name:"Center",value:1},{name:"Axis index",value:0},{name:"Axis",value:"XY"}],objName:"Ops.Gl.Meshes.Grid"},{id:"bb345986-53df-4de8-bc24-5281a04ff57d",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"zp5zlz447",objOut:"bb345986-53df-4de8-bc24-5281a04ff57d"},{portIn:"render",portOut:"trigger",objIn:"i3i8vsddm",objOut:"bb345986-53df-4de8-bc24-5281a04ff57d"},{portIn:"Execute",portOut:"trigger",objIn:"v7rdmcidl",objOut:"bb345986-53df-4de8-bc24-5281a04ff57d"},{portIn:"render",portOut:"trigger",objIn:"hgo5fgjdc",objOut:"bb345986-53df-4de8-bc24-5281a04ff57d"},{portIn:"render",portOut:"trigger",objIn:"cjparvalx",objOut:"bb345986-53df-4de8-bc24-5281a04ff57d"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"5d394820-d452-4060-9b6b-506f93e2b62b",uiAttribs:{},portsOut:[{name:"trigger 0",links:[{portIn:"render",portOut:"trigger 0",objIn:"jws19f1u4",objOut:"5d394820-d452-4060-9b6b-506f93e2b62b"}]},{name:"trigger 8",links:[{portIn:"Set",portOut:"trigger 8",objIn:"3n3k7qw9r",objOut:"5d394820-d452-4060-9b6b-506f93e2b62b"}]},{name:"trigger 15",links:[{portIn:"Update",portOut:"trigger 15",objIn:"i2xxetaa8",objOut:"5d394820-d452-4060-9b6b-506f93e2b62b"}]}],objName:"Ops.Trigger.Sequence"},{id:"5lseev864",uiAttribs:{},portsIn:[{name:"Visible",value:1},{name:"Opacity",value:.85},{name:"Default Minimized",value:1},{name:"Minimized Opacity",value:.5},{name:"Show undo button",value:0},{name:"Show Minimize",value:0},{name:"Title",value:"Camera controls"},{name:"Side",value:0},{name:"Default CSS",value:1}],portsOut:[{name:"childs",title:"Children",links:[{portIn:"link",portOut:"childs",objIn:"wb4ov2t17",objOut:"5lseev864"}]},{name:"Opfened",value:true,title:"Opened"}],objName:"Ops.Sidebar.Sidebar"},{id:"f2eq1qjez",uiAttribs:{},portsIn:[{name:"Text",value:"Positions"},{name:"Show Title",value:1},{name:"Default Minimized",value:0},{name:"Visible",value:1}],portsOut:[{name:"next",links:[{portIn:"link",portOut:"next",objIn:"tx50wxluu",objOut:"f2eq1qjez"}]},{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"tovtl9r1x",objOut:"f2eq1qjez"}]}],objName:"Ops.Sidebar.Group"},{id:"tovtl9r1x",uiAttribs:{},portsIn:[{name:"Text",value:"PositionX"},{name:"Min",value:-6},{name:"Max",value:6},{name:"Step",value:1e-5},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:-1},{name:"Default",value:-1}],portsOut:[{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"oi5dikgg6",objOut:"tovtl9r1x"}]},{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"8ssl3lv9r",objOut:"tovtl9r1x"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"8ssl3lv9r",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionX"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"oi5dikgg6",uiAttribs:{},portsIn:[{name:"Text",value:"PositionY"},{name:"Min",value:-6},{name:"Max",value:6},{name:"Step",value:1e-5},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:-.5},{name:"Default",value:-.5}],portsOut:[{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"ftai1vfd8",objOut:"oi5dikgg6"}]},{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"d2q719yxd",objOut:"oi5dikgg6"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"d2q719yxd",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionY"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"ftai1vfd8",uiAttribs:{},portsIn:[{name:"Text",value:"PositionZ"},{name:"Min",value:-12},{name:"Max",value:12},{name:"Step",value:1e-5},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:0},{name:"Default",value:0}],portsOut:[{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"3x6xwqi8h",objOut:"ftai1vfd8"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"3x6xwqi8h",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionZ"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"tx50wxluu",uiAttribs:{},portsIn:[{name:"Text",value:"Rotations"},{name:"Show Title",value:1},{name:"Default Minimized",value:0},{name:"Visible",value:1}],portsOut:[{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"zgdwy94n9",objOut:"tx50wxluu"}]}],objName:"Ops.Sidebar.Group"},{id:"zgdwy94n9",uiAttribs:{},portsIn:[{name:"Text",value:"Tilt"},{name:"Min",value:-360},{name:"Max",value:360},{name:"Step",value:.1},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:0},{name:"Default",value:0}],portsOut:[{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"6eqz0edr9",objOut:"zgdwy94n9"}]},{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"h40jid823",objOut:"zgdwy94n9"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"h40jid823",uiAttribs:{},portsIn:[{name:"Variable",value:"Tilt"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"6eqz0edr9",uiAttribs:{},portsIn:[{name:"Text",value:"Pan"},{name:"Min",value:-360},{name:"Max",value:360},{name:"Step",value:.1},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:0},{name:"Default",value:0}],portsOut:[{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"699ezyj4p",objOut:"6eqz0edr9"}]},{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"mvqkczt14",objOut:"6eqz0edr9"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"mvqkczt14",uiAttribs:{},portsIn:[{name:"Variable",value:"Pan"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"699ezyj4p",uiAttribs:{},portsIn:[{name:"Text",value:"Roll"},{name:"Min",value:-360},{name:"Max",value:360},{name:"Step",value:.1},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Input",value:0},{name:"Default",value:0}],portsOut:[{name:"Result",links:[{portIn:"Value",portOut:"Result",objIn:"4kq8q3rcr",objOut:"699ezyj4p"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"4kq8q3rcr",uiAttribs:{},portsIn:[{name:"Variable",value:"Roll"}],objName:"Ops.Vars.VarSetNumber_v2"},{id:"jws19f1u4",uiAttribs:{},portsIn:[{name:"Identity",value:1},{name:"projection mode index",value:0},{name:"projection mode",value:"prespective"},{name:"frustum near",value:.01},{name:"frustum far",value:5e3},{name:"fov",value:45},{name:"Auto Aspect Ratio",value:1},{name:"Aspect Ratio",value:1},{name:"eye X",value:0},{name:"eye Y",value:0},{name:"eye Z",value:0},{name:"center X",value:0},{name:"center Y",value:0},{name:"center Z",value:0},{name:"truck",value:1.395,useVariable:".preset_truck_tphleopyp_xj308b5wj"},{name:"boom",value:2.40321,useVariable:".preset_boom_tphleopyp_5o9qszbgz"},{name:"dolly",value:-5.475,useVariable:".preset_dolly_tphleopyp_1of3vltmc"},{name:"tilt",value:31.2,useVariable:".preset_tilt_tphleopyp_4yai7q5nz"},{name:"pan",value:0,useVariable:".preset_pan_tphleopyp_ytd4uq2n3"},{name:"roll",value:0,useVariable:".preset_roll_tphleopyp_ogpydxwb4"}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"8juazn4zj",objOut:"jws19f1u4"}]},{name:"Aspect",value:1.7651515151515151}],objName:"Ops.Gl.Matrix.Camera_v2"},{id:"hmebdsy0b",uiAttribs:{},portsIn:[{name:"Variable",value:"Pan"}],portsOut:[{name:"Value",links:[{portIn:".preset_pan_tphleopyp_ytd4uq2n3",portOut:"Value",objIn:"8sebcdkyb",objOut:"hmebdsy0b"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"qolptitzz",uiAttribs:{},portsIn:[{name:"Variable",value:"Roll"}],portsOut:[{name:"Value",links:[{portIn:".preset_roll_tphleopyp_ogpydxwb4",portOut:"Value",objIn:"8sebcdkyb",objOut:"qolptitzz"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"kt9vvc3em",uiAttribs:{},portsIn:[{name:"Variable",value:"Tilt"}],portsOut:[{name:"Value",links:[{portIn:".preset_tilt_tphleopyp_4yai7q5nz",portOut:"Value",objIn:"8sebcdkyb",objOut:"kt9vvc3em"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"arr4fgpvk",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionZ"}],portsOut:[{name:"Value",links:[{portIn:".preset_dolly_tphleopyp_1of3vltmc",portOut:"Value",objIn:"8sebcdkyb",objOut:"arr4fgpvk"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"yf0p7glj0",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionY"}],portsOut:[{name:"Value",links:[{portIn:".preset_boom_tphleopyp_5o9qszbgz",portOut:"Value",objIn:"8sebcdkyb",objOut:"yf0p7glj0"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"jfwjkej70",uiAttribs:{},portsIn:[{name:"Variable",value:"PositionX"}],portsOut:[{name:"Value",links:[{portIn:".preset_truck_tphleopyp_xj308b5wj",portOut:"Value",objIn:"8sebcdkyb",objOut:"jfwjkej70"}]}],objName:"Ops.Vars.VarGetNumber_v2"},{id:"wb4ov2t17",uiAttribs:{},portsIn:[{name:"Text",value:"Presets Interpolation"},{name:"Show Title",value:1},{name:"Default Minimized",value:0},{name:"Visible",value:1}],portsOut:[{name:"next",links:[{portIn:"link",portOut:"next",objIn:"f2eq1qjez",objOut:"wb4ov2t17"}]},{name:"childs",links:[{portIn:"link",portOut:"childs",objIn:"qq36gkqv8",objOut:"wb4ov2t17"}]}],objName:"Ops.Sidebar.Group"},{id:"qq36gkqv8",uiAttribs:{},portsIn:[{name:"Text",value:"preset"},{name:"Min",value:0},{name:"Max",value:10},{name:"Step",value:.01},{name:"Suffix",value:""},{name:"Grey Out",value:0},{name:"Visible",value:1},{name:"Default",value:.5}],portsOut:[{name:"childs",links:[{portIn:"Link",portOut:"childs",objIn:"91l5q7ayn",objOut:"qq36gkqv8"}]},{name:"Result",links:[{portIn:"Preset A",portOut:"Result",objIn:"8sebcdkyb",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ogcwrw3nt",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"erw47mfj8",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"tp4hm56fc",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"6xsw0o9sn",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"lc413h822",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"pzg2brh3r",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"dlgzus94z",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ca2j32nw7",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"i7mm66xpo",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ke2kphkai",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"v02k7hn2r",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"hv6errv53",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"hhg70pui1",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"2vv084rwd",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"uncjlqeeq",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"35dmtw1m3",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ngvd7yhhv",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"xic7uy0p3",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"t0f2mq3mm",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"634bzpwj3",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"o9dips58v",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"m6mb6ir8a",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"iq6w67tj8",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"8fker30is",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"fwqco6a34",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"9084c56nr",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ixhfs78cz",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"bofkp6wst",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"v63xgvyxv",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"xt3xf481g",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"octu5x22s",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"x4uec9zvk",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"lctg9ouwk",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"97iaov0g5",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"b8qmjzwx8",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"i7km4v1wx",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ibichgc9z",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"axal2z3vd",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"jwqndw3rb",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"aav3w9116",objOut:"qq36gkqv8"},{portIn:"value",portOut:"Result",objIn:"ubjke9qia",objOut:"qq36gkqv8"}]}],objName:"Ops.Sidebar.Slider_v3"},{id:"8sebcdkyb",uiAttribs:{},portsIn:[{name:"data",value:'[{"varname":".preset_truck_tphleopyp_xj308b5wj","title":"Camera truck","type":0},{"varname":".preset_boom_tphleopyp_5o9qszbgz","title":"Camera boom","type":0},{"varname":".preset_dolly_tphleopyp_1of3vltmc","title":"Camera dolly","type":0},{"varname":".preset_tilt_tphleopyp_4yai7q5nz","title":"Camera tilt","type":0},{"varname":".preset_pan_tphleopyp_ytd4uq2n3","title":"Camera pan","type":0},{"varname":".preset_roll_tphleopyp_ogpydxwb4","title":"Camera roll","type":0}]'},{name:"sets",value:'[{"name":"1","values":{".preset_truck_tphleopyp_xj308b5wj":0.435,".preset_boom_tphleopyp_5o9qszbgz":-0.8025,".preset_dolly_tphleopyp_1of3vltmc":-9.77306,".preset_tilt_tphleopyp_4yai7q5nz":0,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"4","values":{".preset_truck_tphleopyp_xj308b5wj":0.37821,".preset_boom_tphleopyp_5o9qszbgz":0.07071,".preset_dolly_tphleopyp_1of3vltmc":-7.33791,".preset_tilt_tphleopyp_4yai7q5nz":8.4,".preset_pan_tphleopyp_ytd4uq2n3":-11.2,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"2","values":{".preset_truck_tphleopyp_xj308b5wj":0.435,".preset_boom_tphleopyp_5o9qszbgz":-0.8025,".preset_dolly_tphleopyp_1of3vltmc":-9.77306,".preset_tilt_tphleopyp_4yai7q5nz":0,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"3","values":{".preset_truck_tphleopyp_xj308b5wj":0.435,".preset_boom_tphleopyp_5o9qszbgz":-0.8025,".preset_dolly_tphleopyp_1of3vltmc":-9.77306,".preset_tilt_tphleopyp_4yai7q5nz":0,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"vue plong","values":{".preset_truck_tphleopyp_xj308b5wj":2.79107,".preset_boom_tphleopyp_5o9qszbgz":-0.24107,".preset_dolly_tphleopyp_1of3vltmc":-12,".preset_tilt_tphleopyp_4yai7q5nz":28.6,".preset_pan_tphleopyp_ytd4uq2n3":-17.9,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"scne","values":{".preset_truck_tphleopyp_xj308b5wj":1.395,".preset_boom_tphleopyp_5o9qszbgz":2.40321,".preset_dolly_tphleopyp_1of3vltmc":-5.475,".preset_tilt_tphleopyp_4yai7q5nz":31.2,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"360 scne","values":{".preset_truck_tphleopyp_xj308b5wj":1.395,".preset_boom_tphleopyp_5o9qszbgz":2.40321,".preset_dolly_tphleopyp_1of3vltmc":-5.475,".preset_tilt_tphleopyp_4yai7q5nz":31.2,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}},{"name":"plong 2","values":{".preset_truck_tphleopyp_xj308b5wj":1.395,".preset_boom_tphleopyp_5o9qszbgz":2.40321,".preset_dolly_tphleopyp_1of3vltmc":-5.475,".preset_tilt_tphleopyp_4yai7q5nz":31.2,".preset_pan_tphleopyp_ytd4uq2n3":0,".preset_roll_tphleopyp_ogpydxwb4":0}}]'},{name:"presetid",value:"tphleopyp"},{name:"Interpolation index",value:2},{name:"Interpolation",value:"a-b"},{name:"Preset B",value:"1"},{name:"Fade",value:0},{name:"Preset index",value:0},{name:"Preset",value:"1"},{name:".preset_truck_tphleopyp_xj308b5wj",title:"Camera truck"},{name:".preset_boom_tphleopyp_5o9qszbgz",title:"Camera boom"},{name:".preset_dolly_tphleopyp_1of3vltmc",title:"Camera dolly"},{name:".preset_tilt_tphleopyp_4yai7q5nz",title:"Camera tilt"},{name:".preset_pan_tphleopyp_ytd4uq2n3",title:"Camera pan"},{name:".preset_roll_tphleopyp_ogpydxwb4",title:"Camera roll"}],portsOut:[{name:"Create Variable",value:0},{name:"Num Presets",value:8},{name:"current Preset",value:0}],objName:"Ops.Number.Preset"},{id:"i2xxetaa8",uiAttribs:{},portsIn:[{name:"Separate inc/dec",value:0},{name:"Inc factor",value:32,title:"Inc/Dec factor"},{name:"Dec factor",value:4}],portsOut:[{name:"Result",links:[{portIn:"Preset A",portOut:"Result",objIn:"8sebcdkyb",objOut:"i2xxetaa8"}]}],objName:"Ops.Anim.Smooth"},{id:"3n3k7qw9r",uiAttribs:{},portsOut:[{name:"Out Value",links:[{portIn:"Value",portOut:"Out Value",objIn:"i2xxetaa8",objOut:"3n3k7qw9r"}]}],objName:"Ops.Trigger.TriggerNumber"},{id:"91l5q7ayn",uiAttribs:{},portsIn:[{name:"Text",value:"Jump to"},{name:"Input",value:0},{name:"Default",value:0}],portsOut:[{name:"Children",links:[{portIn:"link",portOut:"Children",objIn:"wgbb54iaa",objOut:"91l5q7ayn"}]},{name:"Result",links:[{portIn:"Number",portOut:"Result",objIn:"3n3k7qw9r",objOut:"91l5q7ayn"}]}],objName:"Ops.Sidebar.NumberInput_v2"},{id:"dpwm2aszf",uiAttribs:{},portsIn:[{name:"Speed",value:1},{name:"prevent scroll",value:1},{name:"Flip Direction",value:0},{name:"Simple Delta",value:1},{name:"Area index",value:0},{name:"Area",value:"Canvas"},{name:"active",value:1}],portsOut:[{name:"delta",value:1},{name:"delta X",value:.01},{name:"browser event delta",links:[{portIn:"number1",portOut:"browser event delta",objIn:"9qg93148o",objOut:"dpwm2aszf"}]},{name:"Wheel Action",links:[{portIn:"Trigger in",portOut:"Wheel Action",objIn:"fiq06coor",objOut:"dpwm2aszf"}]}],objName:"Ops.Devices.Mouse.MouseWheel_v2"},{id:"fiq06coor",uiAttribs:{},portsIn:[{name:"Multiplier to add number",value:.001},{name:"Default Value",value:0}],portsOut:[{name:"Current value",links:[{portIn:"Value",portOut:"Current value",objIn:"0mj4u6hzu",objOut:"fiq06coor"},{portIn:"number1",portOut:"Current value",objIn:"qrdkvq4ht",objOut:"fiq06coor"}]}],objName:"Ops.Math.Accumulator"},{id:"0mj4u6hzu",uiAttribs:{},portsIn:[{name:"Separate inc/dec",value:0},{name:"Inc factor",value:32,title:"Inc/Dec factor"},{name:"Dec factor",value:4}],portsOut:[{name:"Result",links:[{portIn:"Input",portOut:"Result",objIn:"qq36gkqv8",objOut:"0mj4u6hzu"}]}],objName:"Ops.Anim.Smooth"},{id:"v7rdmcidl",uiAttribs:{},portsOut:[{name:"Next",links:[{portIn:"render",portOut:"Next",objIn:"zxck3stk1",objOut:"v7rdmcidl"},{portIn:"render",portOut:"Next",objIn:"60qipgsr2",objOut:"v7rdmcidl"},{portIn:"render",portOut:"Next",objIn:"oe6xshvv5",objOut:"v7rdmcidl"},{portIn:"render",portOut:"Next",objIn:"847d6xvop",objOut:"v7rdmcidl"},{portIn:"render",portOut:"Next",objIn:"fh5vpay27",objOut:"v7rdmcidl"},{portIn:"render",portOut:"Next",objIn:"f09z8qmus",objOut:"v7rdmcidl"}]}],objName:"Ops.Trigger.TriggerExtender"},{id:"3fclm8bbe",uiAttribs:{},portsIn:[{name:"Flip",value:0},{name:"Normalize",value:0}],portsOut:[{name:"Result",links:[{portIn:"Geometry",portOut:"Result",objIn:"n4lcgd4bf",objOut:"3fclm8bbe"}]}],objName:"Ops.Graphics.Geometry.FlipNormals"},{id:"cbx10az6b",uiAttribs:{},portsIn:[{name:"Height",value:.23},{name:"Smooth",value:1},{name:"Walls",value:1},{name:"Top",value:1},{name:"Bottom",value:1}],portsOut:[{name:"Result Geometry",links:[{portIn:"Geometry",portOut:"Result Geometry",objIn:"3fclm8bbe",objOut:"cbx10az6b"}]}],objName:"Ops.Graphics.Geometry.GeometryExtrude"},{id:"zydvs0axq",uiAttribs:{},portsIn:[{name:"Letter Spacing",value:0}],portsOut:[{name:"Path String",links:[{portIn:"SVG Path",portOut:"Path String",objIn:"xura24sga",objOut:"zydvs0axq"}]}],objName:"Ops.Extension.OpenType.OpentypeToSvgPath"},{id:"xura24sga",uiAttribs:{},portsIn:[{name:"Bezier Stepsize",value:3},{name:"Rescale",value:2.19}],portsOut:[{name:"Geometry",links:[{portIn:"Geometry",portOut:"Geometry",objIn:"cbx10az6b",objOut:"xura24sga"}]}],objName:"Ops.Graphics.Geometry.SvgPathToGeometry_v2"},{id:"n4lcgd4bf",uiAttribs:{},portsIn:[{name:"Render Mesh",value:1},{name:"Add Vertex Numbers",value:1}],objName:"Ops.Gl.RenderGeometry_v2"},{id:"6wn6bkxmj",uiAttribs:{},portsIn:[{name:"posX",value:-1.5},{name:"posZ",value:2.1},{name:"scale",value:.6}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"l68s730ra",objOut:"6wn6bkxmj"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"l68s730ra",uiAttribs:{},portsIn:[{name:"r",value:.9301302083333334},{name:"g",value:.9301302083333334},{name:"b",value:.9301302083333334},{name:"AO Intensity",value:1},{name:"Normal Map Intensity",value:1},{name:"Repeat X",value:1},{name:"Repeat Y",value:1},{name:"Offset X",value:0},{name:"Offset Y",value:0},{name:"Double Sided",value:0},{name:"Screen Space Normals",value:0},{name:"Calc normal tangents",value:1},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"}],portsOut:[{name:"Next",links:[{portIn:"render",portOut:"Next",objIn:"n4lcgd4bf",objOut:"l68s730ra"}]}],objName:"Ops.Gl.Shader.MatCapMaterial_v3"},{id:"8q528zen2",uiAttribs:{},portsIn:[{name:"value",value:"Tim Newson"}],portsOut:[{name:"String",links:[{portIn:"Text",portOut:"String",objIn:"zydvs0axq",objOut:"8q528zen2"}]}],objName:"Ops.String.String_v2"},{id:"zxck3stk1",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"vv1pimh7d",objOut:"zxck3stk1"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"zp5zlz447",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"fced37fe-5305-4dc5-8fdd-c3fd239d824e",objOut:"zp5zlz447"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"1pfb0qo10",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"ivjut704c",objOut:"1pfb0qo10"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"6g00zcjp5",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.09}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"1pfb0qo10",objOut:"6g00zcjp5"}]}],objName:"Ops.Anim.LFO"},{id:"eaug8vys6",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"6g00zcjp5",objOut:"eaug8vys6"}]}],objName:"Ops.Anim.Timer_v2"},{id:"i3i8vsddm",uiAttribs:{},portsIn:[{name:"posY",value:.35},{name:"posZ",value:1.57},{name:"scale",value:1.1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"ihncfhmag",objOut:"i3i8vsddm"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"4o7b5nrno",uiAttribs:{},portsIn:[{name:"Cast Light",value:1},{name:"Intensity",value:1},{name:"X",value:0},{name:"Y",value:3.68},{name:"Z",value:5},{name:"R",value:1},{name:"G",value:1},{name:"B",value:1},{name:"Specular R",value:.2},{name:"Specular G",value:.2},{name:"Specular B",value:.2},{name:"Cast Shadow",value:0},{name:"Rendering Active",value:1},{name:"Map Size index",value:1},{name:"Map Size",value:512},{name:"Shadow Strength",value:1},{name:"LR-BottomTop",value:8},{name:"Near",value:.1},{name:"Far",value:30},{name:"Bias",value:.004},{name:"Polygon Offset",value:0},{name:"Normal Offset",value:0},{name:"Blur Amount",value:0},{name:"Enable Advanced",value:0},{name:"MSAA index",value:0},{name:"MSAA",value:"none"},{name:"Texture Filter index",value:0},{name:"Texture Filter",value:"Linear"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"}],portsOut:[{name:"Trigger Out",links:[{portIn:"exe",portOut:"Trigger Out",objIn:"5d394820-d452-4060-9b6b-506f93e2b62b",objOut:"4o7b5nrno"}]}],objName:"Ops.Gl.Phong.DirectionalLight_v5"},{id:"1tys6iklw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"1pfb0qo10",objOut:"1tys6iklw"}]}],objName:"Ops.Anim.LFO"},{id:"a9dtajbya",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"1tys6iklw",objOut:"a9dtajbya"}]}],objName:"Ops.Anim.Timer_v2"},{id:"3otn8pnv0",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"1pfb0qo10",objOut:"3otn8pnv0"}]}],objName:"Ops.Anim.LFO"},{id:"efb6vbhq5",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"3otn8pnv0",objOut:"efb6vbhq5"}]}],objName:"Ops.Anim.Timer_v2"},{id:"tf5z81djj",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"1pfb0qo10",objOut:"tf5z81djj"}]}],objName:"Ops.Anim.LFO"},{id:"ew0ujz9os",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"tf5z81djj",objOut:"ew0ujz9os"}]}],objName:"Ops.Anim.Timer_v2"},{id:"311wu6rsw",uiAttribs:{},portsIn:[{name:"Intensity",value:1},{name:"Size Irradiance map index",value:2},{name:"Size Irradiance map",value:64},{name:"Size pre-filtered environment index",value:1},{name:"Size pre-filtered environment",value:128},{name:"Size IBL LUT index",value:1},{name:"Size IBL LUT",value:256},{name:"Force 8bit IBL",value:1},{name:"Environment map does not contain RGBE data",value:0},{name:"Rotation",value:.44},{name:"Use parallax correction",value:0},{name:"center X",value:0},{name:"center Y",value:1.8},{name:"center Z",value:0},{name:"Box min X",value:-1},{name:"Box min Y",value:-1},{name:"Box min Z",value:-1},{name:"Box max X",value:1},{name:"Box max Y",value:1},{name:"Box max Z",value:1}],portsOut:[{name:"next",links:[{portIn:"render",portOut:"next",objIn:"bb345986-53df-4de8-bc24-5281a04ff57d",objOut:"311wu6rsw"}]},{name:"Number of Pre-filtered mip levels",value:7}],objName:"Ops.Gl.Pbr.PbrEnvironmentLight"},{id:"43xi4lpu6",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fond__1_.rgbe.png",display:"file"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:0},{name:"Wrap",value:"repeat"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"},{name:"Data Format index",value:3},{name:"Data Format",value:"RGBA"},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0},{name:"Active",value:1},{name:"Save Memory",value:1},{name:"Add Cachebuster",value:0}],portsOut:[{name:"Texture",links:[{portIn:"RGBE Environment map",portOut:"Texture",objIn:"311wu6rsw",objOut:"43xi4lpu6"},{portIn:"Skybox",portOut:"Texture",objIn:"a8fseo4cp",objOut:"43xi4lpu6"}]},{name:"Width",value:3644},{name:"Height",value:2050},{name:"Aspect Ratio",value:1.7775609756097561},{name:"Loaded",value:1},{name:"Loading",value:0}],objName:"Ops.Gl.Texture_v2"},{id:"a8fseo4cp",uiAttribs:{},portsIn:[{name:"Render",value:1},{name:"Rotate",value:0},{name:"RGBE Format",value:1},{name:"Exposure",value:1},{name:"Gamma",value:2.2}],objName:"Ops.Gl.CubeMap.Skybox"},{id:"8juazn4zj",uiAttribs:{},portsIn:[{name:"Active",value:0}],portsOut:[{name:"Next",links:[{portIn:"render",portOut:"Next",objIn:"311wu6rsw",objOut:"8juazn4zj"},{portIn:"Trigger In",portOut:"Next",objIn:"a8fseo4cp",objOut:"8juazn4zj"}]}],objName:"Ops.Gl.Meshes.FloorGrid"},{id:"ymxnvolbh",uiAttribs:{},portsIn:[{name:"Font File",value:"assets/NovaCut-Regular.ttf",display:"file"}],portsOut:[{name:"Opentype Font",links:[{portIn:"Opentype Font",portOut:"Opentype Font",objIn:"zydvs0axq",objOut:"ymxnvolbh"}]}],objName:"Ops.Extension.OpenType.OpentypeFont"},{id:"ek3svqvd1",uiAttribs:{},portsIn:[{name:"File",value:"assets/Texture_chrome_argente_e.avif",display:"file"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:0},{name:"Wrap",value:"repeat"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"},{name:"Data Format index",value:1},{name:"Data Format",value:"RG"},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0},{name:"Active",value:1},{name:"Save Memory",value:1},{name:"Add Cachebuster",value:0}],portsOut:[{name:"Texture",links:[{portIn:"Normal",portOut:"Texture",objIn:"l68s730ra",objOut:"ek3svqvd1"}]},{name:"Width",value:626},{name:"Height",value:418},{name:"Aspect Ratio",value:1.4976076555023923},{name:"Loaded",value:1},{name:"Loading",value:0}],objName:"Ops.Gl.Texture_v2"},{id:"opylu4yxi",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.02}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"6wn6bkxmj",objOut:"opylu4yxi"},{portIn:"posY",portOut:"Result",objIn:"t7fcxmzdn",objOut:"opylu4yxi"}]}],objName:"Ops.Anim.LFO"},{id:"wwsrq446j",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"opylu4yxi",objOut:"wwsrq446j"}]}],objName:"Ops.Anim.Timer_v2"},{id:"ll10krddg",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-1}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"6wn6bkxmj",objOut:"ll10krddg"},{portIn:"rotX",portOut:"Result",objIn:"t7fcxmzdn",objOut:"ll10krddg"}]}],objName:"Ops.Anim.LFO"},{id:"qpt39hj3v",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"ll10krddg",objOut:"qpt39hj3v"}]}],objName:"Ops.Anim.Timer_v2"},{id:"2nfs5b3xi",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-1}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"6wn6bkxmj",objOut:"2nfs5b3xi"},{portIn:"rotY",portOut:"Result",objIn:"t7fcxmzdn",objOut:"2nfs5b3xi"}]}],objName:"Ops.Anim.LFO"},{id:"4kty92dcf",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"2nfs5b3xi",objOut:"4kty92dcf"}]}],objName:"Ops.Anim.Timer_v2"},{id:"t8kyl5iuq",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-1}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"6wn6bkxmj",objOut:"t8kyl5iuq"},{portIn:"rotZ",portOut:"Result",objIn:"t7fcxmzdn",objOut:"t8kyl5iuq"}]}],objName:"Ops.Anim.LFO"},{id:"eqt2lovpn",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"t8kyl5iuq",objOut:"eqt2lovpn"}]}],objName:"Ops.Anim.Timer_v2"},{id:"wgbb54iaa",uiAttribs:{},portsIn:[{name:"Text",value:"reset"},{name:"Grey Out",value:0},{name:"Visible",value:1}],portsOut:[{name:"Pressed Trigger",links:[{portIn:"Set Default Value",portOut:"Pressed Trigger",objIn:"fiq06coor",objOut:"wgbb54iaa"}]}],objName:"Ops.Sidebar.Button_v2"},{id:"ogcwrw3nt",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:1},{name:"new min",value:2},{name:"new max",value:.1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"Number",portOut:"result",objIn:"idgf53jzd",objOut:"ogcwrw3nt"},{portIn:"scale",portOut:"result",objIn:"zxck3stk1",objOut:"ogcwrw3nt"}]}],objName:"Ops.Math.MapRange"},{id:"idgf53jzd",uiAttribs:{},portsOut:[{name:"Result",value:.1}],objName:"Ops.Ui.VizNumber"},{id:"vv1pimh7d",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:.21},{name:"posZ",value:-.45},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"6wn6bkxmj",objOut:"vv1pimh7d"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"erw47mfj8",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:1},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"ihncfhmag",objOut:"erw47mfj8"},{portIn:"a",portOut:"result",objIn:"6clkyjkpf",objOut:"erw47mfj8"}]}],objName:"Ops.Math.MapRange"},{id:"ihncfhmag",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"1pfb0qo10",objOut:"ihncfhmag"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"ivjut704c",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/ASM_-_PBR_Metallic_Roughness.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"6clkyjkpf",objOut:"ivjut704c"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"7e55p6u4o",objOut:"ivjut704c"}]},{name:"Generator",value:"Adobe Substance 3D Painter 11.0.0"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"to9jfhx8j",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.002"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"ivjut704c",objOut:"to9jfhx8j"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"7e55p6u4o",uiAttribs:{},portsIn:[{name:"Name",value:"5"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"6clkyjkpf",objOut:"7e55p6u4o"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"6clkyjkpf",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"to9jfhx8j",objOut:"6clkyjkpf"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"tp4hm56fc",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:.7},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"Opacity",portOut:"result",objIn:"l68s730ra",objOut:"tp4hm56fc"}]}],objName:"Ops.Math.MapRange"},{id:"6xsw0o9sn",uiAttribs:{},portsIn:[{name:"old min",value:1.5},{name:"old max",value:2},{name:"new min",value:0},{name:"new max",value:-2.88},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"posX",portOut:"result",objIn:"i3i8vsddm",objOut:"6xsw0o9sn"}]}],objName:"Ops.Math.MapRange"},{id:"lc413h822",uiAttribs:{},portsIn:[{name:"old min",value:1.3},{name:"old max",value:2},{name:"new min",value:0},{name:"new max",value:390},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"rotY",portOut:"result",objIn:"i3i8vsddm",objOut:"lc413h822"}]}],objName:"Ops.Math.MapRange"},{id:"kl6r28p3t",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"d8uzqg4o9",objOut:"kl6r28p3t"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"7ipwdnuun",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.5}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"kl6r28p3t",objOut:"7ipwdnuun"}]}],objName:"Ops.Anim.LFO"},{id:"7ih1h11su",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"7ipwdnuun",objOut:"7ih1h11su"}]}],objName:"Ops.Anim.Timer_v2"},{id:"v2wl3w6xs",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"kl6r28p3t",objOut:"v2wl3w6xs"}]}],objName:"Ops.Anim.LFO"},{id:"uacvutupq",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"v2wl3w6xs",objOut:"uacvutupq"}]}],objName:"Ops.Anim.Timer_v2"},{id:"q2v6b1tdc",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"kl6r28p3t",objOut:"q2v6b1tdc"}]}],objName:"Ops.Anim.LFO"},{id:"zov3myaxz",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"q2v6b1tdc",objOut:"zov3myaxz"}]}],objName:"Ops.Anim.Timer_v2"},{id:"oac3mfptw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"kl6r28p3t",objOut:"oac3mfptw"}]}],objName:"Ops.Anim.LFO"},{id:"dsei1o00x",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"oac3mfptw",objOut:"dsei1o00x"}]}],objName:"Ops.Anim.Timer_v2"},{id:"yleqhsvjy",uiAttribs:{},portsIn:[{name:"posX",value:1.47},{name:"posY",value:0},{name:"posZ",value:0},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"qb8z9akwc",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"b81xwe6mu",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"gg0qhd8bl",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"5dwdmcmkr",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"1f0pi7ar8",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"0pox45rpy",objOut:"yleqhsvjy"},{portIn:"render",portOut:"trigger",objIn:"p0x5scj4h",objOut:"yleqhsvjy"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"qb8z9akwc",uiAttribs:{},portsIn:[{name:"posX",value:.89},{name:"posY",value:.29},{name:"posZ",value:2.0311018918773547},{name:"scale",value:.35},{name:"rotX",value:-40.12},{name:"rotY",value:-.23},{name:"rotZ",value:37.09}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"kl6r28p3t",objOut:"qb8z9akwc"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"6hbiy2stw",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"5ep5u1934",objOut:"6hbiy2stw"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"59puvov3q",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:.75}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"6hbiy2stw",objOut:"59puvov3q"}]}],objName:"Ops.Anim.LFO"},{id:"ljmi2fhcp",uiAttribs:{},portsIn:[{name:"Speed",value:.07},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"59puvov3q",objOut:"ljmi2fhcp"}]}],objName:"Ops.Anim.Timer_v2"},{id:"g0emb5hgv",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"6hbiy2stw",objOut:"g0emb5hgv"}]}],objName:"Ops.Anim.LFO"},{id:"5ogwfgbil",uiAttribs:{},portsIn:[{name:"Speed",value:.19},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"g0emb5hgv",objOut:"5ogwfgbil"}]}],objName:"Ops.Anim.Timer_v2"},{id:"wj6latqc3",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"6hbiy2stw",objOut:"wj6latqc3"}]}],objName:"Ops.Anim.LFO"},{id:"czp5rhyyl",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"wj6latqc3",objOut:"czp5rhyyl"}]}],objName:"Ops.Anim.Timer_v2"},{id:"9ai2y26le",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-10}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"6hbiy2stw",objOut:"9ai2y26le"}]}],objName:"Ops.Anim.LFO"},{id:"e2x62rnq4",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"9ai2y26le",objOut:"e2x62rnq4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"b81xwe6mu",uiAttribs:{},portsIn:[{name:"posX",value:-.45},{name:"posY",value:-.91},{name:"posZ",value:2.251},{name:"scale",value:.4},{name:"rotX",value:-42.05},{name:"rotY",value:-135.58},{name:"rotZ",value:-39.88}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"6hbiy2stw",objOut:"b81xwe6mu"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"4kjawzd5h",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"5eh0752y4",objOut:"4kjawzd5h"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"zrtp5w8ng",objOut:"4kjawzd5h"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"zrtp5w8ng",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"5eh0752y4",objOut:"zrtp5w8ng"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"ub7dnhu9t",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"4kjawzd5h",objOut:"ub7dnhu9t"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"urd1nihbd",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"4kjawzd5h",objOut:"urd1nihbd"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"eyg0jh224",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:.5}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"urd1nihbd",objOut:"eyg0jh224"}]}],objName:"Ops.Anim.LFO"},{id:"wy0boz9sy",uiAttribs:{},portsIn:[{name:"Speed",value:.07},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"eyg0jh224",objOut:"wy0boz9sy"}]}],objName:"Ops.Anim.Timer_v2"},{id:"6mg3xfuoc",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"urd1nihbd",objOut:"6mg3xfuoc"}]}],objName:"Ops.Anim.LFO"},{id:"xbhs7ldqy",uiAttribs:{},portsIn:[{name:"Speed",value:.19},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"6mg3xfuoc",objOut:"xbhs7ldqy"}]}],objName:"Ops.Anim.Timer_v2"},{id:"2pbkf4wuu",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"urd1nihbd",objOut:"2pbkf4wuu"}]}],objName:"Ops.Anim.LFO"},{id:"apq7640fp",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"2pbkf4wuu",objOut:"apq7640fp"}]}],objName:"Ops.Anim.Timer_v2"},{id:"ikxzdvrk3",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-7}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"urd1nihbd",objOut:"ikxzdvrk3"}]}],objName:"Ops.Anim.LFO"},{id:"hbjcs6dbh",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"ikxzdvrk3",objOut:"hbjcs6dbh"}]}],objName:"Ops.Anim.Timer_v2"},{id:"gg0qhd8bl",uiAttribs:{},portsIn:[{name:"posX",value:-3.49},{name:"posY",value:-.86},{name:"posZ",value:1.761},{name:"scale",value:.58},{name:"rotX",value:-38.98},{name:"rotY",value:-295.15},{name:"rotZ",value:-23.2}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"urd1nihbd",objOut:"gg0qhd8bl"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"a89tj4ghl",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"z4cfo6q9k",objOut:"a89tj4ghl"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"3mgi2k0da",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:.5}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"a89tj4ghl",objOut:"3mgi2k0da"}]}],objName:"Ops.Anim.LFO"},{id:"e8vbbf3au",uiAttribs:{},portsIn:[{name:"Speed",value:.07},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"3mgi2k0da",objOut:"e8vbbf3au"}]}],objName:"Ops.Anim.Timer_v2"},{id:"d7dywwysa",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"a89tj4ghl",objOut:"d7dywwysa"}]}],objName:"Ops.Anim.LFO"},{id:"fdqmomlbq",uiAttribs:{},portsIn:[{name:"Speed",value:.19},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"d7dywwysa",objOut:"fdqmomlbq"}]}],objName:"Ops.Anim.Timer_v2"},{id:"qe7w9ro86",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"a89tj4ghl",objOut:"qe7w9ro86"}]}],objName:"Ops.Anim.LFO"},{id:"tn8jtbpc4",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"qe7w9ro86",objOut:"tn8jtbpc4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"vmpw7eq9g",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-7}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"a89tj4ghl",objOut:"vmpw7eq9g"}]}],objName:"Ops.Anim.LFO"},{id:"6rqrvzscs",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"vmpw7eq9g",objOut:"6rqrvzscs"}]}],objName:"Ops.Anim.Timer_v2"},{id:"5dwdmcmkr",uiAttribs:{},portsIn:[{name:"posX",value:-4.48},{name:"posY",value:.66},{name:"posZ",value:1.981},{name:"scale",value:.4},{name:"rotX",value:-30.52},{name:"rotY",value:-350.04},{name:"rotZ",value:-86.18}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"a89tj4ghl",objOut:"5dwdmcmkr"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"5eh0752y4",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"ub7dnhu9t",objOut:"5eh0752y4"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"6hrlm9ugf",uiAttribs:{},portsIn:[{name:"value",value:"Tim Newson is a wacky contemporary artist of \nAustralian nationality born in Otawa in the 70s\nHe transforms everyday objects into totally\nabsurd sculptures that blend fragility and prestige.\nThrough misappropriation and absurdity, he questions\nconsumer society and its excesses with biting irony.\nHe likes to think out of the box, to come up with\never more original and fantastic creations."},{name:"Syntax index",value:1},{name:"Syntax",value:"glsl"}],portsOut:[{name:"Result",links:[{portIn:"Text",portOut:"Result",objIn:"8931dy4a0",objOut:"6hrlm9ugf"}]}],objName:"Ops.String.StringEditor"},{id:"8931dy4a0",uiAttribs:{},portsIn:[{name:"Scale Text",value:1},{name:"Scale",value:1,title:"Line Scale"},{name:"Font",value:"SpaceGrotesk"},{name:"align index",value:0},{name:"align",value:"left"},{name:"vertical align index",value:1},{name:"vertical align",value:"Middle"},{name:"Line Height",value:1},{name:"Letter Spacing",value:0},{name:"filter index",value:0},{name:"filter",value:"nearest"},{name:"Anisotropic index",value:5},{name:"Anisotropic",value:"16"},{name:"r",value:1},{name:"g",value:1},{name:"b",value:1}],portsOut:[{name:"Total Lines",value:8},{name:"Width",value:18.881567879328657},{name:"Font Available",value:1}],objName:"Ops.Gl.Meshes.TextMesh_v2"},{id:"a8z5esw0v",uiAttribs:{},portsIn:[{name:"scale",value:.3},{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"8931dy4a0",objOut:"a8z5esw0v"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"60qipgsr2",uiAttribs:{},portsIn:[{name:"posX",value:-1.42},{name:"posY",value:.36},{name:"posZ",value:.18},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:-4.9},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"a8z5esw0v",objOut:"60qipgsr2"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"67t99dbze",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"ddj43z5ou",objOut:"67t99dbze"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"zzrr5btjn",objOut:"67t99dbze"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"zzrr5btjn",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"ddj43z5ou",objOut:"zzrr5btjn"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"lcvexpb0g",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"67t99dbze",objOut:"lcvexpb0g"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"ddj43z5ou",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"lcvexpb0g",objOut:"ddj43z5ou"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"8uhtqufbx",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"67t99dbze",objOut:"8uhtqufbx"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"p3ty4e29p",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.43}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"8uhtqufbx",objOut:"p3ty4e29p"}]}],objName:"Ops.Anim.LFO"},{id:"q7m7r5bjx",uiAttribs:{},portsIn:[{name:"Speed",value:.19},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"p3ty4e29p",objOut:"q7m7r5bjx"}]}],objName:"Ops.Anim.Timer_v2"},{id:"86crb0edj",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.48}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"8uhtqufbx",objOut:"86crb0edj"}]}],objName:"Ops.Anim.LFO"},{id:"otobck3zd",uiAttribs:{},portsIn:[{name:"Speed",value:.24},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"86crb0edj",objOut:"otobck3zd"}]}],objName:"Ops.Anim.Timer_v2"},{id:"g0nx4fkag",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-1.64}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"8uhtqufbx",objOut:"g0nx4fkag"}]}],objName:"Ops.Anim.LFO"},{id:"xw4exbqhg",uiAttribs:{},portsIn:[{name:"Speed",value:.13},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"g0nx4fkag",objOut:"xw4exbqhg"}]}],objName:"Ops.Anim.Timer_v2"},{id:"vazq8ayo2",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"8uhtqufbx",objOut:"vazq8ayo2"}]}],objName:"Ops.Anim.LFO"},{id:"fskszbtmv",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"vazq8ayo2",objOut:"fskszbtmv"}]}],objName:"Ops.Anim.Timer_v2"},{id:"1f0pi7ar8",uiAttribs:{},portsIn:[{name:"posX",value:.73},{name:"posY",value:2.21},{name:"posZ",value:.681},{name:"scale",value:.47},{name:"rotX",value:-114.01},{name:"rotY",value:-60.7},{name:"rotZ",value:47.04}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"8uhtqufbx",objOut:"1f0pi7ar8"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"16as0jgsa",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"3wg5rdjv1",objOut:"16as0jgsa"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"jqwj9h8na",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.5}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"16as0jgsa",objOut:"jqwj9h8na"}]}],objName:"Ops.Anim.LFO"},{id:"bpxp4gzc6",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"jqwj9h8na",objOut:"bpxp4gzc6"}]}],objName:"Ops.Anim.Timer_v2"},{id:"djfrg8xsz",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"16as0jgsa",objOut:"djfrg8xsz"}]}],objName:"Ops.Anim.LFO"},{id:"9y6guq20s",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"djfrg8xsz",objOut:"9y6guq20s"}]}],objName:"Ops.Anim.Timer_v2"},{id:"xtqyzhlva",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"16as0jgsa",objOut:"xtqyzhlva"}]}],objName:"Ops.Anim.LFO"},{id:"dxskupi60",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"xtqyzhlva",objOut:"dxskupi60"}]}],objName:"Ops.Anim.Timer_v2"},{id:"8hc01v426",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"16as0jgsa",objOut:"8hc01v426"}]}],objName:"Ops.Anim.LFO"},{id:"ycau2j04g",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"8hc01v426",objOut:"ycau2j04g"}]}],objName:"Ops.Anim.Timer_v2"},{id:"0pox45rpy",uiAttribs:{},portsIn:[{name:"posX",value:-1.88},{name:"posY",value:2.9},{name:"posZ",value:1.611},{name:"scale",value:.32},{name:"rotX",value:-114.01},{name:"rotY",value:-76.06},{name:"rotZ",value:47.04}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"16as0jgsa",objOut:"0pox45rpy"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"b7thw4prj",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"a38gdy7ld",objOut:"b7thw4prj"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"ze7hz6eja",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.45}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"b7thw4prj",objOut:"ze7hz6eja"}]}],objName:"Ops.Anim.LFO"},{id:"d1q6snd8n",uiAttribs:{},portsIn:[{name:"Speed",value:.14},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"ze7hz6eja",objOut:"d1q6snd8n"}]}],objName:"Ops.Anim.Timer_v2"},{id:"3vjcwwdnz",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.11}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"b7thw4prj",objOut:"3vjcwwdnz"}]}],objName:"Ops.Anim.LFO"},{id:"ymdztja5a",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"3vjcwwdnz",objOut:"ymdztja5a"}]}],objName:"Ops.Anim.Timer_v2"},{id:"u7bbszfmh",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.07}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"b7thw4prj",objOut:"u7bbszfmh"}]}],objName:"Ops.Anim.LFO"},{id:"1cwsxdoc8",uiAttribs:{},portsIn:[{name:"Speed",value:.13},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"u7bbszfmh",objOut:"1cwsxdoc8"}]}],objName:"Ops.Anim.Timer_v2"},{id:"l1nnchr0v",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.03}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"b7thw4prj",objOut:"l1nnchr0v"}]}],objName:"Ops.Anim.LFO"},{id:"a9lumqb9c",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"l1nnchr0v",objOut:"a9lumqb9c"}]}],objName:"Ops.Anim.Timer_v2"},{id:"p0x5scj4h",uiAttribs:{},portsIn:[{name:"posX",value:-4.18},{name:"posY",value:2.27},{name:"posZ",value:1.431},{name:"scale",value:.47},{name:"rotX",value:-103.01},{name:"rotY",value:-126.46},{name:"rotZ",value:68.48}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"b7thw4prj",objOut:"p0x5scj4h"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"hgo5fgjdc",uiAttribs:{},portsIn:[{name:"posZ",value:1.86},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"yleqhsvjy",objOut:"hgo5fgjdc"},{portIn:"render",portOut:"trigger",objIn:"0qo3zzkzb",objOut:"hgo5fgjdc"},{portIn:"render",portOut:"trigger",objIn:"crux8nd7k",objOut:"hgo5fgjdc"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"crux8nd7k",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:.82},{name:"posZ",value:-5.49},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"7v6me6mbh",objOut:"crux8nd7k"},{portIn:"render",portOut:"trigger",objIn:"0fprk9k9x",objOut:"crux8nd7k"},{portIn:"render",portOut:"trigger",objIn:"6z0nhj2rn",objOut:"crux8nd7k"},{portIn:"render",portOut:"trigger",objIn:"gh4njh5wp",objOut:"crux8nd7k"},{portIn:"render",portOut:"trigger",objIn:"4viv9znne",objOut:"crux8nd7k"},{portIn:"render",portOut:"trigger",objIn:"rxkj6h69p",objOut:"crux8nd7k"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"rdu49yabf",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"b9t76uamr",objOut:"rdu49yabf"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"f5gft4xzl",objOut:"rdu49yabf"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"f5gft4xzl",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"b9t76uamr",objOut:"f5gft4xzl"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"1zr0t6fo7",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"rdu49yabf",objOut:"1zr0t6fo7"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"hqrxc6fc1",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"rdu49yabf",objOut:"hqrxc6fc1"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"pw9l9yk08",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.45}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"hqrxc6fc1",objOut:"pw9l9yk08"}]}],objName:"Ops.Anim.LFO"},{id:"tgzgafvqm",uiAttribs:{},portsIn:[{name:"Speed",value:.14},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"pw9l9yk08",objOut:"tgzgafvqm"}]}],objName:"Ops.Anim.Timer_v2"},{id:"q14wsvav0",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.11}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"hqrxc6fc1",objOut:"q14wsvav0"}]}],objName:"Ops.Anim.LFO"},{id:"0g6hc25mu",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"q14wsvav0",objOut:"0g6hc25mu"}]}],objName:"Ops.Anim.Timer_v2"},{id:"awzj8ey60",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.07}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"hqrxc6fc1",objOut:"awzj8ey60"}]}],objName:"Ops.Anim.LFO"},{id:"374d57sj4",uiAttribs:{},portsIn:[{name:"Speed",value:.13},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"awzj8ey60",objOut:"374d57sj4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"2vm448wzj",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.03}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"hqrxc6fc1",objOut:"2vm448wzj"}]}],objName:"Ops.Anim.LFO"},{id:"v35gvctua",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"2vm448wzj",objOut:"v35gvctua"}]}],objName:"Ops.Anim.Timer_v2"},{id:"gh4njh5wp",uiAttribs:{},portsIn:[{name:"posX",value:-2.36},{name:"posY",value:2.16},{name:"posZ",value:1.431},{name:"scale",value:.47},{name:"rotX",value:-175.2},{name:"rotY",value:-19.65},{name:"rotZ",value:-31.58}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"hqrxc6fc1",objOut:"gh4njh5wp"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"b9t76uamr",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"1zr0t6fo7",objOut:"b9t76uamr"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"i2fjo1kee",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"f280152n1",objOut:"i2fjo1kee"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"7112hfssc",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.45}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"i2fjo1kee",objOut:"7112hfssc"}]}],objName:"Ops.Anim.LFO"},{id:"b7flwpxes",uiAttribs:{},portsIn:[{name:"Speed",value:.14},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"7112hfssc",objOut:"b7flwpxes"}]}],objName:"Ops.Anim.Timer_v2"},{id:"elosu1eyf",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.11}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"i2fjo1kee",objOut:"elosu1eyf"}]}],objName:"Ops.Anim.LFO"},{id:"uoceuag4e",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"elosu1eyf",objOut:"uoceuag4e"}]}],objName:"Ops.Anim.Timer_v2"},{id:"11sle2ce5",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.07}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"i2fjo1kee",objOut:"11sle2ce5"}]}],objName:"Ops.Anim.LFO"},{id:"3hyggwlhz",uiAttribs:{},portsIn:[{name:"Speed",value:.13},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"11sle2ce5",objOut:"3hyggwlhz"}]}],objName:"Ops.Anim.Timer_v2"},{id:"8xw1jgz4b",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.03}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"i2fjo1kee",objOut:"8xw1jgz4b"}]}],objName:"Ops.Anim.LFO"},{id:"b7zvm582h",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"8xw1jgz4b",objOut:"b7zvm582h"}]}],objName:"Ops.Anim.Timer_v2"},{id:"7v6me6mbh",uiAttribs:{},portsIn:[{name:"posX",value:2.82},{name:"posY",value:3.19},{name:"posZ",value:-3.349},{name:"scale",value:.6},{name:"rotX",value:-202.75},{name:"rotY",value:30.48},{name:"rotZ",value:10.9}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"i2fjo1kee",objOut:"7v6me6mbh"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"nrqb05xqz",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"h9943kuwf",objOut:"nrqb05xqz"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"vuhyb9as0",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.23}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"nrqb05xqz",objOut:"vuhyb9as0"}]}],objName:"Ops.Anim.LFO"},{id:"joim0cp33",uiAttribs:{},portsIn:[{name:"Speed",value:.11},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"vuhyb9as0",objOut:"joim0cp33"}]}],objName:"Ops.Anim.Timer_v2"},{id:"rpucidasn",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.36}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"nrqb05xqz",objOut:"rpucidasn"}]}],objName:"Ops.Anim.LFO"},{id:"mqih13xrm",uiAttribs:{},portsIn:[{name:"Speed",value:.28},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"rpucidasn",objOut:"mqih13xrm"}]}],objName:"Ops.Anim.Timer_v2"},{id:"hd8yro741",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.61}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"nrqb05xqz",objOut:"hd8yro741"}]}],objName:"Ops.Anim.LFO"},{id:"bb9ber68r",uiAttribs:{},portsIn:[{name:"Speed",value:.55},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"hd8yro741",objOut:"bb9ber68r"}]}],objName:"Ops.Anim.Timer_v2"},{id:"mprj9arfh",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.29}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"nrqb05xqz",objOut:"mprj9arfh"}]}],objName:"Ops.Anim.LFO"},{id:"c7iqznwth",uiAttribs:{},portsIn:[{name:"Speed",value:.32},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"mprj9arfh",objOut:"c7iqznwth"}]}],objName:"Ops.Anim.Timer_v2"},{id:"0fprk9k9x",uiAttribs:{},portsIn:[{name:"posX",value:4.92},{name:"posY",value:.04},{name:"posZ",value:1.421},{name:"scale",value:.51},{name:"rotX",value:-126.41},{name:"rotY",value:-152.88},{name:"rotZ",value:-48.93}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"nrqb05xqz",objOut:"0fprk9k9x"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"18vkllxq3",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"n57m0ku4g",objOut:"18vkllxq3"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"w1swbz8zz",objOut:"18vkllxq3"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"w1swbz8zz",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"n57m0ku4g",objOut:"w1swbz8zz"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"x0ntpa4ev",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"18vkllxq3",objOut:"x0ntpa4ev"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"o85cz2c09",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"18vkllxq3",objOut:"o85cz2c09"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"aqvv4nt2r",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.23}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"o85cz2c09",objOut:"aqvv4nt2r"}]}],objName:"Ops.Anim.LFO"},{id:"lvjpvlc2v",uiAttribs:{},portsIn:[{name:"Speed",value:.11},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"aqvv4nt2r",objOut:"lvjpvlc2v"}]}],objName:"Ops.Anim.Timer_v2"},{id:"kqde8vycw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.36}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"o85cz2c09",objOut:"kqde8vycw"}]}],objName:"Ops.Anim.LFO"},{id:"4lhbbic3e",uiAttribs:{},portsIn:[{name:"Speed",value:.28},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"kqde8vycw",objOut:"4lhbbic3e"}]}],objName:"Ops.Anim.Timer_v2"},{id:"h7799fkyz",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.61}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"o85cz2c09",objOut:"h7799fkyz"}]}],objName:"Ops.Anim.LFO"},{id:"mtpnwyb48",uiAttribs:{},portsIn:[{name:"Speed",value:.55},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"h7799fkyz",objOut:"mtpnwyb48"}]}],objName:"Ops.Anim.Timer_v2"},{id:"49waplbom",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.29}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"o85cz2c09",objOut:"49waplbom"}]}],objName:"Ops.Anim.LFO"},{id:"z976ohif3",uiAttribs:{},portsIn:[{name:"Speed",value:.32},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"49waplbom",objOut:"z976ohif3"}]}],objName:"Ops.Anim.Timer_v2"},{id:"6z0nhj2rn",uiAttribs:{},portsIn:[{name:"posX",value:4.23},{name:"posY",value:-3.72},{name:"posZ",value:-.019},{name:"scale",value:.6},{name:"rotX",value:-96.33},{name:"rotY",value:-118.73},{name:"rotZ",value:-81.03}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"o85cz2c09",objOut:"6z0nhj2rn"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"n57m0ku4g",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"x0ntpa4ev",objOut:"n57m0ku4g"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"sm1m7uriu",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"2kny1ch13",objOut:"sm1m7uriu"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"c58fcn8zq",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.23}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"sm1m7uriu",objOut:"c58fcn8zq"}]}],objName:"Ops.Anim.LFO"},{id:"6ely0ygb5",uiAttribs:{},portsIn:[{name:"Speed",value:.11},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"c58fcn8zq",objOut:"6ely0ygb5"}]}],objName:"Ops.Anim.Timer_v2"},{id:"p4964r6i6",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.36}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"sm1m7uriu",objOut:"p4964r6i6"}]}],objName:"Ops.Anim.LFO"},{id:"fr168fsp9",uiAttribs:{},portsIn:[{name:"Speed",value:.28},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"p4964r6i6",objOut:"fr168fsp9"}]}],objName:"Ops.Anim.Timer_v2"},{id:"3ihuo8j41",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.61}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"sm1m7uriu",objOut:"3ihuo8j41"}]}],objName:"Ops.Anim.LFO"},{id:"50ep607qr",uiAttribs:{},portsIn:[{name:"Speed",value:.55},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"3ihuo8j41",objOut:"50ep607qr"}]}],objName:"Ops.Anim.Timer_v2"},{id:"77n4bz8lw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.29}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"sm1m7uriu",objOut:"77n4bz8lw"}]}],objName:"Ops.Anim.LFO"},{id:"lqao7o62i",uiAttribs:{},portsIn:[{name:"Speed",value:.32},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"77n4bz8lw",objOut:"lqao7o62i"}]}],objName:"Ops.Anim.Timer_v2"},{id:"4viv9znne",uiAttribs:{},portsIn:[{name:"posX",value:-.25},{name:"posY",value:-3.153587566145818},{name:"posZ",value:1.581},{name:"scale",value:.6},{name:"rotX",value:-358.27},{name:"rotY",value:-293.85},{name:"rotZ",value:-30.29}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"sm1m7uriu",objOut:"4viv9znne"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"5ifi10mz1",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"qjfgm5ugq",objOut:"5ifi10mz1"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"bhkob8rdu",objOut:"5ifi10mz1"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"bhkob8rdu",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"qjfgm5ugq",objOut:"bhkob8rdu"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"opsfef3rf",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"5ifi10mz1",objOut:"opsfef3rf"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"595s2m2dx",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"5ifi10mz1",objOut:"595s2m2dx"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"9od9kxdue",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.24}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"595s2m2dx",objOut:"9od9kxdue"}]}],objName:"Ops.Anim.LFO"},{id:"jatpmligb",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"9od9kxdue",objOut:"jatpmligb"}]}],objName:"Ops.Anim.Timer_v2"},{id:"sthp4qq63",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.14}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"595s2m2dx",objOut:"sthp4qq63"}]}],objName:"Ops.Anim.LFO"},{id:"g54rp8df4",uiAttribs:{},portsIn:[{name:"Speed",value:.25},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"sthp4qq63",objOut:"g54rp8df4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"txn9wrila",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.08}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"595s2m2dx",objOut:"txn9wrila"}]}],objName:"Ops.Anim.LFO"},{id:"ph0584ovx",uiAttribs:{},portsIn:[{name:"Speed",value:.48},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"txn9wrila",objOut:"ph0584ovx"}]}],objName:"Ops.Anim.Timer_v2"},{id:"x0dxt3b3h",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-7.93}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"595s2m2dx",objOut:"x0dxt3b3h"}]}],objName:"Ops.Anim.LFO"},{id:"03x8lxnvt",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"x0dxt3b3h",objOut:"03x8lxnvt"}]}],objName:"Ops.Anim.Timer_v2"},{id:"rxkj6h69p",uiAttribs:{},portsIn:[{name:"posX",value:-3.98},{name:"posY",value:-1.57},{name:"posZ",value:1.541},{name:"scale",value:.6},{name:"rotX",value:-497.33},{name:"rotY",value:-389.45},{name:"rotZ",value:-130.66}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"595s2m2dx",objOut:"rxkj6h69p"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"qjfgm5ugq",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"opsfef3rf",objOut:"qjfgm5ugq"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"0qo3zzkzb",uiAttribs:{},portsIn:[{name:"posX",value:.32},{name:"posY",value:.62},{name:"posZ",value:-4.27},{name:"scale",value:.96},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"dbtxnyiu2",objOut:"0qo3zzkzb"},{portIn:"render",portOut:"trigger",objIn:"lp6pz46y3",objOut:"0qo3zzkzb"},{portIn:"render",portOut:"trigger",objIn:"i6r73qdir",objOut:"0qo3zzkzb"},{portIn:"render",portOut:"trigger",objIn:"cytawtejw",objOut:"0qo3zzkzb"},{portIn:"render",portOut:"trigger",objIn:"hf2uylwx0",objOut:"0qo3zzkzb"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"a6o5iza7d",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"d8k5ez925",objOut:"a6o5iza7d"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"6rt1p4dxf",objOut:"a6o5iza7d"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"6rt1p4dxf",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"d8k5ez925",objOut:"6rt1p4dxf"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"rc47nnqm7",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"a6o5iza7d",objOut:"rc47nnqm7"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"8z4mab9dn",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"a6o5iza7d",objOut:"8z4mab9dn"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"ols0tyxlc",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.71}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"8z4mab9dn",objOut:"ols0tyxlc"}]}],objName:"Ops.Anim.LFO"},{id:"q5lkzt4co",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"ols0tyxlc",objOut:"q5lkzt4co"}]}],objName:"Ops.Anim.Timer_v2"},{id:"rpiv9ucqr",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.34}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"8z4mab9dn",objOut:"rpiv9ucqr"}]}],objName:"Ops.Anim.LFO"},{id:"tkq22n8hk",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"rpiv9ucqr",objOut:"tkq22n8hk"}]}],objName:"Ops.Anim.Timer_v2"},{id:"4uvso9ai5",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.38}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"8z4mab9dn",objOut:"4uvso9ai5"}]}],objName:"Ops.Anim.LFO"},{id:"hwmbyzqo5",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"4uvso9ai5",objOut:"hwmbyzqo5"}]}],objName:"Ops.Anim.Timer_v2"},{id:"54m4y9pm7",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.53}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"8z4mab9dn",objOut:"54m4y9pm7"}]}],objName:"Ops.Anim.LFO"},{id:"2r70ni5ca",uiAttribs:{},portsIn:[{name:"Speed",value:.08},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"54m4y9pm7",objOut:"2r70ni5ca"}]}],objName:"Ops.Anim.Timer_v2"},{id:"dbtxnyiu2",uiAttribs:{},portsIn:[{name:"posX",value:-7.24},{name:"posY",value:1.68},{name:"posZ",value:1.101},{name:"scale",value:.68},{name:"rotX",value:-174.53},{name:"rotY",value:-37.95},{name:"rotZ",value:-87.5}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"8z4mab9dn",objOut:"dbtxnyiu2"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"d8k5ez925",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"rc47nnqm7",objOut:"d8k5ez925"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"t0f2mq3mm",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:1},{name:"new min",value:1},{name:"new max",value:1.48},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"yleqhsvjy",objOut:"t0f2mq3mm"}]}],objName:"Ops.Math.MapRange"},{id:"e12l5joth",uiAttribs:{},portsIn:[{name:"file",value:"assets/SpaceGrotesk-VariableFont_wght.ttf",display:"file"},{name:"family",value:"SpaceGrotesk"},{name:"Active",value:1}],portsOut:[{name:"Loaded",links:[{portIn:"a",portOut:"Loaded",objIn:"8931dy4a0",objOut:"e12l5joth"}]}],objName:"Ops.Html.FontFile_v2"},{id:"cqy5qhlh1",uiAttribs:{},portsIn:[{name:"File",value:"assets/Texture_chrome_argente_e.avif",display:"file"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:0},{name:"Wrap",value:"repeat"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"},{name:"Data Format index",value:3},{name:"Data Format",value:"RGBA"},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0},{name:"Active",value:1},{name:"Save Memory",value:1},{name:"Add Cachebuster",value:0}],portsOut:[{name:"Texture",links:[{portIn:"Texture Color",portOut:"Texture",objIn:"8931dy4a0",objOut:"cqy5qhlh1"}]},{name:"Width",value:626},{name:"Height",value:418},{name:"Aspect Ratio",value:1.4976076555023923},{name:"Loaded",value:1},{name:"Loading",value:0}],objName:"Ops.Gl.Texture_v2"},{id:"hojf0smr4",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"f3opeikum",objOut:"hojf0smr4"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"1cnll00y6",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.71}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"hojf0smr4",objOut:"1cnll00y6"}]}],objName:"Ops.Anim.LFO"},{id:"6l1okhf5d",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"1cnll00y6",objOut:"6l1okhf5d"}]}],objName:"Ops.Anim.Timer_v2"},{id:"s1zkaxh0o",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.34}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"hojf0smr4",objOut:"s1zkaxh0o"}]}],objName:"Ops.Anim.LFO"},{id:"3b3b2uh4t",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"s1zkaxh0o",objOut:"3b3b2uh4t"}]}],objName:"Ops.Anim.Timer_v2"},{id:"5rxo50t8r",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.38}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"hojf0smr4",objOut:"5rxo50t8r"}]}],objName:"Ops.Anim.LFO"},{id:"472ono6w4",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"5rxo50t8r",objOut:"472ono6w4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"yvcuxz6fu",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.53}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"hojf0smr4",objOut:"yvcuxz6fu"}]}],objName:"Ops.Anim.LFO"},{id:"3tlg468wt",uiAttribs:{},portsIn:[{name:"Speed",value:.08},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"yvcuxz6fu",objOut:"3tlg468wt"}]}],objName:"Ops.Anim.Timer_v2"},{id:"lp6pz46y3",uiAttribs:{},portsIn:[{name:"posX",value:5.99},{name:"posY",value:2.13},{name:"posZ",value:.721},{name:"scale",value:.82},{name:"rotX",value:-174.91},{name:"rotY",value:-136.8},{name:"rotZ",value:-63.02}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"hojf0smr4",objOut:"lp6pz46y3"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"52wx9afhx",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"bspi8cq8c",objOut:"52wx9afhx"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"zqe9sg13g",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.71}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"52wx9afhx",objOut:"zqe9sg13g"}]}],objName:"Ops.Anim.LFO"},{id:"09hnhrspp",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"zqe9sg13g",objOut:"09hnhrspp"}]}],objName:"Ops.Anim.Timer_v2"},{id:"86udjawbm",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.34}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"52wx9afhx",objOut:"86udjawbm"}]}],objName:"Ops.Anim.LFO"},{id:"nsa05rv76",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"86udjawbm",objOut:"nsa05rv76"}]}],objName:"Ops.Anim.Timer_v2"},{id:"djabvd5w3",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.38}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"52wx9afhx",objOut:"djabvd5w3"}]}],objName:"Ops.Anim.LFO"},{id:"7rqrwopa2",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"djabvd5w3",objOut:"7rqrwopa2"}]}],objName:"Ops.Anim.Timer_v2"},{id:"5qxozfc8s",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.53}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"52wx9afhx",objOut:"5qxozfc8s"}]}],objName:"Ops.Anim.LFO"},{id:"2g9pfrde9",uiAttribs:{},portsIn:[{name:"Speed",value:.08},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"5qxozfc8s",objOut:"2g9pfrde9"}]}],objName:"Ops.Anim.Timer_v2"},{id:"i6r73qdir",uiAttribs:{},portsIn:[{name:"posX",value:6.53},{name:"posY",value:-4.51},{name:"posZ",value:1.771},{name:"scale",value:1.18},{name:"rotX",value:-174.91},{name:"rotY",value:-92.57},{name:"rotZ",value:-119.94}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"52wx9afhx",objOut:"i6r73qdir"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"8l4bnqjqt",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/cristal.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"9q8u0nc1f",objOut:"8l4bnqjqt"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"7acai3gsy",objOut:"8l4bnqjqt"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"7acai3gsy",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"9q8u0nc1f",objOut:"7acai3gsy"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"ytjfxh2to",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"8l4bnqjqt",objOut:"ytjfxh2to"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"ttf72bc50",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"8l4bnqjqt",objOut:"ttf72bc50"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"g3nmyp657",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.71}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"ttf72bc50",objOut:"g3nmyp657"}]}],objName:"Ops.Anim.LFO"},{id:"snf2jetbe",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.34}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"ttf72bc50",objOut:"snf2jetbe"}]}],objName:"Ops.Anim.LFO"},{id:"9jfpemx6y",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.38}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"ttf72bc50",objOut:"9jfpemx6y"}]}],objName:"Ops.Anim.LFO"},{id:"s7ym3z1za",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"9jfpemx6y",objOut:"s7ym3z1za"}]}],objName:"Ops.Anim.Timer_v2"},{id:"d0b3pi4x3",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-5.53}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"ttf72bc50",objOut:"d0b3pi4x3"}]}],objName:"Ops.Anim.LFO"},{id:"cytawtejw",uiAttribs:{},portsIn:[{name:"posX",value:-1.35},{name:"posY",value:-3.67},{name:"posZ",value:3.151},{name:"scale",value:.82},{name:"rotX",value:-174.91},{name:"rotY",value:-137.29},{name:"rotZ",value:150.03}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"ttf72bc50",objOut:"cytawtejw"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"9q8u0nc1f",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"ytjfxh2to",objOut:"9q8u0nc1f"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"0ybgb7p19",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"snf2jetbe",objOut:"0ybgb7p19"}]}],objName:"Ops.Anim.Timer_v2"},{id:"z1twjubff",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"g3nmyp657",objOut:"z1twjubff"}]}],objName:"Ops.Anim.Timer_v2"},{id:"mlszrfidd",uiAttribs:{},portsIn:[{name:"Speed",value:.16},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"d0b3pi4x3",objOut:"mlszrfidd"}]}],objName:"Ops.Anim.Timer_v2"},{id:"uj5wsv6x2",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"mc90n9no2",objOut:"uj5wsv6x2"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"7cm9psq0w",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-1.08}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"uj5wsv6x2",objOut:"7cm9psq0w"}]}],objName:"Ops.Anim.LFO"},{id:"qwvqwmo5p",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.77}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"uj5wsv6x2",objOut:"qwvqwmo5p"}]}],objName:"Ops.Anim.LFO"},{id:"1w6bcx4o9",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-3.52}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"uj5wsv6x2",objOut:"1w6bcx4o9"}]}],objName:"Ops.Anim.LFO"},{id:"i2dhb61s0",uiAttribs:{},portsIn:[{name:"Speed",value:.19},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"1w6bcx4o9",objOut:"i2dhb61s0"}]}],objName:"Ops.Anim.Timer_v2"},{id:"b1ewgpda4",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-7.1}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"uj5wsv6x2",objOut:"b1ewgpda4"}]}],objName:"Ops.Anim.LFO"},{id:"hf2uylwx0",uiAttribs:{},portsIn:[{name:"posX",value:-6.71},{name:"posY",value:-3.88},{name:"posZ",value:3.141},{name:"scale",value:.67},{name:"rotX",value:-263.08},{name:"rotY",value:-113.36},{name:"rotZ",value:131.31}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"uj5wsv6x2",objOut:"hf2uylwx0"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"cfveocwxm",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"qwvqwmo5p",objOut:"cfveocwxm"}]}],objName:"Ops.Anim.Timer_v2"},{id:"q60j4m9eq",uiAttribs:{},portsIn:[{name:"Speed",value:.14},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"7cm9psq0w",objOut:"q60j4m9eq"}]}],objName:"Ops.Anim.Timer_v2"},{id:"k4wwb91kb",uiAttribs:{},portsIn:[{name:"Speed",value:.21},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"b1ewgpda4",objOut:"k4wwb91kb"}]}],objName:"Ops.Anim.Timer_v2"},{id:"pzg2brh3r",uiAttribs:{},portsIn:[{name:"old min",value:2},{name:"old max",value:3},{name:"new min",value:390},{name:"new max",value:378},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"rotY",portOut:"result",objIn:"i3i8vsddm",objOut:"pzg2brh3r"}]}],objName:"Ops.Math.MapRange"},{id:"dlgzus94z",uiAttribs:{},portsIn:[{name:"old min",value:2},{name:"old max",value:3},{name:"new min",value:0},{name:"new max",value:-5.33},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"rotX",portOut:"result",objIn:"i3i8vsddm",objOut:"dlgzus94z"}]}],objName:"Ops.Math.MapRange"},{id:"ca2j32nw7",uiAttribs:{},portsIn:[{name:"old min",value:2},{name:"old max",value:3},{name:"new min",value:0},{name:"new max",value:-1.02},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"rotZ",portOut:"result",objIn:"i3i8vsddm",objOut:"ca2j32nw7"}]}],objName:"Ops.Math.MapRange"},{id:"xef2nzzsf",uiAttribs:{},portsIn:[{name:"value",value:0},{name:"old min",value:2},{name:"old max",value:3},{name:"new min",value:1},{name:"new max",value:1.51},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"ihncfhmag",objOut:"xef2nzzsf"}]}],objName:"Ops.Math.MapRange"},{id:"634bzpwj3",uiAttribs:{},portsIn:[{name:"old min",value:3.2},{name:"old max",value:4.2},{name:"new min",value:1.16},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"hgo5fgjdc",objOut:"634bzpwj3"}]}],objName:"Ops.Math.MapRange"},{id:"cjparvalx",uiAttribs:{},portsIn:[{name:"posX",value:-2.88},{name:"posY",value:-1.11},{name:"posZ",value:1.57},{name:"rotX",value:-90},{name:"rotY",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"pbw9zs1k1",objOut:"cjparvalx"},{portIn:"render",portOut:"trigger",objIn:"uh6328akp",objOut:"cjparvalx"},{portIn:"render",portOut:"trigger",objIn:"qvch6t9f6",objOut:"cjparvalx"},{portIn:"render",portOut:"trigger",objIn:"yuch4cbju",objOut:"cjparvalx"},{portIn:"render",portOut:"trigger",objIn:"qynzvcfdz",objOut:"cjparvalx"},{portIn:"render",portOut:"trigger",objIn:"r0gnkiz57",objOut:"cjparvalx"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"l2fkqfoup",uiAttribs:{},portsIn:[{name:"Flip",value:0},{name:"Normalize",value:0}],portsOut:[{name:"Result",links:[{portIn:"Geometry",portOut:"Result",objIn:"jy9y71qis",objOut:"l2fkqfoup"}]}],objName:"Ops.Graphics.Geometry.FlipNormals"},{id:"6icgvm2xr",uiAttribs:{},portsIn:[{name:"Height",value:.23},{name:"Smooth",value:1},{name:"Walls",value:1},{name:"Top",value:1},{name:"Bottom",value:1}],portsOut:[{name:"Result Geometry",links:[{portIn:"Geometry",portOut:"Result Geometry",objIn:"l2fkqfoup",objOut:"6icgvm2xr"}]}],objName:"Ops.Graphics.Geometry.GeometryExtrude"},{id:"quex8mv7x",uiAttribs:{},portsIn:[{name:"Letter Spacing",value:0}],portsOut:[{name:"Path String",links:[{portIn:"SVG Path",portOut:"Path String",objIn:"eulzumlf2",objOut:"quex8mv7x"}]}],objName:"Ops.Extension.OpenType.OpentypeToSvgPath"},{id:"eulzumlf2",uiAttribs:{},portsIn:[{name:"Bezier Stepsize",value:3},{name:"Rescale",value:2.19}],portsOut:[{name:"Geometry",links:[{portIn:"Geometry",portOut:"Geometry",objIn:"6icgvm2xr",objOut:"eulzumlf2"}]}],objName:"Ops.Graphics.Geometry.SvgPathToGeometry_v2"},{id:"jy9y71qis",uiAttribs:{},portsIn:[{name:"Render Mesh",value:1},{name:"Add Vertex Numbers",value:1}],objName:"Ops.Gl.RenderGeometry_v2"},{id:"t7fcxmzdn",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:.6}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"hshn2ip1h",objOut:"t7fcxmzdn"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"hshn2ip1h",uiAttribs:{},portsIn:[{name:"r",value:.9301302083333334},{name:"g",value:.9301302083333334},{name:"b",value:.9301302083333334},{name:"AO Intensity",value:1},{name:"Normal Map Intensity",value:1},{name:"Repeat X",value:1},{name:"Repeat Y",value:1},{name:"Offset X",value:0},{name:"Offset Y",value:0},{name:"Double Sided",value:0},{name:"Screen Space Normals",value:0},{name:"Calc normal tangents",value:1},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"}],portsOut:[{name:"Next",links:[{portIn:"render",portOut:"Next",objIn:"jy9y71qis",objOut:"hshn2ip1h"}]}],objName:"Ops.Gl.Shader.MatCapMaterial_v3"},{id:"3703fltqj",uiAttribs:{},portsIn:[{name:"value",value:"Portfolio 2025"}],portsOut:[{name:"String",links:[{portIn:"Text",portOut:"String",objIn:"quex8mv7x",objOut:"3703fltqj"}]}],objName:"Ops.String.String_v2"},{id:"jql5v4xih",uiAttribs:{},portsIn:[{name:"Font File",value:"assets/SpaceGrotesk-VariableFont_wght.ttf",display:"file"}],portsOut:[{name:"Opentype Font",links:[{portIn:"Opentype Font",portOut:"Opentype Font",objIn:"quex8mv7x",objOut:"jql5v4xih"}]}],objName:"Ops.Extension.OpenType.OpentypeFont"},{id:"5tnqlsjve",uiAttribs:{},portsIn:[{name:"File",value:"assets/Texture_chrome_argente_e.avif",display:"file"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:0},{name:"Wrap",value:"repeat"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"},{name:"Data Format index",value:1},{name:"Data Format",value:"RG"},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0},{name:"Active",value:1},{name:"Save Memory",value:1},{name:"Add Cachebuster",value:0}],portsOut:[{name:"Texture",links:[{portIn:"Normal",portOut:"Texture",objIn:"hshn2ip1h",objOut:"5tnqlsjve"}]},{name:"Width",value:626},{name:"Height",value:418},{name:"Aspect Ratio",value:1.4976076555023923},{name:"Loaded",value:1},{name:"Loading",value:0}],objName:"Ops.Gl.Texture_v2"},{id:"oe6xshvv5",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"1ir9e8gga",objOut:"oe6xshvv5"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"i7mm66xpo",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:1},{name:"new min",value:.65},{name:"new max",value:.1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"oe6xshvv5",objOut:"i7mm66xpo"}]}],objName:"Ops.Math.MapRange"},{id:"ke2kphkai",uiAttribs:{},portsIn:[{name:"old min",value:0},{name:"old max",value:.7},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"Opacity",portOut:"result",objIn:"hshn2ip1h",objOut:"ke2kphkai"}]}],objName:"Ops.Math.MapRange"},{id:"1ir9e8gga",uiAttribs:{},portsIn:[{name:"posX",value:-1.83},{name:"posY",value:.1},{name:"posZ",value:5.14},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"t7fcxmzdn",objOut:"1ir9e8gga"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"fv0mvb33w",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:.84}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"u9ebf6nel",objOut:"fv0mvb33w"},{portIn:"render",portOut:"trigger",objIn:"dlpkgz3zt",objOut:"fv0mvb33w"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"u9ebf6nel",uiAttribs:{},portsIn:[{name:"use viewport size",value:1},{name:"width",value:699},{name:"height",value:396},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"clamp to edge"},{name:"HDR",value:0},{name:"Background Alpha",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"bgudd3wl4",objOut:"u9ebf6nel"},{portIn:"exe",portOut:"trigger",objIn:"1rvnnqyhy",objOut:"u9ebf6nel"}]},{name:"texture_out",links:[{portIn:"texture",portOut:"texture_out",objIn:"ktxctuzgx",objOut:"u9ebf6nel"}]},{name:"Aspect Ratio",value:1.7651515151515151}],objName:"Ops.Gl.ImageCompose.ImageCompose"},{id:"ktxctuzgx",uiAttribs:{},portsIn:[{name:"extrude",value:.5},{name:"flip",value:1},{name:"Ignore Zero Values",value:0},{name:"invert",value:0},{name:"offset X",value:0},{name:"offset Y",value:0},{name:"colorize",value:0},{name:"colorize add",value:0},{name:"mode index",value:6},{name:"mode",value:"add z"}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"mirdtxbnb",objOut:"ktxctuzgx"}]}],objName:"Ops.Gl.ShaderEffects.VertexDisplacementMap"},{id:"1rvnnqyhy",uiAttribs:{},portsIn:[{name:"Multiply",value:1.2}],portsOut:[{name:"result",links:[{portIn:"X",portOut:"result",objIn:"bgudd3wl4",objOut:"1rvnnqyhy"}]}],objName:"Ops.Extension.Deprecated.RelativeTime"},{id:"bgudd3wl4",uiAttribs:{},portsIn:[{name:"Blend Mode index",value:0},{name:"Blend Mode",value:0},{name:"Alpha Mask index",value:0},{name:"Alpha Mask",value:"Off"},{name:"Amount",value:1},{name:"Color index",value:0},{name:"Color",value:"Mono"},{name:"Scale",value:-3},{name:"Aspect",value:0},{name:"Multiply",value:1},{name:"Harmonics index",value:0},{name:"Harmonics",value:"1"},{name:"Y",value:10.19},{name:"Z",value:3.46},{name:"Offset Multiply",value:1},{name:"Offset X index",value:0},{name:"Offset X",value:"None"},{name:"Offset Y index",value:0},{name:"Offset Y",value:"None"},{name:"Offset Z index",value:1},{name:"Offset Z",value:"R"}],objName:"Ops.Gl.ImageCompose.Noise.PerlinNoise"},{id:"dlpkgz3zt",uiAttribs:{},portsIn:[{name:"r",value:.3356735184753614},{name:"g",value:.41269960103784165},{name:"b",value:.1580493709927444},{name:"colorizeTexture",value:0},{name:"billboard",value:0},{name:"Opacity TexCoords Transform",value:0},{name:"preMultiplied alpha",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"ktxctuzgx",objOut:"dlpkgz3zt"}]}],objName:"Ops.Gl.Shader.BasicMaterial"},{id:"06r5plc63",uiAttribs:{},portsIn:[{name:"file",value:"assets/67e41e15ccab331699642cac_polaroid_be_be_.png",display:"file"},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"repeat"},{name:"flip",value:0},{name:"unpackPreMultipliedAlpha",value:0},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"}],portsOut:[{name:"texture",links:[{portIn:"texture",portOut:"texture",objIn:"dlpkgz3zt",objOut:"06r5plc63"}]},{name:"width",value:441},{name:"height",value:538},{name:"loading",value:true},{name:"Aspect Ratio",value:.8197026022304833}],objName:"Ops.Gl.Texture"},{id:"847d6xvop",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"zq7x2vwtq",objOut:"847d6xvop"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"mirdtxbnb",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:.441},{name:"height",value:.538},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:1},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"1fbt7bx4r",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.09}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"fv0mvb33w",objOut:"1fbt7bx4r"}]}],objName:"Ops.Anim.LFO"},{id:"da478lfiw",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"1fbt7bx4r",objOut:"da478lfiw"}]}],objName:"Ops.Anim.Timer_v2"},{id:"b9wbprzot",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"fv0mvb33w",objOut:"b9wbprzot"}]}],objName:"Ops.Anim.LFO"},{id:"5vhbcwvlv",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"b9wbprzot",objOut:"5vhbcwvlv"}]}],objName:"Ops.Anim.Timer_v2"},{id:"0sqhwg68i",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"fv0mvb33w",objOut:"0sqhwg68i"}]}],objName:"Ops.Anim.LFO"},{id:"qbj8k0odw",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"0sqhwg68i",objOut:"qbj8k0odw"}]}],objName:"Ops.Anim.Timer_v2"},{id:"9ykxqqsnx",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"fv0mvb33w",objOut:"9ykxqqsnx"}]}],objName:"Ops.Anim.LFO"},{id:"z6ttd4tq1",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"9ykxqqsnx",objOut:"z6ttd4tq1"}]}],objName:"Ops.Anim.Timer_v2"},{id:"zq7x2vwtq",uiAttribs:{},portsIn:[{name:"posX",value:-2.3},{name:"posY",value:-.25},{name:"posZ",value:2.59},{name:"scale",value:.92},{name:"rotX",value:-11.16},{name:"rotY",value:48.02},{name:"rotZ",value:12.91}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"fv0mvb33w",objOut:"zq7x2vwtq"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"tk4udqc7i",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:.84}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"1bggv57tk",objOut:"tk4udqc7i"},{portIn:"render",portOut:"trigger",objIn:"lw968us2a",objOut:"tk4udqc7i"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"1bggv57tk",uiAttribs:{},portsIn:[{name:"use viewport size",value:1},{name:"width",value:699},{name:"height",value:396},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"clamp to edge"},{name:"HDR",value:0},{name:"Background Alpha",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"kvtmd7yb3",objOut:"1bggv57tk"},{portIn:"exe",portOut:"trigger",objIn:"5jm8pc94v",objOut:"1bggv57tk"}]},{name:"texture_out",links:[{portIn:"texture",portOut:"texture_out",objIn:"qdwze82kv",objOut:"1bggv57tk"}]},{name:"Aspect Ratio",value:1.7651515151515151}],objName:"Ops.Gl.ImageCompose.ImageCompose"},{id:"qdwze82kv",uiAttribs:{},portsIn:[{name:"extrude",value:.5},{name:"flip",value:1},{name:"Ignore Zero Values",value:0},{name:"invert",value:0},{name:"offset X",value:0},{name:"offset Y",value:0},{name:"colorize",value:0},{name:"colorize add",value:0},{name:"mode index",value:6},{name:"mode",value:"add z"}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"154m44riv",objOut:"qdwze82kv"}]}],objName:"Ops.Gl.ShaderEffects.VertexDisplacementMap"},{id:"5jm8pc94v",uiAttribs:{},portsIn:[{name:"Multiply",value:1.2}],portsOut:[{name:"result",links:[{portIn:"X",portOut:"result",objIn:"kvtmd7yb3",objOut:"5jm8pc94v"}]}],objName:"Ops.Extension.Deprecated.RelativeTime"},{id:"kvtmd7yb3",uiAttribs:{},portsIn:[{name:"Blend Mode index",value:0},{name:"Blend Mode",value:0},{name:"Alpha Mask index",value:0},{name:"Alpha Mask",value:"Off"},{name:"Amount",value:1},{name:"Color index",value:0},{name:"Color",value:"Mono"},{name:"Scale",value:-3},{name:"Aspect",value:0},{name:"Multiply",value:1},{name:"Harmonics index",value:0},{name:"Harmonics",value:"1"},{name:"Y",value:10.19},{name:"Z",value:3.46},{name:"Offset Multiply",value:1},{name:"Offset X index",value:0},{name:"Offset X",value:"None"},{name:"Offset Y index",value:0},{name:"Offset Y",value:"None"},{name:"Offset Z index",value:1},{name:"Offset Z",value:"R"}],objName:"Ops.Gl.ImageCompose.Noise.PerlinNoise"},{id:"lw968us2a",uiAttribs:{},portsIn:[{name:"r",value:.3356735184753614},{name:"g",value:.41269960103784165},{name:"b",value:.1580493709927444},{name:"colorizeTexture",value:0},{name:"billboard",value:0},{name:"Opacity TexCoords Transform",value:0},{name:"preMultiplied alpha",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"qdwze82kv",objOut:"lw968us2a"}]}],objName:"Ops.Gl.Shader.BasicMaterial"},{id:"m5kwrei91",uiAttribs:{},portsIn:[{name:"file",value:"assets/polaroid_jeune.png",display:"file"},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"repeat"},{name:"flip",value:0},{name:"unpackPreMultipliedAlpha",value:0},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"}],portsOut:[{name:"texture",links:[{portIn:"texture",portOut:"texture",objIn:"lw968us2a",objOut:"m5kwrei91"}]},{name:"width",value:441},{name:"height",value:538},{name:"loading",value:true},{name:"Aspect Ratio",value:.8197026022304833}],objName:"Ops.Gl.Texture"},{id:"fh5vpay27",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"n22mp1qj8",objOut:"fh5vpay27"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"154m44riv",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:.441},{name:"height",value:.538},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:1},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"bcyetpk73",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.09}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"tk4udqc7i",objOut:"bcyetpk73"}]}],objName:"Ops.Anim.LFO"},{id:"ew3q2qldz",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"bcyetpk73",objOut:"ew3q2qldz"}]}],objName:"Ops.Anim.Timer_v2"},{id:"y8vf304we",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"tk4udqc7i",objOut:"y8vf304we"}]}],objName:"Ops.Anim.LFO"},{id:"fk7690ji8",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"y8vf304we",objOut:"fk7690ji8"}]}],objName:"Ops.Anim.Timer_v2"},{id:"fg9cosrnq",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"tk4udqc7i",objOut:"fg9cosrnq"}]}],objName:"Ops.Anim.LFO"},{id:"0umfd730o",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"fg9cosrnq",objOut:"0umfd730o"}]}],objName:"Ops.Anim.Timer_v2"},{id:"0kwv98eg1",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"tk4udqc7i",objOut:"0kwv98eg1"}]}],objName:"Ops.Anim.LFO"},{id:"dueh7c8bb",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"0kwv98eg1",objOut:"dueh7c8bb"}]}],objName:"Ops.Anim.Timer_v2"},{id:"n22mp1qj8",uiAttribs:{},portsIn:[{name:"posX",value:-1.87},{name:"posY",value:-.44},{name:"posZ",value:2.16},{name:"scale",value:.92},{name:"rotX",value:0},{name:"rotY",value:39.69},{name:"rotZ",value:-.63}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"tk4udqc7i",objOut:"n22mp1qj8"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"widq1qv46",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:.84}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"40lpv1clu",objOut:"widq1qv46"},{portIn:"render",portOut:"trigger",objIn:"xdwi1i416",objOut:"widq1qv46"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"40lpv1clu",uiAttribs:{},portsIn:[{name:"use viewport size",value:1},{name:"width",value:699},{name:"height",value:396},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"clamp to edge"},{name:"HDR",value:0},{name:"Background Alpha",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"fvytt7g8p",objOut:"40lpv1clu"},{portIn:"exe",portOut:"trigger",objIn:"gamdm6dku",objOut:"40lpv1clu"}]},{name:"texture_out",links:[{portIn:"texture",portOut:"texture_out",objIn:"rgoktvuh8",objOut:"40lpv1clu"}]},{name:"Aspect Ratio",value:1.7651515151515151}],objName:"Ops.Gl.ImageCompose.ImageCompose"},{id:"rgoktvuh8",uiAttribs:{},portsIn:[{name:"extrude",value:.5},{name:"flip",value:1},{name:"Ignore Zero Values",value:0},{name:"invert",value:0},{name:"offset X",value:0},{name:"offset Y",value:0},{name:"colorize",value:0},{name:"colorize add",value:0},{name:"mode index",value:6},{name:"mode",value:"add z"}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"59jjbj8xg",objOut:"rgoktvuh8"}]}],objName:"Ops.Gl.ShaderEffects.VertexDisplacementMap"},{id:"gamdm6dku",uiAttribs:{},portsIn:[{name:"Multiply",value:1.2}],portsOut:[{name:"result",links:[{portIn:"X",portOut:"result",objIn:"fvytt7g8p",objOut:"gamdm6dku"}]}],objName:"Ops.Extension.Deprecated.RelativeTime"},{id:"fvytt7g8p",uiAttribs:{},portsIn:[{name:"Blend Mode index",value:0},{name:"Blend Mode",value:0},{name:"Alpha Mask index",value:0},{name:"Alpha Mask",value:"Off"},{name:"Amount",value:1},{name:"Color index",value:0},{name:"Color",value:"Mono"},{name:"Scale",value:-3},{name:"Aspect",value:0},{name:"Multiply",value:1},{name:"Harmonics index",value:0},{name:"Harmonics",value:"1"},{name:"Y",value:10.19},{name:"Z",value:3.46},{name:"Offset Multiply",value:1},{name:"Offset X index",value:0},{name:"Offset X",value:"None"},{name:"Offset Y index",value:0},{name:"Offset Y",value:"None"},{name:"Offset Z index",value:1},{name:"Offset Z",value:"R"}],objName:"Ops.Gl.ImageCompose.Noise.PerlinNoise"},{id:"xdwi1i416",uiAttribs:{},portsIn:[{name:"r",value:.3356735184753614},{name:"g",value:.41269960103784165},{name:"b",value:.1580493709927444},{name:"colorizeTexture",value:0},{name:"billboard",value:0},{name:"Opacity TexCoords Transform",value:0},{name:"preMultiplied alpha",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"rgoktvuh8",objOut:"xdwi1i416"}]}],objName:"Ops.Gl.Shader.BasicMaterial"},{id:"0dch1754z",uiAttribs:{},portsIn:[{name:"file",value:"assets/polaroid_30ans.png",display:"file"},{name:"filter index",value:1},{name:"filter",value:"linear"},{name:"wrap index",value:0},{name:"wrap",value:"repeat"},{name:"flip",value:0},{name:"unpackPreMultipliedAlpha",value:0},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"}],portsOut:[{name:"texture",links:[{portIn:"texture",portOut:"texture",objIn:"xdwi1i416",objOut:"0dch1754z"}]},{name:"width",value:441},{name:"height",value:538},{name:"loading",value:true},{name:"Aspect Ratio",value:.8197026022304833}],objName:"Ops.Gl.Texture"},{id:"f09z8qmus",uiAttribs:{},portsIn:[{name:"x",value:1},{name:"y",value:1},{name:"z",value:1}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"btfi669aa",objOut:"f09z8qmus"}]}],objName:"Ops.Gl.Matrix.Scale"},{id:"59jjbj8xg",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:.441},{name:"height",value:.538},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:1},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"x4vpzvr6l",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.09}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"widq1qv46",objOut:"x4vpzvr6l"}]}],objName:"Ops.Anim.LFO"},{id:"qhzp5zf99",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"x4vpzvr6l",objOut:"qhzp5zf99"}]}],objName:"Ops.Anim.Timer_v2"},{id:"7jpq901hr",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"widq1qv46",objOut:"7jpq901hr"}]}],objName:"Ops.Anim.LFO"},{id:"exgolqc2w",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"7jpq901hr",objOut:"exgolqc2w"}]}],objName:"Ops.Anim.Timer_v2"},{id:"xao02ciql",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"widq1qv46",objOut:"xao02ciql"}]}],objName:"Ops.Anim.LFO"},{id:"boasj4ih6",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"xao02ciql",objOut:"boasj4ih6"}]}],objName:"Ops.Anim.Timer_v2"},{id:"1a0azt6uv",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"widq1qv46",objOut:"1a0azt6uv"}]}],objName:"Ops.Anim.LFO"},{id:"tvfdw6pna",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"1a0azt6uv",objOut:"tvfdw6pna"}]}],objName:"Ops.Anim.Timer_v2"},{id:"btfi669aa",uiAttribs:{},portsIn:[{name:"posX",value:-1.48},{name:"posY",value:-.22},{name:"posZ",value:1.69},{name:"scale",value:.92},{name:"rotX",value:0},{name:"rotY",value:39.69},{name:"rotZ",value:-.63}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"widq1qv46",objOut:"btfi669aa"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"licir9u9a",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/mini_cristal1.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"78qi3x7ad",objOut:"licir9u9a"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"z99h1ih4x",objOut:"licir9u9a"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"xicno8wgh",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.002"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"licir9u9a",objOut:"xicno8wgh"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"z99h1ih4x",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"78qi3x7ad",objOut:"z99h1ih4x"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"wc575hyec",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:-3.0971484989523614},{name:"posZ",value:0},{name:"scale",value:.4},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:52.59}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"ybwk9bo96",objOut:"wc575hyec"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"78qi3x7ad",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"xicno8wgh",objOut:"78qi3x7ad"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"ybwk9bo96",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"licir9u9a",objOut:"ybwk9bo96"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"zl8gdrn05",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.5}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"ybwk9bo96",objOut:"zl8gdrn05"}]}],objName:"Ops.Anim.LFO"},{id:"anf6esyqc",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"zl8gdrn05",objOut:"anf6esyqc"}]}],objName:"Ops.Anim.Timer_v2"},{id:"rqx1mxy5s",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"ybwk9bo96",objOut:"rqx1mxy5s"}]}],objName:"Ops.Anim.LFO"},{id:"e2dccyeut",uiAttribs:{},portsIn:[{name:"Speed",value:.2},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"rqx1mxy5s",objOut:"e2dccyeut"}]}],objName:"Ops.Anim.Timer_v2"},{id:"uc0uxnzl9",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"ybwk9bo96",objOut:"uc0uxnzl9"}]}],objName:"Ops.Anim.LFO"},{id:"po1bp0la2",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"uc0uxnzl9",objOut:"po1bp0la2"}]}],objName:"Ops.Anim.Timer_v2"},{id:"b4cju4sjx",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"ybwk9bo96",objOut:"b4cju4sjx"}]}],objName:"Ops.Anim.LFO"},{id:"x7ywll5wl",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"b4cju4sjx",objOut:"x7ywll5wl"}]}],objName:"Ops.Anim.Timer_v2"},{id:"eppslamlj",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:3.077},{name:"posZ",value:0},{name:"scale",value:0},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:12.16}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"w33ne459o",objOut:"eppslamlj"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"w33ne459o",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"uah5psms7",objOut:"w33ne459o"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"c9jzxq9bz",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.6}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"w33ne459o",objOut:"c9jzxq9bz"}]}],objName:"Ops.Anim.LFO"},{id:"h0fpdhos2",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"c9jzxq9bz",objOut:"h0fpdhos2"}]}],objName:"Ops.Anim.Timer_v2"},{id:"tnuwx0q88",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.07}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"w33ne459o",objOut:"tnuwx0q88"}]}],objName:"Ops.Anim.LFO"},{id:"rfede3ico",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"tnuwx0q88",objOut:"rfede3ico"}]}],objName:"Ops.Anim.Timer_v2"},{id:"evrb86wpn",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"w33ne459o",objOut:"evrb86wpn"}]}],objName:"Ops.Anim.LFO"},{id:"o4ef608od",uiAttribs:{},portsIn:[{name:"Speed",value:.18},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"evrb86wpn",objOut:"o4ef608od"}]}],objName:"Ops.Anim.Timer_v2"},{id:"xcorx0kq2",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.56}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"w33ne459o",objOut:"xcorx0kq2"}]}],objName:"Ops.Anim.LFO"},{id:"kjl41gq6i",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"xcorx0kq2",objOut:"kjl41gq6i"}]}],objName:"Ops.Anim.Timer_v2"},{id:"uah5psms7",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/petitcristal2.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"5zr5dg63k",objOut:"uah5psms7"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"bqw6r9ao6",objOut:"uah5psms7"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"g3bq92y89",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.001"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"uah5psms7",objOut:"g3bq92y89"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"bqw6r9ao6",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"5zr5dg63k",objOut:"bqw6r9ao6"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"5zr5dg63k",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"g3bq92y89",objOut:"5zr5dg63k"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"6fd07tk6u",uiAttribs:{},portsIn:[{name:"posX",value:3.857},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:.34},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:88.19}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"p2a3z0ai4",objOut:"6fd07tk6u"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"p2a3z0ai4",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"zo3i3g91p",objOut:"p2a3z0ai4"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"zuajj7q8a",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.55}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"p2a3z0ai4",objOut:"zuajj7q8a"}]}],objName:"Ops.Anim.LFO"},{id:"x7x5u5jlp",uiAttribs:{},portsIn:[{name:"Speed",value:.01},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"zuajj7q8a",objOut:"x7x5u5jlp"}]}],objName:"Ops.Anim.Timer_v2"},{id:"xxelc9ltn",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.47}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"p2a3z0ai4",objOut:"xxelc9ltn"}]}],objName:"Ops.Anim.LFO"},{id:"ou0t5jgov",uiAttribs:{},portsIn:[{name:"Speed",value:.29},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"xxelc9ltn",objOut:"ou0t5jgov"}]}],objName:"Ops.Anim.Timer_v2"},{id:"l7uc3jven",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.04}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"p2a3z0ai4",objOut:"l7uc3jven"}]}],objName:"Ops.Anim.LFO"},{id:"okeggmh87",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"l7uc3jven",objOut:"okeggmh87"}]}],objName:"Ops.Anim.Timer_v2"},{id:"0heuwcybl",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.65}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"p2a3z0ai4",objOut:"0heuwcybl"}]}],objName:"Ops.Anim.LFO"},{id:"utbnf7uqc",uiAttribs:{},portsIn:[{name:"Speed",value:.21},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"0heuwcybl",objOut:"utbnf7uqc"}]}],objName:"Ops.Anim.Timer_v2"},{id:"zo3i3g91p",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/uncristalsimplet3.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"hfqu91f5z",objOut:"zo3i3g91p"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"r0tw1gprv",objOut:"zo3i3g91p"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"r0tw1gprv",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"hfqu91f5z",objOut:"r0tw1gprv"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"5jnoz0h7h",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"zo3i3g91p",objOut:"5jnoz0h7h"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"hfqu91f5z",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"5jnoz0h7h",objOut:"hfqu91f5z"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"mb9t1d0ir",uiAttribs:{},portsIn:[{name:"posX",value:-3.033},{name:"posY",value:-2.21},{name:"posZ",value:0},{name:"scale",value:.34},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:-51.96}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"p2wy47i2d",objOut:"mb9t1d0ir"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"p2wy47i2d",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"4f3kqp15j",objOut:"p2wy47i2d"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"5yqfhkpj2",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.3}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"p2wy47i2d",objOut:"5yqfhkpj2"}]}],objName:"Ops.Anim.LFO"},{id:"rv742qe30",uiAttribs:{},portsIn:[{name:"Speed",value:.28},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"5yqfhkpj2",objOut:"rv742qe30"}]}],objName:"Ops.Anim.Timer_v2"},{id:"7c8alofgk",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.93}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"p2wy47i2d",objOut:"7c8alofgk"}]}],objName:"Ops.Anim.LFO"},{id:"601sdibe5",uiAttribs:{},portsIn:[{name:"Speed",value:.4},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"7c8alofgk",objOut:"601sdibe5"}]}],objName:"Ops.Anim.Timer_v2"},{id:"m83jts900",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.12}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"p2wy47i2d",objOut:"m83jts900"}]}],objName:"Ops.Anim.LFO"},{id:"99228be9d",uiAttribs:{},portsIn:[{name:"Speed",value:.29},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"m83jts900",objOut:"99228be9d"}]}],objName:"Ops.Anim.Timer_v2"},{id:"lv6pwn7i6",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.73}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"p2wy47i2d",objOut:"lv6pwn7i6"}]}],objName:"Ops.Anim.LFO"},{id:"f844c5990",uiAttribs:{},portsIn:[{name:"Speed",value:.27},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"lv6pwn7i6",objOut:"f844c5990"}]}],objName:"Ops.Anim.Timer_v2"},{id:"4f3kqp15j",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/uncristalsimplet3.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"srvodsrdy",objOut:"4f3kqp15j"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"bmcur0rzq",objOut:"4f3kqp15j"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"bmcur0rzq",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"srvodsrdy",objOut:"bmcur0rzq"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"kukmaxbdb",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"4f3kqp15j",objOut:"kukmaxbdb"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"srvodsrdy",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"kukmaxbdb",objOut:"srvodsrdy"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"1j0coc5dl",uiAttribs:{},portsIn:[{name:"posX",value:2.84},{name:"posY",value:-2.543},{name:"posZ",value:0},{name:"scale",value:.34},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:41.01}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"pa9qbcetu",objOut:"1j0coc5dl"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"pa9qbcetu",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"u172wd539",objOut:"pa9qbcetu"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"vb3ozylee",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.6}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"pa9qbcetu",objOut:"vb3ozylee"}]}],objName:"Ops.Anim.LFO"},{id:"km78p2mqq",uiAttribs:{},portsIn:[{name:"Speed",value:.17},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"vb3ozylee",objOut:"km78p2mqq"}]}],objName:"Ops.Anim.Timer_v2"},{id:"n1ghmo9d1",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.07}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"pa9qbcetu",objOut:"n1ghmo9d1"}]}],objName:"Ops.Anim.LFO"},{id:"jewe5bsdk",uiAttribs:{},portsIn:[{name:"Speed",value:.23},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"n1ghmo9d1",objOut:"jewe5bsdk"}]}],objName:"Ops.Anim.Timer_v2"},{id:"2i1q9pecf",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"pa9qbcetu",objOut:"2i1q9pecf"}]}],objName:"Ops.Anim.LFO"},{id:"p68fwf3r1",uiAttribs:{},portsIn:[{name:"Speed",value:.18},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"2i1q9pecf",objOut:"p68fwf3r1"}]}],objName:"Ops.Anim.Timer_v2"},{id:"c61d2zwg6",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.56}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"pa9qbcetu",objOut:"c61d2zwg6"}]}],objName:"Ops.Anim.LFO"},{id:"wu0mljrkv",uiAttribs:{},portsIn:[{name:"Speed",value:.12},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"c61d2zwg6",objOut:"wu0mljrkv"}]}],objName:"Ops.Anim.Timer_v2"},{id:"u172wd539",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/petitcristal2.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"bpcf0jd4k",objOut:"u172wd539"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"56m806kv2",objOut:"u172wd539"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"wyw5a6jdi",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.001"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"u172wd539",objOut:"wyw5a6jdi"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"56m806kv2",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"bpcf0jd4k",objOut:"56m806kv2"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"bpcf0jd4k",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"wyw5a6jdi",objOut:"bpcf0jd4k"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"23kel5zjj",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/mini_cristal1.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"kqv87pkl0",objOut:"23kel5zjj"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"fdfdcr871",objOut:"23kel5zjj"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"lulcqfx13",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.002"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"23kel5zjj",objOut:"lulcqfx13"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"fdfdcr871",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"kqv87pkl0",objOut:"fdfdcr871"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"iqhbsqpbi",uiAttribs:{},portsIn:[{name:"posX",value:2.57},{name:"posY",value:2.263},{name:"posZ",value:0},{name:"scale",value:.34},{name:"rotX",value:-8.44},{name:"rotY",value:1.12},{name:"rotZ",value:-157.59}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"t19xofwum",objOut:"iqhbsqpbi"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"kqv87pkl0",uiAttribs:{},portsIn:[{name:"r",value:.033539995032354275},{name:"g",value:.8237910168047065},{name:"b",value:.8514132516060142},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"lulcqfx13",objOut:"kqv87pkl0"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"t19xofwum",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"Render",portOut:"trigger",objIn:"23kel5zjj",objOut:"t19xofwum"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"r65kbh5s1",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.49}],portsOut:[{name:"Result",links:[{portIn:"posZ",portOut:"Result",objIn:"t19xofwum",objOut:"r65kbh5s1"}]}],objName:"Ops.Anim.LFO"},{id:"s5xxgpd1p",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"r65kbh5s1",objOut:"s5xxgpd1p"}]}],objName:"Ops.Anim.Timer_v2"},{id:"bde83ehsx",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2.23}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"t19xofwum",objOut:"bde83ehsx"}]}],objName:"Ops.Anim.LFO"},{id:"fitn8ogi9",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"bde83ehsx",objOut:"fitn8ogi9"}]}],objName:"Ops.Anim.Timer_v2"},{id:"58prvftpw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"t19xofwum",objOut:"58prvftpw"}]}],objName:"Ops.Anim.LFO"},{id:"kzteden2a",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"58prvftpw",objOut:"kzteden2a"}]}],objName:"Ops.Anim.Timer_v2"},{id:"2nii54zvk",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"t19xofwum",objOut:"2nii54zvk"}]}],objName:"Ops.Anim.LFO"},{id:"4ssd3jj0a",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"2nii54zvk",objOut:"4ssd3jj0a"}]}],objName:"Ops.Anim.Timer_v2"},{id:"9qg93148o",uiAttribs:{},portsIn:[{name:"number2",value:-1}],portsOut:[{name:"result",links:[{portIn:"Add to number",portOut:"result",objIn:"fiq06coor",objOut:"9qg93148o"}]}],objName:"Ops.Math.Multiply"},{id:"qrdkvq4ht",uiAttribs:{},portsIn:[{name:"number2",value:0}],portsOut:[{name:"result",links:[{portIn:"Value",portOut:"result",objIn:"oed5fp6nn",objOut:"qrdkvq4ht"}]}],objName:"Ops.Math.Compare.LessThan"},{id:"oed5fp6nn",uiAttribs:{},portsOut:[{name:"Next",links:[{portIn:"Set Default Value",portOut:"Next",objIn:"fiq06coor",objOut:"oed5fp6nn"}]}],objName:"Ops.Boolean.TriggerChangedTrue"},{id:"v02k7hn2r",uiAttribs:{},portsIn:[{name:"old min",value:1.8},{name:"old max",value:2},{name:"new min",value:0},{name:"new max",value:1.3},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"8931dy4a0",objOut:"v02k7hn2r"}]}],objName:"Ops.Math.MapRange"},{id:"hv6errv53",uiAttribs:{},portsIn:[{name:"old min",value:1.7},{name:"old max",value:1.9},{name:"new min",value:0},{name:"new max",value:1.3},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"847d6xvop",objOut:"hv6errv53"},{portIn:"a",portOut:"result",objIn:"dlpkgz3zt",objOut:"hv6errv53"}]}],objName:"Ops.Math.MapRange"},{id:"hhg70pui1",uiAttribs:{},portsIn:[{name:"old min",value:1.8},{name:"old max",value:2},{name:"new min",value:0},{name:"new max",value:1.3},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"fh5vpay27",objOut:"hhg70pui1"},{portIn:"a",portOut:"result",objIn:"lw968us2a",objOut:"hhg70pui1"}]}],objName:"Ops.Math.MapRange"},{id:"uncjlqeeq",uiAttribs:{},portsIn:[{name:"old min",value:2},{name:"old max",value:2.2},{name:"new min",value:0},{name:"new max",value:1.3},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"f09z8qmus",objOut:"uncjlqeeq"},{portIn:"a",portOut:"result",objIn:"xdwi1i416",objOut:"uncjlqeeq"}]}],objName:"Ops.Math.MapRange"},{id:"2vv084rwd",uiAttribs:{},portsIn:[{name:"old min",value:2.8},{name:"old max",value:3},{name:"new min",value:1.3},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"8931dy4a0",objOut:"2vv084rwd"}]}],objName:"Ops.Math.MapRange"},{id:"35dmtw1m3",uiAttribs:{},portsIn:[{name:"old min",value:3},{name:"old max",value:3.2},{name:"new min",value:1.3},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"f09z8qmus",objOut:"35dmtw1m3"},{portIn:"a",portOut:"result",objIn:"xdwi1i416",objOut:"35dmtw1m3"}]}],objName:"Ops.Math.MapRange"},{id:"ngvd7yhhv",uiAttribs:{},portsIn:[{name:"old min",value:3},{name:"old max",value:3.2},{name:"new min",value:1.3},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"fh5vpay27",objOut:"ngvd7yhhv"},{portIn:"a",portOut:"result",objIn:"lw968us2a",objOut:"ngvd7yhhv"}]}],objName:"Ops.Math.MapRange"},{id:"xic7uy0p3",uiAttribs:{},portsIn:[{name:"old min",value:3},{name:"old max",value:3.2},{name:"new min",value:1.3},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"847d6xvop",objOut:"xic7uy0p3"},{portIn:"a",portOut:"result",objIn:"dlpkgz3zt",objOut:"xic7uy0p3"}]}],objName:"Ops.Math.MapRange"},{id:"o9dips58v",uiAttribs:{},portsIn:[{name:"old min",value:3.2},{name:"old max",value:4},{name:"new min",value:-.06},{name:"new max",value:-2.83},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"posX",portOut:"result",objIn:"hgo5fgjdc",objOut:"o9dips58v"}]}],objName:"Ops.Math.MapRange"},{id:"m6mb6ir8a",uiAttribs:{},portsIn:[{name:"old min",value:3.2},{name:"old max",value:4},{name:"new min",value:0},{name:"new max",value:-.73},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"posY",portOut:"result",objIn:"hgo5fgjdc",objOut:"m6mb6ir8a"}]}],objName:"Ops.Math.MapRange"},{id:"t7aego014",uiAttribs:{},portsIn:[{name:"posX",value:1.38},{name:"posZ",value:-.05},{name:"scale",value:.32}],portsOut:[{name:"trigger",links:[{portIn:"4y3uaxvxs",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"},{portIn:"4afm0tvlm",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"},{portIn:"ahpj794b9",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"},{portIn:"ip98ojemb",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"},{portIn:"yx2wcoz1q",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"},{portIn:"x68ysan9u",portOut:"trigger",objIn:"pxmqhw3t9",objOut:"t7aego014"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"pxmqhw3t9",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"4y3uaxvxs",title:"render"},{name:"4afm0tvlm",title:"render"},{name:"ahpj794b9",title:"render"},{name:"ip98ojemb",title:"render"},{name:"yx2wcoz1q",title:"render"},{name:"x68ysan9u",title:"render"},{name:"patchId",value:"bp2sub_pxmqhw3t9"}],objName:"Ops.Patch.PLfVxtG.Scene1"},{id:"76iwoluaw",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.06}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"t7aego014",objOut:"76iwoluaw"}]}],objName:"Ops.Anim.LFO"},{id:"la59qa2yl",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"76iwoluaw",objOut:"la59qa2yl"}]}],objName:"Ops.Anim.Timer_v2"},{id:"95pnj280x",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"t7aego014",objOut:"95pnj280x"}]}],objName:"Ops.Anim.LFO"},{id:"v1363xpmf",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"95pnj280x",objOut:"v1363xpmf"}]}],objName:"Ops.Anim.Timer_v2"},{id:"l9yvpkj62",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"t7aego014",objOut:"l9yvpkj62"}]}],objName:"Ops.Anim.LFO"},{id:"ui0l46wto",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"l9yvpkj62",objOut:"ui0l46wto"}]}],objName:"Ops.Anim.Timer_v2"},{id:"fasdj3fqe",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"t7aego014",objOut:"fasdj3fqe"}]}],objName:"Ops.Anim.LFO"},{id:"nldj67hwc",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"fasdj3fqe",objOut:"nldj67hwc"}]}],objName:"Ops.Anim.Timer_v2"},{id:"m7ovd4xwe",uiAttribs:{},portsIn:[{name:"posX",value:-.63},{name:"posY",value:-2.82},{name:"posZ",value:.79},{name:"scale",value:1.47},{name:"rotX",value:90},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"t7aego014",objOut:"m7ovd4xwe"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"h9dzfudn5",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1.04}],portsOut:[{name:"trigger",links:[{portIn:"top2cfpvc",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"},{portIn:"86hqndd33",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"},{portIn:"uxdh39dmd",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"},{portIn:"ezmeafmv2",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"},{portIn:"lep5zghtn",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"},{portIn:"sf1qgnyf2",portOut:"trigger",objIn:"styurbptr",objOut:"h9dzfudn5"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"styurbptr",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"top2cfpvc",title:"render"},{name:"86hqndd33",title:"render"},{name:"uxdh39dmd",title:"render"},{name:"ezmeafmv2",title:"render"},{name:"lep5zghtn",title:"render"},{name:"sf1qgnyf2",title:"render"},{name:"patchId",value:"bp2sub_styurbptr"}],objName:"Ops.Patch.PLfVxtG.Scene2"},{id:"tu303w69k",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.06}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"h9dzfudn5",objOut:"tu303w69k"}]}],objName:"Ops.Anim.LFO"},{id:"sjcqtc2o8",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"tu303w69k",objOut:"sjcqtc2o8"}]}],objName:"Ops.Anim.Timer_v2"},{id:"y6qt77ok1",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"h9dzfudn5",objOut:"y6qt77ok1"}]}],objName:"Ops.Anim.LFO"},{id:"hfdwiprpr",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"y6qt77ok1",objOut:"hfdwiprpr"}]}],objName:"Ops.Anim.Timer_v2"},{id:"gnszjuba5",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"h9dzfudn5",objOut:"gnszjuba5"}]}],objName:"Ops.Anim.LFO"},{id:"5tebpmaal",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"gnszjuba5",objOut:"5tebpmaal"}]}],objName:"Ops.Anim.Timer_v2"},{id:"ej913espb",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"h9dzfudn5",objOut:"ej913espb"}]}],objName:"Ops.Anim.LFO"},{id:"9w1gn2z6n",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"ej913espb",objOut:"9w1gn2z6n"}]}],objName:"Ops.Anim.Timer_v2"},{id:"wmuxcjgoy",uiAttribs:{},portsIn:[{name:"posX",value:-1.66},{name:"posY",value:-2.08},{name:"posZ",value:.57},{name:"scale",value:.7},{name:"rotX",value:90},{name:"rotY",value:39.31},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"h9dzfudn5",objOut:"wmuxcjgoy"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"qyg463btt",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"ywf2m4z87",portOut:"trigger",objIn:"cljhxky27",objOut:"qyg463btt"},{portIn:"bpvghff97",portOut:"trigger",objIn:"cljhxky27",objOut:"qyg463btt"},{portIn:"qtrmi8iov",portOut:"trigger",objIn:"cljhxky27",objOut:"qyg463btt"},{portIn:"bpwrv87h8",portOut:"trigger",objIn:"cljhxky27",objOut:"qyg463btt"},{portIn:"w7qcf3ri1",portOut:"trigger",objIn:"cljhxky27",objOut:"qyg463btt"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"pbw9zs1k1",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"wmuxcjgoy",objOut:"pbw9zs1k1"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"uh6328akp",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"m7ovd4xwe",objOut:"uh6328akp"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"tmf6ioe4x",uiAttribs:{},portsIn:[{name:"posX",value:-2.4},{name:"posY",value:1.54},{name:"posZ",value:.19},{name:"scale",value:1.23},{name:"rotX",value:90},{name:"rotY",value:40.28},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"qyg463btt",objOut:"tmf6ioe4x"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"qvch6t9f6",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"tmf6ioe4x",objOut:"qvch6t9f6"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"xexu0bbi8",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.06}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"qyg463btt",objOut:"xexu0bbi8"}]}],objName:"Ops.Anim.LFO"},{id:"5dj3rzg9f",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"xexu0bbi8",objOut:"5dj3rzg9f"}]}],objName:"Ops.Anim.Timer_v2"},{id:"g6tl4v5ju",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"qyg463btt",objOut:"g6tl4v5ju"}]}],objName:"Ops.Anim.LFO"},{id:"jrafhd6bb",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"g6tl4v5ju",objOut:"jrafhd6bb"}]}],objName:"Ops.Anim.Timer_v2"},{id:"6jco6nb08",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"qyg463btt",objOut:"6jco6nb08"}]}],objName:"Ops.Anim.LFO"},{id:"oqxfwmjtt",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"6jco6nb08",objOut:"oqxfwmjtt"}]}],objName:"Ops.Anim.Timer_v2"},{id:"p72ixh0z1",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"qyg463btt",objOut:"p72ixh0z1"}]}],objName:"Ops.Anim.LFO"},{id:"hn03h78wy",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"p72ixh0z1",objOut:"hn03h78wy"}]}],objName:"Ops.Anim.Timer_v2"},{id:"j4b2jbi8h",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"6ne4h65dr",portOut:"trigger",objIn:"e5oijo7ly",objOut:"j4b2jbi8h"},{portIn:"mgj1bxiv4",portOut:"trigger",objIn:"e5oijo7ly",objOut:"j4b2jbi8h"},{portIn:"vraa1b2jn",portOut:"trigger",objIn:"e5oijo7ly",objOut:"j4b2jbi8h"},{portIn:"render",portOut:"trigger",objIn:"mg1cv6qpu",objOut:"j4b2jbi8h"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"mru7yegoh",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.06}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"j4b2jbi8h",objOut:"mru7yegoh"}]}],objName:"Ops.Anim.LFO"},{id:"r8hy6nty4",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"mru7yegoh",objOut:"r8hy6nty4"}]}],objName:"Ops.Anim.Timer_v2"},{id:"pcqaxhal0",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"j4b2jbi8h",objOut:"pcqaxhal0"}]}],objName:"Ops.Anim.LFO"},{id:"w77cjz8je",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"pcqaxhal0",objOut:"w77cjz8je"}]}],objName:"Ops.Anim.Timer_v2"},{id:"81iho7upn",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"j4b2jbi8h",objOut:"81iho7upn"}]}],objName:"Ops.Anim.LFO"},{id:"eagsjybyy",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"81iho7upn",objOut:"eagsjybyy"}]}],objName:"Ops.Anim.Timer_v2"},{id:"z2x4rxtzv",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"j4b2jbi8h",objOut:"z2x4rxtzv"}]}],objName:"Ops.Anim.LFO"},{id:"dao3fpky8",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"z2x4rxtzv",objOut:"dao3fpky8"}]}],objName:"Ops.Anim.Timer_v2"},{id:"cljhxky27",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"ywf2m4z87",title:"render"},{name:"bpvghff97",title:"render"},{name:"qtrmi8iov",title:"render"},{name:"bpwrv87h8",title:"render"},{name:"w7qcf3ri1",title:"render"},{name:"patchId",value:"bp2sub_cljhxky27"}],objName:"Ops.Patch.PLfVxtG.Scene4"},{id:"e5oijo7ly",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"6ne4h65dr",title:"render"},{name:"mgj1bxiv4",title:"render"},{name:"vraa1b2jn",title:"render"},{name:"patchId",value:"bp2sub_e5oijo7ly"}],objName:"Ops.Patch.PLfVxtG.Scene5"},{id:"1c1724g6n",uiAttribs:{},portsIn:[{name:"posX",value:1.03},{name:"posY",value:2.13},{name:"posZ",value:.19},{name:"scale",value:.94},{name:"rotX",value:90},{name:"rotY",value:150.98},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"j4b2jbi8h",objOut:"1c1724g6n"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"yuch4cbju",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"1c1724g6n",objOut:"yuch4cbju"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"iq6w67tj8",uiAttribs:{},portsIn:[{name:"old min",value:5},{name:"old max",value:10},{name:"new min",value:0},{name:"new max",value:360},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"rotZ",portOut:"result",objIn:"cjparvalx",objOut:"iq6w67tj8"}]}],objName:"Ops.Math.MapRange"},{id:"8fker30is",uiAttribs:{},portsIn:[{name:"old min",value:3.6},{name:"old max",value:4},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"cjparvalx",objOut:"8fker30is"}]}],objName:"Ops.Math.MapRange"},{id:"f3opeikum",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"415r9ipd3",objOut:"f3opeikum"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"djx8bcjx1",objOut:"f3opeikum"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"jxvlh36ho",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"f3opeikum",objOut:"jxvlh36ho"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"djx8bcjx1",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"415r9ipd3",objOut:"djx8bcjx1"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"415r9ipd3",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"jxvlh36ho",objOut:"415r9ipd3"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"a38gdy7ld",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"v43zlwll9",objOut:"a38gdy7ld"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"yc1ze7v98",objOut:"a38gdy7ld"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"n6nsk9c83",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"a38gdy7ld",objOut:"n6nsk9c83"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"yc1ze7v98",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"v43zlwll9",objOut:"yc1ze7v98"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"v43zlwll9",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"n6nsk9c83",objOut:"v43zlwll9"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"f280152n1",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"s3b5d949j",objOut:"f280152n1"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"9tk58kriy",objOut:"f280152n1"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"169jkss32",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"f280152n1",objOut:"169jkss32"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"9tk58kriy",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"s3b5d949j",objOut:"9tk58kriy"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"s3b5d949j",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"169jkss32",objOut:"s3b5d949j"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"2kny1ch13",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"nj9z2bj3z",objOut:"2kny1ch13"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"xkbopjd22",objOut:"2kny1ch13"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"ntc2da79h",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"2kny1ch13",objOut:"ntc2da79h"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"xkbopjd22",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"nj9z2bj3z",objOut:"xkbopjd22"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"nj9z2bj3z",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"ntc2da79h",objOut:"nj9z2bj3z"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"5ep5u1934",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"vyyv11kly",objOut:"5ep5u1934"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"dxx1ugmgo",objOut:"5ep5u1934"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"mpc0su338",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"5ep5u1934",objOut:"mpc0su338"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"dxx1ugmgo",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"vyyv11kly",objOut:"dxx1ugmgo"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"vyyv11kly",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"mpc0su338",objOut:"vyyv11kly"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"z4cfo6q9k",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"ej97fje4d",objOut:"z4cfo6q9k"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"1k378j9d4",objOut:"z4cfo6q9k"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"p4zv6ujcj",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"z4cfo6q9k",objOut:"p4zv6ujcj"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"1k378j9d4",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"ej97fje4d",objOut:"1k378j9d4"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"ej97fje4d",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"p4zv6ujcj",objOut:"ej97fje4d"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"d8uzqg4o9",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"1a18hj6k8",objOut:"d8uzqg4o9"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"avjv9ymrh",objOut:"d8uzqg4o9"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"pzs76guw8",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"d8uzqg4o9",objOut:"pzs76guw8"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"avjv9ymrh",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"1a18hj6k8",objOut:"avjv9ymrh"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"1a18hj6k8",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"pzs76guw8",objOut:"1a18hj6k8"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"w5nf7ylop",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posZ",value:0},{name:"scale",value:1}],portsOut:[{name:"trigger",links:[{portIn:"cigk6gm62",portOut:"trigger",objIn:"ukrqwublo",objOut:"w5nf7ylop"},{portIn:"j79vc7ns0",portOut:"trigger",objIn:"ukrqwublo",objOut:"w5nf7ylop"},{portIn:"j51vvjy5d",portOut:"trigger",objIn:"ukrqwublo",objOut:"w5nf7ylop"},{portIn:"t3bmv2wsz",portOut:"trigger",objIn:"ukrqwublo",objOut:"w5nf7ylop"},{portIn:"mbp1cq2ag",portOut:"trigger",objIn:"ukrqwublo",objOut:"w5nf7ylop"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"ukrqwublo",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"cigk6gm62",title:"render"},{name:"j79vc7ns0",title:"render"},{name:"j51vvjy5d",title:"render"},{name:"t3bmv2wsz",title:"render"},{name:"mbp1cq2ag",title:"render"},{name:"patchId",value:"bp2sub_ukrqwublo"}],objName:"Ops.Patch.PLfVxtG.SubPatch5"},{id:"jqzoba558",uiAttribs:{},portsIn:[{name:"posX",value:-1.26},{name:"posY",value:.16},{name:"posZ",value:-.11},{name:"scale",value:.92},{name:"rotX",value:0},{name:"rotY",value:-42.76},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"w5nf7ylop",objOut:"jqzoba558"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"qynzvcfdz",uiAttribs:{},portsIn:[{name:"posX",value:3.55},{name:"posY",value:0},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:90},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"jqzoba558",objOut:"qynzvcfdz"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"96z5dbnxl",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.06}],portsOut:[{name:"Result",links:[{portIn:"posY",portOut:"Result",objIn:"w5nf7ylop",objOut:"96z5dbnxl"}]}],objName:"Ops.Anim.LFO"},{id:"mfezv39hw",uiAttribs:{},portsIn:[{name:"Speed",value:.22},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"96z5dbnxl",objOut:"mfezv39hw"}]}],objName:"Ops.Anim.Timer_v2"},{id:"24jefxcyf",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotX",portOut:"Result",objIn:"w5nf7ylop",objOut:"24jefxcyf"}]}],objName:"Ops.Anim.LFO"},{id:"zn04356w1",uiAttribs:{},portsIn:[{name:"Speed",value:.46},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"24jefxcyf",objOut:"zn04356w1"}]}],objName:"Ops.Anim.Timer_v2"},{id:"h3ntfteyy",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotY",portOut:"Result",objIn:"w5nf7ylop",objOut:"h3ntfteyy"}]}],objName:"Ops.Anim.LFO"},{id:"bz393mtqv",uiAttribs:{},portsIn:[{name:"Speed",value:.1},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"h3ntfteyy",objOut:"bz393mtqv"}]}],objName:"Ops.Anim.Timer_v2"},{id:"4iq9ocp8v",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:-.2}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"w5nf7ylop",objOut:"4iq9ocp8v"}]}],objName:"Ops.Anim.LFO"},{id:"kaxpt5pmx",uiAttribs:{},portsIn:[{name:"Speed",value:.15},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"4iq9ocp8v",objOut:"kaxpt5pmx"}]}],objName:"Ops.Anim.Timer_v2"},{id:"r0gnkiz57",uiAttribs:{},portsIn:[{name:"posX",value:-.51},{name:"posY",value:-.65},{name:"posZ",value:0},{name:"scale",value:1},{name:"rotX",value:0},{name:"rotY",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"wc575hyec",objOut:"r0gnkiz57"},{portIn:"render",portOut:"trigger",objIn:"eppslamlj",objOut:"r0gnkiz57"},{portIn:"render",portOut:"trigger",objIn:"6fd07tk6u",objOut:"r0gnkiz57"},{portIn:"render",portOut:"trigger",objIn:"mb9t1d0ir",objOut:"r0gnkiz57"},{portIn:"render",portOut:"trigger",objIn:"1j0coc5dl",objOut:"r0gnkiz57"},{portIn:"render",portOut:"trigger",objIn:"iqhbsqpbi",objOut:"r0gnkiz57"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"iye1ldndl",uiAttribs:{},portsIn:[{name:"Type index",value:0},{name:"Type",value:"sine"},{name:"Phase",value:0},{name:"Amplitude",value:360}],portsOut:[{name:"Result",links:[{portIn:"rotZ",portOut:"Result",objIn:"r0gnkiz57",objOut:"iye1ldndl"}]}],objName:"Ops.Anim.LFO"},{id:"12jwzajcy",uiAttribs:{},portsIn:[{name:"Speed",value:.01},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"iye1ldndl",objOut:"12jwzajcy"}]}],objName:"Ops.Anim.Timer_v2"},{id:"bspi8cq8c",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/groscristalpointu4.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"of5f0nweg",objOut:"bspi8cq8c"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"hvlo140sy",objOut:"bspi8cq8c"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"dlpubgusu",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.003"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"bspi8cq8c",objOut:"dlpubgusu"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"hvlo140sy",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"of5f0nweg",objOut:"hvlo140sy"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"of5f0nweg",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"dlpubgusu",objOut:"of5f0nweg"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"h9943kuwf",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/lrgroscristal3.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"of3ynnv5h",objOut:"h9943kuwf"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"6wu8vop84",objOut:"h9943kuwf"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"7e26xjv6b",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.004"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"h9943kuwf",objOut:"7e26xjv6b"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"6wu8vop84",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"of3ynnv5h",objOut:"6wu8vop84"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"of3ynnv5h",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"7e26xjv6b",objOut:"of3ynnv5h"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"3wg5rdjv1",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/lrgroscristal3.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"80vv4g0eg",objOut:"3wg5rdjv1"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"47eksdwiu",objOut:"3wg5rdjv1"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"efhq86plv",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.004"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"3wg5rdjv1",objOut:"efhq86plv"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"47eksdwiu",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"80vv4g0eg",objOut:"47eksdwiu"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"80vv4g0eg",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"efhq86plv",objOut:"80vv4g0eg"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"mc90n9no2",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/lrgroscristal3.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"wfb8rdpy4",objOut:"mc90n9no2"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"xlft3urrf",objOut:"mc90n9no2"}]},{name:"Generator",value:"Khronos glTF Blender I/O v4.4.55"},{name:"GLTF Version",value:2},{name:"Anim Length",value:0},{name:"Anim Time",value:0},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"d6kpcnzjy",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.004"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"mc90n9no2",objOut:"d6kpcnzjy"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"xlft3urrf",uiAttribs:{},portsIn:[{name:"Name",value:"Image_0"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"wfb8rdpy4",objOut:"xlft3urrf"}]},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Type",value:"image/png"},{name:"Found",value:true}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"wfb8rdpy4",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.35},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"d6kpcnzjy",objOut:"wfb8rdpy4"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"149yrcktx",uiAttribs:{},storage:{blueprintVer:2,subPatchVer:2},portsIn:[{name:"dwgm6n0y5",title:"Render"},{name:"uudck28ir",title:"Update"},{name:"y8uhtij81",title:"render"},{name:"patchId",value:"bp2sub_149yrcktx"}],portsOut:[{name:"i87e8kc1b",title:"Result",links:[{portIn:"Input",portOut:"i87e8kc1b",objIn:"qq36gkqv8",objOut:"149yrcktx"}]}],objName:"Ops.Patch.PLfVxtG.SubPatch6"},{id:"0hdaz4neo",uiAttribs:{},portsIn:[{name:"Speed",value:.75},{name:"Play",value:1},{name:"Sync to timeline",value:0}],portsOut:[{name:"Time",links:[{portIn:"Time",portOut:"Time",objIn:"pukyuhyir",objOut:"0hdaz4neo"}]}],objName:"Ops.Anim.Timer_v2"},{id:"gkzi0ytx7",uiAttribs:{},portsIn:[{name:"Name",value:"FitnessGrandma_diffuse.jpg"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Width",value:0},{name:"Height",value:0},{name:"Type",value:""},{name:"Found",value:0}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"3f8gmf3ff",uiAttribs:{},portsIn:[{name:"R",value:.6889264280710078},{name:"G",value:.7879639882916046},{name:"B",value:.8356481424967448},{name:"A",value:1},{name:"Roughness",value:.135},{name:"Metalness",value:0},{name:"Alpha Mode index",value:3},{name:"Alpha Mode",value:"Blend"},{name:"Use Clear Coat",value:0},{name:"Clear Coat Intensity",value:.532},{name:"Clear Coat Roughness",value:.178},{name:"Use Normal map for Clear Coat",value:0},{name:"Use Thin Film",value:0},{name:"Thin Film Intensity",value:.626},{name:"Thin Film IOR",value:1.3},{name:"Thin Film Thickness (nm)",value:600},{name:"Thickness Tex Min",value:300},{name:"Thickness Tex Max",value:600},{name:"Tonemapping index",value:0},{name:"Tonemapping",value:"sRGB"},{name:"Exposure",value:1},{name:"Emission Intensity",value:1},{name:"Disable geometric roughness",value:0},{name:"Use roughness from normal map",value:0},{name:"Use Vertex Colours",value:0},{name:"Vertex Colour Mode index",value:0},{name:"Vertex Colour Mode",value:"colour"},{name:"Height Intensity",value:1},{name:"Faster heightmapping",value:0},{name:"Double Sided",value:0},{name:"Num mip levels",value:0},{name:"Diffuse Intensity",value:1},{name:"Specular Intensity",value:1},{name:"Lightmap is RGBE",value:0},{name:"Lightmap Intensity",value:1}],portsOut:[{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"pukyuhyir",objOut:"3f8gmf3ff"}]}],objName:"Ops.Gl.Pbr.PbrMaterial"},{id:"64jpmvjhj",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/67e6738210ea7516bc39baf0_Rumba_Dancing__2_.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Time",value:0},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Generator",value:"FBX2glTF v0.9.7"},{name:"GLTF Version",value:2},{name:"Anim Length",value:2.3333332538604736},{name:"Anim Time",value:.7340696071609756},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"},{id:"mg1cv6qpu",uiAttribs:{},portsIn:[{name:"posX",value:-3.06},{name:"posY",value:1.07},{name:"posZ",value:-4.64},{name:"rotX",value:0},{name:"rotY",value:226.19},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"3f8gmf3ff",objOut:"mg1cv6qpu"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"gff51osic",uiAttribs:{},portsIn:[{name:"Material Name",value:"Material_0.007"}],portsOut:[{name:"Material",links:[{portIn:"Materials",portOut:"Material",objIn:"pukyuhyir",objOut:"gff51osic"}]}],objName:"Ops.Gl.GLTF.GltfSetMaterial"},{id:"5x6n62xqr",uiAttribs:{},portsIn:[{name:"r",value:.9306567287818861},{name:"g",value:.7804543052948256},{name:"b",value:.9820399072827819},{name:"a",value:.213},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"shader",links:[{portIn:"Shader",portOut:"shader",objIn:"gff51osic",objOut:"5x6n62xqr"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"r3vrzymt5",uiAttribs:{},portsIn:[{name:"Name",value:"Image"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:0},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"5x6n62xqr",objOut:"r3vrzymt5"}]},{name:"Width",value:0},{name:"Height",value:0},{name:"Type",value:""},{name:"Found",value:0}],objName:"Ops.Gl.GLTF.GltfTexture"},{id:"q435k8j9v",uiAttribs:{},portsIn:[{name:"File",value:"assets/Cristaux.png",display:"file"},{name:"Filter index",value:2},{name:"Filter",value:"mipmap"},{name:"Wrap index",value:0},{name:"Wrap",value:"repeat"},{name:"Anisotropic index",value:0},{name:"Anisotropic",value:"0"},{name:"Data Format index",value:3},{name:"Data Format",value:"RGBA"},{name:"Flip",value:0},{name:"Pre Multiplied Alpha",value:0},{name:"Active",value:1},{name:"Save Memory",value:1},{name:"Add Cachebuster",value:0}],portsOut:[{name:"Texture",links:[{portIn:"Albedo",portOut:"Texture",objIn:"3f8gmf3ff",objOut:"q435k8j9v"},{portIn:"texture",portOut:"Texture",objIn:"5x6n62xqr",objOut:"q435k8j9v"}]},{name:"Width",value:1024},{name:"Height",value:1024},{name:"Aspect Ratio",value:1},{name:"Loaded",value:1},{name:"Loading",value:0}],objName:"Ops.Gl.Texture_v2"},{id:"j03ebk7g8",uiAttribs:{},portsIn:[{name:"min distance",value:1},{name:"max distance",value:999999},{name:"min rot y",value:0},{name:"max rot y",value:0},{name:"initial radius",value:2},{name:"initial axis y",value:.5},{name:"initial axis x",value:.25},{name:"Smoothness",value:1},{name:"Speed X",value:1},{name:"Speed Y",value:1},{name:"Active",value:1},{name:"Allow Panning",value:1},{name:"Allow Zooming",value:1},{name:"Allow Rotation",value:1},{name:"restricted",value:1},{name:"Identity",value:1}],portsOut:[{name:"radius",value:236.381600000001},{name:"Rot X",value:99.35831298517463},{name:"Rot Y",value:106.80000732421875}],objName:"Ops.Gl.Matrix.OrbitControls_v3"},{id:"fwqco6a34",uiAttribs:{},portsIn:[{name:"old min",value:8},{name:"old max",value:9},{name:"new min",value:0},{name:"new max",value:.29},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"scale",portOut:"result",objIn:"mg1cv6qpu",objOut:"fwqco6a34"}]}],objName:"Ops.Math.MapRange"},{id:"aag27it09",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"hauar4t4q",objOut:"aag27it09"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"pmijrog1m",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_16.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"aag27it09",objOut:"pmijrog1m"},{portIn:"Texture",portOut:"Texture",objIn:"lcep342mk",objOut:"pmijrog1m"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"a7dbc6h1s",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:10},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"lcep342mk",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"9f4be4be-0ced-4834-87b7-1caf498d56e3"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"hauar4t4q",uiAttribs:{},portsIn:[{name:"posX",value:-1.3},{name:"posY",value:-1},{name:"posZ",value:0},{name:"scale",value:.1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"a7dbc6h1s",objOut:"hauar4t4q"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"j5vhorqrp",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"xbyly5cs9",objOut:"j5vhorqrp"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"r928vwljj",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_18.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"j5vhorqrp",objOut:"r928vwljj"},{portIn:"Texture",portOut:"Texture",objIn:"qud3vceu4",objOut:"r928vwljj"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"ydp34i1w2",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:10},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"qud3vceu4",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"2268914f-0ee0-4a7c-b068-d19239777fb4"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"xbyly5cs9",uiAttribs:{},portsIn:[{name:"posX",value:1.3},{name:"posY",value:-1},{name:"posZ",value:0},{name:"scale",value:.1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"ydp34i1w2",objOut:"xbyly5cs9"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"nr9rrqtfa",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"dv0pq9vei",objOut:"nr9rrqtfa"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"34iixixgr",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_17.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"nr9rrqtfa",objOut:"34iixixgr"},{portIn:"Texture",portOut:"Texture",objIn:"x4zz1qepz",objOut:"34iixixgr"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"yfhn97m9i",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:10},{name:"height",value:2.3},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"x4zz1qepz",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"35b9e56e-7b74-4043-b99e-4fe4f97ebd9d"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"dv0pq9vei",uiAttribs:{},portsIn:[{name:"posX",value:0},{name:"posY",value:-1},{name:"posZ",value:0},{name:"scale",value:.1},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"yfhn97m9i",objOut:"dv0pq9vei"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"doyptzzik",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"8dxif6xkv",objOut:"doyptzzik"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"s8qtgl2qn",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_11.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"doyptzzik",objOut:"s8qtgl2qn"},{portIn:"Texture",portOut:"Texture",objIn:"nebqd8r24",objOut:"s8qtgl2qn"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"z5n0vx5zf",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:5.14},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"nebqd8r24",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"f3bff6fc-6e4a-4a76-a6fe-1fae65454663"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"8dxif6xkv",uiAttribs:{},portsIn:[{name:"posX",value:-.97},{name:"posY",value:-.77},{name:"posZ",value:0},{name:"scale",value:.3},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"z5n0vx5zf",objOut:"8dxif6xkv"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"v63xgvyxv",uiAttribs:{},portsIn:[{name:"old min",value:6},{name:"old max",value:6.2},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"doyptzzik",objOut:"v63xgvyxv"}]}],objName:"Ops.Math.MapRange"},{id:"bofkp6wst",uiAttribs:{},portsIn:[{name:"old min",value:5.3},{name:"old max",value:5.5},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"doyptzzik",objOut:"bofkp6wst"}]}],objName:"Ops.Math.MapRange"},{id:"nnfq9vmao",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"tm84m0sxu",objOut:"nnfq9vmao"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"2b7lxkric",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_12.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"nnfq9vmao",objOut:"2b7lxkric"},{portIn:"Texture",portOut:"Texture",objIn:"r7z86yndq",objOut:"2b7lxkric"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"gndjhi3hy",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:5.14},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"r7z86yndq",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"13b8b4a4-42dc-4d90-844c-af17e59d748b"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"tm84m0sxu",uiAttribs:{},portsIn:[{name:"posX",value:-.97},{name:"posY",value:-.77},{name:"posZ",value:0},{name:"scale",value:.3},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"gndjhi3hy",objOut:"tm84m0sxu"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"9084c56nr",uiAttribs:{},portsIn:[{name:"old min",value:4.4},{name:"old max",value:4.6},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"nnfq9vmao",objOut:"9084c56nr"}]}],objName:"Ops.Math.MapRange"},{id:"7l0lw83tn",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"837ksyvt8",objOut:"7l0lw83tn"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"4d5pcmuii",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_15.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"7l0lw83tn",objOut:"4d5pcmuii"},{portIn:"Texture",portOut:"Texture",objIn:"eg5j17eol",objOut:"4d5pcmuii"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"yekpfmpjp",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:5.14},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"eg5j17eol",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"b1853f74-ba1c-4c7e-b59e-8e71fe876e08"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"837ksyvt8",uiAttribs:{},portsIn:[{name:"posX",value:-.97},{name:"posY",value:-.77},{name:"posZ",value:0},{name:"scale",value:.3},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"yekpfmpjp",objOut:"837ksyvt8"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"xt3xf481g",uiAttribs:{},portsIn:[{name:"old min",value:6.3},{name:"old max",value:6.5},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"7l0lw83tn",objOut:"xt3xf481g"}]}],objName:"Ops.Math.MapRange"},{id:"octu5x22s",uiAttribs:{},portsIn:[{name:"old min",value:7.5},{name:"old max",value:7.6},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"7l0lw83tn",objOut:"octu5x22s"}]}],objName:"Ops.Math.MapRange"},{id:"8d5nev7xy",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"5n6l5bf8z",objOut:"8d5nev7xy"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"jun74tg98",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_13.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"8d5nev7xy",objOut:"jun74tg98"},{portIn:"Texture",portOut:"Texture",objIn:"dtmwmnxme",objOut:"jun74tg98"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"yi6izfcp2",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:5.14},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"dtmwmnxme",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"20c527b2-7295-43ab-8f5e-2368e5c21033"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"5n6l5bf8z",uiAttribs:{},portsIn:[{name:"posX",value:-.97},{name:"posY",value:-.77},{name:"posZ",value:0},{name:"scale",value:.3},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"yi6izfcp2",objOut:"5n6l5bf8z"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"x4uec9zvk",uiAttribs:{},portsIn:[{name:"old min",value:7.6},{name:"old max",value:7.8},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"8d5nev7xy",objOut:"x4uec9zvk"}]}],objName:"Ops.Math.MapRange"},{id:"lctg9ouwk",uiAttribs:{},portsIn:[{name:"old min",value:8.6},{name:"old max",value:8.8},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"8d5nev7xy",objOut:"lctg9ouwk"}]}],objName:"Ops.Math.MapRange"},{id:"hq25ppvb5",uiAttribs:{},portsIn:[{name:"r",value:.7638048366643488},{name:"g",value:.39304891671054065},{name:"b",value:.6472128252498806},{name:"colorizeTexture",value:0},{name:"Vertex Colors",value:0},{name:"Alpha Mask Source index",value:0},{name:"Alpha Mask Source",value:"Luminance"},{name:"Opacity TexCoords Transform",value:0},{name:"Discard Transparent Pixels",value:0},{name:"diffuseRepeatX",value:1},{name:"diffuseRepeatY",value:1},{name:"Tex Offset X",value:0},{name:"Tex Offset Y",value:0},{name:"Crop TexCoords",value:0},{name:"billboard",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"m4ucr0d8r",objOut:"hq25ppvb5"}]}],objName:"Ops.Gl.Shader.BasicMaterial_v3"},{id:"g42y88prv",uiAttribs:{},portsIn:[{name:"File",value:"assets/Fichier_14.svg",display:"file"},{name:"Texture width",value:2048},{name:"Texture height",value:2048},{name:"Wrap index",value:2},{name:"Wrap",value:"clamp to edge"},{name:"Filter index",value:1},{name:"Filter",value:"linear"}],portsOut:[{name:"Texture",links:[{portIn:"texture",portOut:"Texture",objIn:"hq25ppvb5",objOut:"g42y88prv"},{portIn:"Texture",portOut:"Texture",objIn:"hj02yjeyc",objOut:"g42y88prv"}]},{name:"Loaded",value:1}],objName:"Ops.Gl.Textures.TextureSVG_v2"},{id:"1ajcmo15y",uiAttribs:{},portsIn:[{name:"render",title:"Trigger"},{name:"Render Mesh",value:1,title:"Render"},{name:"width",value:5.14},{name:"height",value:2},{name:"pivot x index",value:1},{name:"pivot x",value:"center"},{name:"pivot y index",value:1},{name:"pivot y",value:"center"},{name:"axis index",value:0},{name:"axis",value:"xy"},{name:"Flip TexCoord X",value:0},{name:"Flip TexCoord Y",value:1},{name:"num columns",value:0},{name:"num rows",value:1}],objName:"Ops.Gl.Meshes.Rectangle_v4"},{id:"hj02yjeyc",uiAttribs:{},portsOut:[{name:"Name",value:"unknown"},{name:"PixelFormat",value:"RGBA 8bit ubyte"},{name:"Width",value:2048},{name:"Height",value:2048},{name:"Ratio",value:1},{name:"Filter",value:"1 linear"},{name:"Wrap",value:"2 clamp to edge"},{name:"Flipped",value:1},{name:"HDR",value:0,title:"Float Texture"},{name:"Is Empty Default Texture",value:0},{name:"Is Default Texture",value:0},{name:"Is Cubemap",value:0},{name:"Id",value:"c07dee83-db35-4cb9-988b-91a32a4ce6e5"}],objName:"Ops.Gl.Textures.TextureInfo_v2"},{id:"m4ucr0d8r",uiAttribs:{},portsIn:[{name:"posX",value:-.97},{name:"posY",value:-.77},{name:"posZ",value:0},{name:"scale",value:.3},{name:"rotX",value:0},{name:"rotY",value:0},{name:"rotZ",value:0}],portsOut:[{name:"trigger",links:[{portIn:"render",portOut:"trigger",objIn:"1ajcmo15y",objOut:"m4ucr0d8r"}]}],objName:"Ops.Gl.Matrix.Transform"},{id:"b8qmjzwx8",uiAttribs:{},portsIn:[{name:"old min",value:9.6},{name:"old max",value:9.9},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"hq25ppvb5",objOut:"b8qmjzwx8"}]}],objName:"Ops.Math.MapRange"},{id:"97iaov0g5",uiAttribs:{},portsIn:[{name:"old min",value:8.8},{name:"old max",value:9.1},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"hq25ppvb5",objOut:"97iaov0g5"}]}],objName:"Ops.Math.MapRange"},{id:"ixhfs78cz",uiAttribs:{},portsIn:[{name:"old min",value:5.1},{name:"old max",value:5.3},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"nnfq9vmao",objOut:"ixhfs78cz"}]}],objName:"Ops.Math.MapRange"},{id:"i7km4v1wx",uiAttribs:{},portsIn:[{name:"old min",value:9.9},{name:"old max",value:10},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"aag27it09",objOut:"i7km4v1wx"}]}],objName:"Ops.Math.MapRange"},{id:"ibichgc9z",uiAttribs:{},portsIn:[{name:"old min",value:10},{name:"old max",value:1e5},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"aag27it09",objOut:"ibichgc9z"}]}],objName:"Ops.Math.MapRange"},{id:"axal2z3vd",uiAttribs:{},portsIn:[{name:"old min",value:9.9},{name:"old max",value:10},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"j5vhorqrp",objOut:"axal2z3vd"}]}],objName:"Ops.Math.MapRange"},{id:"jwqndw3rb",uiAttribs:{},portsIn:[{name:"old min",value:10},{name:"old max",value:1e5},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"j5vhorqrp",objOut:"jwqndw3rb"}]}],objName:"Ops.Math.MapRange"},{id:"aav3w9116",uiAttribs:{},portsIn:[{name:"old min",value:9.9},{name:"old max",value:10},{name:"new min",value:0},{name:"new max",value:1},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"nr9rrqtfa",objOut:"aav3w9116"}]}],objName:"Ops.Math.MapRange"},{id:"ubjke9qia",uiAttribs:{},portsIn:[{name:"old min",value:10},{name:"old max",value:1e5},{name:"new min",value:1},{name:"new max",value:0},{name:"Easing index",value:0},{name:"Easing",value:"Linear"},{name:"Clamp",value:1}],portsOut:[{name:"result",links:[{portIn:"a",portOut:"result",objIn:"nr9rrqtfa",objOut:"ubjke9qia"}]}],objName:"Ops.Math.MapRange"},{id:"pukyuhyir",uiAttribs:{},portsIn:[{name:"data",value:""},{name:"glb File",value:"assets/Flair__1_.glb",display:"file"},{name:"Draw",value:1},{name:"Camera index",value:0},{name:"Camera",value:"None"},{name:"Animation",value:""},{name:"Center index",value:1},{name:"Center",value:"XYZ"},{name:"Rescale",value:1},{name:"Rescale Size",value:2.5},{name:"Sync to timeline",value:0},{name:"Loop",value:1},{name:"Normals Format index",value:0},{name:"Normals Format",value:"XYZ"},{name:"Vertices Format index",value:0},{name:"Vertices Format",value:"XYZ"},{name:"Calc Normals index",value:0},{name:"Calc Normals",value:"Auto"},{name:"Hide Nodes",value:0},{name:"Use Material Properties",value:0},{name:"Active",value:1}],portsOut:[{name:"Render Before",links:[{portIn:"render",portOut:"Render Before",objIn:"5x6n62xqr",objOut:"pukyuhyir"}]},{name:"Next",links:[{portIn:"Render",portOut:"Next",objIn:"r3vrzymt5",objOut:"pukyuhyir"}]},{name:"Generator",value:"FBX2glTF v0.9.7"},{name:"GLTF Version",value:2},{name:"Anim Length",value:1},{name:"Anim Time",value:.2661999999955924},{name:"Loading",value:false}],objName:"Ops.Gl.GLTF.GltfScene_v4"}],export:{time:"2025-04-19 11:42",service:"html",exportNumber:1}};if(!CABLES.exportedPatch){CABLES.exportedPatch=CABLES.exportedPatches["LfVxtG"]}"use strict";var CABLES=CABLES||{};CABLES.OPS=CABLES.OPS||{};var Ops=Ops||{};Ops.Gl=Ops.Gl||{};Ops.Ui=Ops.Ui||{};Ops.Anim=Ops.Anim||{};Ops.Html=Ops.Html||{};Ops.Math=Ops.Math||{};Ops.Vars=Ops.Vars||{};Ops.Patch=Ops.Patch||{};Ops.Gl.Pbr=Ops.Gl.Pbr||{};Ops.Number=Ops.Number||{};Ops.String=Ops.String||{};Ops.Boolean=Ops.Boolean||{};Ops.Devices=Ops.Devices||{};Ops.Gl.GLTF=Ops.Gl.GLTF||{};Ops.Sidebar=Ops.Sidebar||{};Ops.Trigger=Ops.Trigger||{};Ops.Gl.Phong=Ops.Gl.Phong||{};Ops.Graphics=Ops.Graphics||{};Ops.WebAudio=Ops.WebAudio||{};Ops.Extension=Ops.Extension||{};Ops.Gl.Matrix=Ops.Gl.Matrix||{};Ops.Gl.Meshes=Ops.Gl.Meshes||{};Ops.Gl.Shader=Ops.Gl.Shader||{};Ops.Gl.CubeMap=Ops.Gl.CubeMap||{};Ops.Gl.Textures=Ops.Gl.Textures||{};Ops.Math.Compare=Ops.Math.Compare||{};Ops.Devices.Mouse=Ops.Devices.Mouse||{};Ops.Patch.PLfVxtG=Ops.Patch.PLfVxtG||{};Ops.Gl.ImageCompose=Ops.Gl.ImageCompose||{};Ops.Gl.ShaderEffects=Ops.Gl.ShaderEffects||{};Ops.Graphics.Geometry=Ops.Graphics.Geometry||{};Ops.Extension.OpenType=Ops.Extension.OpenType||{};Ops.Extension.Mediapipe=Ops.Extension.Mediapipe||{};Ops.Extension.Deprecated=Ops.Extension.Deprecated||{};Ops.Gl.ImageCompose.Noise=Ops.Gl.ImageCompose.Noise||{};Ops.Patch.PLfVxtG.Scene1=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_4y3uaxvxs=op.inTrigger("4y3uaxvxs");\nport_4y3uaxvxs.setUiAttribs({title:"render",});\n\nconst port_4afm0tvlm=op.inTrigger("4afm0tvlm");\nport_4afm0tvlm.setUiAttribs({title:"render",});\n\nconst port_ahpj794b9=op.inTrigger("ahpj794b9");\nport_ahpj794b9.setUiAttribs({title:"render",});\n\nconst port_ip98ojemb=op.inTrigger("ip98ojemb");\nport_ip98ojemb.setUiAttribs({title:"render",});\n\nconst port_yx2wcoz1q=op.inTrigger("yx2wcoz1q");\nport_yx2wcoz1q.setUiAttribs({title:"render",});\n\nconst port_x68ysan9u=op.inTrigger("x68ysan9u");\nport_x68ysan9u.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_4y3uaxvxs = addedOps[i].outTrigger("innerOut_4y3uaxvxs");\ninnerOut_4y3uaxvxs.setUiAttribs({title:"render"});\nport_4y3uaxvxs.onTriggered = () => { innerOut_4y3uaxvxs.trigger(); };\n\nconst innerOut_4afm0tvlm = addedOps[i].outTrigger("innerOut_4afm0tvlm");\ninnerOut_4afm0tvlm.setUiAttribs({title:"render"});\nport_4afm0tvlm.onTriggered = () => { innerOut_4afm0tvlm.trigger(); };\n\nconst innerOut_ahpj794b9 = addedOps[i].outTrigger("innerOut_ahpj794b9");\ninnerOut_ahpj794b9.setUiAttribs({title:"render"});\nport_ahpj794b9.onTriggered = () => { innerOut_ahpj794b9.trigger(); };\n\nconst innerOut_ip98ojemb = addedOps[i].outTrigger("innerOut_ip98ojemb");\ninnerOut_ip98ojemb.setUiAttribs({title:"render"});\nport_ip98ojemb.onTriggered = () => { innerOut_ip98ojemb.trigger(); };\n\nconst innerOut_yx2wcoz1q = addedOps[i].outTrigger("innerOut_yx2wcoz1q");\ninnerOut_yx2wcoz1q.setUiAttribs({title:"render"});\nport_yx2wcoz1q.onTriggered = () => { innerOut_yx2wcoz1q.trigger(); };\n\nconst innerOut_x68ysan9u = addedOps[i].outTrigger("innerOut_x68ysan9u");\ninnerOut_x68ysan9u.setUiAttribs({title:"render"});\nport_x68ysan9u.onTriggered = () => { innerOut_x68ysan9u.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp0-0","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_Salle_4_-_plateforme_ge_ne_rale.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp0-3","objOut":"bp0-0"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-2","objOut":"bp0-0"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-1","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Material Name","value":"Dark Steel"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp0-0","objOut":"bp0-1"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp0-2","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Name","value":"Steel Grey_old_Base Color"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp0-3","objOut":"bp0-2"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/jpeg"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp0-3","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"r","value":0.3182034080191214},{"name":"g","value":0.2335242632177621},{"name":"b","value":0.6708193724173028},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp0-1","objOut":"bp0-3"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp0-4","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.030418613152753553},{"name":"posZ","value":0},{"name":"scale","value":1.54},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp0-0","objOut":"bp0-4"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-5","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_Salle_4_-_arabesque.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp0-9","objOut":"bp0-5"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-7","objOut":"bp0-5"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-6","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Material Name","value":"White Wood"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp0-5","objOut":"bp0-6"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp0-7","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Name","value":"white_wood_Base_color"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp0-9","objOut":"bp0-7"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/jpeg"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp0-8","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.45},{"name":"posZ","value":0.33},{"name":"scale","value":0.32},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp0-5","objOut":"bp0-8"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-9","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"r","value":0.3182034080191214},{"name":"g","value":0.2335242632177621},{"name":"b","value":0.6708193724173028},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp0-6","objOut":"bp0-9"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp0-10","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_Salle_4_-_chaise_arabesque.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp0-13","objOut":"bp0-10"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-12","objOut":"bp0-10"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-11","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp0-10","objOut":"bp0-11"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp0-12","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp0-13","objOut":"bp0-12"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp0-13","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"r","value":0.3182034080191214},{"name":"g","value":0.2335242632177621},{"name":"b","value":0.6708193724173028},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp0-11","objOut":"bp0-13"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp0-14","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":1.3669595043074858},{"name":"posY","value":0.5476273208097314},{"name":"posZ","value":0.47846677678986144},{"name":"scale","value":0.37},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp0-10","objOut":"bp0-14"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-15","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_Salle_4_-_musique.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp0-19","objOut":"bp0-15"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-17","objOut":"bp0-15"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-16","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp0-15","objOut":"bp0-16"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp0-17","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp0-19","objOut":"bp0-17"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp0-18","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":-1.0206128906526606},{"name":"posY","value":0.611945789908514},{"name":"posZ","value":1.1137063845666828},{"name":"scale","value":0.44},{"name":"rotX","value":0},{"name":"rotY","value":4.39},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp0-15","objOut":"bp0-18"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-19","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"r","value":0.3182034080191214},{"name":"g","value":0.2335242632177621},{"name":"b","value":0.6708193724173028},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp0-16","objOut":"bp0-19"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp0-20","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_Salle_4_-_mini_plate.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":1.59},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-21","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"R","value":1},{"name":"G","value":-0.234},{"name":"B","value":0.1726251077651979},{"name":"A","value":1},{"name":"Roughness","value":0},{"name":"Metalness","value":0},{"name":"Alpha Mode index","value":3},{"name":"Alpha Mode","value":"Blend"},{"name":"Use Clear Coat","value":0},{"name":"Clear Coat Intensity","value":1},{"name":"Clear Coat Roughness","value":0.5},{"name":"Use Normal map for Clear Coat","value":0},{"name":"Use Thin Film","value":0},{"name":"Thin Film Intensity","value":1},{"name":"Thin Film IOR","value":1.3},{"name":"Thin Film Thickness (nm)","value":600},{"name":"Thickness Tex Min","value":300},{"name":"Thickness Tex Max","value":600},{"name":"Tonemapping index","value":0},{"name":"Tonemapping","value":"sRGB"},{"name":"Exposure","value":1},{"name":"Emission Intensity","value":1},{"name":"Disable geometric roughness","value":0},{"name":"Use roughness from normal map","value":0},{"name":"Use Vertex Colours","value":0},{"name":"Vertex Colour Mode index","value":0},{"name":"Vertex Colour Mode","value":"colour"},{"name":"Height Intensity","value":1},{"name":"Faster heightmapping","value":0},{"name":"Double Sided","value":0},{"name":"Num mip levels","value":0},{"name":"Diffuse Intensity","value":1},{"name":"Specular Intensity","value":1},{"name":"Lightmap is RGBE","value":0},{"name":"Lightmap Intensity","value":1}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-20","objOut":"bp0-21"}]}],"objName":"Ops.Gl.Pbr.PbrMaterial"},{"id":"bp0-22","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.3943508878200778},{"name":"posZ","value":-1.289473601013437},{"name":"scale","value":0.34},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp0-21","objOut":"bp0-22"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-23","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5700808057c16b1c655c9_lampe_noir.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Generator","value":"https://github.com/mikedh/trimesh"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp0-24","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"posX","value":0.022348368439230715},{"name":"posY","value":0.952970564542362},{"name":"posZ","value":-1.3111133802217174},{"name":"scale","value":0.22},{"name":"rotX","value":0},{"name":"rotY","value":4.39},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp0-25","objOut":"bp0-24"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp0-25","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsIn":[{"name":"R","value":0.6088104248046875},{"name":"G","value":0.9231067991256715},{"name":"B","value":1},{"name":"A","value":0.9771875},{"name":"Roughness","value":0},{"name":"Metalness","value":0},{"name":"Alpha Mode index","value":3},{"name":"Alpha Mode","value":"Blend"},{"name":"Use Clear Coat","value":0},{"name":"Clear Coat Intensity","value":1},{"name":"Clear Coat Roughness","value":0.5},{"name":"Use Normal map for Clear Coat","value":0},{"name":"Use Thin Film","value":0},{"name":"Thin Film Intensity","value":1},{"name":"Thin Film IOR","value":1.3},{"name":"Thin Film Thickness (nm)","value":600},{"name":"Thickness Tex Min","value":300},{"name":"Thickness Tex Max","value":600},{"name":"Tonemapping index","value":0},{"name":"Tonemapping","value":"sRGB"},{"name":"Exposure","value":1},{"name":"Emission Intensity","value":1},{"name":"Disable geometric roughness","value":0},{"name":"Use roughness from normal map","value":0},{"name":"Use Vertex Colours","value":0},{"name":"Vertex Colour Mode index","value":0},{"name":"Vertex Colour Mode","value":"colour"},{"name":"Height Intensity","value":1},{"name":"Faster heightmapping","value":0},{"name":"Double Sided","value":0},{"name":"Num mip levels","value":0},{"name":"Diffuse Intensity","value":1},{"name":"Specular Intensity","value":1},{"name":"Lightmap is RGBE","value":0},{"name":"Lightmap Intensity","value":1}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp0-23","objOut":"bp0-25"}]}],"objName":"Ops.Gl.Pbr.PbrMaterial"},{"id":"bp0-26","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"portsOut":[{"name":"innerOut_4y3uaxvxs","title":"render","links":[{"portIn":"render","portOut":"innerOut_4y3uaxvxs","objIn":"bp0-4","objOut":"bp0-26"}]},{"name":"innerOut_ahpj794b9","title":"render","links":[{"portIn":"render","portOut":"innerOut_ahpj794b9","objIn":"bp0-14","objOut":"bp0-26"}]},{"name":"innerOut_ip98ojemb","title":"render","links":[{"portIn":"render","portOut":"innerOut_ip98ojemb","objIn":"bp0-18","objOut":"bp0-26"}]},{"name":"innerOut_yx2wcoz1q","title":"render","links":[{"portIn":"render","portOut":"innerOut_yx2wcoz1q","objIn":"bp0-22","objOut":"bp0-26"}]},{"name":"innerOut_x68ysan9u","title":"render","links":[{"portIn":"render","portOut":"innerOut_x68ysan9u","objIn":"bp0-24","objOut":"bp0-26"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp0-27","uiAttribs":{"subPatch":"l49t0357n"},"storage":{},"objName":"Ops.Ui.SubPatchOutput"}]}'};const l=e.inTrigger("4y3uaxvxs");l.setUiAttribs({title:"render"});const u=e.inTrigger("4afm0tvlm");u.setUiAttribs({title:"render"});const m=e.inTrigger("ahpj794b9");m.setUiAttribs({title:"render"});const p=e.inTrigger("ip98ojemb");p.setUiAttribs({title:"render"});const c=e.inTrigger("yx2wcoz1q");c.setUiAttribs({title:"render"});const d=e.inTrigger("x68ysan9u");d.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_4y3uaxvxs");n.setUiAttribs({title:"render"});l.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_4afm0tvlm");a.setUiAttribs({title:"render"});u.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_ahpj794b9");i.setUiAttribs({title:"render"});m.onTriggered=()=>{i.trigger()};const r=t[e].outTrigger("innerOut_ip98ojemb");r.setUiAttribs({title:"render"});p.onTriggered=()=>{r.trigger()};const s=t[e].outTrigger("innerOut_yx2wcoz1q");s.setUiAttribs({title:"render"});c.onTriggered=()=>{s.trigger()};const o=t[e].outTrigger("innerOut_x68ysan9u");o.setUiAttribs({title:"render"});d.onTriggered=()=>{o.trigger()}}if(t[e].innerOutput){}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.Scene1.prototype=new CABLES.Op;CABLES.OPS["d7fa85e6-1aa9-453e-bb61-efb2bb4c37ad"]={f:Ops.Patch.PLfVxtG.Scene1,objName:"Ops.Patch.PLfVxtG.Scene1"};Ops.Patch.PLfVxtG.Scene2=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_top2cfpvc=op.inTrigger("top2cfpvc");\nport_top2cfpvc.setUiAttribs({title:"render",});\n\nconst port_86hqndd33=op.inTrigger("86hqndd33");\nport_86hqndd33.setUiAttribs({title:"render",});\n\nconst port_uxdh39dmd=op.inTrigger("uxdh39dmd");\nport_uxdh39dmd.setUiAttribs({title:"render",});\n\nconst port_ezmeafmv2=op.inTrigger("ezmeafmv2");\nport_ezmeafmv2.setUiAttribs({title:"render",});\n\nconst port_lep5zghtn=op.inTrigger("lep5zghtn");\nport_lep5zghtn.setUiAttribs({title:"render",});\n\nconst port_sf1qgnyf2=op.inTrigger("sf1qgnyf2");\nport_sf1qgnyf2.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_top2cfpvc = addedOps[i].outTrigger("innerOut_top2cfpvc");\ninnerOut_top2cfpvc.setUiAttribs({title:"render"});\nport_top2cfpvc.onTriggered = () => { innerOut_top2cfpvc.trigger(); };\n\nconst innerOut_86hqndd33 = addedOps[i].outTrigger("innerOut_86hqndd33");\ninnerOut_86hqndd33.setUiAttribs({title:"render"});\nport_86hqndd33.onTriggered = () => { innerOut_86hqndd33.trigger(); };\n\nconst innerOut_uxdh39dmd = addedOps[i].outTrigger("innerOut_uxdh39dmd");\ninnerOut_uxdh39dmd.setUiAttribs({title:"render"});\nport_uxdh39dmd.onTriggered = () => { innerOut_uxdh39dmd.trigger(); };\n\nconst innerOut_ezmeafmv2 = addedOps[i].outTrigger("innerOut_ezmeafmv2");\ninnerOut_ezmeafmv2.setUiAttribs({title:"render"});\nport_ezmeafmv2.onTriggered = () => { innerOut_ezmeafmv2.trigger(); };\n\nconst innerOut_lep5zghtn = addedOps[i].outTrigger("innerOut_lep5zghtn");\ninnerOut_lep5zghtn.setUiAttribs({title:"render"});\nport_lep5zghtn.onTriggered = () => { innerOut_lep5zghtn.trigger(); };\n\nconst innerOut_sf1qgnyf2 = addedOps[i].outTrigger("innerOut_sf1qgnyf2");\ninnerOut_sf1qgnyf2.setUiAttribs({title:"render"});\nport_sf1qgnyf2.onTriggered = () => { innerOut_sf1qgnyf2.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp1-0","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_platefrome_ge_ne_rale.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.23},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-1","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp1-2","objOut":"bp1-1"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-2","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"R","value":0.5742371582984924},{"name":"G","value":0.6914462644451266},{"name":"B","value":0.94203125},{"name":"A","value":1},{"name":"Roughness","value":0},{"name":"Metalness","value":0},{"name":"Alpha Mode index","value":3},{"name":"Alpha Mode","value":"Blend"},{"name":"Use Clear Coat","value":0},{"name":"Clear Coat Intensity","value":1},{"name":"Clear Coat Roughness","value":0.5},{"name":"Use Normal map for Clear Coat","value":0},{"name":"Use Thin Film","value":0},{"name":"Thin Film Intensity","value":1},{"name":"Thin Film IOR","value":1.3},{"name":"Thin Film Thickness (nm)","value":600},{"name":"Thickness Tex Min","value":300},{"name":"Thickness Tex Max","value":600},{"name":"Tonemapping index","value":0},{"name":"Tonemapping","value":"sRGB"},{"name":"Exposure","value":1},{"name":"Emission Intensity","value":1},{"name":"Disable geometric roughness","value":0},{"name":"Use roughness from normal map","value":0},{"name":"Use Vertex Colours","value":0},{"name":"Vertex Colour Mode index","value":0},{"name":"Vertex Colour Mode","value":"colour"},{"name":"Height Intensity","value":1},{"name":"Faster heightmapping","value":0},{"name":"Double Sided","value":0},{"name":"Num mip levels","value":0},{"name":"Diffuse Intensity","value":1},{"name":"Specular Intensity","value":1},{"name":"Lightmap is RGBE","value":0},{"name":"Lightmap Intensity","value":1}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-0","objOut":"bp1-2"}]}],"objName":"Ops.Gl.Pbr.PbrMaterial"},{"id":"bp1-3","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_chaise_cristaux.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp1-7","objOut":"bp1-3"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-5","objOut":"bp1-3"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-4","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp1-3","objOut":"bp1-4"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp1-5","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp1-7","objOut":"bp1-5"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp1-6","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":-0.8139776412295805},{"name":"posY","value":0.43719613420232467},{"name":"posZ","value":0.8096998276384194},{"name":"scale","value":0.37},{"name":"rotX","value":0},{"name":"rotY","value":-90},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp1-3","objOut":"bp1-6"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-7","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"r","value":0.17007449593241764},{"name":"g","value":0.8806221968611871},{"name":"b","value":0.787986160844234},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp1-4","objOut":"bp1-7"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp1-8","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_platefrome_cercle.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":1.73},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-9","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":-0.00047595595878537067},{"name":"posY","value":0.375260346476861},{"name":"posZ","value":0.015186654159675642},{"name":"scale","value":0.35},{"name":"rotX","value":0},{"name":"rotY","value":-90},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp1-10","objOut":"bp1-9"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-10","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"R","value":0.2741927083333333},{"name":"G","value":0.2741927083333333},{"name":"B","value":0.2741927083333333},{"name":"A","value":1},{"name":"Roughness","value":0},{"name":"Metalness","value":0},{"name":"Alpha Mode index","value":3},{"name":"Alpha Mode","value":"Blend"},{"name":"Use Clear Coat","value":0},{"name":"Clear Coat Intensity","value":1},{"name":"Clear Coat Roughness","value":0.5},{"name":"Use Normal map for Clear Coat","value":0},{"name":"Use Thin Film","value":0},{"name":"Thin Film Intensity","value":1},{"name":"Thin Film IOR","value":1.3},{"name":"Thin Film Thickness (nm)","value":600},{"name":"Thickness Tex Min","value":300},{"name":"Thickness Tex Max","value":600},{"name":"Tonemapping index","value":0},{"name":"Tonemapping","value":"sRGB"},{"name":"Exposure","value":1},{"name":"Emission Intensity","value":1},{"name":"Disable geometric roughness","value":0},{"name":"Use roughness from normal map","value":0},{"name":"Use Vertex Colours","value":0},{"name":"Vertex Colour Mode index","value":0},{"name":"Vertex Colour Mode","value":"colour"},{"name":"Height Intensity","value":1},{"name":"Faster heightmapping","value":0},{"name":"Double Sided","value":0},{"name":"Num mip levels","value":0},{"name":"Diffuse Intensity","value":1},{"name":"Specular Intensity","value":1},{"name":"Lightmap is RGBE","value":0},{"name":"Lightmap Intensity","value":1}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-8","objOut":"bp1-10"}]}],"objName":"Ops.Gl.Pbr.PbrMaterial"},{"id":"bp1-11","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_lavabo.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp1-15","objOut":"bp1-11"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-13","objOut":"bp1-11"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-12","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp1-11","objOut":"bp1-12"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp1-13","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp1-15","objOut":"bp1-13"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp1-14","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.9562435704780214},{"name":"posZ","value":0},{"name":"scale","value":0.25},{"name":"rotX","value":0},{"name":"rotY","value":-90},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp1-11","objOut":"bp1-14"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-15","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"r","value":0.17007449593241764},{"name":"g","value":0.8806221968611871},{"name":"b","value":0.787986160844234},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp1-12","objOut":"bp1-15"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp1-16","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_toilettes.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp1-19","objOut":"bp1-16"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-17","objOut":"bp1-16"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-17","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp1-19","objOut":"bp1-17"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp1-18","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Material Name","value":"Simple Crystal"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp1-16","objOut":"bp1-18"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp1-19","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"r","value":0.17007449593241764},{"name":"g","value":0.8806221968611871},{"name":"b","value":0.787986160844234},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp1-18","objOut":"bp1-19"},{"portIn":"Shader","portOut":"shader","objIn":"bp1-21","objOut":"bp1-19"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp1-20","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":0.7971126429556927},{"name":"posY","value":0.5552844365983226},{"name":"posZ","value":-0.7565862775243394},{"name":"scale","value":0.41},{"name":"rotX","value":0},{"name":"rotY","value":-90},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp1-16","objOut":"bp1-20"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-21","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.002"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp1-16","objOut":"bp1-21"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp1-22","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5792810ea7516bc390700_Salle_5_-_BD_cristaux.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp1-26","objOut":"bp1-22"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp1-24","objOut":"bp1-22"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp1-23","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.003"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp1-22","objOut":"bp1-23"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp1-24","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp1-26","objOut":"bp1-24"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp1-25","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"posX","value":0.5927324330827557},{"name":"posY","value":0.7052363863605613},{"name":"posZ","value":0.8509806778486889},{"name":"scale","value":0.52},{"name":"rotX","value":0},{"name":"rotY","value":-85},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp1-22","objOut":"bp1-25"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp1-26","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsIn":[{"name":"r","value":0.17007449593241764},{"name":"g","value":0.8806221968611871},{"name":"b","value":0.787986160844234},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp1-23","objOut":"bp1-26"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp1-27","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"portsOut":[{"name":"innerOut_top2cfpvc","title":"render","links":[{"portIn":"render","portOut":"innerOut_top2cfpvc","objIn":"bp1-1","objOut":"bp1-27"}]},{"name":"innerOut_86hqndd33","title":"render","links":[{"portIn":"render","portOut":"innerOut_86hqndd33","objIn":"bp1-6","objOut":"bp1-27"}]},{"name":"innerOut_uxdh39dmd","title":"render","links":[{"portIn":"render","portOut":"innerOut_uxdh39dmd","objIn":"bp1-9","objOut":"bp1-27"}]},{"name":"innerOut_ezmeafmv2","title":"render","links":[{"portIn":"render","portOut":"innerOut_ezmeafmv2","objIn":"bp1-14","objOut":"bp1-27"}]},{"name":"innerOut_lep5zghtn","title":"render","links":[{"portIn":"render","portOut":"innerOut_lep5zghtn","objIn":"bp1-20","objOut":"bp1-27"}]},{"name":"innerOut_sf1qgnyf2","title":"render","links":[{"portIn":"render","portOut":"innerOut_sf1qgnyf2","objIn":"bp1-25","objOut":"bp1-27"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp1-28","uiAttribs":{"subPatch":"5s1994pf9"},"storage":{},"objName":"Ops.Ui.SubPatchOutput"}]}'};const l=e.inTrigger("top2cfpvc");l.setUiAttribs({title:"render"});const u=e.inTrigger("86hqndd33");u.setUiAttribs({title:"render"});const m=e.inTrigger("uxdh39dmd");m.setUiAttribs({title:"render"});const p=e.inTrigger("ezmeafmv2");p.setUiAttribs({title:"render"});const c=e.inTrigger("lep5zghtn");c.setUiAttribs({title:"render"});const d=e.inTrigger("sf1qgnyf2");d.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_top2cfpvc");n.setUiAttribs({title:"render"});l.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_86hqndd33");a.setUiAttribs({title:"render"});u.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_uxdh39dmd");i.setUiAttribs({title:"render"});m.onTriggered=()=>{i.trigger()};const r=t[e].outTrigger("innerOut_ezmeafmv2");r.setUiAttribs({title:"render"});p.onTriggered=()=>{r.trigger()};const s=t[e].outTrigger("innerOut_lep5zghtn");s.setUiAttribs({title:"render"});c.onTriggered=()=>{s.trigger()};const o=t[e].outTrigger("innerOut_sf1qgnyf2");o.setUiAttribs({title:"render"});d.onTriggered=()=>{o.trigger()}}if(t[e].innerOutput){}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.Scene2.prototype=new CABLES.Op;CABLES.OPS["68f60d50-36af-4bc9-95e0-deed74679164"]={f:Ops.Patch.PLfVxtG.Scene2,objName:"Ops.Patch.PLfVxtG.Scene2"};Ops.Patch.PLfVxtG.Scene4=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_ywf2m4z87=op.inTrigger("ywf2m4z87");\nport_ywf2m4z87.setUiAttribs({title:"render",});\n\nconst port_bpvghff97=op.inTrigger("bpvghff97");\nport_bpvghff97.setUiAttribs({title:"render",});\n\nconst port_qtrmi8iov=op.inTrigger("qtrmi8iov");\nport_qtrmi8iov.setUiAttribs({title:"render",});\n\nconst port_bpwrv87h8=op.inTrigger("bpwrv87h8");\nport_bpwrv87h8.setUiAttribs({title:"render",});\n\nconst port_w7qcf3ri1=op.inTrigger("w7qcf3ri1");\nport_w7qcf3ri1.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_ywf2m4z87 = addedOps[i].outTrigger("innerOut_ywf2m4z87");\ninnerOut_ywf2m4z87.setUiAttribs({title:"render"});\nport_ywf2m4z87.onTriggered = () => { innerOut_ywf2m4z87.trigger(); };\n\nconst innerOut_bpvghff97 = addedOps[i].outTrigger("innerOut_bpvghff97");\ninnerOut_bpvghff97.setUiAttribs({title:"render"});\nport_bpvghff97.onTriggered = () => { innerOut_bpvghff97.trigger(); };\n\nconst innerOut_qtrmi8iov = addedOps[i].outTrigger("innerOut_qtrmi8iov");\ninnerOut_qtrmi8iov.setUiAttribs({title:"render"});\nport_qtrmi8iov.onTriggered = () => { innerOut_qtrmi8iov.trigger(); };\n\nconst innerOut_bpwrv87h8 = addedOps[i].outTrigger("innerOut_bpwrv87h8");\ninnerOut_bpwrv87h8.setUiAttribs({title:"render"});\nport_bpwrv87h8.onTriggered = () => { innerOut_bpwrv87h8.trigger(); };\n\nconst innerOut_w7qcf3ri1 = addedOps[i].outTrigger("innerOut_w7qcf3ri1");\ninnerOut_w7qcf3ri1.setUiAttribs({title:"render"});\nport_w7qcf3ri1.onTriggered = () => { innerOut_w7qcf3ri1.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp2-0","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e56569ccab331699650b6f_sol_arbre.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp2-3","objOut":"bp2-0"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp2-2","objOut":"bp2-0"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp2-1","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Material Name","value":"Soil Ground.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp2-0","objOut":"bp2-1"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp2-2","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Name","value":"PX_Soil_Ground_23_albedo"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp2-3","objOut":"bp2-2"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/jpeg"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp2-3","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"r","value":0.761836559459268},{"name":"g","value":0.2121575220374361},{"name":"b","value":0.4565950043822775},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp2-1","objOut":"bp2-3"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-4","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e56569ccab331699650b6f_Salle_1_-_chaise_cristaux.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp2-7","objOut":"bp2-4"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp2-6","objOut":"bp2-4"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp2-5","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp2-4","objOut":"bp2-5"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp2-6","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp2-7","objOut":"bp2-6"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp2-7","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"r","value":0.761836559459268},{"name":"g","value":0.2121575220374361},{"name":"b","value":0.4565950043822775},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp2-5","objOut":"bp2-7"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-8","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp2-0","objOut":"bp2-8"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-9","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"posX","value":0.69},{"name":"posY","value":0.33},{"name":"posZ","value":0},{"name":"scale","value":0.2},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp2-4","objOut":"bp2-9"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-10","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e56569ccab331699650b6f_Salle_1_-_racine.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp2-14","objOut":"bp2-10"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp2-13","objOut":"bp2-10"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp2-11","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"posX","value":-0.86},{"name":"posY","value":0.33},{"name":"posZ","value":0},{"name":"scale","value":0.3},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp2-10","objOut":"bp2-11"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-12","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.003"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp2-10","objOut":"bp2-12"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp2-13","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp2-14","objOut":"bp2-13"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp2-14","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"r","value":0.761836559459268},{"name":"g","value":0.2121575220374361},{"name":"b","value":0.4565950043822775},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp2-12","objOut":"bp2-14"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-15","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e56569ccab331699650b6f_tabel_arbre.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp2-18","objOut":"bp2-15"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp2-16","objOut":"bp2-15"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp2-16","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp2-18","objOut":"bp2-16"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp2-17","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp2-15","objOut":"bp2-17"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp2-18","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"r","value":0.761836559459268},{"name":"g","value":0.2121575220374361},{"name":"b","value":0.4565950043822775},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp2-17","objOut":"bp2-18"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-19","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"posX","value":-0.04},{"name":"posY","value":0.28},{"name":"posZ","value":0},{"name":"scale","value":0.42},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp2-15","objOut":"bp2-19"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-20","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e56569ccab331699650b6f_Salle_1_-_lampe.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp2-24","objOut":"bp2-20"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp2-22","objOut":"bp2-20"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp2-21","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.002"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp2-20","objOut":"bp2-21"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp2-22","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp2-24","objOut":"bp2-22"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp2-23","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.63},{"name":"posZ","value":0},{"name":"scale","value":0.1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp2-20","objOut":"bp2-23"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp2-24","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsIn":[{"name":"r","value":0.761836559459268},{"name":"g","value":0.2121575220374361},{"name":"b","value":0.4565950043822775},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp2-21","objOut":"bp2-24"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp2-25","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"portsOut":[{"name":"innerOut_ywf2m4z87","title":"render","links":[{"portIn":"render","portOut":"innerOut_ywf2m4z87","objIn":"bp2-8","objOut":"bp2-25"}]},{"name":"innerOut_bpvghff97","title":"render","links":[{"portIn":"render","portOut":"innerOut_bpvghff97","objIn":"bp2-9","objOut":"bp2-25"}]},{"name":"innerOut_qtrmi8iov","title":"render","links":[{"portIn":"render","portOut":"innerOut_qtrmi8iov","objIn":"bp2-11","objOut":"bp2-25"}]},{"name":"innerOut_bpwrv87h8","title":"render","links":[{"portIn":"render","portOut":"innerOut_bpwrv87h8","objIn":"bp2-19","objOut":"bp2-25"}]},{"name":"innerOut_w7qcf3ri1","title":"render","links":[{"portIn":"render","portOut":"innerOut_w7qcf3ri1","objIn":"bp2-23","objOut":"bp2-25"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp2-26","uiAttribs":{"subPatch":"4b6bxh4x5"},"storage":{},"objName":"Ops.Ui.SubPatchOutput"}]}'};const o=e.inTrigger("ywf2m4z87");o.setUiAttribs({title:"render"});const l=e.inTrigger("bpvghff97");l.setUiAttribs({title:"render"});const u=e.inTrigger("qtrmi8iov");u.setUiAttribs({title:"render"});const m=e.inTrigger("bpwrv87h8");m.setUiAttribs({title:"render"});const p=e.inTrigger("w7qcf3ri1");p.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_ywf2m4z87");n.setUiAttribs({title:"render"});o.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_bpvghff97");a.setUiAttribs({title:"render"});l.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_qtrmi8iov");i.setUiAttribs({title:"render"});u.onTriggered=()=>{i.trigger()};const r=t[e].outTrigger("innerOut_bpwrv87h8");r.setUiAttribs({title:"render"});m.onTriggered=()=>{r.trigger()};const s=t[e].outTrigger("innerOut_w7qcf3ri1");s.setUiAttribs({title:"render"});p.onTriggered=()=>{s.trigger()}}if(t[e].innerOutput){}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.Scene4.prototype=new CABLES.Op;CABLES.OPS["42f747fd-b1dc-412b-b36d-71b0bae222fb"]={f:Ops.Patch.PLfVxtG.Scene4,objName:"Ops.Patch.PLfVxtG.Scene4"};Ops.Patch.PLfVxtG.Scene5=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_6ne4h65dr=op.inTrigger("6ne4h65dr");\nport_6ne4h65dr.setUiAttribs({title:"render",});\n\nconst port_mgj1bxiv4=op.inTrigger("mgj1bxiv4");\nport_mgj1bxiv4.setUiAttribs({title:"render",});\n\nconst port_vraa1b2jn=op.inTrigger("vraa1b2jn");\nport_vraa1b2jn.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_6ne4h65dr = addedOps[i].outTrigger("innerOut_6ne4h65dr");\ninnerOut_6ne4h65dr.setUiAttribs({title:"render"});\nport_6ne4h65dr.onTriggered = () => { innerOut_6ne4h65dr.trigger(); };\n\nconst innerOut_mgj1bxiv4 = addedOps[i].outTrigger("innerOut_mgj1bxiv4");\ninnerOut_mgj1bxiv4.setUiAttribs({title:"render"});\nport_mgj1bxiv4.onTriggered = () => { innerOut_mgj1bxiv4.trigger(); };\n\nconst innerOut_vraa1b2jn = addedOps[i].outTrigger("innerOut_vraa1b2jn");\ninnerOut_vraa1b2jn.setUiAttribs({title:"render"});\nport_vraa1b2jn.onTriggered = () => { innerOut_vraa1b2jn.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp3-0","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1.14},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp3-2","objOut":"bp3-0"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp3-1","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5832608057c16b1c66539_Salle_3_-_Platefoo.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp3-2","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"R","value":0.9361458333333333},{"name":"G","value":0.018269813855489092},{"name":"B","value":0.09528534861480203},{"name":"A","value":1},{"name":"Roughness","value":0},{"name":"Metalness","value":0},{"name":"Alpha Mode index","value":3},{"name":"Alpha Mode","value":"Blend"},{"name":"Use Clear Coat","value":0},{"name":"Clear Coat Intensity","value":1},{"name":"Clear Coat Roughness","value":0.5},{"name":"Use Normal map for Clear Coat","value":0},{"name":"Use Thin Film","value":0},{"name":"Thin Film Intensity","value":1},{"name":"Thin Film IOR","value":1.3},{"name":"Thin Film Thickness (nm)","value":600},{"name":"Thickness Tex Min","value":300},{"name":"Thickness Tex Max","value":600},{"name":"Tonemapping index","value":0},{"name":"Tonemapping","value":"sRGB"},{"name":"Exposure","value":1},{"name":"Emission Intensity","value":1},{"name":"Disable geometric roughness","value":0},{"name":"Use roughness from normal map","value":0},{"name":"Use Vertex Colours","value":0},{"name":"Vertex Colour Mode index","value":0},{"name":"Vertex Colour Mode","value":"colour"},{"name":"Height Intensity","value":1},{"name":"Faster heightmapping","value":0},{"name":"Double Sided","value":0},{"name":"Num mip levels","value":0},{"name":"Diffuse Intensity","value":1},{"name":"Specular Intensity","value":1},{"name":"Lightmap is RGBE","value":0},{"name":"Lightmap Intensity","value":1}],"portsOut":[{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp3-1","objOut":"bp3-2"}]}],"objName":"Ops.Gl.Pbr.PbrMaterial"},{"id":"bp3-3","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5832608057c16b1c66539_Salle_3_-_lampadaire.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp3-7","objOut":"bp3-3"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp3-5","objOut":"bp3-3"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp3-4","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp3-3","objOut":"bp3-4"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp3-5","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp3-7","objOut":"bp3-5"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp3-6","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.6143780363698986},{"name":"posZ","value":0},{"name":"scale","value":0.47},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp3-3","objOut":"bp3-6"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp3-7","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"r","value":0.5463824124587011},{"name":"g","value":0.1417076208250947},{"name":"b","value":0.5400254901725181},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp3-4","objOut":"bp3-7"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp3-8","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e5832608057c16b1c66539_Salle_3_-_chaise_tentacule.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp3-11","objOut":"bp3-8"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp3-10","objOut":"bp3-8"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp3-9","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp3-8","objOut":"bp3-9"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp3-10","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp3-11","objOut":"bp3-10"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp3-11","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"r","value":0.5463824124587011},{"name":"g","value":0.1417076208250947},{"name":"b","value":0.5400254901725181},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp3-9","objOut":"bp3-11"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp3-12","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsIn":[{"name":"posX","value":-0.695213673587908},{"name":"posY","value":0.44157734612196375},{"name":"posZ","value":0},{"name":"scale","value":0.3},{"name":"rotX","value":0},{"name":"rotY","value":160},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp3-8","objOut":"bp3-12"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp3-13","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"portsOut":[{"name":"innerOut_6ne4h65dr","title":"render","links":[{"portIn":"render","portOut":"innerOut_6ne4h65dr","objIn":"bp3-0","objOut":"bp3-13"}]},{"name":"innerOut_mgj1bxiv4","title":"render","links":[{"portIn":"render","portOut":"innerOut_mgj1bxiv4","objIn":"bp3-6","objOut":"bp3-13"}]},{"name":"innerOut_vraa1b2jn","title":"render","links":[{"portIn":"render","portOut":"innerOut_vraa1b2jn","objIn":"bp3-12","objOut":"bp3-13"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp3-14","uiAttribs":{"subPatch":"18utibua3"},"storage":{},"objName":"Ops.Ui.SubPatchOutput"}]}'};const r=e.inTrigger("6ne4h65dr");r.setUiAttribs({title:"render"});const s=e.inTrigger("mgj1bxiv4");s.setUiAttribs({title:"render"});const o=e.inTrigger("vraa1b2jn");o.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_6ne4h65dr");n.setUiAttribs({title:"render"});r.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_mgj1bxiv4");a.setUiAttribs({title:"render"});s.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_vraa1b2jn");i.setUiAttribs({title:"render"});o.onTriggered=()=>{i.trigger()}}if(t[e].innerOutput){}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.Scene5.prototype=new CABLES.Op;CABLES.OPS["60d2fe7b-23f0-4d8d-adaf-4699629bc298"]={f:Ops.Patch.PLfVxtG.Scene5,objName:"Ops.Patch.PLfVxtG.Scene5"};Ops.Patch.PLfVxtG.SubPatch5=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_cigk6gm62=op.inTrigger("cigk6gm62");\nport_cigk6gm62.setUiAttribs({title:"render",});\n\nconst port_j79vc7ns0=op.inTrigger("j79vc7ns0");\nport_j79vc7ns0.setUiAttribs({title:"render",});\n\nconst port_j51vvjy5d=op.inTrigger("j51vvjy5d");\nport_j51vvjy5d.setUiAttribs({title:"render",});\n\nconst port_t3bmv2wsz=op.inTrigger("t3bmv2wsz");\nport_t3bmv2wsz.setUiAttribs({title:"render",});\n\nconst port_mbp1cq2ag=op.inTrigger("mbp1cq2ag");\nport_mbp1cq2ag.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_cigk6gm62 = addedOps[i].outTrigger("innerOut_cigk6gm62");\ninnerOut_cigk6gm62.setUiAttribs({title:"render"});\nport_cigk6gm62.onTriggered = () => { innerOut_cigk6gm62.trigger(); };\n\nconst innerOut_j79vc7ns0 = addedOps[i].outTrigger("innerOut_j79vc7ns0");\ninnerOut_j79vc7ns0.setUiAttribs({title:"render"});\nport_j79vc7ns0.onTriggered = () => { innerOut_j79vc7ns0.trigger(); };\n\nconst innerOut_j51vvjy5d = addedOps[i].outTrigger("innerOut_j51vvjy5d");\ninnerOut_j51vvjy5d.setUiAttribs({title:"render"});\nport_j51vvjy5d.onTriggered = () => { innerOut_j51vvjy5d.trigger(); };\n\nconst innerOut_t3bmv2wsz = addedOps[i].outTrigger("innerOut_t3bmv2wsz");\ninnerOut_t3bmv2wsz.setUiAttribs({title:"render"});\nport_t3bmv2wsz.onTriggered = () => { innerOut_t3bmv2wsz.trigger(); };\n\nconst innerOut_mbp1cq2ag = addedOps[i].outTrigger("innerOut_mbp1cq2ag");\ninnerOut_mbp1cq2ag.setUiAttribs({title:"render"});\nport_mbp1cq2ag.onTriggered = () => { innerOut_mbp1cq2ag.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp4-0","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e563fa08057c16b1c64473_Salle_2_-_aspirateur.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp4-3","objOut":"bp4-0"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp4-2","objOut":"bp4-0"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp4-1","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.001"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp4-0","objOut":"bp4-1"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp4-2","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp4-3","objOut":"bp4-2"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp4-3","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"r","value":0.6054101346742926},{"name":"g","value":0.2870682862242153},{"name":"b","value":0.2626164633472483},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp4-1","objOut":"bp4-3"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp4-4","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"posX","value":0.8588898147357795},{"name":"posY","value":0.477},{"name":"posZ","value":0.5361416454803636},{"name":"scale","value":0.33},{"name":"rotX","value":0},{"name":"rotY","value":12.41},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp4-0","objOut":"bp4-4"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp4-5","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e563fa08057c16b1c64473_Salle_2_-_chaise_boule.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp4-8","objOut":"bp4-5"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp4-7","objOut":"bp4-5"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp4-6","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0.002"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp4-5","objOut":"bp4-6"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp4-7","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp4-8","objOut":"bp4-7"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp4-8","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"r","value":0.6054101346742926},{"name":"g","value":0.2870682862242153},{"name":"b","value":0.2626164633472483},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp4-6","objOut":"bp4-8"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp4-9","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"posX","value":0.7765854455254377},{"name":"posY","value":0.477},{"name":"posZ","value":-0.5562977308221191},{"name":"scale","value":0.26},{"name":"rotX","value":0},{"name":"rotY","value":12.41},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp4-5","objOut":"bp4-9"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp4-10","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e563fa08057c16b1c64473_Salle_2_-_plate_crane.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp4-13","objOut":"bp4-10"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp4-12","objOut":"bp4-10"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp4-11","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Material Name","value":"Worn white marble"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp4-10","objOut":"bp4-11"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp4-12","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Name","value":"used white marble_BaseColor"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp4-13","objOut":"bp4-12"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/jpeg"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp4-13","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"r","value":0.6054101346742926},{"name":"g","value":0.2870682862242153},{"name":"b","value":0.2626164633472483},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp4-11","objOut":"bp4-13"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp4-14","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"posX","value":-0.5795192819328878},{"name":"posY","value":0.28287484130418616},{"name":"posZ","value":0.25277958914786114},{"name":"scale","value":0.19},{"name":"rotX","value":0},{"name":"rotY","value":-0.76},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp4-10","objOut":"bp4-14"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp4-15","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e563fa08057c16b1c64473_Salle_2_-_cra_ne.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp4-19","objOut":"bp4-15"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp4-17","objOut":"bp4-15"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp4-16","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Material Name","value":"Material_0"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp4-15","objOut":"bp4-16"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp4-17","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Name","value":"Image_0"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp4-19","objOut":"bp4-17"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/png"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp4-18","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"posX","value":-0.5485984081448648},{"name":"posY","value":0.7506758218278746},{"name":"posZ","value":0.2530735320106269},{"name":"scale","value":0.2},{"name":"rotX","value":0},{"name":"rotY","value":-0.76},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp4-15","objOut":"bp4-18"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp4-19","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"r","value":0.6054101346742926},{"name":"g","value":0.2870682862242153},{"name":"b","value":0.2626164633472483},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp4-16","objOut":"bp4-19"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp4-20","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"data","value":""},{"name":"glb File","value":"assets/67e563fa08057c16b1c64473_Salle_2_-_traingle.glb","display":"file"},{"name":"Draw","value":1},{"name":"Camera index","value":0},{"name":"Camera","value":"None"},{"name":"Animation","value":""},{"name":"Center index","value":1},{"name":"Center","value":"XYZ"},{"name":"Rescale","value":1},{"name":"Rescale Size","value":2.5},{"name":"Time","value":0},{"name":"Sync to timeline","value":0},{"name":"Loop","value":1},{"name":"Normals Format index","value":0},{"name":"Normals Format","value":"XYZ"},{"name":"Vertices Format index","value":0},{"name":"Vertices Format","value":"XYZ"},{"name":"Calc Normals index","value":0},{"name":"Calc Normals","value":"Auto"},{"name":"Hide Nodes","value":0},{"name":"Use Material Properties","value":0},{"name":"Active","value":1}],"portsOut":[{"name":"Render Before","links":[{"portIn":"render","portOut":"Render Before","objIn":"bp4-23","objOut":"bp4-20"}]},{"name":"Next","links":[{"portIn":"Render","portOut":"Next","objIn":"bp4-22","objOut":"bp4-20"}]},{"name":"Generator","value":"Khronos glTF Blender I/O v4.4.55"},{"name":"GLTF Version","value":2},{"name":"Anim Length","value":0},{"name":"Anim Time","value":0},{"name":"Loading","value":false}],"objName":"Ops.Gl.GLTF.GltfScene_v4"},{"id":"bp4-21","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Material Name","value":"Worn white marble"}],"portsOut":[{"name":"Material","links":[{"portIn":"Materials","portOut":"Material","objIn":"bp4-20","objOut":"bp4-21"}]}],"objName":"Ops.Gl.GLTF.GltfSetMaterial"},{"id":"bp4-22","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"Name","value":"used white marble_BaseColor"},{"name":"Filter index","value":2},{"name":"Filter","value":"mipmap"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"clamp to edge"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Flip","value":0},{"name":"Pre Multiplied Alpha","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"texture","portOut":"Texture","objIn":"bp4-23","objOut":"bp4-22"}]},{"name":"Width","value":2048},{"name":"Height","value":2048},{"name":"Type","value":"image/jpeg"},{"name":"Found","value":true}],"objName":"Ops.Gl.GLTF.GltfTexture"},{"id":"bp4-23","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"r","value":0.6054101346742926},{"name":"g","value":0.2870682862242153},{"name":"b","value":0.2626164633472483},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"shader","links":[{"portIn":"Shader","portOut":"shader","objIn":"bp4-21","objOut":"bp4-23"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp4-24","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsIn":[{"name":"posX","value":0.08559756111758604},{"name":"posY","value":0.008443565926464086},{"name":"posZ","value":0.11157837103999202},{"name":"scale","value":0.96},{"name":"rotX","value":0},{"name":"rotY","value":12.41},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Render","portOut":"trigger","objIn":"bp4-20","objOut":"bp4-24"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp4-25","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"portsOut":[{"name":"innerOut_cigk6gm62","title":"render","links":[{"portIn":"render","portOut":"innerOut_cigk6gm62","objIn":"bp4-4","objOut":"bp4-25"}]},{"name":"innerOut_j79vc7ns0","title":"render","links":[{"portIn":"render","portOut":"innerOut_j79vc7ns0","objIn":"bp4-9","objOut":"bp4-25"}]},{"name":"innerOut_j51vvjy5d","title":"render","links":[{"portIn":"render","portOut":"innerOut_j51vvjy5d","objIn":"bp4-14","objOut":"bp4-25"}]},{"name":"innerOut_t3bmv2wsz","title":"render","links":[{"portIn":"render","portOut":"innerOut_t3bmv2wsz","objIn":"bp4-18","objOut":"bp4-25"}]},{"name":"innerOut_mbp1cq2ag","title":"render","links":[{"portIn":"render","portOut":"innerOut_mbp1cq2ag","objIn":"bp4-24","objOut":"bp4-25"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp4-26","uiAttribs":{"subPatch":"lbdo00xlu"},"storage":{},"objName":"Ops.Ui.SubPatchOutput"}]}'};const o=e.inTrigger("cigk6gm62");o.setUiAttribs({title:"render"});const l=e.inTrigger("j79vc7ns0");l.setUiAttribs({title:"render"});const u=e.inTrigger("j51vvjy5d");u.setUiAttribs({title:"render"});const m=e.inTrigger("t3bmv2wsz");m.setUiAttribs({title:"render"});const p=e.inTrigger("mbp1cq2ag");p.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_cigk6gm62");n.setUiAttribs({title:"render"});o.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_j79vc7ns0");a.setUiAttribs({title:"render"});l.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_j51vvjy5d");i.setUiAttribs({title:"render"});u.onTriggered=()=>{i.trigger()};const r=t[e].outTrigger("innerOut_t3bmv2wsz");r.setUiAttribs({title:"render"});m.onTriggered=()=>{r.trigger()};const s=t[e].outTrigger("innerOut_mbp1cq2ag");s.setUiAttribs({title:"render"});p.onTriggered=()=>{s.trigger()}}if(t[e].innerOutput){}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.SubPatch5.prototype=new CABLES.Op;CABLES.OPS["b5a3f26f-884e-418f-8e17-574eb62ed252"]={f:Ops.Patch.PLfVxtG.SubPatch5,objName:"Ops.Patch.PLfVxtG.SubPatch5"};Ops.Patch.PLfVxtG.SubPatch6=function(){CABLES.Op.apply(this,arguments);const e=this;const n=e.attachments={inc_gen_ports_js:'const port_dwgm6n0y5=op.inTrigger("dwgm6n0y5");\nport_dwgm6n0y5.setUiAttribs({title:"Render",});\n\nconst port_uudck28ir=op.inTrigger("uudck28ir");\nport_uudck28ir.setUiAttribs({title:"Update",});\n\nconst port_i87e8kc1b=op.outNumber("i87e8kc1b");\nport_i87e8kc1b.setUiAttribs({title:"Result",});\n\nconst port_y8uhtij81=op.inTrigger("y8uhtij81");\nport_y8uhtij81.setUiAttribs({title:"render",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_dwgm6n0y5 = addedOps[i].outTrigger("innerOut_dwgm6n0y5");\ninnerOut_dwgm6n0y5.setUiAttribs({title:"Render"});\nport_dwgm6n0y5.onTriggered = () => { innerOut_dwgm6n0y5.trigger(); };\n\nconst innerOut_uudck28ir = addedOps[i].outTrigger("innerOut_uudck28ir");\ninnerOut_uudck28ir.setUiAttribs({title:"Update"});\nport_uudck28ir.onTriggered = () => { innerOut_uudck28ir.trigger(); };\n\nconst innerOut_y8uhtij81 = addedOps[i].outTrigger("innerOut_y8uhtij81");\ninnerOut_y8uhtij81.setUiAttribs({title:"render"});\nport_y8uhtij81.onTriggered = () => { innerOut_y8uhtij81.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_i87e8kc1b = addedOps[i].inFloat("innerIn_i87e8kc1b");\ninnerIn_i87e8kc1b.setUiAttribs({title:"Result"});\ninnerIn_i87e8kc1b.on("change", (a,v) => { port_i87e8kc1b.set(a); });\n\n}\n}\n};\n',subpatch_json:'{"ops":[{"id":"bp5-0","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"URL","value":"assets/67e2de1dccab331699637565_Musique_fond.mp3","display":"file"},{"name":"Create Loading Task","value":1}],"portsOut":[{"name":"Audio Buffer","links":[{"portIn":"Audio Buffer","portOut":"Audio Buffer","objIn":"bp5-1","objOut":"bp5-0"}]},{"name":"Finished Loading","value":1},{"name":"Sample Rate","value":44100},{"name":"Length","value":2097152},{"name":"Duration","value":47.55446712018141},{"name":"Number of Channels","value":2},{"name":"isLoading","value":false}],"objName":"Ops.WebAudio.AudioBuffer_v2"},{"id":"bp5-1","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Start / Stop","value":1},{"name":"Loop","value":1},{"name":"Offset","value":0},{"name":"Playback Rate","value":1},{"name":"Detune","value":0}],"portsOut":[{"name":"Audio Out","links":[{"portIn":"Audio In","portOut":"Audio Out","objIn":"bp5-2","objOut":"bp5-1"}]},{"name":"Is Playing","value":true},{"name":"Loading","value":false}],"objName":"Ops.WebAudio.AudioBufferPlayer_v2"},{"id":"bp5-2","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Volume","value":1},{"name":"Mute","value":0},{"name":"Show Audio Suspended Button","value":1}],"portsOut":[{"name":"Current Volume","value":1},{"name":"Context State","value":"running"}],"objName":"Ops.WebAudio.Output_v2"},{"id":"bp5-3","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Min Confidence Detect","value":0.531},{"name":"Min Confidence Tracking","value":0.5}],"portsOut":[{"name":"Result","links":[{"portIn":"Hands Result","portOut":"Result","objIn":"bp5-5","objOut":"bp5-3"}]},{"name":"Found Hands","value":0}],"objName":"Ops.Extension.Mediapipe.MpHandTracking"},{"id":"bp5-4","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Active","value":1},{"name":"Generate Texture","value":1},{"name":"Webcam Input index","value":0},{"name":"Webcam Input","value":"Default"},{"name":"Requested Width","value":1280},{"name":"Requested Height","value":720},{"name":"Flip X","value":1},{"name":"Flip Y","value":0},{"name":"Show HTML Element","value":0},{"name":"CSS","value":"z-index:99999;position:absolute;"},{"name":"Element Flip X","value":0},{"name":"Element Flip Y","value":0}],"portsOut":[{"name":"Texture","links":[{"portIn":"Texture In","portOut":"Texture","objIn":"bp5-12","objOut":"bp5-4"}]},{"name":"Ratio","value":1.7777777777777777},{"name":"Available","value":1},{"name":"Size Width","value":1280},{"name":"Size Height","value":720},{"name":"Error","value":""},{"name":"HTML Element","links":[{"portIn":"Element","portOut":"HTML Element","objIn":"bp5-3","objOut":"bp5-4"}]},{"name":"Active device","value":"Camra FaceTime HD (3A71:F4B5)"}],"objName":"Ops.Gl.Textures.WebcamTexture_v3"},{"id":"bp5-5","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Hand index","value":0},{"name":"Hand","value":"Left"},{"name":"Min Score","value":0.5}],"portsOut":[{"name":"Points","links":[{"portIn":"Hand Points","portOut":"Points","objIn":"bp5-6","objOut":"bp5-5"}]},{"name":"Found Hand","value":0},{"name":"Score","value":0}],"objName":"Ops.Extension.Mediapipe.MpHand"},{"id":"bp5-6","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Joint index","value":0},{"name":"Joint","value":"WRIST"}],"portsOut":[{"name":"X","value":-0.04363137483596802},{"name":"Y","links":[{"portIn":"value","portOut":"Y","objIn":"bp5-8","objOut":"bp5-6"}]},{"name":"Z","value":0}],"objName":"Ops.Extension.Mediapipe.MpHandCoordinate"},{"id":"bp5-7","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"innerIn_i87e8kc1b","portOut":"Result","objIn":"bp5-14","objOut":"bp5-7"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp5-8","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"old min","value":-1},{"name":"old max","value":1},{"name":"new min","value":-0.28},{"name":"new max","value":13},{"name":"Easing index","value":2},{"name":"Easing","value":"Smootherstep"},{"name":"Clamp","value":1}],"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp5-7","objOut":"bp5-8"}]}],"objName":"Ops.Math.MapRange"},{"id":"bp5-9","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"render","title":"Trigger"},{"name":"Render Mesh","value":1,"title":"Render"},{"name":"width","value":1},{"name":"height","value":0.62},{"name":"pivot x index","value":1},{"name":"pivot x","value":"center"},{"name":"pivot y index","value":1},{"name":"pivot y","value":"center"},{"name":"axis index","value":0},{"name":"axis","value":"xy"},{"name":"Flip TexCoord X","value":0},{"name":"Flip TexCoord Y","value":1},{"name":"num columns","value":1},{"name":"num rows","value":1}],"objName":"Ops.Gl.Meshes.Rectangle_v4"},{"id":"bp5-10","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"r","value":0.5843626368378873},{"name":"g","value":0.3625654235661001},{"name":"b","value":0.9267978978177648},{"name":"a","value":1},{"name":"colorizeTexture","value":0},{"name":"Vertex Colors","value":0},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Opacity TexCoords Transform","value":0},{"name":"Discard Transparent Pixels","value":0},{"name":"diffuseRepeatX","value":1},{"name":"diffuseRepeatY","value":1},{"name":"Tex Offset X","value":0},{"name":"Tex Offset Y","value":0},{"name":"Crop TexCoords","value":0},{"name":"billboard","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp5-11","objOut":"bp5-10"}]}],"objName":"Ops.Gl.Shader.BasicMaterial_v3"},{"id":"bp5-11","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"posX","value":1.6},{"name":"posY","value":-0.84},{"name":"posZ","value":0},{"name":"scale","value":0.78},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bp5-9","objOut":"bp5-11"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"bp5-12","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"Show Info","value":0},{"name":"Visualize outside 0-1 index","value":1},{"name":"Visualize outside 0-1","value":"Anim"},{"name":"Alpha index","value":0},{"name":"Alpha","value":"A"},{"name":"Show Color","value":0},{"name":"X","value":0.5},{"name":"Y","value":0.5}],"portsOut":[{"name":"Texture Out","links":[{"portIn":"texture","portOut":"Texture Out","objIn":"bp5-10","objOut":"bp5-12"}]},{"name":"Info","value":"1280x720 RGBA 8bit ubyte linear clamp\\n"}],"objName":"Ops.Ui.VizTexture"},{"id":"bp5-13","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsOut":[{"name":"innerOut_dwgm6n0y5","title":"Render","links":[{"portIn":"Render","portOut":"innerOut_dwgm6n0y5","objIn":"bp5-4","objOut":"bp5-13"}]},{"name":"innerOut_uudck28ir","title":"Update","links":[{"portIn":"Update","portOut":"innerOut_uudck28ir","objIn":"bp5-7","objOut":"bp5-13"}]},{"name":"innerOut_y8uhtij81","title":"render","links":[{"portIn":"render","portOut":"innerOut_y8uhtij81","objIn":"bp5-10","objOut":"bp5-13"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp5-14","uiAttribs":{"subPatch":"rf21raygn"},"storage":{},"portsIn":[{"name":"innerIn_i87e8kc1b","title":"Result"}],"objName":"Ops.Ui.SubPatchOutput"}]}'};const s=e.inTrigger("dwgm6n0y5");s.setUiAttribs({title:"Render"});const o=e.inTrigger("uudck28ir");o.setUiAttribs({title:"Update"});const l=e.outNumber("i87e8kc1b");l.setUiAttribs({title:"Result"});const u=e.inTrigger("y8uhtij81");u.setUiAttribs({title:"render"});e.initInnerPorts=function(t){for(let e=0;e<t.length;e++){if(t[e].innerInput){const n=t[e].outTrigger("innerOut_dwgm6n0y5");n.setUiAttribs({title:"Render"});s.onTriggered=()=>{n.trigger()};const a=t[e].outTrigger("innerOut_uudck28ir");a.setUiAttribs({title:"Update"});o.onTriggered=()=>{a.trigger()};const i=t[e].outTrigger("innerOut_y8uhtij81");i.setUiAttribs({title:"render"});u.onTriggered=()=>{i.trigger()}}if(t[e].innerOutput){const r=t[e].inFloat("innerIn_i87e8kc1b");r.setUiAttribs({title:"Result"});r.on("change",(e,t)=>{l.set(e)})}}};const a="bp2sub_"+e.id;new CABLES.SubPatchOp(e,{subId:a});t();function t(){if(!n||!n.subpatch_json)return;const t=JSON.parse(n.subpatch_json);CABLES.Patch.replaceOpIds(t,{parentSubPatchId:a,prefixHash:a,oldIdAsRef:true,doNotUnlinkLostLinks:true});for(let e=0;e<t.ops.length;e++){t.ops[e].uiAttribs.blueprintSubpatch2=true}e.loadDependencies(t,()=>{e.patch.deSerialize(t,{opsCreated:e.initInnerPorts});if(CABLES.UI)gui.savedState.setSaved("blueprintloaded",a);e.patch.emitEvent("subpatchExpose",a);e.setStorage({blueprintVer:2});e.patch.emitEvent("subpatchExpose",a)})}};Ops.Patch.PLfVxtG.SubPatch6.prototype=new CABLES.Op;CABLES.OPS["f2899dde-b24b-494c-8b74-31a7b514ebb0"]={f:Ops.Patch.PLfVxtG.SubPatch6,objName:"Ops.Patch.PLfVxtG.SubPatch6"};Ops.Gl.GLTF.GltfScene_v4=function(){CABLES.Op.apply(this,arguments);const _=this;const l=_.attachments={inc_camera_js:"const gltfCamera = class\n{\n    constructor(gltf, node)\n    {\n        this.node = node;\n        this.name = node.name;\n        // console.log(gltf);\n        this.config = gltf.json.cameras[node.camera];\n\n        this.pos = vec3.create();\n        this.quat = quat.create();\n        this.vCenter = vec3.create();\n        this.vUp = vec3.create();\n        this.vMat = mat4.create();\n    }\n\n    updateAnim(time)\n    {\n        if (this.node && this.node._animTrans)\n        {\n            vec3.set(this.pos,\n                this.node._animTrans[0].getValue(time),\n                this.node._animTrans[1].getValue(time),\n                this.node._animTrans[2].getValue(time));\n\n            quat.set(this.quat,\n                this.node._animRot[0].getValue(time),\n                this.node._animRot[1].getValue(time),\n                this.node._animRot[2].getValue(time),\n                this.node._animRot[3].getValue(time));\n        }\n    }\n\n    start(time)\n    {\n        if (cgl.tempData.shadowPass) return;\n\n        this.updateAnim(time);\n        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];\n\n        cgl.pushPMatrix();\n        // mat4.perspective(\n        //     cgl.pMatrix,\n        //     this.config.perspective.yfov*0.5,\n        //     asp,\n        //     this.config.perspective.znear,\n        //     this.config.perspective.zfar);\n\n        cgl.pushViewMatrix();\n        // mat4.identity(cgl.vMatrix);\n\n        // if(this.node && this.node.parent)\n        // {\n        //     console.log(this.node.parent)\n        // vec3.add(this.pos,this.pos,this.node.parent._node.translation);\n        // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);\n        // mat4.translate(cgl.vMatrix,cgl.vMatrix,\n        // [\n        //     -this.node.parent._node.translation[0],\n        //     -this.node.parent._node.translation[1],\n        //     -this.node.parent._node.translation[2]\n        // ])\n        // }\n\n        // vec3.set(this.vUp, 0, 1, 0);\n        // vec3.set(this.vCenter, 0, -1, 0);\n        // // vec3.set(this.vCenter, 0, 1, 0);\n        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);\n        // vec3.normalize(this.vCenter, this.vCenter);\n        // vec3.add(this.vCenter, this.vCenter, this.pos);\n\n        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);\n\n        let mv = mat4.create();\n        mat4.invert(mv, this.node.modelMatAbs());\n\n        // console.log(this.node.modelMatAbs());\n\n        this.vMat = mv;\n\n        mat4.identity(cgl.vMatrix);\n        // console.log(mv);\n        mat4.mul(cgl.vMatrix, cgl.vMatrix, mv);\n    }\n\n    end()\n    {\n        if (cgl.tempData.shadowPass) return;\n        cgl.popPMatrix();\n        cgl.popViewMatrix();\n    }\n};\n",inc_gltf_js:'const le = true; // little endian\n\nconst Gltf = class\n{\n    constructor()\n    {\n        this.json = {};\n        this.accBuffers = [];\n        this.meshes = [];\n        this.nodes = [];\n        this.shaders = [];\n        this.timing = [];\n        this.cams = [];\n        this.startTime = performance.now();\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.loaded = Date.now();\n        this.accBuffersDelete = [];\n    }\n\n    getNode(n)\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            if (this.nodes[i].name == n) return this.nodes[i];\n        }\n    }\n\n    unHideAll()\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            this.nodes[i].unHide();\n        }\n    }\n};\n\nfunction Utf8ArrayToStr(array)\n{\n    if (window.TextDecoder) return new TextDecoder("utf-8").decode(array);\n\n    let out, i, len, c;\n    let char2, char3;\n\n    out = "";\n    len = array.length;\n    i = 0;\n    while (i < len)\n    {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\nfunction readChunk(dv, bArr, arrayBuffer, offset)\n{\n    const chunk = {};\n\n    if (offset >= dv.byteLength)\n    {\n        // op.log("could not read chunk...");\n        return;\n    }\n    chunk.size = dv.getUint32(offset + 0, le);\n\n    // chunk.type = new TextDecoder("utf-8").decode(bArr.subarray(offset+4, offset+4+4));\n    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));\n\n    if (chunk.type == "BIN\\0")\n    {\n        // console.log(chunk.size,arrayBuffer.length,offset);\n        // try\n        // {\n        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);\n        // }\n        // catch(e)\n        // {\n        //     chunk.dataView = null;\n        //     console.log(e);\n        // }\n    }\n    else\n    if (chunk.type == "JSON")\n    {\n        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));\n\n        try\n        {\n            const obj = JSON.parse(json);\n            chunk.data = obj;\n            outGenerator.set(obj.asset.generator);\n        }\n        catch (e)\n        {\n        }\n    }\n    else\n    {\n        op.warn("unknown type", chunk.type);\n    }\n\n    return chunk;\n}\n\nfunction loadAnims(gltf)\n{\n    const uniqueAnimNames = {};\n\n    for (let i = 0; i < gltf.json.animations.length; i++)\n    {\n        const an = gltf.json.animations[i];\n\n        an.name = an.name || "unknown";\n\n        for (let ia = 0; ia < an.channels.length; ia++)\n        {\n            const chan = an.channels[ia];\n\n            const node = gltf.nodes[chan.target.node];\n            const sampler = an.samplers[chan.sampler];\n\n            const acc = gltf.json.accessors[sampler.input];\n            const bufferIn = gltf.accBuffers[sampler.input];\n\n            const accOut = gltf.json.accessors[sampler.output];\n            const bufferOut = gltf.accBuffers[sampler.output];\n\n            gltf.accBuffersDelete.push(sampler.output, sampler.input);\n\n            if (bufferIn && bufferOut)\n            {\n                let numComps = 1;\n                if (accOut.type === "VEC2")numComps = 2;\n                else if (accOut.type === "VEC3")numComps = 3;\n                else if (accOut.type === "VEC4")numComps = 4;\n                else if (accOut.type === "SCALAR")\n                {\n                    numComps = bufferOut.length / bufferIn.length; // is this really the way to find out ? cant find any other way,except number of morph targets, but not really connected...\n                }\n                else op.log("[] UNKNOWN accOut.type", accOut.type);\n\n                const anims = [];\n\n                uniqueAnimNames[an.name] = true;\n\n                for (let k = 0; k < numComps; k++)\n                {\n                    const newAnim = new CABLES.Anim();\n                    // newAnim.name=an.name;\n                    anims.push(newAnim);\n                }\n\n                if (sampler.interpolation === "LINEAR") {}\n                else if (sampler.interpolation === "STEP") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;\n                else if (sampler.interpolation === "CUBICSPLINE") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;\n                else op.warn("unknown interpolation", sampler.interpolation);\n\n                // console.log(bufferOut)\n\n                // if there is no keyframe for time 0 copy value of first keyframe at time 0\n                if (bufferIn[0] !== 0.0)\n                    for (let k = 0; k < numComps; k++)\n                        anims[k].setValue(0, bufferOut[0 * numComps + k]);\n\n                for (let j = 0; j < bufferIn.length; j++)\n                {\n                    maxTime = Math.max(bufferIn[j], maxTime);\n\n                    for (let k = 0; k < numComps; k++)\n                    {\n                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)\n                        {\n                            const idx = ((j * numComps) * 3 + k);\n\n                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);\n                            key.bezTangIn = bufferOut[idx];\n                            key.bezTangOut = bufferOut[idx + (numComps * 2)];\n\n                            // console.log(an.name,k,bufferOut[idx+1]);\n                        }\n                        else\n                        {\n                            // console.log(an.name,k,bufferOut[j * numComps + k]);\n                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);\n                        }\n                    }\n                }\n\n                node.setAnim(chan.target.path, an.name, anims);\n            }\n            else\n            {\n                op.warn("loadAmins bufferIn undefined ", bufferIn === undefined);\n                op.warn("loadAmins bufferOut undefined ", bufferOut === undefined);\n                op.warn("loadAmins ", an.name, sampler, accOut);\n                op.warn("loadAmins num accBuffers", gltf.accBuffers.length);\n                op.warn("loadAmins num accessors", gltf.json.accessors.length);\n            }\n        }\n    }\n\n    gltf.uniqueAnimNames = uniqueAnimNames;\n\n    outAnims.setRef(Object.keys(uniqueAnimNames));\n}\n\nfunction loadCams(gltf)\n{\n    if (!gltf || !gltf.json.cameras) return;\n\n    gltf.cameras = gltf.cameras || [];\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (gltf.nodes[i].hasOwnProperty("camera"))\n        {\n            const cam = new gltfCamera(gltf, gltf.nodes[i]);\n            gltf.cameras.push(cam);\n        }\n    }\n}\n\nfunction loadAfterDraco()\n{\n    if (!window.DracoDecoder)\n    {\n        setTimeout(() =>\n        {\n            loadAfterDraco();\n        }, 100);\n    }\n\n    reloadSoon();\n}\n\nfunction parseGltf(arrayBuffer)\n{\n    const CHUNK_HEADER_SIZE = 8;\n\n    let j = 0, i = 0;\n\n    const gltf = new Gltf();\n    gltf.timing.push(["Start parsing", Math.round((performance.now() - gltf.startTime))]);\n\n    if (!arrayBuffer) return;\n    const byteArray = new Uint8Array(arrayBuffer);\n    let pos = 0;\n\n    // var string = new TextDecoder("utf-8").decode(byteArray.subarray(pos, 4));\n    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));\n    pos += 4;\n    if (string != "glTF") return;\n\n    gltf.timing.push(["dataview", Math.round((performance.now() - gltf.startTime))]);\n\n    const dv = new DataView(arrayBuffer);\n    const version = dv.getUint32(pos, le);\n    pos += 4;\n    const size = dv.getUint32(pos, le);\n    pos += 4;\n\n    outVersion.set(version);\n\n    const chunks = [];\n    gltf.chunks = chunks;\n\n    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));\n    pos += chunks[0].size + CHUNK_HEADER_SIZE;\n    gltf.json = chunks[0].data;\n\n    gltf.cables = {\n        "fileUrl": inFile.get(),\n        "shortFileName": CABLES.basename(inFile.get())\n    };\n\n    outJson.setRef(gltf.json);\n    outExtensions.setRef(gltf.json.extensionsUsed || []);\n\n    let ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    while (ch)\n    {\n        chunks.push(ch);\n        pos += ch.size + CHUNK_HEADER_SIZE;\n        ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    }\n\n    gltf.chunks = chunks;\n\n    const views = chunks[0].data.bufferViews;\n    const accessors = chunks[0].data.accessors;\n\n    gltf.timing.push(["Parse buffers", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1)\n    {\n        if (!window.DracoDecoder)\n        {\n            op.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");\n\n            loadAfterDraco();\n            return gltf;\n        }\n        else\n        {\n            gltf.useDraco = true;\n        }\n    }\n\n    op.setUiError("gltfdraco", null);\n    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n\n    if (views)\n    {\n        for (i = 0; i < accessors.length; i++)\n        {\n            const acc = accessors[i];\n            const view = views[acc.bufferView];\n\n            let numComps = 0;\n            if (acc.type == "SCALAR")numComps = 1;\n            else if (acc.type == "VEC2")numComps = 2;\n            else if (acc.type == "VEC3")numComps = 3;\n            else if (acc.type == "VEC4")numComps = 4;\n            else if (acc.type == "MAT4")numComps = 16;\n            else console.error("unknown accessor type", acc.type);\n\n            //   const decoder = new decoderModule.Decoder();\n            //   const decodedGeometry = decodeDracoData(data, decoder);\n            //   // Encode mesh\n            //   encodeMeshToFile(decodedGeometry, decoder);\n\n            //   decoderModule.destroy(decoder);\n            //   decoderModule.destroy(decodedGeometry);\n\n            // 5120 (BYTE)\t1\n            // 5121 (UNSIGNED_BYTE)\t1\n            // 5122 (SHORT)\t2\n\n            if (chunks[1].dataView)\n            {\n                if (view)\n                {\n                    const num = acc.count * numComps;\n                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n                    let stride = view.byteStride || 0;\n                    let dataBuff = null;\n\n                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT\n                    {\n                        stride = stride || 4;\n\n                        const isInt = acc.componentType == 5125;\n                        if (isInt)dataBuff = new Uint32Array(num);\n                        else dataBuff = new Float32Array(num);\n\n                        dataBuff.cblStride = numComps;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);\n                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);\n\n                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);\n                            accPos += 4;\n                        }\n                    }\n                    else if (acc.componentType == 5123) // UNSIGNED_SHORT\n                    {\n                        stride = stride || 2;\n\n                        dataBuff = new Uint16Array(num);\n                        dataBuff.cblStride = stride;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);\n\n                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);\n\n                            accPos += 2;\n                        }\n                    }\n                    else if (acc.componentType == 5121) // UNSIGNED_BYTE\n                    {\n                        stride = stride || 1;\n\n                        dataBuff = new Uint8Array(num);\n                        dataBuff.cblStride = stride;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);\n\n                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);\n\n                            accPos += 1;\n                        }\n                    }\n\n                    else\n                    {\n                        console.error("unknown component type", acc.componentType);\n                    }\n\n                    gltf.accBuffers.push(dataBuff);\n                }\n                else\n                {\n                    // console.log("has no dataview");\n                }\n            }\n        }\n    }\n\n    gltf.timing.push(["Parse mesh groups", Math.round((performance.now() - gltf.startTime))]);\n\n    gltf.json.meshes = gltf.json.meshes || [];\n\n    if (gltf.json.meshes)\n    {\n        for (i = 0; i < gltf.json.meshes.length; i++)\n        {\n            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);\n            gltf.meshes.push(mesh);\n        }\n    }\n\n    gltf.timing.push(["Parse nodes", Math.round((performance.now() - gltf.startTime))]);\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        if (gltf.json.nodes[i].children)\n            for (j = 0; j < gltf.json.nodes[i].children.length; j++)\n            {\n                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;\n            }\n    }\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        const node = new gltfNode(gltf.json.nodes[i], gltf);\n        gltf.nodes.push(node);\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        const node = gltf.nodes[i];\n\n        if (!node.children) continue;\n        for (let j = 0; j < node.children.length; j++)\n        {\n            gltf.nodes[node.children[j]].parent = node;\n        }\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        gltf.nodes[i].initSkin();\n    }\n\n    needsMatUpdate = true;\n\n    gltf.timing.push(["load anims", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.animations) loadAnims(gltf);\n\n    gltf.timing.push(["load cameras", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.cameras) loadCams(gltf);\n\n    gltf.timing.push(["finished", Math.round((performance.now() - gltf.startTime))]);\n    return gltf;\n}\n',inc_mesh_js:'let gltfMesh = class\n{\n    constructor(name, prim, gltf, finished)\n    {\n        this.POINTS = 0;\n        this.LINES = 1;\n        this.LINE_LOOP = 2;\n        this.LINE_STRIP = 3;\n        this.TRIANGLES = 4;\n        this.TRIANGLE_STRIP = 5;\n        this.TRIANGLE_FAN = 6;\n\n        this.test = 0;\n        this.name = name;\n        this.submeshIndex = 0;\n        this.material = prim.material;\n        // console.log(prim);\n        this.mesh = null;\n        this.geom = new CGL.Geometry("gltf_" + this.name);\n        this.geom.verticesIndices = [];\n        this.bounds = null;\n        this.primitive = 4;\n        this.morphTargetsRenderMod = null;\n        this.weights = prim.weights;\n\n        if (prim.hasOwnProperty("mode")) this.primitive = prim.mode;\n\n        if (prim.hasOwnProperty("indices")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];\n\n        gltf.loadingMeshes = gltf.loadingMeshes || 0;\n        gltf.loadingMeshes++;\n\n        this.materialJson =\n            this._matPbrMetalness =\n            this._matPbrRoughness =\n            this._matDiffuseColor = null;\n\n        if (gltf.json.materials)\n        {\n            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];\n\n            if (this.materialJson && this.materialJson.pbrMetallicRoughness)\n            {\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor"))\n                {\n                    this._matDiffuseColor = [1, 1, 1, 1];\n                }\n                else\n                {\n                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n                }\n\n                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor"))\n                {\n                    this._matPbrMetalness = 1.0;\n                }\n                else\n                {\n                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;\n                }\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor"))\n                {\n                    this._matPbrRoughness = 1.0;\n                }\n                else\n                {\n                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;\n                }\n            }\n        }\n\n        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)\n        {\n            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];\n            const num = view.byteLength;\n            const dataBuff = new Int8Array(num);\n            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);\n            for (let j = 0; j < num; j++)\n            {\n                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);\n                accPos++;\n            }\n\n            const dracoDecoder = window.DracoDecoder;\n            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>\n            {\n                const geom = new CGL.Geometry("draco mesh " + name);\n\n                for (let i = 0; i < geometry.attributes.length; i++)\n                {\n                    const attr = geometry.attributes[i];\n\n                    if (attr.name === "position") geom.vertices = attr.array;\n                    else if (attr.name === "normal") geom.vertexNormals = attr.array;\n                    else if (attr.name === "uv") geom.texCoords = attr.array;\n                    else if (attr.name === "color") geom.vertexColors = this.calcVertexColors(attr.array);\n                    else if (attr.name === "joints") geom.setAttribute("attrJoints", Array.from(attr.array), 4);\n                    else if (attr.name === "weights")\n                    {\n                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);\n\n                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)\n                        {\n                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;\n                            for (let j = 0; j < attr.itemSize; j++)\n                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];\n                        }\n                        geom.setAttribute("attrWeights", arr4, 4);\n                    }\n                    else op.logWarn("unknown draco attrib", attr);\n                }\n\n                geometry.attributes = null;\n                geom.verticesIndices = geometry.index.array;\n\n                this.setGeom(geom);\n\n                this.mesh = null;\n                gltf.loadingMeshes--;\n                gltf.timing.push(["draco decode", Math.round((performance.now() - gltf.startTime))]);\n\n                if (finished)finished(this);\n            }, (error) => { op.logError(error); });\n        }\n        else\n        {\n            gltf.loadingMeshes--;\n            this.fillGeomAttribs(gltf, this.geom, prim.attributes);\n\n            if (prim.targets)\n            {\n                for (let j = 0; j < prim.targets.length; j++)\n                {\n                    const tgeom = new CGL.Geometry("gltf_target_" + j);\n\n                    // if (prim.hasOwnProperty("indices")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];\n\n                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);\n\n                    // { // calculate normals for final position of morphtarget for later...\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];\n                    //     tgeom.calculateNormals();\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];\n                    // }\n\n                    this.geom.morphTargets.push(tgeom);\n                }\n            }\n            if (finished)finished(this);\n        }\n    }\n\n    _linearToSrgb(x)\n    {\n        if (x <= 0)\n            return 0;\n        else if (x >= 1)\n            return 1;\n        else if (x < 0.0031308)\n            return x * 12.92;\n        else\n            return x ** (1 / 2.2) * 1.055 - 0.055;\n    }\n\n    calcVertexColors(arr, type)\n    {\n        let vertexColors = null;\n        if (arr instanceof Float32Array)\n        {\n            let div = false;\n            for (let i = 0; i < arr.length; i++)\n            {\n                if (arr[i] > 1)\n                {\n                    div = true;\n                    continue;\n                }\n            }\n\n            if (div)\n                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;\n\n            vertexColors = arr;\n        }\n\n        else if (arr instanceof Uint16Array)\n        {\n            const fb = new Float32Array(arr.length);\n            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;\n\n            vertexColors = fb;\n        }\n        else vertexColors = arr;\n\n        for (let i = 0; i < vertexColors.length; i++)\n        {\n            vertexColors[i] = this._linearToSrgb(vertexColors[i]);\n        }\n\n        console.log("arr.cblStride", arr.cblStride);\n        if (arr.cblStride == 3)\n        {\n            const nc = new Float32Array(vertexColors.length / 3 * 4);\n            for (let i = 0; i < vertexColors.length / 3; i++)\n            {\n                nc[i * 4 + 0] = vertexColors[i * 3 + 0];\n                nc[i * 4 + 1] = vertexColors[i * 3 + 1];\n                nc[i * 4 + 2] = vertexColors[i * 3 + 2];\n                nc[i * 4 + 3] = 1;\n            }\n            vertexColors = nc;\n        }\n\n        return vertexColors;\n    }\n\n    fillGeomAttribs(gltf, tgeom, attribs, setGeom)\n    {\n        if (attribs.hasOwnProperty("POSITION")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];\n        if (attribs.hasOwnProperty("NORMAL")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];\n        if (attribs.hasOwnProperty("TANGENT")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];\n\n        // // console.log(gltf.accBuffers[attribs.COLOR_0])\n        // console.log(gltf);\n\n        if (attribs.hasOwnProperty("COLOR_0")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0], gltf.accBuffers[attribs.COLOR_0].type);\n        if (attribs.hasOwnProperty("COLOR_1")) tgeom.setAttribute("attrVertColor1", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), gltf.accBuffers[attribs.COLOR_1].type);\n        if (attribs.hasOwnProperty("COLOR_2")) tgeom.setAttribute("attrVertColor2", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), gltf.accBuffers[attribs.COLOR_2].type);\n        if (attribs.hasOwnProperty("COLOR_3")) tgeom.setAttribute("attrVertColor3", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), gltf.accBuffers[attribs.COLOR_3].type);\n        if (attribs.hasOwnProperty("COLOR_4")) tgeom.setAttribute("attrVertColor4", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), gltf.accBuffers[attribs.COLOR_4].type);\n\n        if (attribs.hasOwnProperty("TEXCOORD_0")) tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];\n        if (attribs.hasOwnProperty("TEXCOORD_1")) tgeom.setAttribute("attrTexCoord1", gltf.accBuffers[attribs.TEXCOORD_1], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) tgeom.setAttribute("attrTexCoord2", gltf.accBuffers[attribs.TEXCOORD_2], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) tgeom.setAttribute("attrTexCoord3", gltf.accBuffers[attribs.TEXCOORD_3], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) tgeom.setAttribute("attrTexCoord4", gltf.accBuffers[attribs.TEXCOORD_4], 2);\n\n        if (attribs.hasOwnProperty("WEIGHTS_0"))\n        {\n            tgeom.setAttribute("attrWeights", gltf.accBuffers[attribs.WEIGHTS_0], 4);\n        }\n        if (attribs.hasOwnProperty("JOINTS_0"))\n        {\n            if (!gltf.accBuffers[attribs.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");\n            tgeom.setAttribute("attrJoints", gltf.accBuffers[attribs.JOINTS_0], 4);\n        }\n\n        if (attribs.hasOwnProperty("POSITION")) gltf.accBuffersDelete.push(attribs.POSITION);\n        if (attribs.hasOwnProperty("NORMAL")) gltf.accBuffersDelete.push(attribs.NORMAL);\n        if (attribs.hasOwnProperty("TEXCOORD_0")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);\n        if (attribs.hasOwnProperty("TANGENT")) gltf.accBuffersDelete.push(attribs.TANGENT);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_1"))gltf.accBuffersDelete.push(attribs.COLOR_1);\n        if (attribs.hasOwnProperty("COLOR_2"))gltf.accBuffersDelete.push(attribs.COLOR_2);\n        if (attribs.hasOwnProperty("COLOR_3"))gltf.accBuffersDelete.push(attribs.COLOR_3);\n\n        if (attribs.hasOwnProperty("TEXCOORD_1")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);\n\n        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);\n    }\n\n    setGeom(geom)\n    {\n        if (inNormFormat.get() == "X-ZY")\n        {\n            for (let i = 0; i < geom.vertexNormals.length; i += 3)\n            {\n                let t = geom.vertexNormals[i + 2];\n                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];\n                geom.vertexNormals[i + 1] = -t;\n            }\n        }\n\n        if (inVertFormat.get() == "XZ-Y")\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n            {\n                let t = geom.vertices[i + 2];\n                geom.vertices[i + 2] = -geom.vertices[i + 1];\n                geom.vertices[i + 1] = t;\n            }\n        }\n\n        if (this.primitive == this.TRIANGLES)\n        {\n            if (inCalcNormals.get() == "Force Smooth" || inCalcNormals.get() == false) geom.calculateNormals();\n            else if (!geom.vertexNormals.length && inCalcNormals.get() == "Auto") geom.calculateNormals({ "smooth": false });\n\n            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)\n            {\n                const bitan = vec3.create();\n                const tan = vec3.create();\n\n                const tangents = geom.tangents;\n                geom.tangents = new Float32Array(tangents.length / 4 * 3);\n                geom.biTangents = new Float32Array(tangents.length / 4 * 3);\n\n                for (let i = 0; i < tangents.length; i += 4)\n                {\n                    const idx = i / 4 * 3;\n\n                    vec3.cross(\n                        bitan,\n                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],\n                        [tangents[i], tangents[i + 1], tangents[i + 2]]\n                    );\n\n                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);\n                    vec3.normalize(bitan, bitan);\n\n                    geom.biTangents[idx + 0] = bitan[0];\n                    geom.biTangents[idx + 1] = bitan[1];\n                    geom.biTangents[idx + 2] = bitan[2];\n\n                    geom.tangents[idx + 0] = tangents[i + 0];\n                    geom.tangents[idx + 1] = tangents[i + 1];\n                    geom.tangents[idx + 2] = tangents[i + 2];\n                }\n            }\n\n            if (geom.tangents.length === 0 || inCalcNormals.get() != "Never")\n            {\n                // console.log("[gltf ]no tangents... calculating tangents...");\n                geom.calcTangentsBitangents();\n            }\n        }\n\n        this.geom = geom;\n\n        this.bounds = geom.getBounds();\n    }\n\n    render(cgl, ignoreMaterial, skinRenderer)\n    {\n        if (!this.mesh && this.geom && this.geom.verticesIndices)\n        {\n            let g = this.geom;\n            if (this.geom.vertices.length / 3 > 64000)\n            {\n                g = this.geom.copy();\n                g.unIndex(false, true);\n            }\n\n            let glprim;\n\n            if (cgl.gl)\n            {\n                if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;\n                else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;\n                else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;\n                else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;\n                else\n                {\n                    op.logWarn("unknown primitive type", this);\n                }\n            }\n\n            this.mesh = op.patch.cg.createMesh(g, { "glPrimitive": glprim });\n        }\n\n        if (this.mesh)\n        {\n            // update morphTargets\n            if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod)\n            {\n                this.mesh.addVertexNumbers = true;\n                this.morphTargetsRenderMod = new GltfTargetsRenderer(this);\n            }\n\n            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];\n            if (skinRenderer)useMat = false;\n\n            if (useMat) cgl.pushShader(gltf.shaders[this.material]);\n\n            const currentShader = cgl.getShader() || {};\n            const uniDiff = currentShader.uniformColorDiffuse;\n\n            const uniPbrMetalness = currentShader.uniformPbrMetalness;\n            const uniPbrRoughness = currentShader.uniformPbrRoughness;\n\n            // if (gltf.shaders[this.material] && !inUseMatProps.get())\n            // {\n            //     gltf.shaders[this.material]=null;\n            // }\n\n            if (!gltf.shaders[this.material] && inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor)\n                {\n                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];\n                    uniDiff.setValue(this._matDiffuseColor);\n                }\n\n                if (uniPbrMetalness)\n                    if (this._matPbrMetalness != null)\n                    {\n                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();\n                        uniPbrMetalness.setValue(this._matPbrMetalness);\n                    }\n                    else\n                        uniPbrMetalness.setValue(0);\n\n                if (uniPbrRoughness)\n                    if (this._matPbrRoughness != null)\n                    {\n                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();\n                        uniPbrRoughness.setValue(this._matPbrRoughness);\n                    }\n                    else\n                    {\n                        uniPbrRoughness.setValue(0);\n                    }\n            }\n\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderStart(cgl, 0);\n            if (this.mesh)\n            {\n                // console.log(this.mesh)\n                // this.mesh.lastMaterial=0;\n                this.mesh.render(cgl.getShader(), ignoreMaterial);\n            }\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderFinish(cgl);\n\n            if (inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);\n                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);\n                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);\n            }\n\n            if (useMat) cgl.popShader();\n        }\n    }\n};\n',inc_meshGroup_js:"const gltfMeshGroup = class\n{\n    constructor(gltf, m)\n    {\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.meshes = [];\n        this.name = m.name;\n        const prims = m.primitives;\n\n        for (let i = 0; i < prims.length; i++)\n        {\n            const mesh = new gltfMesh(this.name, prims[i], gltf,\n                (mesh) =>\n                {\n                    mesh.extras = m.extras;\n                    this.bounds.apply(mesh.bounds);\n                });\n\n            mesh.submeshIndex = i;\n            this.meshes.push(mesh);\n        }\n    }\n\n    render(cgl, ignoreMat, skinRenderer, _time, weights)\n    {\n        for (let i = 0; i < this.meshes.length; i++)\n        {\n            const useMat = gltf.shaders[this.meshes[i].material];\n\n            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);\n            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)\n            if (skinRenderer)skinRenderer.renderStart(cgl, _time);\n            if (weights) this.meshes[i].weights = weights;\n            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);\n            if (skinRenderer)skinRenderer.renderFinish(cgl);\n            if (!ignoreMat && useMat) cgl.popShader();\n        }\n    }\n};\n",inc_node_js:'const gltfNode = class\n{\n    constructor(node, gltf)\n    {\n        this.isChild = node.isChild || false;\n        this.name = node.name;\n        if (node.hasOwnProperty("camera")) this.camera = node.camera;\n        this.hidden = false;\n        this.mat = mat4.create();\n        this._animActions = {};\n        this.animWeights = [];\n        this._animMat = mat4.create();\n        this._tempMat = mat4.create();\n        this._tempQuat = quat.create();\n        this._tempRotmat = mat4.create();\n        this.mesh = null;\n        this.children = [];\n        this._node = node;\n        this._gltf = gltf;\n        this.absMat = mat4.create();\n        this.addTranslate = null;\n        this._tempAnimScale = null;\n        this.addMulMat = null;\n        this.updateMatrix();\n        this.skinRenderer = null;\n        this.copies = [];\n    }\n\n    get skin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._node.skin;\n        else return -1;\n    }\n\n    copy()\n    {\n        this.isCopy = true;\n        const n = new gltfNode(this._node, this._gltf);\n        n.copyOf = this;\n\n        n._animActions = this._animActions;\n        n.children = this.children;\n        if (this.skin) n.skinRenderer = new GltfSkin(this);\n\n        this.updateMatrix();\n        return n;\n    }\n\n    hasSkin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";\n        return false;\n    }\n\n    initSkin()\n    {\n        if (this.skin > -1)\n        {\n            this.skinRenderer = new GltfSkin(this);\n        }\n    }\n\n    updateMatrix()\n    {\n        mat4.identity(this.mat);\n        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);\n\n        if (this._node.rotation)\n        {\n            const rotmat = mat4.create();\n            this._rot = this._node.rotation;\n\n            mat4.fromQuat(rotmat, this._node.rotation);\n            mat4.mul(this.mat, this.mat, rotmat);\n        }\n\n        if (this._node.scale)\n        {\n            this._scale = this._node.scale;\n            mat4.scale(this.mat, this.mat, this._scale);\n        }\n\n        if (this._node.hasOwnProperty("mesh"))\n        {\n            this.mesh = this._gltf.meshes[this._node.mesh];\n            if (this.isCopy)\n            {\n                // console.log(this.mesh);\n            }\n        }\n\n        if (this._node.children)\n        {\n            for (let i = 0; i < this._node.children.length; i++)\n            {\n                this._gltf.json.nodes[i].isChild = true;\n                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;\n                this.children.push(this._node.children[i]);\n            }\n        }\n    }\n\n    unHide()\n    {\n        this.hidden = false;\n        for (let i = 0; i < this.children.length; i++)\n            if (this.children[i].unHide) this.children[i].unHide();\n    }\n\n    calcBounds(gltf, mat, bounds)\n    {\n        const localMat = mat4.create();\n\n        if (mat) mat4.copy(localMat, mat);\n        if (this.mat) mat4.mul(localMat, localMat, this.mat);\n\n        if (this.mesh)\n        {\n            const bb = this.mesh.bounds.copy();\n            bb.mulMat4(localMat);\n            bounds.apply(bb);\n\n            if (bounds.changed)\n            {\n                boundingPoints.push(\n                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,\n                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)\n            {\n                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);\n\n                bounds.apply(b);\n            }\n        }\n\n        if (bounds.changed) return bounds;\n        else return null;\n    }\n\n    setAnimAction(name)\n    {\n        // console.log("setAnimAction:", name);\n        if (!name) return;\n\n        this._currentAnimaction = name;\n\n        if (name && !this._animActions[name])\n        {\n            // console.log("no action found:", name,this._animActions);\n            return null;\n        }\n\n        // else console.log("YES action found:", name);\n        // console.log(this._animActions);\n\n        for (let path in this._animActions[name])\n        {\n            if (path == "translation") this._animTrans = this._animActions[name][path];\n            else if (path == "rotation") this._animRot = this._animActions[name][path];\n            else if (path == "scale") this._animScale = this._animActions[name][path];\n            else if (path == "weights") this.animWeights = this._animActions[name][path];\n            else console.log("[gltfNode] unknown anim path", path, this._animActions[name][path]);\n        }\n    }\n\n    setAnim(path, name, anims)\n    {\n        if (!path || !name || !anims) return;\n\n        // console.log("setanim", this._node.name, path, name, anims);\n\n        this._animActions[name] = this._animActions[name] || {};\n\n        // console.log(this._animActions);\n        // debugger;\n\n        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;\n\n        if (this._animActions[name][path]) op.log("[gltfNode] animation action path already exists", name, path, this._animActions[name][path]);\n\n        this._animActions[name][path] = anims;\n\n        if (path == "translation") this._animTrans = anims;\n        else if (path == "rotation") this._animRot = anims;\n        else if (path == "scale") this._animScale = anims;\n        else if (path == "weights")\n        {\n            // console.log("weights",name,path,anims)\n            this.animWeights = this._animActions[name][path];\n            // console.log(this.animWeights);\n        }\n        else console.warn("unknown anim path", path, anims);\n    }\n\n    modelMatLocal()\n    {\n        return this._animMat || this.mat;\n    }\n\n    modelMatAbs()\n    {\n        return this.absMat;\n    }\n\n    transform(cgl, _time)\n    {\n        if (!_time && _time != 0)_time = time;\n\n        this._lastTimeTrans = _time;\n\n        // console.log(this._rot)\n\n        gltfTransforms++;\n\n        if (!this._animTrans && !this._animRot && !this._animScale)\n        {\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);\n            this._animMat = null;\n        }\n        else\n        {\n            this._animMat = this._animMat || mat4.create();\n            mat4.identity(this._animMat);\n\n            const playAnims = true;\n\n            if (playAnims && this._animTrans)\n            {\n                mat4.translate(this._animMat, this._animMat, [\n                    this._animTrans[0].getValue(_time),\n                    this._animTrans[1].getValue(_time),\n                    this._animTrans[2].getValue(_time)]);\n            }\n            else\n            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);\n\n            if (playAnims && this._animRot)\n            {\n                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)\n                {\n                    this._tempQuat[0] = this._animRot[0].getValue(_time);\n                    this._tempQuat[1] = this._animRot[1].getValue(_time);\n                    this._tempQuat[2] = this._animRot[2].getValue(_time);\n                    this._tempQuat[3] = this._animRot[3].getValue(_time);\n                }\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)\n                {\n                    CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                }\n\n                mat4.fromQuat(this._tempMat, this._tempQuat);\n                mat4.mul(this._animMat, this._animMat, this._tempMat);\n            }\n            else if (this._rot)\n            {\n                mat4.fromQuat(this._tempRotmat, this._rot);\n                mat4.mul(this._animMat, this._animMat, this._tempRotmat);\n            }\n\n            if (playAnims && this._animScale)\n            {\n                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];\n                this._tempAnimScale[0] = this._animScale[0].getValue(_time);\n                this._tempAnimScale[1] = this._animScale[1].getValue(_time);\n                this._tempAnimScale[2] = this._animScale[2].getValue(_time);\n                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);\n            }\n            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);\n\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);\n        }\n\n        if (this.animWeights)\n        {\n            this.weights = this.weights || [];\n\n            let str = "";\n            for (let i = 0; i < this.animWeights.length; i++)\n            {\n                this.weights[i] = this.animWeights[i].getValue(_time);\n                str += this.weights[i] + "/";\n            }\n\n            // console.log(str);\n            // this.mesh.weights=this.animWeights.get(_time);\n            // console.log(this.animWeights);\n        }\n\n        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);\n\n        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);\n\n        mat4.copy(this.absMat, cgl.mMatrix);\n    }\n\n    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)\n    {\n        if (!dontTransform) cgl.pushModelMatrix();\n\n        if (_time === undefined) _time = gltf.time;\n\n        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);\n\n        if (this.hidden && !drawHidden)\n        {\n        }\n        else\n        {\n            if (this.skinRenderer)\n            {\n                this.skinRenderer.time = _time;\n                if (!dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time, this.weights);\n            }\n            else\n            {\n                if (this.mesh && !dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, null, _time, this.weights);\n            }\n        }\n\n        if (!ignoreChilds && !this.hidden)\n            for (let i = 0; i < this.children.length; i++)\n                if (gltf.nodes[this.children[i]])\n                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);\n\n        if (!dontTransform)cgl.popModelMatrix();\n    }\n};\n',inc_print_js:'let tab = null;\n\nfunction closeTab()\n{\n    if (tab)gui.mainTabs.closeTab(tab.id);\n    tab = null;\n}\n\nfunction formatVec(arr)\n{\n    const nums = [];\n    for (let i = 0; i < arr.length; i++)\n    {\n        nums.push(Math.round(arr[i] * 1000) / 1000);\n    }\n\n    return nums.join(",");\n}\n\nfunction printNode(html, node, level)\n{\n    if (!gltf) return;\n\n    html += "<tr class=\\"row\\">";\n\n    let ident = "";\n    let identSpace = "";\n\n    for (let i = 1; i < level; i++)\n    {\n        identSpace += "&nbsp;&nbsp;&nbsp;";\n        let identClass = "identBg";\n        if (i == 1)identClass = "identBgLevel0";\n        ident += "<td class=\\"ident " + identClass + "\\" ><div style=\\"\\"></div></td>";\n    }\n    let id = CABLES.uuid();\n    html += ident;\n    html += "<td colspan=\\"" + (21 - level) + "\\">";\n\n    if (node.mesh && node.mesh.meshes.length)html += "<span class=\\"icon icon-cube\\"></span>&nbsp;";\n    else html += "<span class=\\"icon icon-box-select\\"></span> &nbsp;";\n\n    html += node.name + "</td><td></td>";\n\n    if (node.mesh)\n    {\n        html += "<td>";\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (i > 0)html += ", ";\n            html += node.mesh.meshes[i].name;\n        }\n\n        html += "</td>";\n\n        html += "<td>";\n        html += node.hasSkin() || "-";\n        html += "</td>";\n\n        html += "<td>";\n        let countMats = 0;\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (countMats > 0)html += ", ";\n            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[node.mesh.meshes[i].material])\n                {\n                    html += gltf.json.materials[node.mesh.meshes[i].material].name;\n                    countMats++;\n                }\n            }\n        }\n        if (countMats == 0)html += "none";\n        html += "</td>";\n    }\n    else\n    {\n        html += "<td>-</td><td>-</td><td>-</td>";\n    }\n\n    html += "<td>";\n\n    if (node._node.translation || node._node.rotation || node._node.scale)\n    {\n        let info = "";\n\n        if (node._node.translation)info += "Translate: `" + formatVec(node._node.translation) + "` || ";\n        if (node._node.rotation)info += "Rotation: `" + formatVec(node._node.rotation) + "` || ";\n        if (node._node.scale)info += "Scale: `" + formatVec(node._node.scale) + "` || ";\n\n        html += "<span class=\\"icon icon-gizmo info\\" data-info=\\"" + info + "\\"></span> &nbsp;";\n    }\n\n    if (node._animRot || node._animScale || node._animTrans)\n    {\n        let info = "Animated: ";\n        if (node._animRot) info += "Rot ";\n        if (node._animScale) info += "Scale ";\n        if (node._animTrans) info += "Trans ";\n\n        html += "<span class=\\"icon icon-clock info\\" data-info=\\"" + info + "\\"></span>&nbsp;";\n    }\n\n    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += "-";\n\n    html += "</td>";\n\n    html += "<td>";\n    let hideclass = "";\n    if (node.hidden)hideclass = "node-hidden";\n\n    // html+=\'\';\n    html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'transform\')\\" class=\\"treebutton\\">Transform</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'hierarchy\')\\" class=\\"treebutton\\">Hierarchy</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\')\\" class=\\"treebutton\\">Node</a>";\n\n    if (node.hasSkin())\n        html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',false,{skin:true});\\" class=\\"treebutton\\">Skin</a>";\n\n    html += "</td><td>";\n    html += "&nbsp;<span class=\\"icon iconhover icon-eye " + hideclass + "\\" onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').toggleNodeVisibility(\'" + node.name + "\');this.classList.toggle(\'node-hidden\');\\"></span>";\n    html += "</td>";\n\n    html += "</tr>";\n\n    if (node.children)\n    {\n        for (let i = 0; i < node.children.length; i++)\n            html = printNode(html, gltf.nodes[node.children[i]], level + 1);\n    }\n\n    return html;\n}\n\nfunction printMaterial(mat, idx)\n{\n    let html = "<tr>";\n    html += " <td>" + idx + "</td>";\n    html += " <td>" + mat.name + "</td>";\n\n    html += " <td>";\n\n    const info = JSON.stringify(mat, null, 4).replaceAll("\\"", "").replaceAll("\\n", "<br/>");\n\n    html += "<span class=\\"icon icon-info\\" onclick=\\"new CABLES.UI.ModalDialog({ \'html\': \'<pre>" + info + "</pre>\', \'title\': \'" + mat.name + "\' });\\"></span>&nbsp;";\n\n    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)\n    {\n        let rgb = "";\n        rgb += "" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);\n\n        html += "<div style=\\"width:15px;height:15px;background-color:rgb(" + rgb + ");display:inline-block\\">&nbsp;</a>";\n    }\n    html += " <td style=\\"\\">" + (gltf.shaders[idx] ? "-" : "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').assignMaterial(\'" + mat.name + "\')\\" class=\\"treebutton\\">Assign</a>") + "<td>";\n    html += "<td>";\n\n    html += "</tr>";\n    return html;\n}\n\nfunction printInfo()\n{\n    if (!gltf) return;\n\n    const startTime = performance.now();\n    const sizes = {};\n    let html = "<div style=\\"overflow:scroll;width:100%;height:100%\\">";\n\n    html += "File: <a href=\\"" + CABLES.platform.getCablesUrl() + "/asset/patches/?filename=" + inFile.get() + "\\" target=\\"_blank\\">" + CABLES.basename(inFile.get()) + "</a><br/>";\n\n    html += "Generator:" + gltf.json.asset.generator;\n\n    let numNodes = 0;\n    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;\n    html += "<div id=\\"groupNodes\\">Nodes (" + numNodes + ")</div>";\n\n    html += "<table id=\\"sectionNodes\\" class=\\"table treetable\\">";\n\n    html += "<tr>";\n    html += " <th colspan=\\"21\\">Name</th>";\n    html += " <th>Mesh</th>";\n    html += " <th>Skin</th>";\n    html += " <th>Material</th>";\n    html += " <th>Transform</th>";\n    html += " <th>Expose</th>";\n    html += " <th></th>";\n    html += "</tr>";\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (!gltf.nodes[i].isChild)\n            html = printNode(html, gltf.nodes[i], 1);\n    }\n    html += "</table>";\n\n    // / //////////////////\n\n    let numMaterials = 0;\n    if (gltf.json.materials)numMaterials = gltf.json.materials.length;\n    html += "<div id=\\"groupMaterials\\">Materials (" + numMaterials + ")</div>";\n\n    if (!gltf.json.materials || gltf.json.materials.length == 0)\n    {\n    }\n    else\n    {\n        html += "<table id=\\"materialtable\\"  class=\\"table treetable\\">";\n        html += "<tr>";\n        html += " <th>Index</th>";\n        html += " <th>Name</th>";\n        html += " <th>Color</th>";\n        html += " <th>Function</th>";\n        html += " <th></th>";\n        html += "</tr>";\n        for (let i = 0; i < gltf.json.materials.length; i++)\n        {\n            html += printMaterial(gltf.json.materials[i], i);\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    html += "<div id=\\"groupMeshes\\">Meshes (" + gltf.json.meshes.length + ")</div>";\n\n    html += "<table id=\\"meshestable\\"  class=\\"table treetable\\">";\n    html += "<tr>";\n    html += " <th>Name</th>";\n    html += " <th>Node</th>";\n    html += " <th>Material</th>";\n    html += " <th>Vertices</th>";\n    html += " <th>Attributes</th>";\n    html += "</tr>";\n\n    let sizeBufferViews = [];\n    sizes.meshes = 0;\n    sizes.meshTargets = 0;\n\n    for (let i = 0; i < gltf.json.meshes.length; i++)\n    {\n        html += "<tr>";\n        html += "<td>" + gltf.json.meshes[i].name + "</td>";\n\n        html += "<td>";\n        let count = 0;\n        let nodename = "";\n        for (let j = 0; j < gltf.json.nodes.length; j++)\n        {\n            if (gltf.json.nodes[j].mesh == i)\n            {\n                count++;\n                if (count == 1)\n                {\n                    nodename = gltf.json.nodes[j].name;\n                }\n            }\n        }\n        if (count > 1) html += (count) + " nodes (" + nodename + " ...)";\n        else html += nodename;\n        html += "</td>";\n\n        // -------\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[gltf.json.meshes[i]])\n                {\n                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + " ";\n                }\n            }\n            else html += "None";\n        }\n        html += "</td>";\n\n        html += "<td>";\n        let numVerts = 0;\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)\n            {\n                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);\n                numVerts += v;\n                html += "" + v + "<br/>";\n            }\n            else html += "-<br/>";\n        }\n\n        if (gltf.json.meshes[i].primitives.length > 1)\n            html += "=" + numVerts;\n        html += "</td>";\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);\n            html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeGeom(\'" + gltf.json.meshes[i].name + "\'," + j + ")\\" class=\\"treebutton\\">Geometry</a>";\n            html += "<br/>";\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n            {\n                html += gltf.json.meshes[i].primitives[j].targets.length + " targets<br/>";\n\n                if (gltf.json.meshes[i].extras && gltf.json.meshes[i].extras.targetNames)\n                    html += "Targetnames:<br/>" + gltf.json.meshes[i].extras.targetNames.join("<br/>");\n\n                html += "<br/>";\n            }\n        }\n\n        html += "</td>";\n        html += "</tr>";\n\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];\n            if (accessor)\n            {\n                let bufView = accessor.bufferView;\n\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let k in gltf.json.meshes[i].primitives[j].attributes)\n            {\n                const attr = gltf.json.meshes[i].primitives[j].attributes[k];\n                const bufView2 = gltf.json.accessors[attr].bufferView;\n\n                if (sizeBufferViews.indexOf(bufView2) == -1)\n                {\n                    sizeBufferViews.push(bufView2);\n                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;\n                }\n            }\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n                for (let k = 0; k < gltf.json.meshes[i].primitives[j].targets.length; k++)\n                {\n                    for (let l in gltf.json.meshes[i].primitives[j].targets[k])\n                    {\n                        const accessorIdx = gltf.json.meshes[i].primitives[j].targets[k][l];\n                        const accessor = gltf.json.accessors[accessorIdx];\n                        const bufView2 = accessor.bufferView;\n                        console.log("accessor", accessor);\n                        if (sizeBufferViews.indexOf(bufView2) == -1)\n                            if (gltf.json.bufferViews[bufView2])\n                            {\n                                sizeBufferViews.push(bufView2);\n                                sizes.meshTargets += gltf.json.bufferViews[bufView2].byteLength;\n                            }\n                    }\n                }\n        }\n    }\n    html += "</table>";\n\n    // / //////////////////////////////////\n\n    let numSamplers = 0;\n    let numAnims = 0;\n    let numKeyframes = 0;\n\n    if (gltf.json.animations)\n    {\n        numAnims = gltf.json.animations.length;\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            numSamplers += gltf.json.animations[i].samplers.length;\n        }\n    }\n\n    html += "<div id=\\"groupAnims\\">Animations (" + numAnims + "/" + numSamplers + ")</div>";\n\n    if (gltf.json.animations)\n    {\n        html += "<table id=\\"sectionAnim\\" class=\\"table treetable\\">";\n        html += "<tr>";\n        html += "  <th>Name</th>";\n        html += "  <th>Target node</th>";\n        html += "  <th>Path</th>";\n        html += "  <th>Interpolation</th>";\n        html += "  <th>Keys</th>";\n        html += "</tr>";\n\n\n        sizes.animations = 0;\n\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)\n            {\n                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n\n                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)\n            {\n                html += "<tr>";\n                html += "  <td> Anim " + i + ": " + gltf.json.animations[i].name + "</td>";\n\n                html += "  <td>" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + "</td>";\n                html += "  <td>";\n                html += gltf.json.animations[i].channels[j].target.path + " ";\n                html += "  </td>";\n\n                const smplidx = gltf.json.animations[i].channels[j].sampler;\n                const smplr = gltf.json.animations[i].samplers[smplidx];\n\n                html += "  <td>" + smplr.interpolation + "</td>";\n\n                html += "  <td>" + gltf.json.accessors[smplr.output].count;\n                numKeyframes += gltf.json.accessors[smplr.output].count;\n\n                // html += "&nbsp;&nbsp;<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').showAnim(\'" + i + "\',\'" + j + "\')\\" class=\\"icon icon-search\\"></a>";\n\n                html += "</td>";\n\n                html += "</tr>";\n            }\n        }\n\n        html += "<tr>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td>" + numKeyframes + " total</td>";\n        html += "</tr>";\n        html += "</table>";\n    }\n    else\n    {\n\n    }\n\n    // / ///////////////////\n\n    let numImages = 0;\n    if (gltf.json.images)numImages = gltf.json.images.length;\n    html += "<div id=\\"groupImages\\">Images (" + numImages + ")</div>";\n\n    if (gltf.json.images)\n    {\n        html += "<table id=\\"sectionImages\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>func</th>";\n        html += "</tr>";\n\n        sizes.images = 0;\n\n        for (let i = 0; i < gltf.json.images.length; i++)\n        {\n            if (gltf.json.images[i].hasOwnProperty("bufferView"))\n            {\n                // if (sizeBufferViews.indexOf(gltf.json.images[i].hasOwnProperty("bufferView")) == -1)console.log("image bufferview already there?!");\n                // else\n                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;\n            }\n            else console.log("image has no bufferview?!");\n\n            html += "<tr>";\n            html += "<td>" + gltf.json.images[i].name + "</td>";\n            html += "<td>" + gltf.json.images[i].mimeType + "</td>";\n            html += "<td>";\n\n            let name = gltf.json.images[i].name;\n            if (name === undefined)name = gltf.json.images[i].bufferView;\n\n            html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeTexture(\'" + name + "\')\\" class=\\"treebutton\\">Expose</a>";\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    let numCameras = 0;\n    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;\n    html += "<div id=\\"groupCameras\\">Cameras (" + numCameras + ")</div>";\n\n    if (gltf.json.cameras)\n    {\n        html += "<table id=\\"sectionCameras\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>info</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.cameras.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.cameras[i].name + "</td>";\n            html += "<td>" + gltf.json.cameras[i].type + "</td>";\n            html += "<td>";\n\n            if (gltf.json.cameras[i].perspective)\n            {\n                html += "yfov: " + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;\n                html += ", ";\n                html += "zfar: " + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;\n                html += ", ";\n                html += "znear: " + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;\n            }\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    let numSkins = 0;\n    if (gltf.json.skins)numSkins = gltf.json.skins.length;\n    html += "<div id=\\"groupSkins\\">Skins (" + numSkins + ")</div>";\n\n    if (gltf.json.skins)\n    {\n        // html += "<h3>Skins (" + gltf.json.skins.length + ")</h3>";\n        html += "<table id=\\"sectionSkins\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th></th>";\n        html += "  <th>total joints</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.skins.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.skins[i].name + "</td>";\n            html += "<td>" + "</td>";\n            html += "<td>" + gltf.json.skins[i].joints.length + "</td>";\n            html += "<td>";\n            html += "</td>";\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    if (gltf.timing)\n    {\n        html += "<div id=\\"groupTiming\\">Debug Loading Timing </div>";\n\n        html += "<table id=\\"sectionTiming\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>task</th>";\n        html += "  <th>time used</th>";\n        html += "</tr>";\n\n        let lt = 0;\n        for (let i = 0; i < gltf.timing.length - 1; i++)\n        {\n            html += "<tr>";\n            html += "  <td>" + gltf.timing[i][0] + "</td>";\n            html += "  <td>" + (gltf.timing[i + 1][1] - gltf.timing[i][1]) + " ms</td>";\n            html += "</tr>";\n            // lt = gltf.timing[i][1];\n        }\n        html += "</table>";\n    }\n\n    // / //////////////////////////\n\n    let sizeBin = 0;\n    if (gltf.json.buffers)\n        sizeBin = gltf.json.buffers[0].byteLength;\n\n    html += "<div id=\\"groupBinary\\">File Size Allocation (" + Math.round(sizeBin / 1024) + "k )</div>";\n\n    html += "<table id=\\"sectionBinary\\" class=\\"table treetable\\">";\n    html += "<tr>";\n    html += "  <th>name</th>";\n    html += "  <th>size</th>";\n    html += "  <th>%</th>";\n    html += "</tr>";\n    let sizeUnknown = sizeBin;\n    for (let i in sizes)\n    {\n        // html+=i+\':\'+Math.round(sizes[i]/1024);\n        html += "<tr>";\n        html += "<td>" + i + "</td>";\n        html += "<td>" + readableSize(sizes[i]) + " </td>";\n        html += "<td>" + Math.round(sizes[i] / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n        sizeUnknown -= sizes[i];\n    }\n\n    if (sizeUnknown != 0)\n    {\n        html += "<tr>";\n        html += "<td>unknown</td>";\n        html += "<td>" + readableSize(sizeUnknown) + " </td>";\n        html += "<td>" + Math.round(sizeUnknown / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n    }\n\n    html += "</table>";\n    html += "</div>";\n\n    tab = new CABLES.UI.Tab("GLTF " + CABLES.basename(inFile.get()), { "icon": "cube", "infotext": "tab_gltf", "padding": true, "singleton": true });\n    gui.mainTabs.addTab(tab, true);\n\n    tab.addEventListener("close", closeTab);\n    tab.html(html);\n\n    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);\n\n    gui.maintabPanel.show(true);\n}\n\nfunction readableSize(n)\n{\n    if (n > 1024) return Math.round(n / 1024) + " kb";\n    if (n > 1024 * 500) return Math.round(n / 1024) + " mb";\n    else return n + " bytes";\n}\n',inc_skin_js:'const GltfSkin = class\n{\n    constructor(node)\n    {\n        this._mod = null;\n        this._node = node;\n        this._lastTime = 0;\n        this._matArr = [];\n        this._m = mat4.create();\n        this._invBindMatrix = mat4.create();\n        this.identity = true;\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.skin_head_vert || "",\n                "srcBodyVert": attachments.skin_vert || ""\n            });\n\n            this._mod.addUniformVert("m4[]", "MOD_boneMats", []);// bohnenmatze\n            const tr = vec3.create();\n        }\n\n        const skinIdx = this._node.skin;\n        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;\n\n        // if (this._lastTime != time || !time)\n        {\n            // this._lastTime=inTime.get();\n            if (this._matArr.length != arrLength) this._matArr.length = arrLength;\n\n            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)\n            {\n                const i16 = i * 16;\n                const jointIdx = gltf.json.skins[skinIdx].joints[i];\n                const nodeJoint = gltf.nodes[jointIdx];\n\n                for (let j = 0; j < 16; j++)\n                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];\n\n                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);\n\n                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];\n            }\n\n            this._mod.setUniformValue("MOD_boneMats", this._matArr);\n            this._lastTime = time;\n        }\n\n        this._mod.define("SKIN_NUM_BONES", gltf.json.skins[skinIdx].joints.length);\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n};\n',inc_targets_js:'const GltfTargetsRenderer = class\n{\n    constructor(mesh)\n    {\n        this.mesh = mesh;\n        this.tex = null;\n        this.numRowsPerTarget = 0;\n\n        this.makeTex(mesh.geom);\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, "gltftarget");\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.targets_head_vert || "",\n                "srcBodyVert": attachments.targets_vert || ""\n            });\n\n            this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);\n            this._mod.addUniformVert("t", "MOD_targetTex", 1);\n            this._mod.addUniformVert("f[]", "MOD_weights", []);\n\n            const tr = vec3.create();\n        }\n\n        this._mod.pushTexture("MOD_targetTex", this.tex);\n        if (this.tex && this.mesh.weights)\n        {\n            this._mod.setUniformValue("MOD_weights", this.mesh.weights);\n            this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);\n\n            this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));\n        }\n        else\n        {\n            this._mod.define("MOD_NUM_WEIGHTS", 1);\n        }\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n\n    makeTex(geom)\n    {\n        if (!geom.morphTargets || !geom.morphTargets.length) return;\n\n        let w = geom.morphTargets[0].vertices.length / 3;\n        let h = 0;\n        this.numRowsPerTarget = 0;\n\n        if (geom.morphTargets[0].vertices && geom.morphTargets[0].vertices.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].vertexNormals && geom.morphTargets[0].vertexNormals.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].tangents && geom.morphTargets[0].tangents.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].bitangents && geom.morphTargets[0].bitangents.length) this.numRowsPerTarget++;\n\n        h = geom.morphTargets.length * this.numRowsPerTarget;\n\n        // console.log("this.numRowsPerTarget", this.numRowsPerTarget);\n\n        const pixels = new Float32Array(w * h * 4);\n        let row = 0;\n\n        for (let i = 0; i < geom.morphTargets.length; i++)\n        {\n            if (geom.morphTargets[i].vertices && geom.morphTargets[i].vertices.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertices.length; j += 3)\n                {\n                    pixels[((row * w) + (j / 3)) * 4 + 0] = geom.morphTargets[i].vertices[j + 0];\n                    pixels[((row * w) + (j / 3)) * 4 + 1] = geom.morphTargets[i].vertices[j + 1];\n                    pixels[((row * w) + (j / 3)) * 4 + 2] = geom.morphTargets[i].vertices[j + 2];\n                    pixels[((row * w) + (j / 3)) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].vertexNormals && geom.morphTargets[i].vertexNormals.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertexNormals.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].vertexNormals[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].vertexNormals[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].vertexNormals[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n\n                row++;\n            }\n\n            if (geom.morphTargets[i].tangents && geom.morphTargets[i].tangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].tangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].tangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].tangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].tangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].bitangents && geom.morphTargets[i].bitangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].bitangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].bitangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].bitangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].bitangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n        }\n\n        this.tex = new CGL.Texture(cgl, { "isFloatingPointTexture": true, "name": "targetsTexture" });\n\n        this.tex.initFromData(pixels, w, h, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);\n\n        // console.log("morphTargets generated texture", w, h);\n    }\n};\n',skin_vert:"int index=int(attrJoints.x);\nvec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\nvec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\nindex=int(attrJoints.y);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.y;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n\nindex=int(attrJoints.z);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.z;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n\nindex=int(attrJoints.w);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n\npos=newPos;\n\nnorm=normalize(newNorm.xyz);\n\n\n",skin_head_vert:"\nIN vec4 attrWeights;\nIN vec4 attrJoints;\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];\n",targets_vert:"\n\nfloat MOD_width=MOD_targetTexInfo.x;\nfloat MOD_height=MOD_targetTexInfo.y;\nfloat MOD_numTargets=MOD_targetTexInfo.w;\nfloat MOD_numLinesPerTarget=MOD_height/MOD_numTargets;\n\nfloat halfpix=(1.0/MOD_width)*0.5;\nfloat halfpixy=(1.0/MOD_height)*0.5;\n\nfloat x=(attrVertIndex)/MOD_width+halfpix;\n\nvec3 off=vec3(0.0);\n\nfor(float i=0.0;i<MOD_numTargets;i+=1.0)\n{\n    float y=1.0-((MOD_numLinesPerTarget*i)/MOD_height+halfpixy);\n    vec2 coord=vec2(x,y);\n    vec3 targetXYZ = texture(MOD_targetTex,coord).xyz;\n\n    off+=(targetXYZ*MOD_weights[int(i)]);\n\n\n\n    coord.y+=1.0/MOD_height; // normals are in next row\n    vec3 targetNormal = texture(MOD_targetTex,coord).xyz;\n    norm+=targetNormal*MOD_weights[int(i)];\n\n\n}\n\n// norm=normalize(norm);\npos.xyz+=off;\n",targets_head_vert:"\nUNI float MOD_weights[MOD_NUM_WEIGHTS];\n"};const k=class{constructor(e,t){this.node=t;this.name=t.name;this.config=e.json.cameras[t.camera];this.pos=vec3.create();this.quat=quat.create();this.vCenter=vec3.create();this.vUp=vec3.create();this.vMat=mat4.create()}updateAnim(e){if(this.node&&this.node._animTrans){vec3.set(this.pos,this.node._animTrans[0].getValue(e),this.node._animTrans[1].getValue(e),this.node._animTrans[2].getValue(e));quat.set(this.quat,this.node._animRot[0].getValue(e),this.node._animRot[1].getValue(e),this.node._animRot[2].getValue(e),this.node._animRot[3].getValue(e))}}start(e){if(h.tempData.shadowPass)return;this.updateAnim(e);const t=h.getViewPort()[2]/h.getViewPort()[3];h.pushPMatrix();h.pushViewMatrix();let n=mat4.create();mat4.invert(n,this.node.modelMatAbs());this.vMat=n;mat4.identity(h.vMatrix);mat4.mul(h.vMatrix,h.vMatrix,n)}end(){if(h.tempData.shadowPass)return;h.popPMatrix();h.popViewMatrix()}};const T=true;const F=class{constructor(){this.json={};this.accBuffers=[];this.meshes=[];this.nodes=[];this.shaders=[];this.timing=[];this.cams=[];this.startTime=performance.now();this.bounds=new CABLES.CG.BoundingBox;this.loaded=Date.now();this.accBuffersDelete=[]}getNode(t){for(let e=0;e<this.nodes.length;e++){if(this.nodes[e].name==t)return this.nodes[e]}}unHideAll(){for(let e=0;e<this.nodes.length;e++){this.nodes[e].unHide()}}};function I(e){if(window.TextDecoder)return new TextDecoder("utf-8").decode(e);let t,n,a,i;let r,s;t="";a=e.length;n=0;while(n<a){i=e[n++];switch(i>>4){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:t+=String.fromCharCode(i);break;case 12:case 13:r=e[n++];t+=String.fromCharCode((i&31)<<6|r&63);break;case 14:r=e[n++];s=e[n++];t+=String.fromCharCode((i&15)<<12|(r&63)<<6|(s&63)<<0);break}}return t}function y(e,t,n,a){const i={};if(a>=e.byteLength){return}i.size=e.getUint32(a+0,T);i.type=I(t.subarray(a+4,a+4+4));if(i.type=="BIN\0"){i.dataView=new DataView(n,a+8,i.size)}else if(i.type=="JSON"){const r=I(t.subarray(a+8,a+8+i.size));try{const s=JSON.parse(r);i.data=s;se.set(s.asset.generator)}catch(e){}}else{_.warn("unknown type",i.type)}return i}function G(t){const a={};for(let e=0;e<t.json.animations.length;e++){const i=t.json.animations[e];i.name=i.name||"unknown";for(let e=0;e<i.channels.length;e++){const r=i.channels[e];const s=t.nodes[r.target.node];const o=i.samplers[r.sampler];const n=t.json.accessors[o.input];const l=t.accBuffers[o.input];const u=t.json.accessors[o.output];const m=t.accBuffers[o.output];t.accBuffersDelete.push(o.output,o.input);if(l&&m){let n=1;if(u.type==="VEC2")n=2;else if(u.type==="VEC3")n=3;else if(u.type==="VEC4")n=4;else if(u.type==="SCALAR"){n=m.length/l.length}else _.log("[] UNKNOWN accOut.type",u.type);const p=[];a[i.name]=true;for(let e=0;e<n;e++){const c=new CABLES.Anim;p.push(c)}if(o.interpolation==="LINEAR"){}else if(o.interpolation==="STEP")for(let e=0;e<n;e++)p[e].defaultEasing=CABLES.EASING_ABSOLUTE;else if(o.interpolation==="CUBICSPLINE")for(let e=0;e<n;e++)p[e].defaultEasing=CABLES.EASING_CUBICSPLINE;else _.warn("unknown interpolation",o.interpolation);if(l[0]!==0)for(let e=0;e<n;e++)p[e].setValue(0,m[0*n+e]);for(let t=0;t<l.length;t++){x=Math.max(l[t],x);for(let e=0;e<n;e++){if(p[e].defaultEasing===CABLES.EASING_CUBICSPLINE){const d=t*n*3+e;const h=p[e].setValue(l[t],m[d+n]);h.bezTangIn=m[d];h.bezTangOut=m[d+n*2]}else{p[e].setValue(l[t],m[t*n+e])}}}s.setAnim(r.target.path,i.name,p)}else{_.warn("loadAmins bufferIn undefined ",l===undefined);_.warn("loadAmins bufferOut undefined ",m===undefined);_.warn("loadAmins ",i.name,o,u);_.warn("loadAmins num accBuffers",t.accBuffers.length);_.warn("loadAmins num accessors",t.json.accessors.length)}}}t.uniqueAnimNames=a;ce.setRef(Object.keys(a))}function U(n){if(!n||!n.json.cameras)return;n.cameras=n.cameras||[];for(let t=0;t<n.nodes.length;t++){if(n.nodes[t].hasOwnProperty("camera")){const e=new k(n,n.nodes[t]);n.cameras.push(e)}}}function B(){if(!window.DracoDecoder){setTimeout(()=>{B()},100)}P()}function D(e){const t=8;let i=0,n=0;const r=new F;r.timing.push(["Start parsing",Math.round(performance.now()-r.startTime)]);if(!e)return;const a=new Uint8Array(e);let s=0;const o=I(a.subarray(s,4));s+=4;if(o!="glTF")return;r.timing.push(["dataview",Math.round(performance.now()-r.startTime)]);const l=new DataView(e);const u=l.getUint32(s,T);s+=4;const m=l.getUint32(s,T);s+=4;oe.set(u);const p=[];r.chunks=p;p.push(y(l,a,e,s));s+=p[0].size+t;r.json=p[0].data;r.cables={fileUrl:S.get(),shortFileName:CABLES.basename(S.get())};pe.setRef(r.json);le.setRef(r.json.extensionsUsed||[]);let c=y(l,a,e,s);while(c){p.push(c);s+=c.size+t;c=y(l,a,e,s)}r.chunks=p;const d=p[0].data.bufferViews;const h=p[0].data.accessors;r.timing.push(["Parse buffers",Math.round(performance.now()-r.startTime)]);if(r.json.extensionsUsed&&r.json.extensionsUsed.indexOf("KHR_draco_mesh_compression")>-1){if(!window.DracoDecoder){_.setUiError("gltfdraco","GLTF draco compression lib not found / add draco op to your patch!");B();return r}else{r.useDraco=true}}_.setUiError("gltfdraco",null);if(d){for(n=0;n<h.length;n++){const f=h[n];const v=d[f.bufferView];let a=0;if(f.type=="SCALAR")a=1;else if(f.type=="VEC2")a=2;else if(f.type=="VEC3")a=3;else if(f.type=="VEC4")a=4;else if(f.type=="MAT4")a=16;else console.error("unknown accessor type",f.type);if(p[1].dataView){if(v){const g=f.count*a;let e=(v.byteOffset||0)+(f.byteOffset||0);let t=v.byteStride||0;let n=null;if(f.componentType==5126||f.componentType==5125){t=t||4;const b=f.componentType==5125;if(b)n=new Uint32Array(g);else n=new Float32Array(g);n.cblStride=a;for(i=0;i<g;i++){if(b)n[i]=p[1].dataView.getUint32(e,T);else n[i]=p[1].dataView.getFloat32(e,T);if(t!=4&&(i+1)%a===0)e+=t-a*4;e+=4}}else if(f.componentType==5123){t=t||2;n=new Uint16Array(g);n.cblStride=t;for(i=0;i<g;i++){n[i]=p[1].dataView.getUint16(e,T);if(t!=2&&(i+1)%a===0)e+=t-a*2;e+=2}}else if(f.componentType==5121){t=t||1;n=new Uint8Array(g);n.cblStride=t;for(i=0;i<g;i++){n[i]=p[1].dataView.getUint8(e,T);if(t!=1&&(i+1)%a===0)e+=t-a*1;e+=1}}else{console.error("unknown component type",f.componentType)}r.accBuffers.push(n)}else{}}}}r.timing.push(["Parse mesh groups",Math.round(performance.now()-r.startTime)]);r.json.meshes=r.json.meshes||[];if(r.json.meshes){for(n=0;n<r.json.meshes.length;n++){const x=new z(r,r.json.meshes[n]);r.meshes.push(x)}}r.timing.push(["Parse nodes",Math.round(performance.now()-r.startTime)]);for(n=0;n<r.json.nodes.length;n++){if(r.json.nodes[n].children)for(i=0;i<r.json.nodes[n].children.length;i++){r.json.nodes[r.json.nodes[n].children[i]].isChild=true}}for(n=0;n<r.json.nodes.length;n++){const O=new X(r.json.nodes[n],r);r.nodes.push(O)}for(n=0;n<r.nodes.length;n++){const O=r.nodes[n];if(!O.children)continue;for(let e=0;e<O.children.length;e++){r.nodes[O.children[e]].parent=O}}for(n=0;n<r.nodes.length;n++){r.nodes[n].initSkin()}j=true;r.timing.push(["load anims",Math.round(performance.now()-r.startTime)]);if(r.json.animations)G(r);r.timing.push(["load cameras",Math.round(performance.now()-r.startTime)]);if(r.json.cameras)U(r);r.timing.push(["finished",Math.round(performance.now()-r.startTime)]);return r}let V=class{constructor(e,n,r,s){this.POINTS=0;this.LINES=1;this.LINE_LOOP=2;this.LINE_STRIP=3;this.TRIANGLES=4;this.TRIANGLE_STRIP=5;this.TRIANGLE_FAN=6;this.test=0;this.name=e;this.submeshIndex=0;this.material=n.material;this.mesh=null;this.geom=new CGL.Geometry("gltf_"+this.name);this.geom.verticesIndices=[];this.bounds=null;this.primitive=4;this.morphTargetsRenderMod=null;this.weights=n.weights;if(n.hasOwnProperty("mode"))this.primitive=n.mode;if(n.hasOwnProperty("indices"))this.geom.verticesIndices=r.accBuffers[n.indices];r.loadingMeshes=r.loadingMeshes||0;r.loadingMeshes++;this.materialJson=this._matPbrMetalness=this._matPbrRoughness=this._matDiffuseColor=null;if(r.json.materials){if(this.material!=-1)this.materialJson=r.json.materials[this.material];if(this.materialJson&&this.materialJson.pbrMetallicRoughness){if(!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor")){this._matDiffuseColor=[1,1,1,1]}else{this._matDiffuseColor=this.materialJson.pbrMetallicRoughness.baseColorFactor}this._matDiffuseColor=this.materialJson.pbrMetallicRoughness.baseColorFactor;if(!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor")){this._matPbrMetalness=1}else{this._matPbrMetalness=this.materialJson.pbrMetallicRoughness.metallicFactor||null}if(!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor")){this._matPbrRoughness=1}else{this._matPbrRoughness=this.materialJson.pbrMetallicRoughness.roughnessFactor||null}}}if(r.useDraco&&n.extensions.KHR_draco_mesh_compression){const a=r.chunks[0].data.bufferViews[n.extensions.KHR_draco_mesh_compression.bufferView];const i=a.byteLength;const o=new Int8Array(i);let t=a.byteOffset||0;for(let e=0;e<i;e++){o[e]=r.chunks[1].dataView.getInt8(t,T);t++}const l=window.DracoDecoder;l.decodeGeometry(o.buffer,t=>{const n=new CGL.Geometry("draco mesh "+e);for(let e=0;e<t.attributes.length;e++){const a=t.attributes[e];if(a.name==="position")n.vertices=a.array;else if(a.name==="normal")n.vertexNormals=a.array;else if(a.name==="uv")n.texCoords=a.array;else if(a.name==="color")n.vertexColors=this.calcVertexColors(a.array);else if(a.name==="joints")n.setAttribute("attrJoints",Array.from(a.array),4);else if(a.name==="weights"){const i=new Float32Array(a.array.length/a.itemSize*4);for(let t=0;t<a.array.length/a.itemSize;t++){i[t*4]=i[t*4+1]=i[t*4+2]=i[t*4+3]=0;for(let e=0;e<a.itemSize;e++)i[t*4+e]=a.array[t*a.itemSize+e]}n.setAttribute("attrWeights",i,4)}else _.logWarn("unknown draco attrib",a)}t.attributes=null;n.verticesIndices=t.index.array;this.setGeom(n);this.mesh=null;r.loadingMeshes--;r.timing.push(["draco decode",Math.round(performance.now()-r.startTime)]);if(s)s(this)},e=>{_.logError(e)})}else{r.loadingMeshes--;this.fillGeomAttribs(r,this.geom,n.attributes);if(n.targets){for(let e=0;e<n.targets.length;e++){const t=new CGL.Geometry("gltf_target_"+e);this.fillGeomAttribs(r,t,n.targets[e],false);this.geom.morphTargets.push(t)}}if(s)s(this)}}_linearToSrgb(e){if(e<=0)return 0;else if(e>=1)return 1;else if(e<.0031308)return e*12.92;else return e**(1/2.2)*1.055-.055}calcVertexColors(n,e){let a=null;if(n instanceof Float32Array){let t=false;for(let e=0;e<n.length;e++){if(n[e]>1){t=true;continue}}if(t)for(let e=0;e<n.length;e++)n[e]/=65535;a=n}else if(n instanceof Uint16Array){const t=new Float32Array(n.length);for(let e=0;e<n.length;e++)t[e]=n[e]/65535;a=t}else a=n;for(let e=0;e<a.length;e++){a[e]=this._linearToSrgb(a[e])}console.log("arr.cblStride",n.cblStride);if(n.cblStride==3){const i=new Float32Array(a.length/3*4);for(let e=0;e<a.length/3;e++){i[e*4+0]=a[e*3+0];i[e*4+1]=a[e*3+1];i[e*4+2]=a[e*3+2];i[e*4+3]=1}a=i}return a}fillGeomAttribs(e,t,n,a){if(n.hasOwnProperty("POSITION"))t.vertices=e.accBuffers[n.POSITION];if(n.hasOwnProperty("NORMAL"))t.vertexNormals=e.accBuffers[n.NORMAL];if(n.hasOwnProperty("TANGENT"))t.tangents=e.accBuffers[n.TANGENT];if(n.hasOwnProperty("COLOR_0"))t.vertexColors=this.calcVertexColors(e.accBuffers[n.COLOR_0],e.accBuffers[n.COLOR_0].type);if(n.hasOwnProperty("COLOR_1"))t.setAttribute("attrVertColor1",this.calcVertexColors(e.accBuffers[n.COLOR_1]),e.accBuffers[n.COLOR_1].type);if(n.hasOwnProperty("COLOR_2"))t.setAttribute("attrVertColor2",this.calcVertexColors(e.accBuffers[n.COLOR_2]),e.accBuffers[n.COLOR_2].type);if(n.hasOwnProperty("COLOR_3"))t.setAttribute("attrVertColor3",this.calcVertexColors(e.accBuffers[n.COLOR_3]),e.accBuffers[n.COLOR_3].type);if(n.hasOwnProperty("COLOR_4"))t.setAttribute("attrVertColor4",this.calcVertexColors(e.accBuffers[n.COLOR_4]),e.accBuffers[n.COLOR_4].type);if(n.hasOwnProperty("TEXCOORD_0"))t.texCoords=e.accBuffers[n.TEXCOORD_0];if(n.hasOwnProperty("TEXCOORD_1"))t.setAttribute("attrTexCoord1",e.accBuffers[n.TEXCOORD_1],2);if(n.hasOwnProperty("TEXCOORD_2"))t.setAttribute("attrTexCoord2",e.accBuffers[n.TEXCOORD_2],2);if(n.hasOwnProperty("TEXCOORD_3"))t.setAttribute("attrTexCoord3",e.accBuffers[n.TEXCOORD_3],2);if(n.hasOwnProperty("TEXCOORD_4"))t.setAttribute("attrTexCoord4",e.accBuffers[n.TEXCOORD_4],2);if(n.hasOwnProperty("WEIGHTS_0")){t.setAttribute("attrWeights",e.accBuffers[n.WEIGHTS_0],4)}if(n.hasOwnProperty("JOINTS_0")){if(!e.accBuffers[n.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");t.setAttribute("attrJoints",e.accBuffers[n.JOINTS_0],4)}if(n.hasOwnProperty("POSITION"))e.accBuffersDelete.push(n.POSITION);if(n.hasOwnProperty("NORMAL"))e.accBuffersDelete.push(n.NORMAL);if(n.hasOwnProperty("TEXCOORD_0"))e.accBuffersDelete.push(n.TEXCOORD_0);if(n.hasOwnProperty("TANGENT"))e.accBuffersDelete.push(n.TANGENT);if(n.hasOwnProperty("COLOR_0"))e.accBuffersDelete.push(n.COLOR_0);if(n.hasOwnProperty("COLOR_0"))e.accBuffersDelete.push(n.COLOR_0);if(n.hasOwnProperty("COLOR_1"))e.accBuffersDelete.push(n.COLOR_1);if(n.hasOwnProperty("COLOR_2"))e.accBuffersDelete.push(n.COLOR_2);if(n.hasOwnProperty("COLOR_3"))e.accBuffersDelete.push(n.COLOR_3);if(n.hasOwnProperty("TEXCOORD_1"))e.accBuffersDelete.push(n.TEXCOORD_1);if(n.hasOwnProperty("TEXCOORD_2"))e.accBuffersDelete.push(n.TEXCOORD_2);if(n.hasOwnProperty("TEXCOORD_3"))e.accBuffersDelete.push(n.TEXCOORD_3);if(n.hasOwnProperty("TEXCOORD_4"))e.accBuffersDelete.push(n.TEXCOORD_4);if(a!==false)if(t&&t.verticesIndices)this.setGeom(t)}setGeom(n){if(te.get()=="X-ZY"){for(let t=0;t<n.vertexNormals.length;t+=3){let e=n.vertexNormals[t+2];n.vertexNormals[t+2]=n.vertexNormals[t+1];n.vertexNormals[t+1]=-e}}if(ne.get()=="XZ-Y"){for(let t=0;t<n.vertices.length;t+=3){let e=n.vertices[t+2];n.vertices[t+2]=-n.vertices[t+1];n.vertices[t+1]=e}}if(this.primitive==this.TRIANGLES){if(m.get()=="Force Smooth"||m.get()==false)n.calculateNormals();else if(!n.vertexNormals.length&&m.get()=="Auto")n.calculateNormals({smooth:false});if((!n.biTangents||n.biTangents.length==0)&&n.tangents){const t=vec3.create();const e=vec3.create();const a=n.tangents;n.tangents=new Float32Array(a.length/4*3);n.biTangents=new Float32Array(a.length/4*3);for(let e=0;e<a.length;e+=4){const i=e/4*3;vec3.cross(t,[n.vertexNormals[i],n.vertexNormals[i+1],n.vertexNormals[i+2]],[a[e],a[e+1],a[e+2]]);vec3.div(t,t,[a[e+3],a[e+3],a[e+3]]);vec3.normalize(t,t);n.biTangents[i+0]=t[0];n.biTangents[i+1]=t[1];n.biTangents[i+2]=t[2];n.tangents[i+0]=a[e+0];n.tangents[i+1]=a[e+1];n.tangents[i+2]=a[e+2]}}if(n.tangents.length===0||m.get()!="Never"){n.calcTangentsBitangents()}}this.geom=n;this.bounds=n.getBounds()}render(n,t,a){if(!this.mesh&&this.geom&&this.geom.verticesIndices){let e=this.geom;if(this.geom.vertices.length/3>64e3){e=this.geom.copy();e.unIndex(false,true)}let t;if(n.gl){if(this.primitive==this.TRIANGLES)t=n.gl.TRIANGLES;else if(this.primitive==this.LINES)t=n.gl.LINES;else if(this.primitive==this.LINE_STRIP)t=n.gl.LINE_STRIP;else if(this.primitive==this.POINTS)t=n.gl.POINTS;else{_.logWarn("unknown primitive type",this)}}this.mesh=_.patch.cg.createMesh(e,{glPrimitive:t})}if(this.mesh){if(this.geom&&this.geom.morphTargets.length&&!this.morphTargetsRenderMod){this.mesh.addVertexNumbers=true;this.morphTargetsRenderMod=new Z(this)}let e=!t&&this.material!=-1&&E.shaders[this.material];if(a)e=false;if(e)n.pushShader(E.shaders[this.material]);const i=n.getShader()||{};const r=i.uniformColorDiffuse;const s=i.uniformPbrMetalness;const o=i.uniformPbrRoughness;if(!E.shaders[this.material]&&ie.get()){if(r&&this._matDiffuseColor){this._matDiffuseColorOrig=[r.getValue()[0],r.getValue()[1],r.getValue()[2],r.getValue()[3]];r.setValue(this._matDiffuseColor)}if(s)if(this._matPbrMetalness!=null){this._matPbrMetalnessOrig=s.getValue();s.setValue(this._matPbrMetalness)}else s.setValue(0);if(o)if(this._matPbrRoughness!=null){this._matPbrRoughnessOrig=o.getValue();o.setValue(this._matPbrRoughness)}else{o.setValue(0)}}if(this.morphTargetsRenderMod)this.morphTargetsRenderMod.renderStart(n,0);if(this.mesh){this.mesh.render(n.getShader(),t)}if(this.morphTargetsRenderMod)this.morphTargetsRenderMod.renderFinish(n);if(ie.get()){if(r&&this._matDiffuseColor)r.setValue(this._matDiffuseColorOrig);if(s&&this._matPbrMetalnessOrig!=undefined)s.setValue(this._matPbrMetalnessOrig);if(o&&this._matPbrRoughnessOrig!=undefined)o.setValue(this._matPbrRoughnessOrig)}if(e)n.popShader()}}};const z=class{constructor(t,n){this.bounds=new CABLES.CG.BoundingBox;this.meshes=[];this.name=n.name;const a=n.primitives;for(let e=0;e<a.length;e++){const i=new V(this.name,a[e],t,e=>{e.extras=n.extras;this.bounds.apply(e.bounds)});i.submeshIndex=e;this.meshes.push(i)}}render(t,n,a,i,r){for(let e=0;e<this.meshes.length;e++){const s=E.shaders[this.meshes[e].material];if(!n&&s)t.pushShader(E.shaders[this.meshes[e].material]);if(a)a.renderStart(t,i);if(r)this.meshes[e].weights=r;this.meshes[e].render(t,n,a,i);if(a)a.renderFinish(t);if(!n&&s)t.popShader()}}};const X=class{constructor(e,t){this.isChild=e.isChild||false;this.name=e.name;if(e.hasOwnProperty("camera"))this.camera=e.camera;this.hidden=false;this.mat=mat4.create();this._animActions={};this.animWeights=[];this._animMat=mat4.create();this._tempMat=mat4.create();this._tempQuat=quat.create();this._tempRotmat=mat4.create();this.mesh=null;this.children=[];this._node=e;this._gltf=t;this.absMat=mat4.create();this.addTranslate=null;this._tempAnimScale=null;this.addMulMat=null;this.updateMatrix();this.skinRenderer=null;this.copies=[]}get skin(){if(this._node.hasOwnProperty("skin"))return this._node.skin;else return-1}copy(){this.isCopy=true;const e=new X(this._node,this._gltf);e.copyOf=this;e._animActions=this._animActions;e.children=this.children;if(this.skin)e.skinRenderer=new W(this);this.updateMatrix();return e}hasSkin(){if(this._node.hasOwnProperty("skin"))return this._gltf.json.skins[this._node.skin].name||"unknown";return false}initSkin(){if(this.skin>-1){this.skinRenderer=new W(this)}}updateMatrix(){mat4.identity(this.mat);if(this._node.translation)mat4.translate(this.mat,this.mat,this._node.translation);if(this._node.rotation){const e=mat4.create();this._rot=this._node.rotation;mat4.fromQuat(e,this._node.rotation);mat4.mul(this.mat,this.mat,e)}if(this._node.scale){this._scale=this._node.scale;mat4.scale(this.mat,this.mat,this._scale)}if(this._node.hasOwnProperty("mesh")){this.mesh=this._gltf.meshes[this._node.mesh];if(this.isCopy){}}if(this._node.children){for(let e=0;e<this._node.children.length;e++){this._gltf.json.nodes[e].isChild=true;if(this._gltf.nodes[this._node.children[e]])this._gltf.nodes[this._node.children[e]].isChild=true;this.children.push(this._node.children[e])}}}unHide(){this.hidden=false;for(let e=0;e<this.children.length;e++)if(this.children[e].unHide)this.children[e].unHide()}calcBounds(t,e,n){const a=mat4.create();if(e)mat4.copy(a,e);if(this.mat)mat4.mul(a,a,this.mat);if(this.mesh){const i=this.mesh.bounds.copy();i.mulMat4(a);n.apply(i);if(n.changed){b.push(i._min[0]||0,i._min[1]||0,i._min[2]||0,i._max[0]||0,i._max[1]||0,i._max[2]||0)}}for(let e=0;e<this.children.length;e++){if(t.nodes[this.children[e]]&&t.nodes[this.children[e]].calcBounds){const r=t.nodes[this.children[e]].calcBounds(t,a,n);n.apply(r)}}if(n.changed)return n;else return null}setAnimAction(t){if(!t)return;this._currentAnimaction=t;if(t&&!this._animActions[t]){return null}for(let e in this._animActions[t]){if(e=="translation")this._animTrans=this._animActions[t][e];else if(e=="rotation")this._animRot=this._animActions[t][e];else if(e=="scale")this._animScale=this._animActions[t][e];else if(e=="weights")this.animWeights=this._animActions[t][e];else console.log("[gltfNode] unknown anim path",e,this._animActions[t][e])}}setAnim(e,t,n){if(!e||!t||!n)return;this._animActions[t]=this._animActions[t]||{};if(this._animActions[t][e])_.log("[gltfNode] animation action path already exists",t,e,this._animActions[t][e]);this._animActions[t][e]=n;if(e=="translation")this._animTrans=n;else if(e=="rotation")this._animRot=n;else if(e=="scale")this._animScale=n;else if(e=="weights"){this.animWeights=this._animActions[t][e]}else console.warn("unknown anim path",e,n)}modelMatLocal(){return this._animMat||this.mat}modelMatAbs(){return this.absMat}transform(e,n){if(!n&&n!=0)n=C;this._lastTimeTrans=n;be++;if(!this._animTrans&&!this._animRot&&!this._animScale){mat4.mul(e.mMatrix,e.mMatrix,this.mat);this._animMat=null}else{this._animMat=this._animMat||mat4.create();mat4.identity(this._animMat);const t=true;if(t&&this._animTrans){mat4.translate(this._animMat,this._animMat,[this._animTrans[0].getValue(n),this._animTrans[1].getValue(n),this._animTrans[2].getValue(n)])}else if(this._node.translation)mat4.translate(this._animMat,this._animMat,this._node.translation);if(t&&this._animRot){if(this._animRot[0].defaultEasing==CABLES.EASING_LINEAR)CABLES.Anim.slerpQuaternion(n,this._tempQuat,this._animRot[0],this._animRot[1],this._animRot[2],this._animRot[3]);else if(this._animRot[0].defaultEasing==CABLES.EASING_ABSOLUTE){this._tempQuat[0]=this._animRot[0].getValue(n);this._tempQuat[1]=this._animRot[1].getValue(n);this._tempQuat[2]=this._animRot[2].getValue(n);this._tempQuat[3]=this._animRot[3].getValue(n)}else if(this._animRot[0].defaultEasing==CABLES.EASING_CUBICSPLINE){CABLES.Anim.slerpQuaternion(n,this._tempQuat,this._animRot[0],this._animRot[1],this._animRot[2],this._animRot[3])}mat4.fromQuat(this._tempMat,this._tempQuat);mat4.mul(this._animMat,this._animMat,this._tempMat)}else if(this._rot){mat4.fromQuat(this._tempRotmat,this._rot);mat4.mul(this._animMat,this._animMat,this._tempRotmat)}if(t&&this._animScale){if(!this._tempAnimScale)this._tempAnimScale=[1,1,1];this._tempAnimScale[0]=this._animScale[0].getValue(n);this._tempAnimScale[1]=this._animScale[1].getValue(n);this._tempAnimScale[2]=this._animScale[2].getValue(n);mat4.scale(this._animMat,this._animMat,this._tempAnimScale)}else if(this._scale)mat4.scale(this._animMat,this._animMat,this._scale);mat4.mul(e.mMatrix,e.mMatrix,this._animMat)}if(this.animWeights){this.weights=this.weights||[];let t="";for(let e=0;e<this.animWeights.length;e++){this.weights[e]=this.animWeights[e].getValue(n);t+=this.weights[e]+"/"}}if(this.addTranslate)mat4.translate(e.mMatrix,e.mMatrix,this.addTranslate);if(this.addMulMat)mat4.mul(e.mMatrix,e.mMatrix,this.addMulMat);mat4.copy(this.absMat,e.mMatrix)}render(t,n,a,i,r,s,o){if(!n)t.pushModelMatrix();if(o===undefined)o=E.time;if(!n||this.skinRenderer)this.transform(t,o);if(this.hidden&&!s){}else{if(this.skinRenderer){this.skinRenderer.time=o;if(!a)this.mesh.render(t,i,this.skinRenderer,o,this.weights)}else{if(this.mesh&&!a)this.mesh.render(t,i,null,o,this.weights)}}if(!r&&!this.hidden)for(let e=0;e<this.children.length;e++)if(E.nodes[this.children[e]])E.nodes[this.children[e]].render(t,n,a,i,r,s,o);if(!n)t.popModelMatrix()}};let O=null;function A(){if(O)gui.mainTabs.closeTab(O.id);O=null}function o(t){const n=[];for(let e=0;e<t.length;e++){n.push(Math.round(t[e]*1e3)/1e3)}return n.join(",")}function q(n,a,i){if(!E)return;n+='<tr class="row">';let r="";let s="";for(let t=1;t<i;t++){s+="&nbsp;&nbsp;&nbsp;";let e="identBg";if(t==1)e="identBgLevel0";r+='<td class="ident '+e+'" ><div style=""></div></td>'}let e=CABLES.uuid();n+=r;n+='<td colspan="'+(21-i)+'">';if(a.mesh&&a.mesh.meshes.length)n+='<span class="icon icon-cube"></span>&nbsp;';else n+='<span class="icon icon-box-select"></span> &nbsp;';n+=a.name+"</td><td></td>";if(a.mesh){n+="<td>";for(let e=0;e<a.mesh.meshes.length;e++){if(e>0)n+=", ";n+=a.mesh.meshes[e].name}n+="</td>";n+="<td>";n+=a.hasSkin()||"-";n+="</td>";n+="<td>";let t=0;for(let e=0;e<a.mesh.meshes.length;e++){if(t>0)n+=", ";if(E.json.materials&&a.mesh.meshes[e].hasOwnProperty("material")){if(E.json.materials[a.mesh.meshes[e].material]){n+=E.json.materials[a.mesh.meshes[e].material].name;t++}}}if(t==0)n+="none";n+="</td>"}else{n+="<td>-</td><td>-</td><td>-</td>"}n+="<td>";if(a._node.translation||a._node.rotation||a._node.scale){let e="";if(a._node.translation)e+="Translate: `"+o(a._node.translation)+"` || ";if(a._node.rotation)e+="Rotation: `"+o(a._node.rotation)+"` || ";if(a._node.scale)e+="Scale: `"+o(a._node.scale)+"` || ";n+='<span class="icon icon-gizmo info" data-info="'+e+'"></span> &nbsp;'}if(a._animRot||a._animScale||a._animTrans){let e="Animated: ";if(a._animRot)e+="Rot ";if(a._animScale)e+="Scale ";if(a._animTrans)e+="Trans ";n+='<span class="icon icon-clock info" data-info="'+e+'"></span>&nbsp;'}if(!a._node.translation&&!a._node.rotation&&!a._node.scale&&!a._animRot&&!a._animScale&&!a._animTrans)n+="-";n+="</td>";n+="<td>";let t="";if(a.hidden)t="node-hidden";n+="<a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeNode('"+a.name+"','transform')\" class=\"treebutton\">Transform</a>";n+=" <a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeNode('"+a.name+"','hierarchy')\" class=\"treebutton\">Hierarchy</a>";n+=" <a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeNode('"+a.name+'\')" class="treebutton">Node</a>';if(a.hasSkin())n+=" <a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeNode('"+a.name+'\',false,{skin:true});" class="treebutton">Skin</a>';n+="</td><td>";n+='&nbsp;<span class="icon iconhover icon-eye '+t+'" onclick="gui.corePatch().getOpById(\''+_.id+"').toggleNodeVisibility('"+a.name+"');this.classList.toggle('node-hidden');\"></span>";n+="</td>";n+="</tr>";if(a.children){for(let e=0;e<a.children.length;e++)n=q(n,E.nodes[a.children[e]],i+1)}return n}function H(t,e){let n="<tr>";n+=" <td>"+e+"</td>";n+=" <td>"+t.name+"</td>";n+=" <td>";const a=JSON.stringify(t,null,4).replaceAll('"',"").replaceAll("\n","<br/>");n+="<span class=\"icon icon-info\" onclick=\"new CABLES.UI.ModalDialog({ 'html': '<pre>"+a+"</pre>', 'title': '"+t.name+"' });\"></span>&nbsp;";if(t.pbrMetallicRoughness&&t.pbrMetallicRoughness.baseColorFactor){let e="";e+=""+Math.round(t.pbrMetallicRoughness.baseColorFactor[0]*255);e+=","+Math.round(t.pbrMetallicRoughness.baseColorFactor[1]*255);e+=","+Math.round(t.pbrMetallicRoughness.baseColorFactor[2]*255);n+='<div style="width:15px;height:15px;background-color:rgb('+e+');display:inline-block">&nbsp;</a>'}n+=' <td style="">'+(E.shaders[e]?"-":"<a onclick=\"gui.corePatch().getOpById('"+_.id+"').assignMaterial('"+t.name+'\')" class="treebutton">Assign</a>')+"<td>";n+="<td>";n+="</tr>";return n}function e(){if(!E)return;const e=performance.now();const r={};let s='<div style="overflow:scroll;width:100%;height:100%">';s+='File: <a href="'+CABLES.platform.getCablesUrl()+"/asset/patches/?filename="+S.get()+'" target="_blank">'+CABLES.basename(S.get())+"</a><br/>";s+="Generator:"+E.json.asset.generator;let t=0;if(E.json.nodes)t=E.json.nodes.length;s+='<div id="groupNodes">Nodes ('+t+")</div>";s+='<table id="sectionNodes" class="table treetable">';s+="<tr>";s+=' <th colspan="21">Name</th>';s+=" <th>Mesh</th>";s+=" <th>Skin</th>";s+=" <th>Material</th>";s+=" <th>Transform</th>";s+=" <th>Expose</th>";s+=" <th></th>";s+="</tr>";for(let e=0;e<E.nodes.length;e++){if(!E.nodes[e].isChild)s=q(s,E.nodes[e],1)}s+="</table>";let n=0;if(E.json.materials)n=E.json.materials.length;s+='<div id="groupMaterials">Materials ('+n+")</div>";if(!E.json.materials||E.json.materials.length==0){}else{s+='<table id="materialtable"  class="table treetable">';s+="<tr>";s+=" <th>Index</th>";s+=" <th>Name</th>";s+=" <th>Color</th>";s+=" <th>Function</th>";s+=" <th></th>";s+="</tr>";for(let e=0;e<E.json.materials.length;e++){s+=H(E.json.materials[e],e)}s+="</table>"}s+='<div id="groupMeshes">Meshes ('+E.json.meshes.length+")</div>";s+='<table id="meshestable"  class="table treetable">';s+="<tr>";s+=" <th>Name</th>";s+=" <th>Node</th>";s+=" <th>Material</th>";s+=" <th>Vertices</th>";s+=" <th>Attributes</th>";s+="</tr>";let o=[];r.meshes=0;r.meshTargets=0;for(let i=0;i<E.json.meshes.length;i++){s+="<tr>";s+="<td>"+E.json.meshes[i].name+"</td>";s+="<td>";let t=0;let n="";for(let e=0;e<E.json.nodes.length;e++){if(E.json.nodes[e].mesh==i){t++;if(t==1){n=E.json.nodes[e].name}}}if(t>1)s+=t+" nodes ("+n+" ...)";else s+=n;s+="</td>";s+="<td>";for(let e=0;e<E.json.meshes[i].primitives.length;e++){if(E.json.meshes[i].primitives[e].hasOwnProperty("material")){if(E.json.materials[E.json.meshes[i]]){s+=E.json.materials[E.json.meshes[i].primitives[e].material].name+" "}}else s+="None"}s+="</td>";s+="<td>";let a=0;for(let t=0;t<E.json.meshes[i].primitives.length;t++){if(E.json.meshes[i].primitives[t].attributes.POSITION!=undefined){let e=parseInt(E.json.accessors[E.json.meshes[i].primitives[t].attributes.POSITION].count);a+=e;s+=""+e+"<br/>"}else s+="-<br/>"}if(E.json.meshes[i].primitives.length>1)s+="="+a;s+="</td>";s+="<td>";for(let e=0;e<E.json.meshes[i].primitives.length;e++){s+=Object.keys(E.json.meshes[i].primitives[e].attributes);s+=" <a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeGeom('"+E.json.meshes[i].name+"',"+e+')" class="treebutton">Geometry</a>';s+="<br/>";if(E.json.meshes[i].primitives[e].targets){s+=E.json.meshes[i].primitives[e].targets.length+" targets<br/>";if(E.json.meshes[i].extras&&E.json.meshes[i].extras.targetNames)s+="Targetnames:<br/>"+E.json.meshes[i].extras.targetNames.join("<br/>");s+="<br/>"}}s+="</td>";s+="</tr>";for(let n=0;n<E.json.meshes[i].primitives.length;n++){const h=E.json.accessors[E.json.meshes[i].primitives[n].indices];if(h){let e=h.bufferView;if(o.indexOf(e)==-1){o.push(e);if(E.json.bufferViews[e])r.meshes+=E.json.bufferViews[e].byteLength}}for(let e in E.json.meshes[i].primitives[n].attributes){const f=E.json.meshes[i].primitives[n].attributes[e];const v=E.json.accessors[f].bufferView;if(o.indexOf(v)==-1){o.push(v);if(E.json.bufferViews[v])r.meshes+=E.json.bufferViews[v].byteLength}}if(E.json.meshes[i].primitives[n].targets)for(let t=0;t<E.json.meshes[i].primitives[n].targets.length;t++){for(let e in E.json.meshes[i].primitives[n].targets[t]){const g=E.json.meshes[i].primitives[n].targets[t][e];const h=E.json.accessors[g];const v=h.bufferView;console.log("accessor",h);if(o.indexOf(v)==-1)if(E.json.bufferViews[v]){o.push(v);r.meshTargets+=E.json.bufferViews[v].byteLength}}}}}s+="</table>";let a=0;let i=0;let l=0;if(E.json.animations){i=E.json.animations.length;for(let e=0;e<E.json.animations.length;e++){a+=E.json.animations[e].samplers.length}}s+='<div id="groupAnims">Animations ('+i+"/"+a+")</div>";if(E.json.animations){s+='<table id="sectionAnim" class="table treetable">';s+="<tr>";s+="  <th>Name</th>";s+="  <th>Target node</th>";s+="  <th>Path</th>";s+="  <th>Interpolation</th>";s+="  <th>Keys</th>";s+="</tr>";r.animations=0;for(let n=0;n<E.json.animations.length;n++){for(let t=0;t<E.json.animations[n].samplers.length;t++){let e=E.json.accessors[E.json.animations[n].samplers[t].input].bufferView;if(o.indexOf(e)==-1){o.push(e);r.animations+=E.json.bufferViews[e].byteLength}e=E.json.accessors[E.json.animations[n].samplers[t].output].bufferView;if(o.indexOf(e)==-1){o.push(e);r.animations+=E.json.bufferViews[e].byteLength}}for(let e=0;e<E.json.animations[n].channels.length;e++){s+="<tr>";s+="  <td> Anim "+n+": "+E.json.animations[n].name+"</td>";s+="  <td>"+E.nodes[E.json.animations[n].channels[e].target.node].name+"</td>";s+="  <td>";s+=E.json.animations[n].channels[e].target.path+" ";s+="  </td>";const b=E.json.animations[n].channels[e].sampler;const x=E.json.animations[n].samplers[b];s+="  <td>"+x.interpolation+"</td>";s+="  <td>"+E.json.accessors[x.output].count;l+=E.json.accessors[x.output].count;s+="</td>";s+="</tr>"}}s+="<tr>";s+="  <td></td>";s+="  <td></td>";s+="  <td></td>";s+="  <td></td>";s+="  <td>"+l+" total</td>";s+="</tr>";s+="</table>"}else{}let u=0;if(E.json.images)u=E.json.images.length;s+='<div id="groupImages">Images ('+u+")</div>";if(E.json.images){s+='<table id="sectionImages" class="table treetable">';s+="<tr>";s+="  <th>name</th>";s+="  <th>type</th>";s+="  <th>func</th>";s+="</tr>";r.images=0;for(let t=0;t<E.json.images.length;t++){if(E.json.images[t].hasOwnProperty("bufferView")){r.images+=E.json.bufferViews[E.json.images[t].bufferView].byteLength}else console.log("image has no bufferview?!");s+="<tr>";s+="<td>"+E.json.images[t].name+"</td>";s+="<td>"+E.json.images[t].mimeType+"</td>";s+="<td>";let e=E.json.images[t].name;if(e===undefined)e=E.json.images[t].bufferView;s+="<a onclick=\"gui.corePatch().getOpById('"+_.id+"').exposeTexture('"+e+'\')" class="treebutton">Expose</a>';s+="</td>";s+="<tr>"}s+="</table>"}let m=0;if(E.json.cameras)m=E.json.cameras.length;s+='<div id="groupCameras">Cameras ('+m+")</div>";if(E.json.cameras){s+='<table id="sectionCameras" class="table treetable">';s+="<tr>";s+="  <th>name</th>";s+="  <th>type</th>";s+="  <th>info</th>";s+="</tr>";for(let e=0;e<E.json.cameras.length;e++){s+="<tr>";s+="<td>"+E.json.cameras[e].name+"</td>";s+="<td>"+E.json.cameras[e].type+"</td>";s+="<td>";if(E.json.cameras[e].perspective){s+="yfov: "+Math.round(E.json.cameras[e].perspective.yfov*100)/100;s+=", ";s+="zfar: "+Math.round(E.json.cameras[e].perspective.zfar*100)/100;s+=", ";s+="znear: "+Math.round(E.json.cameras[e].perspective.znear*100)/100}s+="</td>";s+="<tr>"}s+="</table>"}let p=0;if(E.json.skins)p=E.json.skins.length;s+='<div id="groupSkins">Skins ('+p+")</div>";if(E.json.skins){s+='<table id="sectionSkins" class="table treetable">';s+="<tr>";s+="  <th>name</th>";s+="  <th></th>";s+="  <th>total joints</th>";s+="</tr>";for(let e=0;e<E.json.skins.length;e++){s+="<tr>";s+="<td>"+E.json.skins[e].name+"</td>";s+="<td>"+"</td>";s+="<td>"+E.json.skins[e].joints.length+"</td>";s+="<td>";s+="</td>";s+="<tr>"}s+="</table>"}if(E.timing){s+='<div id="groupTiming">Debug Loading Timing </div>';s+='<table id="sectionTiming" class="table treetable">';s+="<tr>";s+="  <th>task</th>";s+="  <th>time used</th>";s+="</tr>";let e=0;for(let e=0;e<E.timing.length-1;e++){s+="<tr>";s+="  <td>"+E.timing[e][0]+"</td>";s+="  <td>"+(E.timing[e+1][1]-E.timing[e][1])+" ms</td>";s+="</tr>"}s+="</table>"}let c=0;if(E.json.buffers)c=E.json.buffers[0].byteLength;s+='<div id="groupBinary">File Size Allocation ('+Math.round(c/1024)+"k )</div>";s+='<table id="sectionBinary" class="table treetable">';s+="<tr>";s+="  <th>name</th>";s+="  <th>size</th>";s+="  <th>%</th>";s+="</tr>";let d=c;for(let e in r){s+="<tr>";s+="<td>"+e+"</td>";s+="<td>"+Y(r[e])+" </td>";s+="<td>"+Math.round(r[e]/c*100)+"% </td>";s+="<tr>";d-=r[e]}if(d!=0){s+="<tr>";s+="<td>unknown</td>";s+="<td>"+Y(d)+" </td>";s+="<td>"+Math.round(d/c*100)+"% </td>";s+="<tr>"}s+="</table>";s+="</div>";O=new CABLES.UI.Tab("GLTF "+CABLES.basename(S.get()),{icon:"cube",infotext:"tab_gltf",padding:true,singleton:true});gui.mainTabs.addTab(O,true);O.addEventListener("close",A);O.html(s);CABLES.UI.Collapsable.setup(ele.byId("groupNodes"),ele.byId("sectionNodes"),false);CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"),ele.byId("materialtable"),true);CABLES.UI.Collapsable.setup(ele.byId("groupAnims"),ele.byId("sectionAnim"),true);CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"),ele.byId("meshestable"),true);CABLES.UI.Collapsable.setup(ele.byId("groupCameras"),ele.byId("sectionCameras"),true);CABLES.UI.Collapsable.setup(ele.byId("groupImages"),ele.byId("sectionImages"),true);CABLES.UI.Collapsable.setup(ele.byId("groupSkins"),ele.byId("sectionSkins"),true);CABLES.UI.Collapsable.setup(ele.byId("groupBinary"),ele.byId("sectionBinary"),true);CABLES.UI.Collapsable.setup(ele.byId("groupTiming"),ele.byId("sectionTiming"),true);gui.maintabPanel.show(true)}function Y(e){if(e>1024)return Math.round(e/1024)+" kb";if(e>1024*500)return Math.round(e/1024)+" mb";else return e+" bytes"}const W=class{constructor(e){this._mod=null;this._node=e;this._lastTime=0;this._matArr=[];this._m=mat4.create();this._invBindMatrix=mat4.create();this.identity=true}renderFinish(e){e.popModelMatrix();this._mod.unbind()}renderStart(e,t){if(!this._mod){this._mod=new CGL.ShaderModifier(e,_.name+this._node.name);this._mod.addModule({priority:-2,name:"MODULE_VERTEX_POSITION",srcHeadVert:l.skin_head_vert||"",srcBodyVert:l.skin_vert||""});this._mod.addUniformVert("m4[]","MOD_boneMats",[]);const i=vec3.create()}const n=this._node.skin;const a=E.json.skins[n].joints.length*16;{if(this._matArr.length!=a)this._matArr.length=a;for(let e=0;e<E.json.skins[n].joints.length;e++){const r=e*16;const s=E.json.skins[n].joints[e];const o=E.nodes[s];for(let e=0;e<16;e++)this._invBindMatrix[e]=E.accBuffers[E.json.skins[n].inverseBindMatrices][r+e];mat4.mul(this._m,o.modelMatAbs(),this._invBindMatrix);for(let e=0;e<this._m.length;e++)this._matArr[r+e]=this._m[e]}this._mod.setUniformValue("MOD_boneMats",this._matArr);this._lastTime=t}this._mod.define("SKIN_NUM_BONES",E.json.skins[n].joints.length);this._mod.bind();e.pushModelMatrix();if(this.identity)mat4.identity(e.mMatrix)}};const Z=class{constructor(e){this.mesh=e;this.tex=null;this.numRowsPerTarget=0;this.makeTex(e.geom)}renderFinish(e){e.popModelMatrix();this._mod.unbind()}renderStart(e,t){if(!this._mod){this._mod=new CGL.ShaderModifier(e,"gltftarget");this._mod.addModule({priority:-2,name:"MODULE_VERTEX_POSITION",srcHeadVert:l.targets_head_vert||"",srcBodyVert:l.targets_vert||""});this._mod.addUniformVert("4f","MOD_targetTexInfo",[0,0,0,0]);this._mod.addUniformVert("t","MOD_targetTex",1);this._mod.addUniformVert("f[]","MOD_weights",[]);const n=vec3.create()}this._mod.pushTexture("MOD_targetTex",this.tex);if(this.tex&&this.mesh.weights){this._mod.setUniformValue("MOD_weights",this.mesh.weights);this._mod.setUniformValue("MOD_targetTexInfo",[this.tex.width,this.tex.height,this.numRowsPerTarget,this.mesh.weights.length]);this._mod.define("MOD_NUM_WEIGHTS",Math.max(1,this.mesh.weights.length))}else{this._mod.define("MOD_NUM_WEIGHTS",1)}this._mod.bind();e.pushModelMatrix();if(this.identity)mat4.identity(e.mMatrix)}makeTex(n){if(!n.morphTargets||!n.morphTargets.length)return;let a=n.morphTargets[0].vertices.length/3;let e=0;this.numRowsPerTarget=0;if(n.morphTargets[0].vertices&&n.morphTargets[0].vertices.length)this.numRowsPerTarget++;if(n.morphTargets[0].vertexNormals&&n.morphTargets[0].vertexNormals.length)this.numRowsPerTarget++;if(n.morphTargets[0].tangents&&n.morphTargets[0].tangents.length)this.numRowsPerTarget++;if(n.morphTargets[0].bitangents&&n.morphTargets[0].bitangents.length)this.numRowsPerTarget++;e=n.morphTargets.length*this.numRowsPerTarget;const i=new Float32Array(a*e*4);let r=0;for(let t=0;t<n.morphTargets.length;t++){if(n.morphTargets[t].vertices&&n.morphTargets[t].vertices.length){for(let e=0;e<n.morphTargets[t].vertices.length;e+=3){i[(r*a+e/3)*4+0]=n.morphTargets[t].vertices[e+0];i[(r*a+e/3)*4+1]=n.morphTargets[t].vertices[e+1];i[(r*a+e/3)*4+2]=n.morphTargets[t].vertices[e+2];i[(r*a+e/3)*4+3]=1}r++}if(n.morphTargets[t].vertexNormals&&n.morphTargets[t].vertexNormals.length){for(let e=0;e<n.morphTargets[t].vertexNormals.length;e+=3){i[(r*a+e/3)*4+0]=n.morphTargets[t].vertexNormals[e+0];i[(r*a+e/3)*4+1]=n.morphTargets[t].vertexNormals[e+1];i[(r*a+e/3)*4+2]=n.morphTargets[t].vertexNormals[e+2];i[(r*a+e/3)*4+3]=1}r++}if(n.morphTargets[t].tangents&&n.morphTargets[t].tangents.length){for(let e=0;e<n.morphTargets[t].tangents.length;e+=3){i[(r*a+e/3)*4+0]=n.morphTargets[t].tangents[e+0];i[(r*a+e/3)*4+1]=n.morphTargets[t].tangents[e+1];i[(r*a+e/3)*4+2]=n.morphTargets[t].tangents[e+2];i[(r*a+e/3)*4+3]=1}r++}if(n.morphTargets[t].bitangents&&n.morphTargets[t].bitangents.length){for(let e=0;e<n.morphTargets[t].bitangents.length;e+=3){i[(r*a+e/3)*4+0]=n.morphTargets[t].bitangents[e+0];i[(r*a+e/3)*4+1]=n.morphTargets[t].bitangents[e+1];i[(r*a+e/3)*4+2]=n.morphTargets[t].bitangents[e+2];i[(r*a+e/3)*4+3]=1}r++}}this.tex=new CGL.Texture(h,{isFloatingPointTexture:true,name:"targetsTexture"});this.tex.initFromData(i,a,e,CGL.Texture.FILTER_LINEAR,CGL.Texture.WRAP_REPEAT)}};const K=_.inTrigger("Render"),t=_.inString("data"),S=_.inUrl("glb File",[".glb"]),J=_.inBool("Draw",true),n=_.inDropDown("Camera",["None"],"None"),Q=_.inString("Animation",""),$=_.inTriggerButton("Show Structure"),a=_.inSwitch("Center",["None","XYZ","XZ"],"XYZ"),i=_.inBool("Rescale",true),r=_.inFloat("Rescale Size",2.5),s=_.inFloat("Time"),u=_.inBool("Sync to timeline",false),ee=_.inBool("Loop",true),te=_.inSwitch("Normals Format",["XYZ","X-ZY"],"XYZ"),ne=_.inSwitch("Vertices Format",["XYZ","XZ-Y"],"XYZ"),m=_.inSwitch("Calc Normals",["Auto","Force Smooth","Never"],"Auto"),p=_.inObject("Materials"),ae=_.inArray("Hide Nodes"),ie=_.inBool("Use Material Properties",false),c=_.inBool("Active",true),re=_.outTrigger("Render Before"),d=_.outTrigger("Next"),se=_.outString("Generator"),oe=_.outNumber("GLTF Version"),le=_.outArray("GLTF Extensions Used"),ue=_.outNumber("Anim Length",0),me=_.outNumber("Anim Time",0),pe=_.outObject("Json"),ce=_.outArray("Anims"),de=_.outArray("BoundingPoints"),he=_.outObject("Bounds"),fe=_.outTrigger("Finished"),ve=_.outBool("Loading");_.setPortGroup("Timing",[s,u,ee]);let h=_.patch.cg||_.patch.cgl;let f=null;let ge=false;let be=0;let v=false;let g=null;let b=[];let E=null;let x=0;let C=0;let j=true;let xe=null;let N=null;let L=null;const Oe=vec3.create();let _e=0;let Te=false;const M=vec3.create();S.onChange=ne.onChange=m.onChange=te.onChange=P;$.onTriggered=e;t.onChange=Ne;ae.onChange=je;Q.onChange=Me;a.onChange=ye;_.toWorkPortsNeedToBeLinked(K);t.setUiAttribs({hideParam:true,hidePort:true});_.setPortGroup("Transform",[i,r,a]);function Ie(){const t=["None"];if(E){for(let e=0;e<E.nodes.length;e++){if(E.nodes[e].camera>=0){t.push(E.nodes[e].name)}}}n.uiAttribs.values=t}function ye(){Te=a.get()!="None";if(E&&E.bounds){M.set(E.bounds.center);M[0]=-M[0];M[1]=-M[1];M[2]=-M[2];if(a.get()=="XZ")M[1]=-E.bounds.minY}}i.onChange=function(){r.setUiAttribs({greyout:!i.get()})};p.onChange=function(){j=true};_.onDelete=function(){A()};u.onChange=function(){s.setUiAttribs({greyout:u.get()})};n.onChange=Ae;function Ae(){g=null;if(!E)return;for(let e=0;e<E.nodes.length;e++){if(E.nodes[e].name==n.get())g=new k(E,E.nodes[e])}}K.onTriggered=function(){h=_.patch.cg||_.patch.cgl;if(!v)return;if(!c.get())return;if(ge){if(!f)f=CGL.MESHES.getSimpleCube(h,"ErrorCube");f.render(h.getShader())}be=0;if(u.get())C=_.patch.timer.getTime();else C=Math.max(0,s.get());if(ee.get()){C%=x;if(C<_e)fe.trigger()}else{if(x>0&&C>=x)fe.trigger()}_e=C;h.pushModelMatrix();me.set(C||0);if(v&&E&&E.bounds){if(i.get()){let e=r.get()/E.bounds.maxAxis;E.scale=e;vec3.set(Oe,e,e,e);mat4.scale(h.mMatrix,h.mMatrix,Oe)}if(Te){mat4.translate(h.mMatrix,h.mMatrix,M)}}let e=h.tempData.currentScene||null;h.tempData.currentScene=E;re.trigger();if(v){if(j)Ee();if(g)g.start(C);if(E){E.time=C;if(E.bounds&&h.shouldDrawHelpers(_)){if(_.isCurrentUiOp())h.pushShader(CABLES.GL_MARKER.getSelectedShader(h));else h.pushShader(CABLES.GL_MARKER.getDefaultShader(h));E.bounds.render(h,null,_);h.popShader()}if(J.get()){for(let e=0;e<E.nodes.length;e++)if(!E.nodes[e].isChild)E.nodes[e].render(h)}else{for(let e=0;e<E.nodes.length;e++)if(!E.nodes[e].isChild)E.nodes[e].render(h,false,true)}}}d.trigger();h.tempData.currentScene=e;h.popModelMatrix();if(g)g.end()};function R(){if(!E){v=true;ge=true;h.patch.loading.finished(N);_.setUiError("nogltf","GLTF File not found");return}_.setUiError("nogltf",null);if(E.loadingMeshes>0){setTimeout(R,100);return}E.timing.push(["finishLoading()",Math.round(performance.now()-E.startTime)]);j=true;ue.set(x);E.bounds=new CABLES.CG.BoundingBox;E.timing.push(["start calc bounds",Math.round(performance.now()-E.startTime)]);for(let e=0;e<E.nodes.length;e++){const t=E.nodes[e];t.updateMatrix();if(!t.isChild)t.calcBounds(E,null,E.bounds)}if(E.bounds)he.set(E.bounds);E.timing.push(["calced bounds",Math.round(performance.now()-E.startTime)]);je();E.timing.push(["hideNodesFromData",Math.round(performance.now()-E.startTime)]);if(O)e();E.timing.push(["printinfo",Math.round(performance.now()-E.startTime)]);Ie();Ae();de.set(b);if(E){if(S.get()&&!S.get().startsWith("data:")){_.setUiAttrib({extendTitle:CABLES.basename(S.get())})}E.loaded=Date.now()}if(E){for(let e=0;e<E.nodes.length;e++){if(!E.nodes[e].isChild){E.nodes[e].render(h,false,true,true,false,true,0)}}for(let e=0;e<E.nodes.length;e++){const t=E.nodes[e];t.children=Pe(t.children)}}ye();Me();ve.set(false);h.patch.loading.finished(N);N=null;if(E.accBuffersDelete){for(let e=0;e<E.accBuffersDelete.length;e++){E.accBuffers[E.accBuffersDelete[e]]=null}}if(!(E.json.images&&E.json.images.length))E.chunks=null;v=true}function Se(e){if(!c.get())return;if(!N)N=h.patch.loading.start("gltfScene",S.get(),_);let t=S.get();if(!t||t=="null")return;let n=_.patch.getFilePath(String(S.get()));if(!n)return;if(S.get()&&!S.get().startsWith("data:")){if(e===true)n+="?rnd="+CABLES.generateUUID()}j=true;ve.set(true);fetch(n).then(e=>{return e.arrayBuffer()}).then(e=>{if(S.get()!=t){h.patch.loading.finished(N);N=null;return}b=[];x=0;E=D(e);e=null;R()}).catch(e=>{if(N)h.patch.loading.finished(N);N=null;R();_.logError("gltf fetch error",e)});A();const a=new XMLHttpRequest;a.open("GET",n,true);a.responseType="arraybuffer";h.patch.loading.addAssetLoadingTask(()=>{})}_.onFileChanged=function(e){if(S.get()&&S.get().indexOf(e)>-1){P(true)}};c.onChange=()=>{if(c.get())P();if(!c.get()){E=null}};function P(e){clearTimeout(xe);xe=setTimeout(function(){Se(e)},30)}function Ee(){if(!E)return;E.shaders={};if(p.links.length==1&&p.get()){j=true;const n=p.links[0].portOut.op;const a=n.getPort("Shader");const i=n.getPort("Material Name");if(!a&&!i){const r=p.get();for(let t in r){if(r[t]&&E.json.materials)for(let e=0;e<E.json.materials.length;e++){if(E.json.materials[e].name==t){if(E.shaders[e]){n.warn("double material assignment:",name)}E.shaders[e]=r[t]}}}}}if(p.get()){for(let e=0;e<p.links.length;e++){const t=p.links[e].portOut.op;const a=t.getPort("Shader");const i=t.getPort("Material Name");if(a&&i&&a.get()){const name=i.get();if(E.json.materials)for(let e=0;e<E.json.materials.length;e++)if(E.json.materials[e].name==name){if(E.shaders[e]){t.warn("double material assignment:",name)}E.shaders[e]=a.get()}}}}j=false;if(O)e()}function Ce(){const t=ae.get();if(!E||!L||!L.hiddenNodes)return;if(!t){return}for(let e=0;e<t.length;e++){const n=E.getNode(t[e]);if(n)n.hidden=true}}function je(){if(!L)Ne();if(!E)return;E.unHideAll();if(L&&L.hiddenNodes){for(const e in L.hiddenNodes){const t=E.getNode(e);if(t)t.hidden=true;else _.verbose("node to be hidden not found",e,t)}}Ce()}function Ne(){L=t.get();if(!L||L==="")L={};else L=JSON.parse(L);if(E)je();return L}function Le(){t.set(JSON.stringify(L))}function Me(){if(E&&E.nodes){for(let e=0;e<E.nodes.length;e++){E.nodes[e].setAnimAction(Q.get())}}}function Re(t,n){for(let e=0;e<E.nodes.length;e++){if(E.nodes[e].children.indexOf(n)>=0){t.push(E.nodes[e]);if(E.nodes[e].isChild)Re(t,e)}}}_.exposeTexture=function(e){const t=gui.corePatch().addOp("Ops.Gl.GLTF.GltfTexture");t.getPort("Name").set(e);w(t,1);_.patch.link(_,d.name,t,"Render");gui.patchView.testCollision(t);gui.patchView.centerSelectOp(t.id,true)};_.exposeGeom=function(e,t){const n=gui.corePatch().addOp("Ops.Gl.GLTF.GltfGeometry");n.getPort("Name").set(e);n.getPort("Submesh").set(t);w(n,1);_.patch.link(_,d.name,n,"Update");gui.patchView.testCollision(n);gui.patchView.centerSelectOp(n.id,true)};function w(e,t){t=t||1;e.setUiAttrib({subPatch:_.uiAttribs.subPatch,translate:{x:_.uiAttribs.translate.x,y:_.uiAttribs.translate.y+t*CABLES.GLUI.glUiConfig.newOpDistanceY}})}_.exposeNode=function(n,e,a){let t=e=="hierarchy";if(t){let i=[];for(let e=0;e<E.nodes.length;e++){if(E.nodes[e].name==n){let t=[];const r=E.nodes[e];Re(t,e);t=t.reverse();t.push(r,r);let n=d.name;let a=_;for(let e=0;e<t.length;e++){const s=gui.corePatch().addOp("Ops.Gl.GLTF.GltfNode_v2");s.getPort("Node Name").set(t[e].name);_.patch.link(a,n,s,"Render");w(s,e);if(e==t.length-1){s.getPort("Transformation").set(false)}else{s.getPort("Draw Mesh").set(false);s.getPort("Draw Childs").set(false)}n="Next";a=s;i.push(s);gui.patchView.testCollision(s)}}}for(let e=0;e<i.length;e++){i[e].selectChilds()}}else{let t="Ops.Gl.GLTF.GltfNode_v2";if(a&&a.skin)t="Ops.Gl.GLTF.GltfSkin";if(e=="transform")t="Ops.Gl.GLTF.GltfNodeTransform_v2";gui.serverOps.loadOpLibs(t,()=>{let e=gui.corePatch().addOp(t);e.getPort("Node Name").set(n);w(e);_.patch.link(_,d.name,e,"Render");gui.patchView.testCollision(e);gui.patchView.centerSelectOp(e.id,true)})}gui.closeModal()};_.assignMaterial=function(e){const t=gui.corePatch().addOp("Ops.Gl.GLTF.GltfSetMaterial");t.getPort("Material Name").set(e);_.patch.link(_,p.name,t,"Material");w(t);gui.patchView.testCollision(t);gui.patchView.centerSelectOp(t.id,true);gui.closeModal()};_.toggleNodeVisibility=function(e){const t=E.getNode(e);t.hidden=!t.hidden;L.hiddenNodes=L.hiddenNodes||{};if(t)if(t.hidden)L.hiddenNodes[e]=true;else delete L.hiddenNodes[e];Le()};function Pe(n){const a={},i=[];for(let e=0,t=n.length;e<t;++e){if(!a.hasOwnProperty(n[e])){i.push(n[e]);a[n[e]]=1}}return i}};Ops.Gl.GLTF.GltfScene_v4.prototype=new CABLES.Op;CABLES.OPS["c9cbb226-46f7-4ca6-8dab-a9d0bdca4331"]={f:Ops.Gl.GLTF.GltfScene_v4,objName:"Ops.Gl.GLTF.GltfScene_v4"};Ops.Gl.GLTF.GltfSetMaterial=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inObject("Shader",null,"shader"),a=e.inString("Material Name","none"),i=e.outObject("Material");a.onChange=n.onChange=function(){e.setUiAttrib({extendTitle:a.get()});i.setRef(n.get()||e.patch.cgl.getDefaultShader())}};Ops.Gl.GLTF.GltfSetMaterial.prototype=new CABLES.Op;CABLES.OPS["baf968ea-e4df-4fca-9cda-e6ddd38a4200"]={f:Ops.Gl.GLTF.GltfSetMaterial,objName:"Ops.Gl.GLTF.GltfSetMaterial"};Ops.Gl.GLTF.GltfTexture=function(){CABLES.Op.apply(this,arguments);const o=this;const e=o.attachments={};const t=o.inTrigger("Render"),l=o.inString("Name",""),u=o.inSwitch("Filter",["nearest","linear","mipmap"],"mipmap"),n=o.inValueSelect("Wrap",["repeat","mirrored repeat","clamp to edge"],"clamp to edge"),m=o.inSwitch("Anisotropic",[0,1,2,4,8,16],0),p=o.inValueBool("Flip",false),c=o.inValueBool("Pre Multiplied Alpha",false),d=o.outTexture("Texture"),h=o.outNumber("Width"),f=o.outNumber("Height"),v=o.outString("Type"),g=o.outBool("Found");const b=o.patch.cgl;let x=null;let O=0;let _=0;let T=0;let I=null;m.onChange=u.onChange=i;n.onChange=r;l.onChange=p.onChange=c.onChange=function(){a()};function a(){x=null}t.onTriggered=function(){if(b.tempData.currentScene!=I)x=null;if(x)return;if(!b.tempData.currentScene||!b.tempData.currentScene.json||!b.tempData.currentScene.chunks)return;if(b.tempData.currentScene.chunks.length<2){return}if(!b.tempData.currentScene.json.images)return;let t=null;I=b.tempData.currentScene;for(let e=0;e<b.tempData.currentScene.json.images.length;e++){if(b.tempData.currentScene.json.images[e].name==l.get()||b.tempData.currentScene.json.images[e].bufferView==parseFloat(l.get())){t=b.tempData.currentScene.json.images[e]}}if(!t){x=CGL.Texture.getEmptyTexture(b);g.set(false);d.set(x);h.set(x.width);f.set(x.height);return}const n=b.tempData.currentScene.json.bufferViews[t.bufferView];let a=b.tempData.currentScene.chunks[1].dataView;if(!n)return;const i=new Uint8Array(n.byteLength);for(let e=0;e<n.byteLength;e++)i[e]=a.getUint8(n.byteOffset+e);const e=new Blob([i.buffer],{type:t.mimeType});const r=URL.createObjectURL(e);if(u.get()=="nearest")O=CGL.Texture.FILTER_NEAREST;else if(u.get()=="linear")O=CGL.Texture.FILTER_LINEAR;else if(u.get()=="mipmap")O=CGL.Texture.FILTER_MIPMAP;T=parseFloat(m.get());const s=b.patch.loading.start("gltfTextureOp",CABLES.uuid(),o);x=CGL.Texture.load(b,r,function(e){b.patch.loading.finished(s);if(!x)return;if(e){console.error("img load error",e)}else{h.set(x.width);f.set(x.height);v.set(t.mimeType);d.setRef(x);g.set(true)}},{anisotropic:T,wrap:_,flip:p.get(),unpackAlpha:c.get(),filter:O});d.setRef(x)};function i(){a()}function r(){if(n.get()=="repeat")_=CGL.Texture.WRAP_REPEAT;if(n.get()=="mirrored repeat")_=CGL.Texture.WRAP_MIRRORED_REPEAT;if(n.get()=="clamp to edge")_=CGL.Texture.WRAP_CLAMP_TO_EDGE;a()}};Ops.Gl.GLTF.GltfTexture.prototype=new CABLES.Op;CABLES.OPS["6479a948-7a48-42a3-b40a-794f4364715f"]={f:Ops.Gl.GLTF.GltfTexture,objName:"Ops.Gl.GLTF.GltfTexture"};Ops.Gl.Shader.BasicMaterial_v3=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={basicmaterial_frag:"{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IR\n                col.a*=1.0-texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n",basicmaterial_vert:"\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 modelViewMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       modelViewMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * modelViewMatrix * vec4((\n           position.x * vec3(\n               modelViewMatrix[0][0],\n               modelViewMatrix[1][0],\n               modelViewMatrix[2][0] ) +\n           position.y * vec3(\n               modelViewMatrix[0][1],\n               modelViewMatrix[1][1],\n               modelViewMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        modelViewMatrix=viewMatrix * mMatrix;\n\n        {{MODULE_VERTEX_MODELVIEW}}\n\n    #endif\n\n    // mat4 modelViewMatrix=viewMatrix*mMatrix;\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * modelViewMatrix * pos;\n    #endif\n}\n"};const n=e.inTrigger("render");const a=e.outTrigger("trigger");const i=e.outObject("shader",null,"shader");i.ignoreValueSerialize=true;e.toWorkPortsNeedToBeLinked(n);e.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose",CABLES.OP_PORT_TYPE_FUNCTION);const r=e.patch.cgl;const s=new CGL.Shader(r,"basicmaterialnew",this);s.addAttribute({type:"vec3",name:"vPosition"});s.addAttribute({type:"vec2",name:"attrTexCoord"});s.addAttribute({type:"vec3",name:"attrVertNormal",nameFrag:"norm"});s.addAttribute({type:"float",name:"attrVertIndex"});s.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG","MODULE_VERTEX_MODELVIEW"]);s.setSource(t.basicmaterial_vert,t.basicmaterial_frag);i.setRef(s);n.onTriggered=E;const o=e.inValueSlider("r",Math.random());const l=e.inValueSlider("g",Math.random());const u=e.inValueSlider("b",Math.random());const m=e.inValueSlider("a",1);o.setUiAttribs({colorPick:true});const p=s.addUniformFrag("4f","color",o,l,u,m);s.uniformColorDiffuse=p;const c=e.inTexture("texture");let d=null;c.onChange=j;const h=e.inValueBool("colorizeTexture",false);const f=e.inValueBool("Vertex Colors",false);const v=e.inTexture("textureOpacity");let g=null;const b=e.inSwitch("Alpha Mask Source",["Luminance","R","G","B","A","1-A","1-R"],"Luminance");b.setUiAttribs({greyout:true});v.onChange=C;const x=e.inValueBool("Opacity TexCoords Transform",false);const O=e.inValueBool("Discard Transparent Pixels");const _=e.inValue("diffuseRepeatX",1),T=e.inValue("diffuseRepeatY",1),I=e.inValue("Tex Offset X",0),y=e.inValue("Tex Offset Y",0),A=e.inBool("Crop TexCoords",false);s.addUniformFrag("f","diffuseRepeatX",_);s.addUniformFrag("f","diffuseRepeatY",T);s.addUniformFrag("f","texOffsetX",I);s.addUniformFrag("f","texOffsetY",y);const S=e.inValueBool("billboard",false);b.onChange=S.onChange=O.onChange=x.onChange=A.onChange=f.onChange=h.onChange=L;e.setPortGroup("Color",[o,l,u,m]);e.setPortGroup("Color Texture",[c,f,h]);e.setPortGroup("Opacity",[v,b,O,x]);e.setPortGroup("Texture Transform",[_,T,I,y,A]);C();j();e.preRender=function(){s.bind();E()};function E(){if(!s)return;r.pushShader(s);s.popTextures();if(d&&c.get())s.pushTexture(d,c.get());if(g&&v.get())s.pushTexture(g,v.get());a.trigger();r.popShader()}function C(){if(v.get()){if(g!==null)return;s.removeUniform("texOpacity");s.define("HAS_TEXTURE_OPACITY");if(!g)g=new CGL.Uniform(s,"t","texOpacity")}else{s.removeUniform("texOpacity");s.removeDefine("HAS_TEXTURE_OPACITY");g=null}L()}function j(){if(c.get()){if(!s.hasDefine("HAS_TEXTURE_DIFFUSE"))s.define("HAS_TEXTURE_DIFFUSE");if(!d)d=new CGL.Uniform(s,"t","texDiffuse")}else{s.removeUniform("texDiffuse");s.removeDefine("HAS_TEXTURE_DIFFUSE");d=null}N()}function N(){const e=c.isLinked()||v.isLinked();_.setUiAttribs({greyout:!e});T.setUiAttribs({greyout:!e});I.setUiAttribs({greyout:!e});y.setUiAttribs({greyout:!e});h.setUiAttribs({greyout:!e});b.setUiAttribs({greyout:!v.get()});x.setUiAttribs({greyout:!v.get()});let t=true;t=c.get()&&!h.get();o.setUiAttribs({greyout:t});l.setUiAttribs({greyout:t});u.setUiAttribs({greyout:t})}function L(){s.toggleDefine("VERTEX_COLORS",f.get());s.toggleDefine("CROP_TEXCOORDS",A.get());s.toggleDefine("COLORIZE_TEXTURE",h.get());s.toggleDefine("TRANSFORMALPHATEXCOORDS",x.get());s.toggleDefine("DISCARDTRANS",O.get());s.toggleDefine("BILLBOARD",S.get());s.toggleDefine("ALPHA_MASK_ALPHA",b.get()=="A");s.toggleDefine("ALPHA_MASK_IALPHA",b.get()=="1-A");s.toggleDefine("ALPHA_MASK_IR",b.get()=="1-R");s.toggleDefine("ALPHA_MASK_LUMI",b.get()=="Luminance");s.toggleDefine("ALPHA_MASK_R",b.get()=="R");s.toggleDefine("ALPHA_MASK_G",b.get()=="G");s.toggleDefine("ALPHA_MASK_B",b.get()=="B");N()}};Ops.Gl.Shader.BasicMaterial_v3.prototype=new CABLES.Op;CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"]={f:Ops.Gl.Shader.BasicMaterial_v3,objName:"Ops.Gl.Shader.BasicMaterial_v3"};Ops.Gl.Matrix.Transform=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const t=n.inTrigger("render"),a=n.inValue("posX",0),i=n.inValue("posY",0),r=n.inValue("posZ",0),s=n.inValue("scale",1),o=n.inValue("rotX",0),l=n.inValue("rotY",0),u=n.inValue("rotZ",0),m=n.outTrigger("trigger");n.setPortGroup("Rotation",[o,l,u]);n.setPortGroup("Position",[a,i,r]);n.setPortGroup("Scale",[s]);n.setUiAxisPorts(a,i,r);n.toWorkPortsNeedToBeLinked(t,m);const p=vec3.create();const c=vec3.create();const d=mat4.create();mat4.identity(d);let h=false,f=false,v=true,g=true,b=true;o.onChange=l.onChange=u.onChange=y;a.onChange=i.onChange=r.onChange=T;s.onChange=I;t.onTriggered=function(){let e=false;if(v){O();e=true}if(g){_();e=true}if(b)e=true;if(e)x();const t=n.patch.cg||n.patch.cgl;t.pushModelMatrix();mat4.multiply(t.mMatrix,t.mMatrix,d);m.trigger();t.popModelMatrix();if(CABLES.UI){if(!a.isLinked()&&!i.isLinked()&&!r.isLinked()){gui.setTransform(n.id,a.get(),i.get(),r.get());if(n.isCurrentUiOp())gui.setTransformGizmo({posX:a,posY:i,posZ:r})}}};function x(){mat4.identity(d);if(f)mat4.translate(d,d,p);if(o.get()!==0)mat4.rotateX(d,d,o.get()*CGL.DEG2RAD);if(l.get()!==0)mat4.rotateY(d,d,l.get()*CGL.DEG2RAD);if(u.get()!==0)mat4.rotateZ(d,d,u.get()*CGL.DEG2RAD);if(h)mat4.scale(d,d,c);b=false}function O(){f=false;if(a.get()!==0||i.get()!==0||r.get()!==0)f=true;vec3.set(p,a.get(),i.get(),r.get());v=false}function _(){h=true;vec3.set(c,s.get(),s.get(),s.get());g=false}function T(){v=true}function I(){g=true}function y(){b=true}x()};Ops.Gl.Matrix.Transform.prototype=new CABLES.Op;CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"]={f:Ops.Gl.Matrix.Transform,objName:"Ops.Gl.Matrix.Transform"};Ops.Gl.Pbr.PbrMaterial=function(){CABLES.Op.apply(this,arguments);const i=this;const o=i.attachments={BasicPBR_frag:'precision highp float;\nprecision highp int;\n{{MODULES_HEAD}}\n\n#ifndef PI\n#define PI 3.14159265358\n#endif\n\n// set by cables\nUNI vec3 camPos;\n// utility maps\n#ifdef USE_ENVIRONMENT_LIGHTING\n    UNI sampler2D IBL_BRDF_LUT;\n#endif\n// mesh maps\n#ifdef USE_ALBEDO_TEX\n    UNI sampler2D _AlbedoMap;\n#else\n    UNI vec4 _Albedo;\n#endif\n#ifdef USE_NORMAL_TEX\n    UNI sampler2D _NormalMap;\n#endif\n#ifdef USE_EMISSION\n    UNI sampler2D _EmissionMap;\n#endif\n#ifdef USE_HEIGHT_TEX\n    UNI sampler2D _HeightMap;\n#endif\n#ifdef USE_THIN_FILM_MAP\n    UNI sampler2D _ThinFilmMap;\n    UNI float _TFThicknessTexMin;\n    UNI float _TFThicknessTexMax;\n#endif\n#ifdef USE_AORM_TEX\n    UNI sampler2D _AORMMap;\n#else\n    UNI float _Roughness;\n    UNI float _Metalness;\n#endif\n#ifdef USE_LIGHTMAP\n    #ifndef VERTEX_COLORS\n        UNI sampler2D _Lightmap;\n    #else\n        #ifndef VCOL_LIGHTMAP\n            UNI sampler2D _Lightmap;\n        #endif\n    #endif\n#endif\n#ifdef USE_CLEAR_COAT\n    UNI float _ClearCoatIntensity;\n    UNI float _ClearCoatRoughness;\n    #ifdef USE_CC_NORMAL_MAP\n        #ifndef USE_NORMAL_MAP_FOR_CC\n            UNI sampler2D _CCNormalMap;\n        #endif\n    #endif\n#endif\n#ifdef USE_THIN_FILM\n    UNI float _ThinFilmIntensity;\n    UNI float _ThinFilmIOR;\n    UNI float _ThinFilmThickness;\n#endif\n// IBL inputs\n#ifdef USE_ENVIRONMENT_LIGHTING\n    UNI samplerCube _irradiance;\n    UNI samplerCube _prefilteredEnvironmentColour;\n    UNI float MAX_REFLECTION_LOD;\n    UNI float diffuseIntensity;\n    UNI float specularIntensity;\n    UNI float envIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n    UNI float lightmapIntensity;\n#endif\nUNI float tonemappingExposure;\n#ifdef USE_HEIGHT_TEX\n    UNI float _HeightDepth;\n    #ifndef USE_OPTIMIZED_HEIGHT\n        UNI mat4 modelMatrix;\n    #endif\n#endif\n#ifdef USE_PARALLAX_CORRECTION\n    UNI vec3 _PCOrigin;\n    UNI vec3 _PCboxMin;\n    UNI vec3 _PCboxMax;\n#endif\n#ifdef USE_EMISSION\n    UNI float _EmissionIntensity;\n#endif\nIN vec2 texCoord;\n#ifdef USE_LIGHTMAP\n    #ifndef ATTRIB_texCoord1\n    #ifndef VERTEX_COLORS\n        IN vec2 texCoord1;\n    #else\n        #ifndef VCOL_LIGHTMAP\n            IN vec2 texCoord1;\n        #endif\n    #endif\n    #endif\n#endif\nIN vec4 FragPos;\nIN mat3 TBN;\nIN vec3 norm;\nIN vec3 normM;\n#ifdef VERTEX_COLORS\n    IN vec4 vertCol;\n#endif\n#ifdef USE_HEIGHT_TEX\n    #ifdef USE_OPTIMIZED_HEIGHT\n        IN vec3 fragTangentViewDir;\n    #else\n        IN mat3 invTBN;\n    #endif\n#endif\n\n\n// structs\nstruct Light {\n    vec3 color;\n    vec3 position;\n    vec3 specular;\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int castLight;\n\n    vec3 conePointAt;\n    #define COSCONEANGLE x\n    #define COSCONEANGLEINNER y\n    #define SPOTEXPONENT z\n    vec3 spotProperties;\n};\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod textureCubeLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nhighp vec4 EncodeRGBE8(highp vec3 rgb)\n{\n    highp vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nhighp vec3 DecodeRGBE8(highp vec4 rgbe)\n{\n    highp vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/pbrIBLFunctions.fx\nfloat environmentRadianceOcclusion(float ambientOcclusion, float NdotVUnclamped) {\n    // Best balanced (implementation time vs result vs perf) analytical environment specular occlusion found.\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float temp = NdotVUnclamped + ambientOcclusion;\n    return clamp(temp * temp - 1.0 + ambientOcclusion, 0.0, 1.0);\n}\nfloat environmentHorizonOcclusion(vec3 view, vec3 normal, vec3 geometricNormal) {\n    // http://marmosetco.tumblr.com/post/81245981087\n    vec3 reflection = reflect(view, normal);\n    float temp = clamp(1.0 + 1.1 * dot(reflection, geometricNormal), 0.0, 1.0);\n    return temp * temp;\n}\n#ifdef ALPHA_DITHERED\n// from https://github.com/google/filament/blob/main/shaders/src/dithering.fs\n// modified to use this to discard based on factor instead of dithering\nfloat interleavedGradientNoise(highp vec2 n) {\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), n)));\n}\nfloat Dither_InterleavedGradientNoise(float a) {\n    // Jimenez 2014, "Next Generation Post-Processing in Call of Duty"\n    highp vec2 uv = gl_FragCoord.xy;\n\n    // The noise variable must be highp to workaround Adreno bug #1096.\n    highp float noise = interleavedGradientNoise(uv);\n\n    return step(noise, a);\n}\n#endif\n\n#ifdef USE_HEIGHT_TEX\n#ifndef WEBGL1\n// based on Jasper Flicks great tutorials (:\nfloat getSurfaceHeight(sampler2D surfaceHeightMap, vec2 UV)\n{\n\treturn texture(surfaceHeightMap, UV).r;\n}\n\nvec2 RaymarchedParallax(vec2 UV, sampler2D surfaceHeightMap, float strength, vec3 viewDir)\n{\n    #ifndef USE_OPTIMIZED_HEIGHT\n\t#define PARALLAX_RAYMARCHING_STEPS 50\n    #else\n    #define PARALLAX_RAYMARCHING_STEPS 20\n    #endif\n\tvec2 uvOffset = vec2(0.0);\n\tfloat stepSize = 1.0 / float(PARALLAX_RAYMARCHING_STEPS);\n\tvec2 uvDelta = vec2(viewDir * (stepSize * strength));\n\tfloat stepHeight = 1.0;\n\tfloat surfaceHeight = getSurfaceHeight(surfaceHeightMap, UV);\n\n\tvec2 prevUVOffset = uvOffset;\n\tfloat prevStepHeight = stepHeight;\n\tfloat prevSurfaceHeight = surfaceHeight;\n\n    // doesnt work with webgl 1.0 as the && condition is not fixed length for loop\n\tfor (int i = 1; i < PARALLAX_RAYMARCHING_STEPS && stepHeight > surfaceHeight; ++i)\n\t{\n\t\tprevUVOffset = uvOffset;\n\t\tprevStepHeight = stepHeight;\n\t\tprevSurfaceHeight = surfaceHeight;\n\n\t\tuvOffset -= uvDelta;\n\t\tstepHeight -= stepSize;\n\t\tsurfaceHeight = getSurfaceHeight(surfaceHeightMap, UV + uvOffset);\n\t}\n\n\tfloat prevDifference = prevStepHeight - prevSurfaceHeight;\n\tfloat difference = surfaceHeight - stepHeight;\n\tfloat t = prevDifference / (prevDifference + difference);\n\tuvOffset = mix(prevUVOffset, uvOffset, t);\n\treturn uvOffset;\n}\n#endif // TODO: use non raymarched parallax mapping here if webgl 1.0?\n#endif\n\n#ifdef USE_PARALLAX_CORRECTION\nvec3 BoxProjection(vec3 direction, vec3 position, vec3 cubemapPosition, vec3 boxMin, vec3 boxMax)\n{\n\tboxMin -= position;\n\tboxMax -= position;\n\tfloat x = (direction.x > 0.0 ? boxMax.x : boxMin.x) / direction.x;\n\tfloat y = (direction.y > 0.0 ? boxMax.y : boxMin.y) / direction.y;\n\tfloat z = (direction.z > 0.0 ? boxMax.z : boxMin.z) / direction.z;\n\tfloat scalar = min(min(x, y), z);\n\n\treturn direction * scalar + (position - cubemapPosition);\n}\n#endif\n\n#ifdef USE_THIN_FILM\n// section from https://github.com/BabylonJS/Babylon.js/blob/8a5077e0efb4ba471d16f7cd010fe6124ea8d005/packages/dev/core/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\n// helper functions from https://github.com/BabylonJS/Babylon.js/blob/8a5077e0efb4ba471d16f7cd010fe6124ea8d005/packages/dev/core/src/Shaders/ShadersInclude/helperFunctions.fx\nfloat square(float value)\n{\n    return value * value;\n}\nvec3 square(vec3 value)\n{\n    return value * value;\n}\nfloat pow5(float value) {\n    float sq = value * value;\n    return sq * sq * value;\n}\nconst mat3 XYZ_TO_REC709 = mat3(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n// Assume air interface for top\n// Note: We don\'t handle the case fresnel0 == 1\nvec3 getIORTfromAirToSurfaceR0(vec3 f0) {\n    vec3 sqrtF0 = sqrt(f0);\n    return (1. + sqrtF0) / (1. - sqrtF0);\n}\n\n// Conversion FO/IOR\nvec3 getR0fromIORs(vec3 iorT, float iorI) {\n    return square((iorT - vec3(iorI)) / (iorT + vec3(iorI)));\n}\n\nfloat getR0fromIORs(float iorT, float iorI) {\n    return square((iorT - iorI) / (iorT + iorI));\n}\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nvec3 evalSensitivity(float opd, vec3 shift) {\n    float phase = 2.0 * PI * opd * 1.0e-9;\n\n    const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-square(phase) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * square(phase));\n    xyz /= 1.0685e-7;\n\n    vec3 srgb = XYZ_TO_REC709 * xyz;\n    return srgb;\n}\n// from https://github.com/BabylonJS/Babylon.js/blob/8a5077e0efb4ba471d16f7cd010fe6124ea8d005/packages/dev/core/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow5(1.0 - VdotH);\n}\nfloat fresnelSchlickGGX(float VdotH, float reflectance0, float reflectance90)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow5(1.0 - VdotH);\n}\nvec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\n    vec3 I = vec3(1.0);\n\n    // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n    float iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n    // Evaluate the cosTheta on the base layer (Snell law)\n    float sinTheta2Sq = square(outsideIOR / iridescenceIOR) * (1.0 - square(cosTheta1));\n\n    // Handle TIR:\n    float cosTheta2Sq = 1.0 - sinTheta2Sq;\n    if (cosTheta2Sq < 0.0) {\n        return I;\n    }\n\n    float cosTheta2 = sqrt(cosTheta2Sq);\n\n    // First interface\n    float R0 = getR0fromIORs(iridescenceIOR, outsideIOR);\n    float R12 = fresnelSchlickGGX(cosTheta1, R0, 1.);\n    float R21 = R12;\n    float T121 = 1.0 - R12;\n    float phi12 = 0.0;\n    if (iridescenceIOR < outsideIOR) phi12 = PI;\n    float phi21 = PI - phi12;\n\n    // Second interface\n    vec3 baseIOR = getIORTfromAirToSurfaceR0(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\n    vec3 R1 = getR0fromIORs(baseIOR, iridescenceIOR);\n    vec3 R23 = fresnelSchlickGGX(cosTheta2, R1, vec3(1.));\n    vec3 phi23 = vec3(0.0);\n    if (baseIOR[0] < iridescenceIOR) phi23[0] = PI;\n    if (baseIOR[1] < iridescenceIOR) phi23[1] = PI;\n    if (baseIOR[2] < iridescenceIOR) phi23[2] = PI;\n\n    // Phase shift\n    float opd = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n    vec3 phi = vec3(phi21) + phi23;\n\n    // Compound terms\n    vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\n    vec3 r123 = sqrt(R123);\n    vec3 Rs = square(T121) * R23 / (vec3(1.0) - R123);\n\n    // Reflectance term for m = 0 (DC term amplitude)\n    vec3 C0 = R12 + Rs;\n    I = C0;\n\n    // Reflectance term for m > 0 (pairs of diracs)\n    vec3 Cm = Rs - T121;\n    for (int m = 1; m <= 2; ++m)\n    {\n        Cm *= r123;\n        vec3 Sm = 2.0 * evalSensitivity(float(m) * opd, float(m) * phi);\n        I += Cm * Sm;\n    }\n\n    // Since out of gamut colors might be produced, negative color values are clamped to 0.\n    return max(I, vec3(0.0));\n}\n#endif\n\n{{PBR_FRAGMENT_HEAD}}\nvoid main()\n{\n    vec4 col;\n\n    // set up interpolated vertex data\n    vec2 UV0             = texCoord;\n    #ifdef USE_LIGHTMAP\n        #ifndef VERTEX_COLORS\n            vec2 UV1             = texCoord1;\n        #else\n            #ifndef VCOL_LIGHTMAP\n                vec2 UV1             = texCoord1;\n            #endif\n        #endif\n    #endif\n    vec3 V               = normalize(camPos - FragPos.xyz);\n\n    #ifdef USE_HEIGHT_TEX\n        #ifndef USE_OPTIMIZED_HEIGHT\n            vec3 fragTangentViewDir = normalize(invTBN * (camPos - FragPos.xyz));\n        #endif\n        #ifndef WEBGL1\n            UV0 += RaymarchedParallax(UV0, _HeightMap, _HeightDepth * 0.1, fragTangentViewDir);\n        #endif\n    #endif\n\n    // load relevant mesh maps\n    #ifdef USE_ALBEDO_TEX\n        vec4 AlbedoMap   = texture(_AlbedoMap, UV0);\n    #else\n        vec4 AlbedoMap   = _Albedo;\n    #endif\n    #ifdef ALPHA_MASKED\n\tif ( AlbedoMap.a <= 0.5 )\n\t    discard;\n\t#endif\n\n\t#ifdef ALPHA_DITHERED\n\tif ( Dither_InterleavedGradientNoise(AlbedoMap.a) <= 0.5 )\n\t    discard;\n\t#endif\n\n    #ifdef USE_AORM_TEX\n        vec4 AORM        = texture(_AORMMap, UV0);\n    #else\n        vec4 AORM        = vec4(1.0, _Roughness, _Metalness, 1.0);\n    #endif\n    #ifdef USE_NORMAL_TEX\n        vec3 internalNormals = texture(_NormalMap, UV0).rgb;\n        internalNormals      = internalNormals * 2.0 - 1.0;\n        internalNormals      = normalize(TBN * internalNormals);\n    #else\n        vec3 internalNormals = normM;\n\n        #ifdef DOUBLE_SIDED\n            if(!gl_FrontFacing) internalNormals = internalNormals*-1.0;\n        #endif\n\n    #endif\n\t#ifdef USE_LIGHTMAP\n    \t#ifndef VERTEX_COLORS\n\t        #ifndef LIGHTMAP_IS_RGBE\n                vec3 Lightmap = texture(_Lightmap, UV1).rgb;\n            #else\n                vec3 Lightmap = DecodeRGBE8(texture(_Lightmap, UV1));\n            #endif\n        #else\n            #ifdef VCOL_LIGHTMAP\n                vec3 Lightmap = pow(vertCol.rgb, vec3(2.2));\n            #else\n  \t            #ifndef LIGHTMAP_IS_RGBE\n                    vec3 Lightmap = texture(_Lightmap, UV1).rgb;\n                #else\n                    vec3 Lightmap = DecodeRGBE8(texture(_Lightmap, UV1));\n                #endif\n            #endif\n        #endif\n    #endif\n    // initialize texture values\n    float AO             = AORM.r;\n    float specK          = AORM.g;\n    float metalness      = AORM.b;\n    vec3  N              = normalize(internalNormals);\n    vec3  albedo         = pow(AlbedoMap.rgb, vec3(2.2));\n\n    #ifdef VERTEX_COLORS\n        #ifdef VCOL_COLOUR\n            albedo.rgb *= pow(vertCol.rgb, vec3(2.2));\n            AlbedoMap.rgb *= pow(vertCol.rgb, vec3(2.2));\n        #endif\n        #ifdef VCOL_AORM\n            AO = vertCol.r;\n            specK = vertCol.g;\n            metalness = vertCol.b;\n        #endif\n        #ifdef VCOL_AO\n            AO = vertCol.r;\n        #endif\n        #ifdef VCOL_R\n            specK = vertCol.g;\n        #endif\n        #ifdef VCOL_M\n            metalness = vertCol.b;\n        #endif\n    #endif\n\n    // set up values for later calculations\n    float NdotV          = abs(dot(N, V));\n    vec3  F0             = mix(vec3(0.04), AlbedoMap.rgb, metalness);\n\n    #ifdef USE_THIN_FILM\n        #ifndef USE_THIN_FILM_MAP\n            vec3 iridescenceFresnel = evalIridescence(1.0, _ThinFilmIOR, NdotV, _ThinFilmThickness, F0);\n            F0 = mix(F0, iridescenceFresnel, _ThinFilmIntensity);\n        #else\n            vec3 ThinFilmParameters = texture(_ThinFilmMap, UV0).rgb;\n            vec3 iridescenceFresnel = evalIridescence(1.0, 1.0 / ThinFilmParameters.b, NdotV, mix(_TFThicknessTexMin, _TFThicknessTexMax, ThinFilmParameters.g), F0);\n            F0 = mix(F0, iridescenceFresnel, ThinFilmParameters.r);\n        #endif\n    #endif\n\n    #ifndef WEBGL1\n        #ifndef DONT_USE_GR\n            // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrHelperFunctions.fx\n            // modified to fit variable names\n            #ifndef DONT_USE_NMGR\n                vec3 nDfdx = dFdx(normM.xyz);\n                vec3 nDfdy = dFdy(normM.xyz);\n            #else\n                vec3 nDfdx = dFdx(N.xyz) + dFdx(normM.xyz);\n                vec3 nDfdy = dFdy(N.xyz) + dFdy(normM.xyz);\n            #endif\n            float slopeSquare = max(dot(nDfdx, nDfdx), dot(nDfdy, nDfdy));\n\n            // Vive analytical lights roughness factor.\n            float geometricRoughnessFactor = pow(clamp(slopeSquare, 0.0, 1.0), 0.333);\n\n            specK = max(specK, geometricRoughnessFactor);\n            #endif\n        #endif\n\n    \t// IBL\n    \t// from https://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/shaders/src/light_indirect.fs\n    \t// and https://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/shaders/src/shading_lit.fs\n    \t// modified to fit structure/variable names\n    \t#ifdef USE_ENVIRONMENT_LIGHTING\n        \tvec2 envBRDF = texture(IBL_BRDF_LUT, vec2(NdotV, specK)).xy;\n        \tvec3 E = mix(envBRDF.xxx, envBRDF.yyy, F0);\n        #endif\n\n        float specOcclusion    = environmentRadianceOcclusion(AO, NdotV);\n        float horizonOcclusion = environmentHorizonOcclusion(-V, N, normM);\n\n        #ifdef USE_ENVIRONMENT_LIGHTING\n            float envSampleSpecK = specK * MAX_REFLECTION_LOD;\n            vec3  R = reflect(-V, N);\n\n            #ifdef USE_PARALLAX_CORRECTION\n                R = BoxProjection(R, FragPos.xyz, _PCOrigin, _PCboxMin, _PCboxMax);\n            #endif\n\n    \t    vec3 prefilteredEnvColour = DecodeRGBE8(SAMPLETEX(_prefilteredEnvironmentColour, R, envSampleSpecK)) * specularIntensity*envIntensity;\n\n        \tvec3 Fr = E * prefilteredEnvColour;\n        \tFr *= specOcclusion * horizonOcclusion * (1.0 + F0 * (1.0 / envBRDF.y - 1.0));\n        \tFr *= 1.0 + F0; // TODO: this might be wrong, figure this out\n\n        \t#ifdef USE_LIGHTMAP\n                vec3 IBLIrradiance = Lightmap * lightmapIntensity;\n            #else\n                vec3 IBLIrradiance = DecodeRGBE8(SAMPLETEX(_irradiance, N, 0.0)) * diffuseIntensity*envIntensity;\n        #endif\n\n\t    vec3 Fd = (1.0 - metalness) * albedo * IBLIrradiance * (1.0 - E) * AO;\n    #endif\n    vec3 directLighting = vec3(0.0);\n\n    {{PBR_FRAGMENT_BODY}}\n\n    // combine IBL\n    col.rgb = directLighting;\n    #ifdef USE_ENVIRONMENT_LIGHTING\n\n        col.rgb += Fr + Fd;\n\n        #ifdef USE_CLEAR_COAT\n            float CCEnvSampleSpecK = _ClearCoatRoughness * MAX_REFLECTION_LOD;\n            #ifndef USE_NORMAL_MAP_FOR_CC\n                #ifndef USE_CC_NORMAL_MAP\n                    vec3 CCR = reflect(-V, normM);\n                #else\n                    vec3 CCN = texture(_CCNormalMap, UV0).rgb;\n                    CCN      = CCN * 2.0 - 1.0;\n                    CCN      = normalize(TBN * CCN);\n                    vec3 CCR = reflect(-V, CCN);\n                #endif\n                #ifdef USE_PARALLAX_CORRECTION\n                    CCR = BoxProjection(CCR, FragPos.xyz, _PCOrigin, _PCboxMin, _PCboxMax);\n                #endif\n            #endif\n            #ifndef USE_NORMAL_MAP_FOR_CC\n        \t    vec3 CCPrefilteredEnvColour = DecodeRGBE8(SAMPLETEX(_prefilteredEnvironmentColour, CCR, CCEnvSampleSpecK));\n        \t#else\n        \t    vec3 CCPrefilteredEnvColour = DecodeRGBE8(SAMPLETEX(_prefilteredEnvironmentColour, R, CCEnvSampleSpecK));\n        \t#endif\n        \tvec3 CCFr = E * CCPrefilteredEnvColour;\n        \tCCFr *= specOcclusion * horizonOcclusion * (0.96 + (0.04 / envBRDF.y));\n        \tCCFr *= 1.04;\n        \tcol.rgb += CCFr * _ClearCoatIntensity*envIntensity;\n        #endif\n    #else\n        #ifdef USE_LIGHTMAP\n            col.rgb += (1.0 - metalness) * albedo * Lightmap * lightmapIntensity;\n        #endif\n    #endif\n    #ifdef USE_EMISSION\n    col.rgb += texture(_EmissionMap, UV0).rgb * _EmissionIntensity;\n    #endif\n    col.a   = 1.0;\n\n    #ifdef ALPHA_BLEND\n        col.a = AlbedoMap.a;\n    #endif\n\n    // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/tonemap.fragment.fx\n    // modified to fit variable names\n    #ifdef TONEMAP_HejiDawson\n        col.rgb *= tonemappingExposure;\n\n        vec3 X = max(vec3(0.0, 0.0, 0.0), col.rgb - 0.004);\n        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n\n        col.rgb = retColor * retColor;\n    #elif defined(TONEMAP_Photographic)\n        col.rgb =  vec3(1.0, 1.0, 1.0) - exp2(-tonemappingExposure * col.rgb);\n    #else\n        col.rgb *= tonemappingExposure;\n        //col.rgb = clamp(col.rgb, vec3(0.0), vec3(1.0));\n    #endif\n\n    col.rgb = pow(col.rgb, vec3(1.0/2.2));\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}\n',BasicPBR_vert:"precision highp float;\nprecision highp int;\n\nUNI vec3 camPos;\n\nIN vec3  vPosition;\nIN vec2  attrTexCoord;\n#ifdef USE_LIGHTMAP\n    #ifndef ATTRIB_attrTexCoord1\n        IN vec2 attrTexCoord1;\n        OUT vec2 texCoord1;\n        #define ATTRIB_attrTexCoord1\n        #define ATTRIB_texCoord1\n    #endif\n#endif\nIN vec3  attrVertNormal;\nIN vec3  attrTangent;\nIN vec3  attrBiTangent;\nIN float attrVertIndex;\n#ifdef VERTEX_COLORS\nIN vec4 attrVertColor;\n#endif\n\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\n\nOUT vec4 FragPos;\nOUT mat3 TBN;\nOUT vec3 norm;\nOUT vec3 normM;\n#ifdef VERTEX_COLORS\nOUT vec4 vertCol;\n#endif\n#ifdef USE_HEIGHT_TEX\n#ifdef USE_OPTIMIZED_HEIGHT\nOUT vec3 fragTangentViewDir;\n#else\nOUT mat3 invTBN;\n#endif\n#endif\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    mat4 mMatrix = modelMatrix; // needed to make vertex effects work\n    #ifdef USE_LIGHTMAP\n        texCoord1 = attrTexCoord1;\n    #endif\n    texCoord = attrTexCoord;\n    texCoord.y = 1.0 - texCoord.y;\n    vec4 pos = vec4(vPosition,  1.0);\n    norm = attrVertNormal;\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n\n    mat4 theMMat=mMatrix;\n    #ifdef INSTANCING\n        #ifdef TEXINSTMAT\n            theMMat = texInstMat;\n        #endif\n        #ifndef TEXINSTMAT\n            theMMat = instMat;\n        #endif\n    #endif\n\n    FragPos = theMMat * pos;\n\n    tangent = normalize(vec3(theMMat * vec4(tangent,    0.0)));\n    vec3 N = normalize(vec3(theMMat * vec4(norm, 0.0)));\n    bitangent = normalize(vec3(theMMat * vec4(bitangent,  0.0)));\n\n    #ifdef VERTEX_COLORS\n        vertCol = attrVertColor;\n    #endif\n\n    TBN = mat3(tangent, bitangent, N);\n\n    #ifdef USE_HEIGHT_TEX\n    #ifndef WEBGL1\n    #ifdef USE_OPTIMIZED_HEIGHT\n    fragTangentViewDir = normalize(transpose(TBN) * (camPos - FragPos.xyz));\n    #else\n    invTBN = transpose(TBN);\n    #endif\n    #endif\n    #endif\n\n    normM = N;\n\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n    {{MODULE_VERTEX_MODELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n",light_body_directional_frag:"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO, false);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO, false);\n#endif\n",light_body_point_frag:"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position - FragPos.xyz);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO, true);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO, true);\n#endif\n",light_body_spot_frag:"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position - FragPos.xyz);\nfloat spotIntensity{{LIGHT_INDEX}} = CalculateSpotLightEffect(\n    lightOP{{LIGHT_INDEX}}.position, lightOP{{LIGHT_INDEX}}.conePointAt, lightOP{{LIGHT_INDEX}}.spotProperties.COSCONEANGLE,\n    lightOP{{LIGHT_INDEX}}.spotProperties.COSCONEANGLEINNER, lightOP{{LIGHT_INDEX}}.spotProperties.SPOTEXPONENT,\n    L{{LIGHT_INDEX}}\n);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO * spotIntensity{{LIGHT_INDEX}}, true);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO * spotIntensity{{LIGHT_INDEX}}, true);\n#endif\n",light_head_frag:"UNI Light lightOP{{LIGHT_INDEX}};\n",light_includes_frag:'#ifndef PI\n#define PI 3.14159265359\n#endif\n\n// from https://github.com/google/filament/blob/036bfa9b20d730bb8e5852ed449b024570167648/shaders/src/brdf.fs\n// modified to fit variable names / structure\nfloat F_Schlick(float f0, float f90, float VoH)\n{\n    return f0 + (f90 - f0) * pow(1.0 - VoH, 5.0);\n}\nvec3 F_Schlick(const vec3 f0, float VoH)\n{\n    float f = pow(1.0 - VoH, 5.0);\n    return f + f0 * (1.0 - f);\n}\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH)\n{\n    // Burley 2012, "Physically-Based Shading at Disney"\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\nfloat D_GGX(float roughness, float NoH, const vec3 h)\n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n\n    float a = NoH * roughness;\n    float k = roughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return clamp(d, 0.0, 1.0);\n}\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL)\n{\n    // Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"\n    float a2 = roughness * roughness;\n    // TODO: lambdaV can be pre-computed for all the lights, it should be moved out of this function\n    float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    float v = 0.5 / (lambdaV + lambdaL);\n    // a2=0 => v = 1 / 4*NoL*NoV   => min=1/4, max=+inf\n    // a2=1 => v = 1 / 2*(NoL+NoV) => min=1/4, max=+inf\n    // clamp to the maximum value representable in mediump\n    return clamp(v, 0.0, 1.0);\n}\n// from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/light_punctual.fs\n// modified to fit variable names\nfloat getSquareFalloffAttenuation(float distanceSquare, float falloff)\n{\n    float factor = distanceSquare * falloff;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    // We would normally divide by the square distance here\n    // but we do it at the call site\n    return smoothFactor * smoothFactor;\n}\n\nfloat getDistanceAttenuation(vec3 posToLight, float falloff, vec3 V, float volume)\n{\n    float distanceSquare = dot(posToLight, posToLight);\n    float attenuation = getSquareFalloffAttenuation(distanceSquare, falloff);\n    // light far attenuation\n    float d = dot(V, V);\n    float f = 100.0; // CONFIG_Z_LIGHT_FAR, ttps://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/filament/src/details/Engine.h\n    vec2 lightFarAttenuationParams = 0.5 * vec2(10.0, 10.0 / (f * f));\n    attenuation *= clamp(lightFarAttenuationParams.x - d * lightFarAttenuationParams.y, 0.0, 1.0);\n    // Assume a punctual light occupies a min volume of 1cm to avoid a division by 0\n    return attenuation / max(distanceSquare, max(1e-4, volume));\n}\n\n#ifdef USE_CLEAR_COAT\n// from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/shading_model_standard.fs\n// modified to fit variable names / structure\nfloat clearCoatLobe(vec3 shading_clearCoatNormal, vec3 h, float LoH, float CCSpecK)\n{\n    float clearCoatNoH = clamp(dot(shading_clearCoatNormal, h), 0.0, 1.0);\n\n    // clear coat specular lobe\n    float D = D_GGX(CCSpecK, clearCoatNoH, h);\n    // from https://github.com/google/filament/blob/036bfa9b20d730bb8e5852ed449b024570167648/shaders/src/brdf.fs\n    float V = clamp(0.25 / (LoH * LoH), 0.0, 1.0);\n    float F = F_Schlick(0.04, 1.0, LoH); // fix IOR to 1.5\n\n    return D * V * F;\n}\n#endif\n\n#ifdef USE_ENVIRONMENT_LIGHTING\nvec3 evaluateLighting(Light light, vec3 L, vec4 FragPos, vec3 V, vec3 N, vec3 albedo, float specK, float NdotV, vec3 F0, float envBRDFY, float AO, bool hasFalloff)\n#else\nvec3 evaluateLighting(Light light, vec3 L, vec4 FragPos, vec3 V, vec3 N, vec3 albedo, float specK, float NdotV, vec3 F0, float AO, bool hasFalloff)\n#endif\n{\n    vec3 directLightingResult = vec3(0.0);\n    if (light.castLight == 1)\n    {\n        specK = max(0.08, specK);\n        // from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/shading_model_standard.fs\n        // modified to fit variable names / structure\n        vec3 H = normalize(V + L);\n\n        float NdotL = clamp(dot(N, L), 0.0, 1.0);\n        float NdotH = clamp(dot(N, H), 0.0, 1.0);\n        float LdotH = clamp(dot(L, H), 0.0, 1.0);\n\n        vec3 Fd = albedo * Fd_Burley(specK, NdotV, NdotL, LdotH);\n\n        float D  = D_GGX(specK, NdotH, H);\n        float V2 = V_SmithGGXCorrelated(specK, NdotV, NdotL);\n        vec3  F  = F_Schlick(F0, LdotH);\n\n        // TODO: modify this with the radius\n        vec3 Fr = (D * V2) * F;\n\n        #ifdef USE_ENVIRONMENT_LIGHTING\n        vec3 directLighting = Fd + Fr * (1.0 + F0 * (1.0 / envBRDFY - 1.0));\n        #else\n        vec3 directLighting = Fd + Fr;\n        #endif\n\n        float attenuation = getDistanceAttenuation(L, hasFalloff ? light.lightProperties.FALLOFF : 0.0, V, light.lightProperties.RADIUS);\n\n        directLightingResult = (directLighting * light.color) *\n                          (light.lightProperties.INTENSITY * attenuation * NdotL * AO);\n\n        #ifdef USE_CLEAR_COAT\n        directLightingResult += clearCoatLobe(normM, H, LdotH, _ClearCoatRoughness);\n        #endif\n    }\n    return directLightingResult;\n}\n\n// from phong OP to make sure the light parameters change lighting similar to what people are used to\nfloat CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n    vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n    float spotAngle = dot(-lightDirection, spotLightDirection);\n    float epsilon = cosConeAngle - cosConeAngleInner;\n\n    float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n    spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n    return max(0., spotIntensity);\n}\n'};const r=i.patch.cgl;const k=i.inTrigger("render");const e=i.inFloat("R",Math.random());const t=i.inFloat("G",Math.random());const n=i.inFloat("B",Math.random());const a=i.inFloatSlider("A",1);const F=[e,t,n,a];i.setPortGroup("Diffuse Color",F);const s=i.inFloatSlider("Roughness",.5);const l=i.inFloatSlider("Metalness",0);const u=i.inSwitch("Alpha Mode",["Opaque","Masked","Dithered","Blend"],"Blend");const m=i.inValueBool("Use Clear Coat",false);const G=i.inFloatSlider("Clear Coat Intensity",1);const U=i.inFloatSlider("Clear Coat Roughness",.5);const p=i.inValueBool("Use Normal map for Clear Coat",false);const c=i.inTexture("Clear Coat Normal map");const d=i.inValueBool("Use Thin Film",false);const B=i.inFloatSlider("Thin Film Intensity",1);const D=i.inFloat("Thin Film IOR",1.3);const V=i.inFloat("Thin Film Thickness (nm)",600);const z=i.inFloat("Thickness Tex Min",300);const X=i.inFloat("Thickness Tex Max",600);const h=i.inSwitch("Tonemapping",["sRGB","HejiDawson","Photographic"],"sRGB");const q=i.inFloat("Exposure",1);const H=i.inFloat("Emission Intensity",1);const f=i.inBool("Disable geometric roughness",false);const v=i.inBool("Use roughness from normal map",false);const g=i.inValueBool("Use Vertex Colours",false);const b=i.inSwitch("Vertex Colour Mode",["colour","AORM","AO","R","M","lightmap"],"colour");const Y=i.inFloat("Height Intensity",1);const x=i.inValueBool("Faster heightmapping",false);const O=i.inValueBool("Double Sided",false);const _=i.inTexture("IBL LUT");const T=i.inTexture("Diffuse Irradiance");const I=i.inTexture("Pre-filtered envmap");const y=i.inInt("Num mip levels");const A=i.inTexture("Albedo");const S=i.inTexture("AORM");const E=i.inTexture("Normal map");const C=i.inTexture("Emission");const j=i.inTexture("Height");const N=i.inTexture("Lightmap");const L=i.inTexture("Thin Film");const W=i.inFloat("Diffuse Intensity",1);const Z=i.inFloat("Specular Intensity",1);const M=i.inBool("Lightmap is RGBE",false);const K=i.inFloat("Lightmap Intensity",1);k.onTriggered=He;const J=i.outTrigger("Next");const Q=i.outObject("Shader");Q.ignoreValueSerialize=true;i.toWorkPortsNeedToBeLinked(k);i.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose",CABLES.OP_PORT_TYPE_FUNCTION);e.setUiAttribs({colorPick:true});i.setPortGroup("Shader Parameters",[s,l,u]);i.setPortGroup("Advanced Shader Parameters",[H,f,v,g,b,Y,x,O]);i.setPortGroup("Textures",[A,S,E,C,j,N,L]);i.setPortGroup("Lighting",[W,Z,K,M,_,T,I,y]);i.setPortGroup("Tonemapping",[h,q]);i.setPortGroup("Clear Coat",[m,G,U,p,c]);i.setPortGroup("Thin Film Iridescence",[d,B,D,V,z,X]);let R=new CGL.Shader(r,"PBRShader",this);R.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG","MODULE_VERTEX_MODELVIEW"]);let P=[];const w=[];const $=new RegExp("{{LIGHT_INDEX}}","g");const ee=new RegExp("{{PBR_FRAGMENT_HEAD}}","g");const te=new RegExp("{{PBR_FRAGMENT_BODY}}","g");const ne=o.light_head_frag;const ae={point:o.light_body_point_frag,directional:o.light_body_directional_frag,spot:o.light_body_spot_frag};const ie=e=>{return ne.replace("{{LIGHT_INDEX}}",e)};const re=(e,t)=>{return(ae[t]||"").replace($,e)};let se=-1;const oe=[{type:"point",position:[5,5,5],color:[1,1,1],specular:[1,1,1],intensity:120,attenuation:0,falloff:.5,radius:60,castLight:1}];if(r.glVersion==1){if(!r.gl.getExtension("EXT_shader_texture_lod")){i.log("no EXT_shader_texture_lod texture extension");throw"no EXT_shader_texture_lod texture extension"}else{R.enableExtension("GL_EXT_shader_texture_lod");r.gl.getExtension("OES_texture_float");r.gl.getExtension("OES_texture_float_linear");r.gl.getExtension("OES_texture_half_float");r.gl.getExtension("OES_texture_half_float_linear");R.enableExtension("GL_OES_standard_derivatives");R.enableExtension("GL_OES_texture_float");R.enableExtension("GL_OES_texture_float_linear");R.enableExtension("GL_OES_texture_half_float");R.enableExtension("GL_OES_texture_half_float_linear")}}Xe();const le=new CGL.Uniform(R,"t","_AlbedoMap",0);const ue=new CGL.Uniform(R,"t","_AORMMap",0);const me=new CGL.Uniform(R,"t","_NormalMap",0);const pe=new CGL.Uniform(R,"t","_EmissionMap",0);const ce=new CGL.Uniform(R,"t","_CCNormalMap",0);const de=new CGL.Uniform(R,"t","IBL_BRDF_LUT",0);const he=new CGL.Uniform(R,"tc","_irradiance",1);const fe=new CGL.Uniform(R,"tc","_prefilteredEnvironmentColour",1);const ve=new CGL.Uniform(R,"f","MAX_REFLECTION_LOD",0);const ge=new CGL.Uniform(R,"f","tonemappingExposure",q);const be=new CGL.Uniform(R,"f","diffuseIntensity",W);const xe=new CGL.Uniform(R,"f","specularIntensity",Z);const Oe=new CGL.Uniform(R,"f","envIntensity",1);const _e=new CGL.Uniform(R,"t","_HeightMap",0);const Te=new CGL.Uniform(R,"t","_Lightmap",0);const Ie=new CGL.Uniform(R,"f","lightmapIntensity",K);const ye=new CGL.Uniform(R,"t","_ThinFilmMap",0);const Ae=new CGL.Uniform(R,"4f","_Albedo",e,t,n,a);const Se=new CGL.Uniform(R,"f","_Roughness",s);const Ee=new CGL.Uniform(R,"f","_Metalness",l);const Ce=new CGL.Uniform(R,"f","_HeightDepth",Y);const je=new CGL.Uniform(R,"f","_ClearCoatIntensity",G);const Ne=new CGL.Uniform(R,"f","_ClearCoatRoughness",U);const Le=new CGL.Uniform(R,"f","_EmissionIntensity",H);const Me=new CGL.Uniform(R,"f","_ThinFilmIntensity",B);const Re=new CGL.Uniform(R,"f","_ThinFilmIOR",D);const Pe=new CGL.Uniform(R,"f","_ThinFilmThickness",V);const we=new CGL.Uniform(R,"f","_TFThicknessTexMin",z);const ke=new CGL.Uniform(R,"f","_TFThicknessTexMax",X);const Fe=new CGL.Uniform(R,"3f","_PCOrigin",[0,0,0]);const Ge=new CGL.Uniform(R,"3f","_PCboxMin",[-1,-1,-1]);const Ue=new CGL.Uniform(R,"3f","_PCboxMax",[1,1,1]);R.uniformColorDiffuse=Ae;R.uniformPbrMetalness=Ee;R.uniformPbrRoughness=Se;I.onChange=Ve;S.onChange=O.onChange=M.onChange=p.onChange=m.onChange=c.onChange=A.onChange=E.onChange=C.onChange=j.onChange=u.onChange=v.onChange=h.onChange=N.onChange=L.onChange=x.onChange=g.onChange=f.onChange=d.onChange=b.onChange=Be;function Be(){R.toggleDefine("DOUBLE_SIDED",O.get());R.toggleDefine("USE_OPTIMIZED_HEIGHT",x.get());R.toggleDefine("USE_CLEAR_COAT",m.get());R.toggleDefine("USE_NORMAL_MAP_FOR_CC",p.get());R.toggleDefine("USE_CC_NORMAL_MAP",c.isLinked());R.toggleDefine("LIGHTMAP_IS_RGBE",M.get());R.toggleDefine("USE_LIGHTMAP",N.isLinked()||b.get()==="lightmap");R.toggleDefine("USE_NORMAL_TEX",E.isLinked());R.toggleDefine("USE_HEIGHT_TEX",j.isLinked());R.toggleDefine("DONT_USE_NMGR",v.get());R.toggleDefine("DONT_USE_GR",f.get());R.toggleDefine("USE_THIN_FILM",d.get());R.toggleDefine("USE_EMISSION",C.get());R.toggleDefine("USE_THIN_FILM_MAP",L.get());R.toggleDefine("VCOL_COLOUR",b.get()==="colour");R.toggleDefine("VCOL_AORM",b.get()==="AORM");R.toggleDefine("VCOL_AO",b.get()==="AO");R.toggleDefine("VCOL_R",b.get()==="R");R.toggleDefine("VCOL_M",b.get()==="M");R.toggleDefine("VCOL_LIGHTMAP",b.get()==="lightmap");R.toggleDefine("USE_ALBEDO_TEX",A.get());e.setUiAttribs({greyout:A.isLinked()});t.setUiAttribs({greyout:A.isLinked()});n.setUiAttribs({greyout:A.isLinked()});a.setUiAttribs({greyout:A.isLinked()});R.toggleDefine("USE_AORM_TEX",S.get());s.setUiAttribs({greyout:S.isLinked()});l.setUiAttribs({greyout:S.isLinked()});R.toggleDefine("VERTEX_COLORS",g.get());if(!g.get()){R.toggleDefine("USE_LIGHTMAP",N.get())}else{if(b.get()==="lightmap"){R.define("USE_LIGHTMAP")}}R.toggleDefine("ALPHA_MASKED",u.get()==="Masked");R.toggleDefine("ALPHA_DITHERED",u.get()==="Dithered");R.toggleDefine("ALPHA_BLEND",u.get()==="Blend");R.toggleDefine("TONEMAP_sRGB",h.get()==="sRGB");R.toggleDefine("TONEMAP_HejiDawson",h.get()==="HejiDawson");R.toggleDefine("TONEMAP_Photographic",h.get()==="Photographic")}Be();function De(e){R.toggleDefine("USE_ENVIRONMENT_LIGHTING",e)}function Ve(){y.setUiAttribs({greyout:!I.get()})}function ze(){for(let e=0;e<P.length;e+=1){const t=P[e];t.isUsed=true;w[e].position.setValue(t.position);w[e].color.setValue(t.color);w[e].specular.setValue(t.specular);w[e].lightProperties.setValue([t.intensity,t.attenuation,t.falloff,t.radius]);w[e].conePointAt.setValue(t.conePointAt);w[e].spotProperties.setValue([t.cosConeAngle,t.cosConeAngleInner,t.spotExponent]);w[e].castLight.setValue(t.castLight)}}function Xe(){const e=o.BasicPBR_vert;const t=o.light_includes_frag;let n=o.BasicPBR_frag;let a="";let i="";if(P.length>0){a=a.concat(t)}for(let e=0;e<P.length;e+=1){const r=P[e];const s=r.type;a=a.concat(ie(e)||"");i=i.concat(re(e,r.type)||"")}n=n.replace(ee,a||"");n=n.replace(te,i||"");R.setSource(e,n);Q.set(R);for(let e=0;e<P.length;e+=1){w[e]=null;if(!w[e]){w[e]={color:new CGL.Uniform(R,"3f","lightOP"+e+".color",[1,1,1]),position:new CGL.Uniform(R,"3f","lightOP"+e+".position",[0,11,0]),specular:new CGL.Uniform(R,"3f","lightOP"+e+".specular",[1,1,1]),lightProperties:new CGL.Uniform(R,"4f","lightOP"+e+".lightProperties",[1,1,1,1]),conePointAt:new CGL.Uniform(R,"3f","lightOP"+e+".conePointAt",vec3.create()),spotProperties:new CGL.Uniform(R,"3f","lightOP"+e+".spotProperties",[0,0,0,0]),castLight:new CGL.Uniform(R,"i","lightOP"+e+".castLight",1)}}}}function qe(){if(r.tempData.lightStack){let t=se!==r.tempData.lightStack.length;if(!t){for(let e=0;e<r.tempData.lightStack.length;e++){if(P[e]!=r.tempData.lightStack[e]){t=true;break}}}if(t){P.length=0;for(let e=0;e<r.tempData.lightStack.length;e++)P[e]=r.tempData.lightStack[e];Xe();se=r.tempData.lightStack.length}}}function He(){if(!R)Xe();r.pushShader(R);let e=false;R.popTextures();let t=0;if(r.tempData.lightStack)t=r.tempData.lightStack.length;if((!r.tempData.pbrEnvStack||r.tempData.pbrEnvStack.length==0)&&!N.isLinked()&&t==0){e=true;i.setUiError("deflight","Default light is enabled. Please add lights or PBREnvironmentLights to your patch to make this warning disappear.",1)}else i.setUiError("deflight",null);if(r.tempData.pbrEnvStack&&r.tempData.pbrEnvStack.length>0&&r.tempData.pbrEnvStack[r.tempData.pbrEnvStack.length-1].texIBLLUT.tex&&r.tempData.pbrEnvStack[r.tempData.pbrEnvStack.length-1].texDiffIrr.tex&&r.tempData.pbrEnvStack[r.tempData.pbrEnvStack.length-1].texPreFiltered.tex){const n=r.tempData.pbrEnvStack[r.tempData.pbrEnvStack.length-1];Oe.setValue(n.intensity);R.pushTexture(de,n.texIBLLUT.tex);R.pushTexture(he,n.texDiffIrr.tex,r.gl.TEXTURE_CUBE_MAP);R.pushTexture(fe,n.texPreFiltered.tex,r.gl.TEXTURE_CUBE_MAP);ve.setValue(n.texPreFilteredMipLevels||7);R.toggleDefine("USE_PARALLAX_CORRECTION",n.UseParallaxCorrection);if(n.UseParallaxCorrection){Fe.setValue(n.PCOrigin);Ge.setValue(n.PCboxMin);Ue.setValue(n.PCboxMax)}De(true)}else{De(false)}if(e){const a=mat4.create();mat4.invert(a,r.vMatrix);oe[0].position=[a[12],a[13],a[14]];r.tempData.lightStack=oe}if(_.get()){De(true);R.pushTexture(de,_.get().tex);ve.setValue(y.get());if(T.get())R.pushTexture(he,T.get().cubemap,r.gl.TEXTURE_CUBE_MAP);if(I.get())R.pushTexture(fe,I.get().cubemap,r.gl.TEXTURE_CUBE_MAP)}if(A.get())R.pushTexture(le,A.get().tex);if(S.get())R.pushTexture(ue,S.get().tex);if(E.get())R.pushTexture(me,E.get().tex);if(C.get())R.pushTexture(pe,C.get().tex);if(j.get())R.pushTexture(_e,j.get().tex);if(N.get())R.pushTexture(Te,N.get().tex);if(c.get())R.pushTexture(ce,c.get().tex);if(L.get())R.pushTexture(ye,L.get().tex);qe();ze();J.trigger();r.popShader();if(e)r.tempData.lightStack=[]}};Ops.Gl.Pbr.PbrMaterial.prototype=new CABLES.Op;CABLES.OPS["a5234947-f65a-41e2-a691-b81382903a71"]={f:Ops.Gl.Pbr.PbrMaterial,objName:"Ops.Gl.Pbr.PbrMaterial"};Ops.Ui.SubPatchInput=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};t.innerInput=true;const n=t.inTriggerButton("Goto SubPatchOp");n.setUiAttribs({hidePort:true});n.onTriggered=()=>{const e=t.patch.getSubPatchOuterOp(t.uiAttribs.subPatch);gui.patchView.centerSelectOp(e.id)}};Ops.Ui.SubPatchInput.prototype=new CABLES.Op;CABLES.OPS["c4e4e933-136e-479e-8de8-0b35b75d9217"]={f:Ops.Ui.SubPatchInput,objName:"Ops.Ui.SubPatchInput"};Ops.Ui.SubPatchOutput=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};e.innerOutput=true};Ops.Ui.SubPatchOutput.prototype=new CABLES.Op;CABLES.OPS["02d45073-7936-4830-81ad-59a162febf1f"]={f:Ops.Ui.SubPatchOutput,objName:"Ops.Ui.SubPatchOutput"};Ops.WebAudio.AudioBuffer_v2=function(){CABLES.Op.apply(this,arguments);const a=this;const e=a.attachments={};const i=a.patch.cgl;const t=CABLES.WEBAUDIO.createAudioContext(a),n=a.inUrl("URL","audio"),r=a.inBool("Create Loading Task",true),s=a.outObject("Audio Buffer",null,"audioBuffer"),o=a.outBoolNum("Finished Loading",false),l=a.outNumber("Sample Rate",0),u=a.outNumber("Length",0),m=a.outNumber("Duration",0),p=a.outNumber("Number of Channels",0),c=a.outBool("isLoading",0);let d=null;let h=false;let f=null;let v=null;let g=false;let b=false;let x=false;let O=new FileReader;let _=null;let T=0;if(!s.isLinked()){a.setUiError("notConnected","To play back sound, connect this op to a playback operator such as SamplePlayer or AudioBufferPlayer.",0)}else{a.setUiError("notConnected",null)}s.onLinkChanged=()=>{if(s.isLinked()){a.setUiError("notConnected",null)}else{a.setUiError("notConnected","To play back sound, connect this op to a playback operator such as SamplePlayer or AudioBufferPlayer.",0)}};function I(t,e){f=t;h=true;c.set(h);if(!e){const n=t.substr(t.lastIndexOf(".")+1);if(n==="wav"){a.setUiError("wavFormat","You are using a .wav file. Make sure the .wav file is 16 bit to be supported by all browsers. Safari does not support 24 bit .wav files.",1)}else{a.setUiError("wavFormat",null)}CABLES.WEBAUDIO.loadAudioFile(a.patch,t,S,E,r.get())}else{let e=y(t);if(e.type==="audio/wav"){a.setUiError("wavFormat","You are using a .wav file. Make sure the .wav file is 16 bit to be supported by all browsers. Safari does not support 24 bit .wav files.",1)}else{a.setUiError("wavFormat",null)}if(r.get()){T=i.patch.loading.start("audiobuffer from data-url "+a.id,t,a);if(i.patch.isEditorMode())gui.jobs().start({id:"loadaudio"+T,title:" loading audio data url ("+a.id+")"})}O.readAsArrayBuffer(e)}}function y(e){let t=atob(e.split(",")[1]);let n=e.split(",")[0].split(":")[1].split(";")[0];let a=new ArrayBuffer(t.length);let i=new Uint8Array(a);for(let e=0;e<t.length;e++){i[e]=t.charCodeAt(e)}let r=new Blob([a],{type:n});return r}n.onChange=function(){if(n.get()){b=String(n.get()).indexOf("data:")==0;if(h){x=String(n.get()).indexOf("data:")==0;const t=x?n.get():a.patch.getFilePath(n.get());if(t!==f){v=t}else{v=null}g=false;return}C();const e=b?n.get():a.patch.getFilePath(n.get());I(e,b)}else{if(h){g=true;return}C();a.setUiError("wavFormat",null);a.setUiError("failedLoading",null)}};O.onloadend=()=>{_=O.result;i.patch.loading.finished(T);if(i.patch.isEditorMode())gui.jobs().finish("loadaudio"+T);A()};function A(){if(_)t.decodeAudioData(_,S,E)}function S(e){h=false;c.set(h);if(g){C();g=false;return}if(v){I(v,x);v=null}else{d=e;u.set(e.length);m.set(e.duration);p.set(e.numberOfChannels);l.set(e.sampleRate);s.set(e);a.setUiError("failedLoading",null);o.set(true);b=false;x=false}}function E(e){a.setUiError("failedLoading","The audio file could not be loaded. Make sure the right file URL is used.",2);h=false;C();c.set(h);d=null;if(v){I(v,x);v=null}}function C(){u.set(0);m.set(0);p.set(0);l.set(0);s.set(null);o.set(false)}};Ops.WebAudio.AudioBuffer_v2.prototype=new CABLES.Op;CABLES.OPS["5f1d6a2f-1c04-4744-b0fb-910825beceee"]={f:Ops.WebAudio.AudioBuffer_v2,objName:"Ops.WebAudio.AudioBuffer_v2"};Ops.WebAudio.AudioBufferPlayer_v2=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const a=n.inObject("Audio Buffer",null,"audioBuffer");const i=n.inBool("Start / Stop",false);const r=n.inBool("Loop",false);const t=n.inTriggerButton("Restart");const s=n.inFloat("Offset",0);const o=n.inFloat("Playback Rate",1);const l=n.inFloat("Detune",0);n.setPortGroup("Playback Controls",[i,r,t]);n.setPortGroup("Time Controls",[s]);n.setPortGroup("Miscellaneous",[o,l]);const u=n.outObject("Audio Out",null,"audioNode");const m=n.outBool("Is Playing",false);const p=n.outBool("Loading",false);let c=null;let d=false;let h=false;let f=null;let v=null;let g=false;const b=CABLES.WEBAUDIO.createAudioContext(n);const x=b.createGain();if(!a.isLinked()){n.setUiError("inputNotConnected","To be able to play back sound, you need to connect an AudioBuffer to this op.",0)}else{n.setUiError("inputNotConnected",null)}a.onLinkChanged=()=>{if(!a.isLinked()){n.setUiError("inputNotConnected","To be able to play back sound, you need to connect an AudioBuffer to this op.",0)}else{n.setUiError("inputNotConnected",null)}};if(!u.isLinked()){n.setUiError("outputNotConnected","To be able to hear sound playing, you need to connect this op to an Output op.",0)}else{n.setUiError("outputNotConnected",null)}u.onLinkChanged=()=>{if(!u.isLinked()){n.setUiError("outputNotConnected","To be able to hear sound playing, you need to connect this op to an Output op.",0)}else{n.setUiError("outputNotConnected",null)}};a.onChange=function(){if(a.get())I();else{if(g){g=false;p.set(g)}if(d){C(0);if(c)c.buffer=null;c=null}}};i.onChange=function(){if(!a.get())return;if(!c){if(!g)I()}if(i.get()){const e=0;S(e)}else{const t=0;C(t)}};r.onChange=function(){if(c){c.loop=!!r.get()}};l.onChange=O;function O(){if(!c)return;const e=l.get()||0;if(c.detune){c.detune.setValueAtTime(e,b.currentTime)}}o.onChange=_;function _(){if(!c)return;const e=o.get()||0;if(e>=c.playbackRate.minValue&&e<=c.playbackRate.maxValue){c.playbackRate.setValueAtTime(e,b.currentTime)}}let T=false;t.onTriggered=function(){if(!c)return;if(!a.get())return;else{if(!(a.get()instanceof AudioBuffer))return}if(i.get()){if(d){T=true;C(0)}else{S(0)}}};function I(e=false){if(g)return;if(!(a.get()instanceof AudioBuffer))return;g=true;p.set(g);if(c){c.onended=null;if(c.buffer){C(0);c.disconnect(x);c.buffer=null}c=null}c=b.createBufferSource();const t=a.get();if(!t){g=false;p.set(g);return}c.buffer=t;c.onended=j;c.loop=r.get();c.connect(x);_();O();u.set(x);g=false;p.set(g);if(T){S(0);T=false;return}if(i.get()&&!e){S(0)}}let y=false;let A=null;s.onChange=()=>{if(s.get()>=0)n.setUiError("offsetNegative",null);else{n.setUiError("offsetNegative","Offset cannot be negative. Setting to 0.",1)}if(c){if(c.buffer){if(s.get()>c.buffer.duration){n.setUiError("offsetTooLong","Your offset value is higher than the total time of your audio file. Please decrease the duration to be able to hear sound when playing back your buffer.",1)}else{n.setUiError("offsetTooLong",null)}}}};function S(t){try{if(c){let e=Math.max(0,s.get());c.start(t,e);d=true;h=false;m.set(true)}else{n.log("start() but no src...")}}catch(e){n.log("Error on start: ",e.message);m.set(false);d=false}}function E(){let e=!r.get();I(e)}function C(e){try{if(c){c.stop();if(!T)E()}d=false;m.set(false)}catch(e){n.setUiError(e);m.set(false)}}function j(){if(r.get()){d=true;h=false}else{d=false;h=true}m.set(d);E()}};Ops.WebAudio.AudioBufferPlayer_v2.prototype=new CABLES.Op;CABLES.OPS["3abd0dbb-eeee-4c65-ae31-b8bc2345e2d5"]={f:Ops.WebAudio.AudioBufferPlayer_v2,objName:"Ops.WebAudio.AudioBufferPlayer_v2"};Ops.WebAudio.Output_v2=function(){CABLES.Op.apply(this,arguments);const i=this;const e=i.attachments={};const t=i.inObject("Audio In",null,"audioNode"),r=i.inFloatSlider("Volume",1),s=i.inBool("Mute",false),n=i.inBool("Show Audio Suspended Button",true),o=i.outNumber("Current Volume",0),a=i.outString("Context State","unknown");i.setPortGroup("Volume Settings",[s,r]);let l=false;let u=CABLES.WEBAUDIO.createAudioContext(i);let m=u.createGain();const p=u.destination;let c=null;let d=false;s.onChange=()=>{g(s.get());b()};r.onChange=v;i.onMasterVolumeChanged=v;let h=i.patch.on("pause",v);let f=i.patch.on("resume",v);u.addEventListener("statechange",b);n.onChange=x;b();x();i.onDelete=()=>{if(m)m.disconnect();m=null;if(CABLES.interActionNeededButton)CABLES.interActionNeededButton.remove("audiosuspended");if(h)i.patch.off(h);if(f)i.patch.off(f)};t.onChange=function(){if(!t.get()){if(c){try{if(c.disconnect){c.disconnect(m)}}catch(e){i.logError(e)}}i.setUiError("multipleInputs",null);if(d){if(m)m.disconnect(p);d=false}}else{if(t.links.length>1)i.setUiError("multipleInputs","You have connected multiple inputs. It is possible that you experience unexpected behaviour. Please use a Mixer op to connect multiple audio streams.",1);else i.setUiError("multipleInputs",null);if(t.get().connect)t.get().connect(m)}c=t.get();if(!d){if(m)m.connect(p);d=true}v()};function v(e){const t=i.patch.config.masterVolume||0;let n=r.get()*t;if(i.patch._paused||s.get())n=0;let a=.05;if(e)a=.2;n=CABLES.clamp(n,0,1);if(!m)i.logError("gainNode undefined");if(m)m.gain.linearRampToValueAtTime(n,u.currentTime+a);o.set(n)}function g(e){if(e){if(u.state==="suspended"){if(m){m.gain.cancelScheduledValues(u.currentTime);m.gain.value=0;m.gain.setValueAtTime(0,u.currentTime)}o.set(0);return}}v(true)}function b(){a.set(u.state);i.logVerbose("audioCtx.state change",u.state);i.setUiError("ctxSusp",null);if(u.state=="suspended"){const t="Your Browser suspended audio context, use playButton op to play audio after a user interaction";let e=1;if(s.get())e=0;i.setUiError("ctxSusp",t,e)}x()}function x(){if(u.state=="suspended"){g(true);if(n.get()){l=true;if(CABLES.interActionNeededButton){CABLES.interActionNeededButton.add(i.patch,"audiosuspended",()=>{if(u&&u.state=="suspended"){u.resume();if(CABLES.interActionNeededButton)CABLES.interActionNeededButton.remove("audiosuspended")}})}}else{if(CABLES.interActionNeededButton)CABLES.interActionNeededButton.remove("audiosuspended")}}else{if(CABLES.interActionNeededButton)CABLES.interActionNeededButton.remove("audiosuspended");if(l){i.log("was suspended - set vol");v(true)}}}};Ops.WebAudio.Output_v2.prototype=new CABLES.Op;CABLES.OPS["90b95403-b0c4-4980-ab3b-b6c354771c81"]={f:Ops.WebAudio.Output_v2,objName:"Ops.WebAudio.Output_v2"};Ops.Extension.Mediapipe.MpHandTracking=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inObject("Element",null,"element"),a=e.inFloatSlider("Min Confidence Detect",.5),i=e.inFloatSlider("Min Confidence Tracking",.5),r=e.outObject("Result"),s=e.outNumber("Found Hands");const o=new Hands({locateFile:e=>{return`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1/${e}`}});let l=null;u();i.onChange=a.onChange=u;n.onChange=()=>{if(!n.get())return;l=new Camera(n.get(),{onFrame:async()=>{const e=n.get();if(e)await o.send({image:e})},width:n.get().width,height:n.get().height});l.start()};function u(){o.setOptions({maxNumHands:2,minDetectionConfidence:a.get(),minTrackingConfidence:i.get()})}o.onResults(e=>{if(e&&e.multiHandedness){s.set(e.multiHandedness.length)}else{s.set(0)}r.set(e)})};Ops.Extension.Mediapipe.MpHandTracking.prototype=new CABLES.Op;CABLES.OPS["5251e50f-abaf-4ca3-a809-61f8ca58ec35"]={f:Ops.Extension.Mediapipe.MpHandTracking,objName:"Ops.Extension.Mediapipe.MpHandTracking"};Ops.Gl.Textures.WebcamTexture_v3=function(){CABLES.Op.apply(this,arguments);const t=this;const k=t.attachments={texcopy_frag:"UNI sampler2D tex;\nIN vec2 texCoord;\n\n\nvoid main()\n{\n    vec2 tc=vec2(texCoord.x,texCoord.y);\n\n    #ifdef FLIPX\n        tc.x=1.0-texCoord.x;\n    #endif\n    #ifdef FLIPY\n        tc.y=1.0-texCoord.y;\n    #endif\n    outColor=texture(tex,tc);\n}"};const e=t.inTrigger("Render"),n=t.inBool("Active",true),r=t.inValueBool("Generate Texture",true),s=t.inDropDown("Webcam Input",["Default"],"Default"),o=t.inValueInt("Requested Width",1280),l=t.inValueInt("Requested Height",720),a=t.inValueBool("Flip X",false),i=t.inValueBool("Flip Y",false),u=t.inValueBool("Show HTML Element",false),m=t.inStringEditor("CSS","z-index:99999;\nposition:absolute;\n","inline-css"),p=t.inValueBool("Element Flip X",false),c=t.inValueBool("Element Flip Y",false),F=t.outTrigger("Next"),d=t.outTexture("Texture"),G=t.outNumber("Ratio"),h=t.outBoolNum("Available"),U=t.outNumber("Size Width"),B=t.outNumber("Size Height"),f=t.outString("Error"),D=t.outObject("HTML Element",null,"element"),V=t.outArray("Available devices"),z=t.outString("Active device"),X=t.outTrigger("Texture updated");t.setPortGroup("Camera",[s,o,l]);t.setPortGroup("Texture",[a,i]);t.setPortGroup("Video Element",[u,m,p,c]);t.toWorkPortsNeedToBeLinked(e);let v=0;const g=t.patch.cgl;const q=CGL.Texture.getEmptyTexture(g);const b=document.createElement("video");const H="webcam"+t.id;b.setAttribute("id",H);b.setAttribute("autoplay","");b.setAttribute("muted","");b.setAttribute("playsinline","");b.setAttribute("style",m.get());t.patch.cgl.canvas.parentElement.parentElement.appendChild(b);let x=null;let O=false;let _=false;let T=false;let I=false;let y=null;let A=null;let S=null;let E=false;let Y=false;let W=null;let C=null;d.set(q);a.onChange=i.onChange=N;s.onChange=o.onChange=l.onChange=w;p.onChange=c.onChange=J;t.onDelete=K;u.onChange=m.onChange=L;Z();L();t.on("loadedValueSet",j);n.onChange=j;function j(){setTimeout(()=>{if(n.get())te()},50)}function N(){if(!C)C=new CGL.CopyTexture(g,"webcamFlippedTexture",{shader:k.texcopy_frag});C.bgShader.toggleDefine("FLIPX",a.get());C.bgShader.toggleDefine("FLIPY",!i.get())}function Z(){if(x)x.delete();x=new CGL.Texture(g,{name:"webcam"});if(b)x.setSize(b.videoWidth,b.videoHeight)}function K(){if(b)b.remove()}function L(){if(!u.get())b.setAttribute("style","display:none;");else b.setAttribute("style",m.get());m.setUiAttribs({greyout:!u.get()});p.setUiAttribs({greyout:!u.get()});c.setUiAttribs({greyout:!u.get()})}function J(){if(p.get()&&!c.get())b.style.transform="scaleX(-1)";else if(!p.get()&&c.get())b.style.transform="scaleY(-1)";else if(p.get()&&c.get())b.style.transform="scale(-1, -1)";else b.style.transform="unset"}function M(e){if(T&&I){if(e){E=true;b.play()}else{E=false;b.pause()}}}r.onChange=()=>{M(r.get())};function Q(){g.gl.bindTexture(g.gl.TEXTURE_2D,x.tex);g.gl.texImage2D(g.gl.TEXTURE_2D,0,g.gl.RGBA,g.gl.RGBA,g.gl.UNSIGNED_BYTE,b);g.gl.bindTexture(g.gl.TEXTURE_2D,null);if(!C)N();if(C)d.setRef(C.copy(x))}function $(){if(!A)return;M(false);h.set(false);A.getTracks().forEach(e=>{e.stop()});A=null}function R(i){A=i;b.srcObject=i;b.onloadedmetadata=e=>{z.set(i.getTracks()[0].label);if(s.get()!="Default"&&i.getTracks()[0].label!=s.get()&&v<3){v++;return w()}const t=i.getTracks()[0].getSettings();_=false;const n=t.width||o.get();const a=t.height||l.get();B.set(a);U.set(n);G.set(t.aspectRatio||n/a);f.set("");b.setAttribute("width",t.width);b.setAttribute("height",t.height);D.set(b);x.setSize(n,a);h.set(true);M(r.get())}}function ee(){const e=P();const t=e.video.width==b.videoWidth&&e.video.height==b.videoHeight;return t}function P(){let n={audio:false,video:{}};if(I){let t=s.get();let e=null;if(!t||t==="Default"||t==="..."){e=Object.values(S)[0]}else{e=S.filter(e=>{return e.label===t});if(e){e=e[0]}else{e=Object.values(S)[t]}if(!e){e=Object.values(S)[0]}}n.video={deviceId:{exact:e.deviceId}}}const e=o.get();const t=l.get();let a={min:640};let i={min:480};if(e)a.ideal=e;if(t)i.ideal=t;n.video.width=a;n.video.height=i;return n}function w(){if(!n.get())return;$();_=true;const e=P();navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia;if(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){navigator.mediaDevices.getUserMedia(e).then(R).catch(e=>{_=false;t.logError(e.name+": "+e.message,e);f.set(e.name+": "+e.message)})}else if(navigator.getUserMedia){_=false;navigator.getUserMedia(e,R,()=>{return h.set(false)})}}function te(){if(!n.get())return;O=true;if(y)g.patch.loading.finished(y);y=g.patch.loading.start("Webcam inputs","",t);const e=P();navigator.mediaDevices.getUserMedia(e).then(e=>{return navigator.mediaDevices.enumerateDevices()}).then(e=>{S=e.filter(e=>{return e.kind==="videoinput"});O=false;s.uiAttribs.values=S.map((e,t)=>{return e.label||t});s.uiAttribs.values.unshift("Default");V.set(s.uiAttribs.values);g.patch.loading.finished(y);I=true;w();T=true}).catch(e=>{O=false;t.error("error",e);f.set(e.name+": "+e.message);g.patch.loading.finished(y);I=false})}e.onTriggered=()=>{if(!O&&n.get()){if(T&&I&&E){Q();X.trigger()}if(!T&&I){w()}}F.trigger()}};Ops.Gl.Textures.WebcamTexture_v3.prototype=new CABLES.Op;CABLES.OPS["71c0468d-e942-4574-a91d-b3d7271922d0"]={f:Ops.Gl.Textures.WebcamTexture_v3,objName:"Ops.Gl.Textures.WebcamTexture_v3"};Ops.Extension.Mediapipe.MpHand=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const o=e.inObject("Hands Result"),l=e.inSwitch("Hand",["Left","Right"],"Left"),u=e.inFloatSlider("Min Score",.2),m=e.outArray("Points"),p=e.outArray("Lines"),c=e.outObject("Data"),d=e.outBoolNum("Found Hand"),h=e.outNumber("Score");function f(e){const t=[];t.push(e[0*3+0],e[0*3+1],e[0*3+2]);t.push(e[1*3+0],e[1*3+1],e[1*3+2]);t.push(e[1*3+0],e[1*3+1],e[1*3+2]);t.push(e[2*3+0],e[2*3+1],e[2*3+2]);t.push(e[2*3+0],e[2*3+1],e[2*3+2]);t.push(e[3*3+0],e[3*3+1],e[3*3+2]);t.push(e[3*3+0],e[3*3+1],e[3*3+2]);t.push(e[4*3+0],e[4*3+1],e[4*3+2]);t.push(e[0*3+0],e[0*3+1],e[0*3+2]);t.push(e[5*3+0],e[5*3+1],e[5*3+2]);t.push(e[5*3+0],e[5*3+1],e[5*3+2]);t.push(e[9*3+0],e[9*3+1],e[9*3+2]);t.push(e[9*3+0],e[9*3+1],e[9*3+2]);t.push(e[13*3+0],e[13*3+1],e[13*3+2]);t.push(e[13*3+0],e[13*3+1],e[13*3+2]);t.push(e[17*3+0],e[17*3+1],e[17*3+2]);t.push(e[17*3+0],e[17*3+1],e[17*3+2]);t.push(e[0*3+0],e[0*3+1],e[0*3+2]);t.push(e[5*3+0],e[5*3+1],e[5*3+2]);t.push(e[6*3+0],e[6*3+1],e[6*3+2]);t.push(e[6*3+0],e[6*3+1],e[6*3+2]);t.push(e[7*3+0],e[7*3+1],e[7*3+2]);t.push(e[7*3+0],e[7*3+1],e[7*3+2]);t.push(e[8*3+0],e[8*3+1],e[8*3+2]);t.push(e[9*3+0],e[9*3+1],e[9*3+2]);t.push(e[10*3+0],e[10*3+1],e[10*3+2]);t.push(e[10*3+0],e[10*3+1],e[10*3+2]);t.push(e[11*3+0],e[11*3+1],e[11*3+2]);t.push(e[11*3+0],e[11*3+1],e[11*3+2]);t.push(e[12*3+0],e[12*3+1],e[12*3+2]);t.push(e[13*3+0],e[13*3+1],e[13*3+2]);t.push(e[14*3+0],e[14*3+1],e[14*3+2]);t.push(e[14*3+0],e[14*3+1],e[14*3+2]);t.push(e[15*3+0],e[15*3+1],e[15*3+2]);t.push(e[15*3+0],e[15*3+1],e[15*3+2]);t.push(e[16*3+0],e[16*3+1],e[16*3+2]);t.push(e[17*3+0],e[17*3+1],e[17*3+2]);t.push(e[18*3+0],e[18*3+1],e[18*3+2]);t.push(e[18*3+0],e[18*3+1],e[18*3+2]);t.push(e[19*3+0],e[19*3+1],e[19*3+2]);t.push(e[19*3+0],e[19*3+1],e[19*3+2]);t.push(e[20*3+0],e[20*3+1],e[20*3+2]);return t}o.onChange=()=>{let t=[];let e=[];let n=null;let a=null;let i=o.get();if(i&&i.multiHandedness){}else{d.set(false);h.set(0);return}let r=0;let s=false;if(i.multiHandedness){for(let e=0;e<i.multiHandedness.length;e++){if(i.multiHandedness[e].label==l.get()){r=e;h.set(i.multiHandedness[e].score);s=true}}}if(s&&h.get()>u.get()){d.set(true);if(i&&i.multiHandLandmarks&&i.multiHandLandmarks[r]){for(let e=0;e<i.multiHandLandmarks[r].length;e++){t[e*3]=(i.multiHandLandmarks[r][e].x-.5)*2;t[e*3+1]=-1*(i.multiHandLandmarks[r][e].y-.5)*2;t[e*3+2]=0}n=f(t);m.set(t);p.set(n);c.set(i.multiHandLandmarks[r])}}else{c.set(null);m.set(null);p.set(null);d.set(false)}}};Ops.Extension.Mediapipe.MpHand.prototype=new CABLES.Op;CABLES.OPS["935b0d02-1dce-4d5c-87a8-f1fa36c5d25e"]={f:Ops.Extension.Mediapipe.MpHand,objName:"Ops.Extension.Mediapipe.MpHand"};Ops.Extension.Mediapipe.MpHandCoordinate=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=["WRIST","THUMB_CMC","THUMB_MCP","THUMB_IP","THUMB_TIP","INDEX_FINGER_MCP","INDEX_FINGER_PIP","INDEX_FINGER_DIP","INDEX_FINGER_TIP","MIDDLE_FINGER_MCP","MIDDLE_FINGER_PIP","MIDDLE_FINGER_DIP","MIDDLE_FINGER_TIP","RING_FINGER_MCP","RING_FINGER_PIP","RING_FINGER_DIP","RING_FINGER_TIP","PINKY_MCP","PINKY_PIP","PINKY_DIP","PINKY_TIP"];const a=e.inArray("Hand Points"),i=e.inDropDown("Joint",n,"WRIST"),r=e.outNumber("X"),s=e.outNumber("Y"),o=e.outNumber("Z");let l=0;i.onChange=()=>{l=n.indexOf(i.get());u()};a.onChange=u;function u(){const e=a.get();if(e&&e.length>l*3){r.set(e[l*3+0]);s.set(e[l*3+1]);o.set(e[l*3+2])}}};Ops.Extension.Mediapipe.MpHandCoordinate.prototype=new CABLES.Op;CABLES.OPS["d3adef3d-5c99-48fd-86f0-48ec4a290afb"]={f:Ops.Extension.Mediapipe.MpHandCoordinate,objName:"Ops.Extension.Mediapipe.MpHandCoordinate"};Ops.Anim.Smooth=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTrigger("Update"),a=e.inBool("Separate inc/dec",false),i=e.inValue("Value"),r=e.outTrigger("Next"),s=e.inValue("Inc factor",4),o=e.inValue("Dec factor",4),l=e.outNumber("Result",0);let u=0;let m=0;let p=0;let c=0;e.toWorkPortsNeedToBeLinked(n);let d;let h;let f=4;let v=true;let g=0;const b=0;const x=1;O();_();a.setUiAttribs({hidePort:true});s.onChange=o.onChange=_;a.onChange=O;T();function O(){const e=a.get();if(!e)g=b;else g=x;if(g==b){o.setUiAttribs({greyout:true});s.setUiAttribs({title:"Inc/Dec factor"})}else if(g==x){o.setUiAttribs({greyout:false});s.setUiAttribs({title:"Inc factor"})}_();T()}function _(){if(g==b){d=s.get();h=s.get()}else if(g==x){d=s.get();h=o.get()}if(d<=.2||d!=d)d=.2;if(h<=.2||h!=h)h=.2}i.onChange=function(){v=false;let e=m;m=i.get()};s.onChange=function(){_()};function T(){let e=1;if(performance.now()-c>500||c===0)u=i.get()||0;else e=(performance.now()-c)/(performance.now()-c);c=performance.now();if(u!=u)u=0;if(f<=0)f=1e-4;const t=m-u;if(t>=0)u+=t/(h*e);else u+=t/(d*e);if(Math.abs(t)<1e-5)u=m;if(f!=f)u=0;if(u!=u||u==-Infinity||u==Infinity)u=i.get();if(p!=u){l.set(u);p=u}if(u==m&&!v){v=true;l.set(u)}r.trigger()}n.onTriggered=function(){T()}};Ops.Anim.Smooth.prototype=new CABLES.Op;CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"]={f:Ops.Anim.Smooth,objName:"Ops.Anim.Smooth"};Ops.Math.MapRange=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const c=e.inValueFloat("value",0),d=e.inValueFloat("old min",0),h=e.inValueFloat("old max",1),f=e.inValueFloat("new min",0),v=e.inValueFloat("new max",1),n=e.inValueSelect("Easing",["Linear","Smoothstep","Smootherstep"],"Linear"),a=e.inBool("Clamp",true),g=e.outNumber("result",0);e.setPortGroup("Input Range",[d,h]);e.setPortGroup("Output Range",[f,v]);let b=true;let x=0;let O=0;c.onChange=d.onChange=h.onChange=f.onChange=v.onChange=i;i();a.onChange=()=>{b=a.get();i()};n.onChange=function(){if(n.get()=="Smoothstep")x=1;else if(n.get()=="Smootherstep")x=2;else x=0};function i(){const e=f.get();const t=v.get();const n=d.get();const a=h.get();let i=c.get();if(b){if(i>=Math.max(a,n)){g.set(t);return}else if(i<=Math.min(a,n)){g.set(e);return}}let r=false;const s=Math.min(n,a);const o=Math.max(n,a);if(s!=n)r=true;let l=false;const u=Math.min(e,t);const m=Math.max(e,t);if(u!=e)l=true;let p=0;if(r)p=(o-i)*(m-u)/(o-s);else p=(i-s)*(m-u)/(o-s);if(l)O=m-p;else O=p+u;if(x===0){g.set(O)}else if(x==1){i=Math.max(0,Math.min(1,(O-e)/(t-e)));g.set(e+i*i*(3-2*i)*(t-e))}else if(x==2){i=Math.max(0,Math.min(1,(O-e)/(t-e)));g.set(e+i*i*i*(i*(i*6-15)+10)*(t-e))}}};Ops.Math.MapRange.prototype=new CABLES.Op;CABLES.OPS["2617b407-60a0-4ff6-b4a7-18136cfa7817"]={f:Ops.Math.MapRange,objName:"Ops.Math.MapRange"};Ops.Gl.Meshes.Rectangle_v4=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.inTrigger("render"),a=t.inValueBool("Render Mesh",true),E=t.inValue("width",1),C=t.inValue("height",1),j=t.inSwitch("pivot x",["left","center","right"],"center"),N=t.inSwitch("pivot y",["top","center","bottom"],"center"),L=t.inSwitch("axis",["xy","xz"],"xy"),M=t.inBool("Flip TexCoord X",false),R=t.inBool("Flip TexCoord Y",true),P=t.inValueInt("num columns",1),w=t.inValueInt("num rows",1),i=t.outTrigger("trigger"),k=t.outObject("geometry",null,"geometry");k.ignoreValueSerialize=true;const F=new CGL.Geometry("rectangle");a.setUiAttribs({title:"Render"});n.setUiAttribs({title:"Trigger"});i.setUiAttribs({title:"Next"});t.setPortGroup("Pivot",[j,N,L]);t.setPortGroup("Size",[E,C]);t.setPortGroup("Structure",[P,w]);t.toWorkPortsNeedToBeLinked(n);t.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose",CABLES.OP_PORT_TYPE_TRIGGER);const G=0;const U=1;let B=G;let D=null;let V=true;let z=true;const r=vec3.create();vec3.set(r,1,1,1);L.onChange=j.onChange=N.onChange=M.onChange=R.onChange=w.onChange=P.onChange=s;X();E.onChange=C.onChange=()=>{if(z)X();else V=true};function X(){if(B===G)vec3.set(r,E.get(),C.get(),1);if(B===U)vec3.set(r,E.get(),1,C.get())}k.onLinkChanged=()=>{z=!k.isLinked();X();V=true};function s(){V=true}n.onTriggered=()=>{if(V)o();const e=t.patch.cg;if(e&&D&&a.get()){if(z){e.pushModelMatrix();mat4.scale(e.mMatrix,e.mMatrix,r)}D.render(e.getShader());if(z)e.popModelMatrix()}i.trigger()};t.onDelete=()=>{if(D)D.dispose();s()};function o(){if(L.get()=="xy")B=G;if(L.get()=="xz")B=U;X();let n=E.get();let a=C.get();if(z)n=a=1;let i=0;let r=0;if(j.get()=="center")i=0;else if(j.get()=="right")i=-n/2;else if(j.get()=="left")i=+n/2;if(N.get()=="center")r=0;else if(N.get()=="top")r=-a/2;else if(N.get()=="bottom")r=+a/2;const s=Math.max(1,Math.round(w.get()));const o=Math.max(1,Math.round(P.get()));const l=n/o;const u=a/s;const m=[];const p=new Float32Array((o+1)*(s+1)*2);const c=new Float32Array((o+1)*(s+1)*3);const d=new Float32Array((o+1)*(s+1)*3);const h=new Float32Array((o+1)*(s+1)*3);const f=new Float32Array((o+1)*(s+1)*3);let v=0;let g=0;let b=0;let x=0;let O=0;for(let t=0;t<=s;t++){for(let e=0;e<=o;e++){c[g++]=e*l-n/2+i;if(B==U)c[g++]=0;c[g++]=t*u-a/2+r;if(B==G)c[g++]=0;p[v++]=e/o;p[v++]=t/s;if(B==G){d[b++]=0;d[b++]=0;d[b++]=1;h[x++]=1;h[x++]=0;h[x++]=0;f[O++]=0;f[O++]=1;f[O++]=0}else if(B==U){d[b++]=0;d[b++]=1;d[b++]=0;f[O++]=0;f[O++]=0;f[O++]=1}}}m.length=o*s*6;let _=0;for(let t=0;t<o;t++){for(let e=0;e<s;e++){const T=t+(o+1)*e;const I=T;const y=T+1;const A=T+o+1;const S=T+1+o+1;if(B==G){m[_++]=I;m[_++]=y;m[_++]=A;m[_++]=A;m[_++]=y;m[_++]=S}else if(B==U){m[_++]=I;m[_++]=A;m[_++]=y;m[_++]=y;m[_++]=A;m[_++]=S}}}if(R.get())for(let e=0;e<p.length;e+=2)p[e+1]=1-p[e+1];if(M.get())for(let e=0;e<p.length;e+=2)p[e]=1-p[e];F.clear();F.vertices=c;F.texCoords=p;F.verticesIndices=m;F.vertexNormals=d;F.tangents=h;F.biTangents=f;if(t.patch.cg)if(!D)D=t.patch.cg.createMesh(F,{opId:t.id});else D.setGeom(F);k.setRef(F);V=false}};Ops.Gl.Meshes.Rectangle_v4.prototype=new CABLES.Op;CABLES.OPS["cc8c3ede-7103-410b-849f-a645793cab39"]={f:Ops.Gl.Meshes.Rectangle_v4,objName:"Ops.Gl.Meshes.Rectangle_v4"};Ops.Ui.VizTexture=function(){CABLES.Op.apply(this,arguments);const k=this;const n=k.attachments={viztex_frag:"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI samplerCube cubeMap;\nUNI float width;\nUNI float height;\nUNI float type;\nUNI float time;\n\nfloat LinearizeDepth(float d,float zNear,float zFar)\n{\n    float z_n = 2.0 * d - 1.0;\n    return 2.0 * zNear / (zFar + zNear - z_n * (zFar - zNear));\n}\n\nvoid main()\n{\n    vec4 col=vec4(vec3(0.),0.0);\n\n    vec4 colTex=texture(tex,texCoord);\n\n\n\n    if(type==1.0)\n    {\n        vec4 depth=vec4(0.);\n        vec2 localST=texCoord;\n        localST.y = 1. - localST.y;\n\n        localST.t = mod(localST.t*3.,1.);\n        localST.s = mod(localST.s*4.,1.);\n\n        #ifdef WEBGL2\n            #define texCube texture\n        #endif\n        #ifdef WEBGL1\n            #define texCube textureCube\n        #endif\n\n//         //Due to the way my depth-cubeMap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side\n//         //Inside where top/bottom is to be drawn?\n        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)\n        {\n            //Bottom (-y) quad\n            if (texCoord.t*3. < 1.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1\n                depth = texCube(cubeMap, dir);\n            }\n            //top (+y) quad\n            else if (texCoord.t*3. > 2.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubeMap\n                depth = texCube(cubeMap, dir);\n            }\n            else//Front (-z) quad\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n//         //If not, only these ranges should be drawn\n        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)\n        {\n            if (texCoord.x*4. < 1.)//left (-x) quad\n            {\n                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)\n            {\n                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else //back (+z) quad\n            {\n                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n        // colTex = vec4(vec3(depth),1.);\n        colTex = vec4(depth);\n    }\n\n    if(type==2.0)\n    {\n       float near = 0.1;\n       float far = 50.;\n       float depth = LinearizeDepth(colTex.r, near, far);\n       colTex.rgb = vec3(depth);\n    }\n\n\n\n\n    #ifdef ANIM_RANGE\n\n        if(colTex.r>1.0 || colTex.r<0.0)\n            colTex.r=mod(colTex.r,1.0)*0.5+(sin(colTex.r+mod(colTex.r*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.g>1.0 || colTex.g<0.0)\n            colTex.g=mod(colTex.g,1.0)*0.5+(sin(colTex.g+mod(colTex.g*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n        if(colTex.b>1.0 || colTex.b<0.0)\n            colTex.b=mod(colTex.b,1.0)*0.5+(sin(colTex.b+mod(colTex.b*3.0,1.0)+time*5.0)*0.5+0.5)*0.5;\n\n    #endif\n\n\n    // #ifdef ANIM_RANGE\n    //     if(colTex.r>1.0 || colTex.r<0.0)\n    //     {\n    //         float r=mod( time+colTex.r,1.0)*0.5+0.5;\n    //         colTex.r=r;\n    //     }\n    //     if(colTex.g>1.0 || colTex.g<0.0)\n    //     {\n    //         float r=mod( time+colTex.g,1.0)*0.5+0.5;\n    //         colTex.g=r;\n    //     }\n    //     if(colTex.b>1.0 || colTex.b<0.0)\n    //     {\n    //         float r=mod( time+colTex.b,1.0)*0.5+0.5;\n    //         colTex.b=r;\n    //     }\n    // #endif\n\n    #ifdef MOD_RANGE\n        colTex.r=mod(colTex.r,1.0001);\n        colTex.g=mod(colTex.g,1.0001);\n        colTex.b=mod(colTex.b,1.0001);\n\n    #endif\n\n    #ifdef ALPHA_ONE\n        colTex.a=1.0;\n    #endif\n    #ifdef ALPHA_INV\n        colTex.a=1.0-colTex.a;\n    #endif\n\n    outColor = mix(col,colTex,colTex.a);\n}\n\n",viztex_vert:"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nvoid main()\n{\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mvMatrix=viewMatrix * modelMatrix;\n    gl_Position = projMatrix * mvMatrix * pos;\n}"};const F=k.inTexture("Texture In"),G=k.inBool("Show Info",false),e=k.inSwitch("Visualize outside 0-1",["Off","Anim","Modulo"],"Anim"),t=k.inSwitch("Alpha",["A","1","1-A"],"A"),U=k.inBool("Show Color",false),B=k.inFloatSlider("X",.5),D=k.inFloatSlider("Y",.5),a=k.outTexture("Texture Out"),V=k.outString("Info");k.setUiAttrib({height:150,resizable:true});const z=new CABLES.Timer;let i=null;let X=null;let q=null;let H="";let r=true;t.onChange=e.onChange=o;U.onChange=s;s();if(CABLES.UI){z.play()}function s(){B.setUiAttribs({greyout:!U.get()});D.setUiAttribs({greyout:!U.get()})}F.onChange=()=>{const e=F.get();a.setRef(e);let t="";if(F.get()&&F.isLinked())t=F.links[0].getOtherPort(F).name;k.setUiAttrib({extendTitle:t})};function o(){if(!i)return;i.toggleDefine("MOD_RANGE",e.get()=="Modulo");i.toggleDefine("ANIM_RANGE",e.get()=="Anim");i.toggleDefine("ALPHA_INV",t.get()=="1-A");i.toggleDefine("ALPHA_ONE",t.get()=="1")}k.renderVizLayerGl=(m,p)=>{if(!F.isLinked())return;if(!p.useGl)return;const c=F;const d=5;const h=d+1;const e=CABLES.UI.uiProfiler.start("previewlayer texture");const f=c.op.patch.cgl;if(!this._emptyCubemap)this._emptyCubemap=CGL.Texture.getEmptyCubemapTexture(f);c.op.patch.cgl.profileData.profileTexPreviews++;const v=c.get()||CGL.Texture.getEmptyTexture(f);if(!this._mesh){const t=new CGL.Geometry("vizTexture rect");t.vertices=[1,1,0,-1,1,0,1,-1,0,-1,-1,0];t.texCoords=[1,1,0,1,1,0,0,0];t.verticesIndices=[0,1,2,3,1,2];this._mesh=new CGL.Mesh(f,t)}if(!this._shader){this._shader=new CGL.Shader(f,"glpreviewtex");this._shader.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);this._shader.setSource(n.viztex_vert,n.viztex_frag);this._shaderTexUniform=new CGL.Uniform(this._shader,"t","tex",d);this._shaderTexCubemapUniform=new CGL.Uniform(this._shader,"tc","cubeMap",h);i=this._shader;o();this._shaderTexUniformW=new CGL.Uniform(this._shader,"f","width",v.width);this._shaderTexUniformH=new CGL.Uniform(this._shader,"f","height",v.height);this._shaderTypeUniform=new CGL.Uniform(this._shader,"f","type",0);this._shaderTimeUniform=new CGL.Uniform(this._shader,"f","time",0)}f.pushPMatrix();const g=[v.width,v.height];const b=c.op.patch.cgl.canvasWidth>g[0]&&c.op.patch.cgl.canvasHeight>g[1];if(b){mat4.ortho(f.pMatrix,0,c.op.patch.cgl.canvasWidth,c.op.patch.cgl.canvasHeight,0,.001,11)}else mat4.ortho(f.pMatrix,-1,1,1,-1,.001,11);const x=f.getTexture(d);const O=f.getTexture(h);let _=0;if(v){if(v.cubemap)_=1;if(v.textureType==CGL.Texture.TYPE_DEPTH)_=2;if(_==0||_==2){f.setTexture(d,v.tex);f.setTexture(h,this._emptyCubemap.cubemap,f.gl.TEXTURE_CUBE_MAP)}else if(_==1){f.setTexture(h,v.cubemap,f.gl.TEXTURE_CUBE_MAP)}z.update();this._shaderTimeUniform.setValue(z.get());this._shaderTypeUniform.setValue(_);let t=[c.op.patch.cgl.canvasWidth,c.op.patch.cgl.canvasHeight];f.gl.clearColor(0,0,0,0);f.gl.clear(f.gl.COLOR_BUFFER_BIT|f.gl.DEPTH_BUFFER_BIT);f.pushModelMatrix();if(b){t=g;mat4.translate(f.mMatrix,f.mMatrix,[g[0]/2,g[1]/2,0]);mat4.scale(f.mMatrix,f.mMatrix,[g[0]/2,g[1]/2,0])}this._mesh.render(this._shader);f.popModelMatrix();if(_==0)f.setTexture(d,x);if(_==1)f.setTexture(h,O);f.popPMatrix();f.resetViewPort();const T=[p.width,p.height];const I=false;if(v.width>v.height)T[1]=p.width*g[1]/g[0];else{T[1]=p.width*(g[1]/g[0]);if(T[1]>p.height){const E=p.height/T[1];T[0]*=E;T[1]*=E}}const y=T[0]>g[0]&&T[1]>g[1];m.imageSmoothingEnabled=true;m.fillStyle="#ffffff";m.fillRect(p.x,p.y-10,10,10);m.fillStyle="#000000";m.fillRect(p.x,p.y-10,5,5);m.fillRect(p.x+5,p.y-10+5,5,5);let e=p.height;let n=10*p.width/e;let a=e/10;let i=p.width/n;for(let t=0;t<n;t++)for(let e=0;e<10;e++){if((t+e)%2==0)m.fillStyle="#333333";else m.fillStyle="#393939";m.fillRect(p.x+i*t,p.y+a*e,i,a)}m.fillStyle="#222";const A=(p.width-T[0])/2;const S=(e-T[1])/2;let r=p.x+(p.width-T[0])/2;let s=p.y+(e-T[1])/2;let o=T[0];let l=T[1];if(e-T[1]<0){r=p.x+(p.width-T[0]*e/T[1])/2;s=p.y;o=T[0]*e/T[1];l=e}m.fillRect(p.x,p.y,r-p.x,e);m.fillRect(p.x+o+r-p.x,p.y,o,e);m.fillRect(p.x,p.y,p.width,S);m.fillRect(p.x,p.y+T[1]+S,p.width,S);if(f.canvas&&f.canvasWidth>0&&f.canvasHeight>0&&f.canvas.width>0&&f.canvas.height>0){try{const C=o/t[0]>3||l/t[1]>3;const j=o/t[0]>10||l/t[1]>10;if(g[1]==1){m.imageSmoothingEnabled=false;m.drawImage(f.canvas,0,0,t[0],t[1],p.x,p.y,p.width,e);m.imageSmoothingEnabled=true}else if(g[0]==1){m.imageSmoothingEnabled=false;m.drawImage(f.canvas,0,0,t[0],t[1],p.x,p.y,p.width,e);m.imageSmoothingEnabled=true}else if(T[0]!=0&&T[1]!=0&&p.width!=0&&e!=0&&o!=0&&l!=0){m.imageSmoothingEnabled=!C;m.drawImage(f.canvas,0,0,t[0],t[1],r,s,o,l)}if(j){const N=o/t[0];const L=l/t[1];m.imageSmoothingEnabled=true;m.lineWidth=1;m.globalAlpha=.5;m.beginPath();for(let e=0;e<=t[0];e++){m.moveTo(r+e*N,s);m.lineTo(r+e*N,s+l)}for(let e=0;e<=t[1];e++){m.moveTo(r,s+e*L);m.lineTo(r+o,s+e*L)}m.strokeStyle="#555";m.stroke();m.globalAlpha=1}}catch(e){console.error("canvas drawimage exception...",e)}}let u="";if(c.get()&&c.get().getInfoOneLine)u+=c.get().getInfoOneLine()+"\n";V.set(u);if(U.get()){u+=H+"\n";const M=r+o*B.get();const R=s+l*D.get();m.fillStyle="#000";m.fillRect(M-1,R-10,3,20);m.fillRect(M,R-1,20,3);m.fillStyle="#fff";m.fillRect(M-1,R-10,1,20);m.fillRect(M-10,R-1,20,1)}if(G.get()){k.setUiAttrib({comment:u})}if(U.get()){const P=f.gl;const w=F.get();if(!w){H="";return}if(!X)X=P.createFramebuffer();if(!q)q=new CGL.PixelReader;P.bindFramebuffer(P.FRAMEBUFFER,X);P.framebufferTexture2D(P.FRAMEBUFFER,P.COLOR_ATTACHMENT0,P.TEXTURE_2D,w.tex,0);P.bindFramebuffer(P.FRAMEBUFFER,null);q.read(f,X,w.pixelFormat,B.get()*w.width,w.height-D.get()*w.height,1,1,e=>{if(!CGL.Texture.isPixelFormatFloat(w.pixelFormat)){H="Pixel Float: "+Math.floor(e[0]/255*100)/100;if(!isNaN(e[1]))H+=", "+Math.floor(e[1]/255*100)/100;if(!isNaN(e[2]))H+=", "+Math.floor(e[2]/255*100)/100;if(!isNaN(e[3]))H+=", "+Math.floor(e[3]/255*100)/100;H+="\n";if(w.pixelFormat.indexOf("ubyte")>0){H+="Pixel UByte: ";H+=Math.round(e[0]);if(!isNaN(e[1]))H+=", "+Math.round(e[1]);if(!isNaN(e[2]))H+=", "+Math.round(e[2]);if(!isNaN(e[3]))H+=", "+Math.round(e[3]);H+="\n"}}else{H="Pixel Float: "+Math.round(e[0]*100)/100+", "+Math.round(e[1]*100)/100+", "+Math.round(e[2]*100)/100+", "+Math.round(e[3]*100)/100;H+="\n"}})}}f.gl.clearColor(0,0,0,0);f.gl.clear(f.gl.COLOR_BUFFER_BIT|f.gl.DEPTH_BUFFER_BIT);e.finish()}};Ops.Ui.VizTexture.prototype=new CABLES.Op;CABLES.OPS["4ea2d7b0-ca74-45db-962b-4d1965ac20c0"]={f:Ops.Ui.VizTexture,objName:"Ops.Ui.VizTexture"};Ops.Gl.MainLoop=function(){CABLES.Op.apply(this,arguments);const a=this;const e=a.attachments={};const t=a.inValue("FPS Limit",0),n=a.outTrigger("trigger"),i=a.outNumber("width"),r=a.outNumber("height"),s=a.inValueBool("Reduce FPS not focussed",false),o=a.inValueBool("Reduce FPS loading"),l=a.inValueBool("Clear",true),u=a.inValueBool("ClearAlpha",true),m=a.inValueBool("Fullscreen Button",false),p=a.inValueBool("Active",true),c=a.inValueBool("Hires Displays",false),d=a.inSwitch("Pixel Unit",["Display","CSS"],"Display");a.onAnimFrame=S;c.onChange=function(){if(c.get())a.patch.cgl.pixelDensity=window.devicePixelRatio;else a.patch.cgl.pixelDensity=1;a.patch.cgl.updateSize();if(CABLES.UI)gui.setLayout()};p.onChange=function(){a.patch.removeOnAnimFrame(a);if(p.get()){a.setUiAttrib({extendTitle:""});a.onAnimFrame=S;a.patch.addOnAnimFrame(a);a.log("adding again!")}else{a.setUiAttrib({extendTitle:"Inactive"})}};const h=a.patch.cgl;let f=0;let v=0;let g=null;let b=false;if(!a.patch.cgl)a.uiAttr({error:"No webgl cgl context"});const x=vec3.create();vec3.set(x,0,0,0);const O=vec3.create();vec3.set(O,0,0,-2);m.onChange=A;setTimeout(A,100);let _=null;let T=true;let I=true;window.addEventListener("blur",()=>{T=false});window.addEventListener("focus",()=>{T=true});document.addEventListener("visibilitychange",()=>{I=!document.hidden});E();a.patch.tempData.mainloopOp=this;d.onChange=()=>{i.set(0);r.set(0)};function y(){if(o.get()&&a.patch.loading.getProgress()<1)return 5;if(s.get()){if(!I)return 10;if(!T)return 30}return t.get()}function A(){function e(){if(_)_.style.display="block"}function t(){if(_)_.style.display="none"}a.patch.cgl.canvas.addEventListener("mouseleave",t);a.patch.cgl.canvas.addEventListener("mouseenter",e);if(m.get()){if(!_){_=document.createElement("div");const n=a.patch.cgl.canvas.parentElement;if(n)n.appendChild(_);_.addEventListener("mouseenter",e);_.addEventListener("click",function(e){if(CABLES.UI&&!e.shiftKey)gui.cycleFullscreen();else h.fullScreen()})}_.style.padding="10px";_.style.position="absolute";_.style.right="5px";_.style.top="5px";_.style.width="20px";_.style.height="20px";_.style.cursor="pointer";_.style["border-radius"]="40px";_.style.background="#444";_.style["z-index"]="9999";_.style.display="none";_.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" viewBox="0 0 490 490" style="width:20px;height:20px;" xml:space="preserve" width="512px" height="512px"><g><path d="M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z" fill="#FFFFFF"/><path d="M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z" fill="#FFFFFF"/><path d="M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z" fill="#FFFFFF"/><path d="M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z" fill="#FFFFFF"/></g></svg>'}else{if(_){_.style.display="none";_.remove();_=null}}}a.onDelete=function(){h.gl.clearColor(0,0,0,0);h.gl.clear(h.gl.COLOR_BUFFER_BIT|h.gl.DEPTH_BUFFER_BIT)};function S(e){if(!p.get())return;if(h.aborted||h.canvas.clientWidth===0||h.canvas.clientHeight===0)return;a.patch.cg=h;if(c.get())a.patch.cgl.pixelDensity=window.devicePixelRatio;const t=performance.now();a.patch.config.fpsLimit=y();if(h.canvasWidth==-1){h.setCanvas(a.patch.config.glCanvasId);return}if(h.canvasWidth!=i.get()||h.canvasHeight!=r.get()){let e=1;if(d.get()=="CSS")e=a.patch.cgl.pixelDensity;i.set(h.canvasWidth/e);r.set(h.canvasHeight/e)}if(CABLES.now()-v>1e3){CGL.fpsReport=CGL.fpsReport||[];if(a.patch.loading.getProgress()>=1&&v!==0)CGL.fpsReport.push(f);f=0;v=CABLES.now()}CGL.MESH.lastShader=null;CGL.MESH.lastMesh=null;h.renderStart(h,x,O);if(l.get()){h.gl.clearColor(0,0,0,1);h.gl.clear(h.gl.COLOR_BUFFER_BIT|h.gl.DEPTH_BUFFER_BIT)}n.trigger();if(CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();if(CGL.Texture.previewTexture){if(!CGL.Texture.texturePreviewer)CGL.Texture.texturePreviewer=new CGL.Texture.texturePreview(h);CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture)}h.renderEnd(h);a.patch.cg=null;if(u.get()){h.gl.clearColor(1,1,1,1);h.gl.colorMask(false,false,false,true);h.gl.clear(h.gl.COLOR_BUFFER_BIT);h.gl.colorMask(true,true,true,true)}if(!h.tempData.phong)h.tempData.phong={};f++;a.patch.cgl.profileData.profileMainloopMs=performance.now()-t}function E(){clearTimeout(g);g=setTimeout(()=>{if(a.patch.getOpsByObjName(a.name).length>1){a.setUiError("multimainloop","there should only be one mainloop op!");if(!b)b=a.patch.addEventListener("onOpDelete",E)}else a.setUiError("multimainloop",null,1)},500)}};Ops.Gl.MainLoop.prototype=new CABLES.Op;CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"]={f:Ops.Gl.MainLoop,objName:"Ops.Gl.MainLoop"};Ops.Gl.Meshes.Grid=function(){CABLES.Op.apply(this,arguments);const l=this;const e=l.attachments={};const t=l.inTrigger("Render"),u=l.inInt("Num",10),m=l.inValue("Spacing",1),p=l.inBool("Center",true),c=l.inSwitch("Axis",["XY","XZ"],"XY"),n=l.outTrigger("Next");const d=l.patch.cgl;let h=null;c.onChange=p.onChange=u.onChange=m.onChange=function(){if(h)h.dispose();h=null};function a(){const t=new CGL.Geometry(l.name);const e=new CGL.Geometry(l.name);const n=m.get();const a=Math.floor(u.get());const i=n*a/2;const r=[];let s=-a/2;let o=a/2+1;if(c.get()=="XY")for(let e=s;e<o;e++){t.vertices.push(-i,e*n,0);t.vertices.push(i,e*n,0);t.vertices.push(e*n,-i,0);t.vertices.push(e*n,i,0);r.push(0,0,0,0,0,0,0,0)}else for(let e=s;e<o;e++){t.vertices.push(-i,0,e*n);t.vertices.push(i,0,e*n);t.vertices.push(e*n,0,-i);t.vertices.push(e*n,0,i);r.push(0,0,0,0,0,0,0,0)}if(!p.get()){for(let e=0;e<t.vertices.length;e+=3){t.vertices[e+0]+=i;t.vertices[e+1]+=i}}t.setTexCoords(r);t.calculateNormals();if(!h)h=new CGL.Mesh(d,t);else h.setGeom(t)}t.onTriggered=function(){if(!h)a();let e=d.getShader();if(!e)return;let t=e.glPrimitive;e.glPrimitive=d.gl.LINES;h.render(e);e.glPrimitive=t;n.trigger()}};Ops.Gl.Meshes.Grid.prototype=new CABLES.Op;CABLES.OPS["677a7c03-6885-46b4-8a64-e4ea54ee5d7f"]={f:Ops.Gl.Meshes.Grid,objName:"Ops.Gl.Meshes.Grid"};Ops.Trigger.Sequence=function(){CABLES.Op.apply(this,arguments);const r=this;const e=r.attachments={};const t=r.inTrigger("exe"),n=r.inTriggerButton("Clean up connections");r.setUiAttrib({resizable:true,resizableY:false,stretchPorts:true});const a=[],s=[],i=16;let o=null,l=[];t.onTriggered=p;n.onTriggered=c;n.setUiAttribs({hideParam:true,hidePort:true});for(let t=0;t<i;t++){const d=r.outTrigger("trigger "+t);s.push(d);d.onLinkChanged=m;if(t<i-1){let e=r.inTrigger("exe "+t);e.onTriggered=p;a.push(e)}}u();function u(){l.length=0;for(let e=0;e<s.length;e++)if(s[e].links.length>0)l.push(s[e])}function m(){u();clearTimeout(o);o=setTimeout(()=>{let t=false;for(let e=0;e<s.length;e++)if(s[e].links.length>1)t=true;n.setUiAttribs({hideParam:!t});if(r.isCurrentUiOp())r.refreshParams()},60)}function p(){for(let e=0;e<l.length;e++)l[e].trigger()}function c(){let a=0;for(let n=0;n<s.length;n++){let t=[];if(s[n].links.length>1)for(let e=1;e<s[n].links.length;e++){while(s[a].links.length>0)a++;t.push(s[n].links[e]);const i=s[n].links[e].getOtherPort(s[n]);r.patch.link(r,"trigger "+a,i.op,i.name);a++}for(let e=0;e<t.length;e++)t[e].remove()}m();u()}};Ops.Trigger.Sequence.prototype=new CABLES.Op;CABLES.OPS["a466bc1f-06e9-4595-8849-bffb9fe22f99"]={f:Ops.Trigger.Sequence,objName:"Ops.Trigger.Sequence"};Ops.Sidebar.Sidebar=function(){CABLES.Op.apply(this,arguments);const s=this;const n=s.attachments={style_css:" /*\n * SIDEBAR\n  http://danielstern.ca/range.css/#/\n  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value\n */\n\n.sidebar-icon-undo\n{\n    width:10px;\n    height:10px;\n    background-image: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E\");\n    background-size: 19px;\n    background-repeat: no-repeat;\n    top: -19px;\n    margin-top: -7px;\n}\n\n.icon-chevron-down {\n    top: 2px;\n    right: 9px;\n}\n\n.iconsidebar-chevron-up,.sidebar__close-button {\n\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n}\n\n.iconsidebar-minimizebutton {\n    background-position: 98% center;\n    background-repeat: no-repeat;\n}\n\n.sidebar-cables-right\n{\n    right: 15px;\n    left: initial !important;\n}\n\n.sidebar-cables *\n{\n    color: #BBBBBB !important;\n    font-family: Arial;\n}\n\n.sidebar-cables {\n    --sidebar-color: #07f78c;\n    --sidebar-width: 220px;\n    --sidebar-border-radius: 10px;\n    --sidebar-monospace-font-stack: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n    --sidebar-hover-transition-time: .2s;\n\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    border-radius: var(--sidebar-border-radius);\n    z-index: 100000;\n    width: var(--sidebar-width);\n    max-height: 100%;\n    box-sizing: border-box;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: 13px;\n    line-height: 1em; /* prevent emojis from breaking height of the title */\n}\n\n.sidebar-cables::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar-cables::-webkit-scrollbar {\n    background-color: transparent;\n    --cables-scrollbar-width: 8px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-track {\n    background-color: transparent;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-thumb {\n    background-color: #333333;\n    border-radius: 4px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables--closed {\n    width: auto;\n}\n\n.sidebar__close-button {\n    background-color: #222;\n    /*-webkit-user-select: none;  */\n    /*-moz-user-select: none;     */\n    /*-ms-user-select: none;      */\n    /*user-select: none;          */\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    /*color: #CCCCCC;*/\n    height: 2px;\n    /*border-bottom:20px solid #222;*/\n\n    /*box-sizing: border-box;*/\n    /*padding-top: 2px;*/\n    /*text-align: center;*/\n    /*cursor: pointer;*/\n    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/\n    /*opacity: 1.0;*/\n    /*transition: opacity 0.3s;*/\n    /*overflow: hidden;*/\n}\n\n.sidebar__close-button-icon {\n    display: inline-block;\n    /*opacity: 0;*/\n    width: 20px;\n    height: 20px;\n    /*position: relative;*/\n    /*top: -1px;*/\n\n\n}\n\n.sidebar--closed {\n    width: auto;\n    margin-right: 20px;\n}\n\n.sidebar--closed .sidebar__close-button {\n    margin-top: 8px;\n    margin-left: 8px;\n    padding:10px;\n\n    height: 25px;\n    width:25px;\n    border-radius: 50%;\n    cursor: pointer;\n    opacity: 0.3;\n    background-repeat: no-repeat;\n    background-position: center center;\n    transform:rotate(180deg);\n}\n\n.sidebar--closed .sidebar__group\n{\n    display:none;\n\n}\n.sidebar--closed .sidebar__close-button-icon {\n    background-position: 0px 0px;\n}\n\n.sidebar__close-button:hover {\n    background-color: #111111;\n    opacity: 1.0 !important;\n}\n\n/*\n * SIDEBAR ITEMS\n */\n\n.sidebar__items {\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5;*/\n    background-color: #222;\n    padding-bottom: 20px;\n}\n\n.sidebar--closed .sidebar__items {\n    /* max-height: 0; */\n    height: 0;\n    display: none;\n    pointer-interactions: none;\n}\n\n.sidebar__item__right {\n    float: right;\n}\n\n/*\n * SIDEBAR GROUP\n */\n\n.sidebar__group {\n    /*background-color: #1A1A1A;*/\n    overflow: hidden;\n    box-sizing: border-box;\n    animate: height;\n    /*background-color: #151515;*/\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5s; */\n--sidebar-group-header-height: 33px;\n}\n\n.sidebar__group-items\n{\n    padding-top: 15px;\n    padding-bottom: 15px;\n}\n\n.sidebar__group--closed {\n    /* max-height: 13px; */\n    height: var(--sidebar-group-header-height);\n}\n\n.sidebar__group-header {\n    box-sizing: border-box;\n    color: #EEEEEE;\n    background-color: #151515;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n\n    /*height: 100%;//var(--sidebar-group-header-height);*/\n\n    padding-top: 7px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    cursor: pointer;\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    position: relative;\n}\n\n.sidebar__group-header:hover {\n  background-color: #111111;\n}\n\n.sidebar__group-header-title {\n  /*float: left;*/\n  overflow: hidden;\n  padding: 0 15px;\n  padding-top:5px;\n  padding-bottom:10px;\n  font-weight:bold;\n}\n\n.sidebar__group-header-undo {\n    float: right;\n    overflow: hidden;\n    padding-right: 15px;\n    padding-top:5px;\n    font-weight:bold;\n  }\n\n.sidebar__group-header-icon {\n    width: 17px;\n    height: 14px;\n    background-repeat: no-repeat;\n    display: inline-block;\n    position: absolute;\n    background-size: cover;\n\n    /* icon open */\n    /* feather icon: chevron up */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n    top: 4px;\n    right: 5px;\n    opacity: 0.0;\n    transition: opacity 0.3;\n}\n\n.sidebar__group-header:hover .sidebar__group-header-icon {\n    opacity: 1.0;\n}\n\n/* icon closed */\n.sidebar__group--closed .sidebar__group-header-icon {\n    /* feather icon: chevron down */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);\n    top: 4px;\n    right: 5px;\n}\n\n/*\n * SIDEBAR ITEM\n */\n\n.sidebar__item\n{\n    box-sizing: border-box;\n    padding: 7px;\n    padding-left:15px;\n    padding-right:15px;\n\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar__item-label {\n    display: inline-block;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    width: calc(50% - 7px);\n    margin-right: 7px;\n    margin-top: 2px;\n    text-overflow: ellipsis;\n    /* overflow: hidden; */\n}\n\n.sidebar__item-value-label {\n    font-family: var(--sidebar-monospace-font-stack);\n    display: inline-block;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    max-width: 60%;\n}\n\n.sidebar__item-value-label::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar__item + .sidebar__item,\n.sidebar__item + .sidebar__group,\n.sidebar__group + .sidebar__item,\n.sidebar__group + .sidebar__group {\n    /*border-top: 1px solid #272727;*/\n}\n\n/*\n * SIDEBAR ITEM TOGGLE\n */\n\n/*.sidebar__toggle */\n.icon_toggle{\n    cursor: pointer;\n}\n\n.sidebar__toggle-input {\n    --sidebar-toggle-input-color: #CCCCCC;\n    --sidebar-toggle-input-color-hover: #EEEEEE;\n    --sidebar-toggle-input-border-size: 2px;\n    display: inline;\n    float: right;\n    box-sizing: border-box;\n    border-radius: 50%;\n    /*outline-style: solid;*/\n    /*outline-color:red;*/\n    cursor: pointer;\n    --toggle-size: 11px;\n    margin-top: 2px;\n    background-color: transparent !important;\n    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);\n    width: var(--toggle-size);\n    height: var(--toggle-size);\n    transition: background-color var(--sidebar-hover-transition-time);\n    transition: border-color var(--sidebar-hover-transition-time);\n}\n.sidebar__toggle:hover .sidebar__toggle-input {\n    border-color: var(--sidebar-toggle-input-color-hover);\n}\n\n.sidebar__toggle .sidebar__item-value-label {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    max-width: calc(50% - 12px);\n}\n.sidebar__toggle-input::after { clear: both; }\n\n.sidebar__toggle--active .icon_toggle\n{\n\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    opacity: 1;\n    transform: rotate(0deg);\n    background-position: -4px -9px;\n}\n\n\n.icon_toggle\n{\n    float: right;\n    width:40px;\n    height:18px;\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    background-size: 50px 37px;\n    background-position: -6px -10px;\n    transform: rotate(180deg);\n    opacity: 0.4;\n}\n\n\n\n/*.sidebar__toggle--active .sidebar__toggle-input {*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    background-color: var(--sidebar-toggle-input-color);*/\n/*}*/\n/*.sidebar__toggle--active .sidebar__toggle-input:hover*/\n/*{*/\n/*    background-color: var(--sidebar-toggle-input-color-hover);*/\n/*    border-color: var(--sidebar-toggle-input-color-hover);*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    transition: border-color var(--sidebar-hover-transition-time);*/\n/*}*/\n\n/*\n * SIDEBAR ITEM BUTTON\n */\n\n.sidebar__button {}\n\n.sidebar__button-input:active\n{\n    background-color: #555 !important;\n}\n\n.sidebar__button-input {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    min-height: 24px;\n    background-color: transparent;\n    color: #CCCCCC;\n    box-sizing: border-box;\n    padding-top: 3px;\n    text-align: center;\n    border-radius: 125px;\n    border:2px solid #555;\n    cursor: pointer;\n    padding-bottom: 3px;\n    display:block;\n    width:100%;\n}\n\n.sidebar__button-input.plus, .sidebar__button-input.minus {\n    display: inline-block;\n    min-width: 20px;\n}\n\n.sidebar__button-input:hover {\n  background-color: #333;\n  border:2px solid var(--sidebar-color);\n}\n\n/*\n * VALUE DISPLAY (shows a value)\n */\n\n.sidebar__value-display {}\n\n/*\n * SLIDER\n */\n\n.sidebar__slider {\n    --sidebar-slider-input-height: 3px;\n}\n\n.sidebar__slider-input-wrapper {\n    width: 100%;\n\n    margin-top: 8px;\n    position: relative;\n}\n\n.sidebar__slider-input {\n    -webkit-appearance: none;\n    appearance: none;\n    margin: 0;\n    width: 100%;\n    height: var(--sidebar-slider-input-height);\n    background: #555;\n    cursor: pointer;\n    /*outline: 0;*/\n\n    -webkit-transition: .2s;\n    transition: background-color .2s;\n    border: none;\n}\n\n.sidebar__slider-input:focus, .sidebar__slider-input:hover {\n    border: none;\n}\n\n.sidebar__slider-input-active-track {\n    user-select: none;\n    position: absolute;\n    z-index: 11;\n    top: 0;\n    left: 0;\n    background-color: var(--sidebar-color);\n    pointer-events: none;\n    height: var(--sidebar-slider-input-height);\n    max-width: 100%;\n}\n\n/* Mouse-over effects */\n.sidebar__slider-input:hover {\n    /*background-color: #444444;*/\n}\n\n/*.sidebar__slider-input::-webkit-progress-value {*/\n/*    background-color: green;*/\n/*    color:green;*/\n\n/*    }*/\n\n/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n\n.sidebar__slider-input::-moz-range-thumb\n{\n    position: absolute;\n    height: 15px;\n    width: 15px;\n    z-index: 900 !important;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: var(--sidebar-color) !important;\n    user-select: none;\n\n}\n\n.sidebar__slider-input::-webkit-slider-thumb\n{\n    position: relative;\n    appearance: none;\n    -webkit-appearance: none;\n    user-select: none;\n    height: 15px;\n    width: 15px;\n    display: block;\n    z-index: 900 !important;\n    border: 0;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: #777 !important;\n}\n\n.sidebar__slider-input:hover ::-webkit-slider-thumb {\n    background-color: #EEEEEE !important;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb {*/\n\n/*    width: 0 !important;*/\n/*    height: var(--sidebar-slider-input-height);*/\n/*    background: #EEEEEE;*/\n/*    cursor: pointer;*/\n/*    border-radius: 0 !important;*/\n/*    border: none;*/\n/*    outline: 0;*/\n/*    z-index: 100 !important;*/\n/*}*/\n\n.sidebar__slider-input::-moz-range-track {\n    background-color: transparent;\n    z-index: 11;\n}\n\n.sidebar__slider input[type=text],\n.sidebar__slider input[type=paddword]\n{\n    box-sizing: border-box;\n    /*background-color: #333333;*/\n    text-align: right;\n    color: #BBBBBB;\n    display: inline-block;\n    background-color: transparent !important;\n\n    width: 40%;\n    height: 18px;\n    /*outline: none;*/\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__slider input[type=text]:active,\n.sidebar__slider input[type=text]:focus,\n.sidebar__slider input[type=text]:hover\n.sidebar__slider input[type=password]:active,\n.sidebar__slider input[type=password]:focus,\n.sidebar__slider input[type=password]:hover\n{\n\n    color: #EEEEEE;\n}\n\n/*\n * TEXT / DESCRIPTION\n */\n\n.sidebar__text .sidebar__item-label {\n    width: auto;\n    display: block;\n    max-height: none;\n    margin-right: 0;\n    line-height: 1.1em;\n}\n\n/*\n * SIDEBAR INPUT\n */\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=date],\n.sidebar__text-input input[type=datetime-local],\n.sidebar__text-input input[type=text],\n.sidebar__text-input input[type=password] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: 50%;\n    height: 18px;\n\n\n    border: none;\n    border-radius: 0;\n    border:1px solid #666;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    color-scheme: dark;\n}\n\n.sidebar__text-input textarea:focus::placeholder {\n  color: transparent;\n}\n\n\n\n\n\n.sidebar__color-picker .sidebar__item-label\n{\n    width:45%;\n}\n\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text]:active,\n.sidebar__text-input input[type=text]:focus,\n.sidebar__text-input input[type=text]:hover,\n.sidebar__text-input input[type=password]:active,\n.sidebar__text-input input[type=password]:focus,\n.sidebar__text-input input[type=password]:hover {\n    background-color: transparent;\n    color: #EEEEEE;\n\n}\n\n.sidebar__text-input textarea\n{\n    margin-top:10px;\n    height:60px;\n    width:100%;\n}\n\n/*\n * SIDEBAR SELECT\n */\n\n\n\n .sidebar__select {}\n .sidebar__select-select {\n    color: #BBBBBB;\n    /*-webkit-appearance: none;*/\n    /*-moz-appearance: none;*/\n    appearance: none;\n    /*box-sizing: border-box;*/\n    width: 50%;\n    /*height: 20px;*/\n    background-color: #333333;\n    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/\n    background-repeat: no-repeat;\n    background-position: right center;\n    background-size: 16px 16px;\n    margin: 0;\n    /*padding: 0 2 2 6px;*/\n    border-radius: 5px;\n    border: 1px solid #777;\n    background-color: #444;\n    cursor: pointer;\n    /*outline: none;*/\n    padding-left: 5px;\n\n }\n\n.sidebar__select-select:hover,\n.sidebar__select-select:active,\n.sidebar__select-select:inactive {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\n/*.sidebar__select-select option*/\n/*{*/\n/*    background-color: #444444;*/\n/*    color: #bbb;*/\n/*}*/\n\n.sidebar__select-select option:checked\n{\n    background-color: #000;\n    color: #FFF;\n}\n\n\n/*\n * COLOR PICKER\n */\n\n\n .sidebar__color-picker input[type=text] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: calc(50% - 21px); /* 50% minus space of picker circle */\n    height: 18px;\n    /*outline: none;*/\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    margin-right: 7px;\n}\n\n.sidebar__color-picker input[type=text]:active,\n.sidebar__color-picker input[type=text]:focus,\n.sidebar__color-picker input[type=text]:hover {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\ndiv.sidebar__color-picker-color-input,\n.sidebar__color-picker input[type=color],\n.sidebar__palette-picker input[type=color] {\n    display: inline-block;\n    border-radius: 100%;\n    height: 14px;\n    width: 14px;\n\n    padding: 0;\n    border: none;\n    /*border:2px solid red;*/\n    border-color: transparent;\n    outline: none;\n    background: none;\n    appearance: none;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    cursor: pointer;\n    position: relative;\n    top: 3px;\n}\n.sidebar__color-picker input[type=color]:focus,\n.sidebar__palette-picker input[type=color]:focus {\n    outline: none;\n}\n.sidebar__color-picker input[type=color]::-moz-color-swatch,\n.sidebar__palette-picker input[type=color]::-moz-color-swatch {\n    border: none;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {\n    padding: 0;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch {\n    border: none;\n    border-radius: 100%;\n}\n\n/*\n * Palette Picker\n */\n.sidebar__palette-picker .sidebar__palette-picker-color-input.first {\n    margin-left: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input.last {\n    margin-right: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input {\n    margin: 0 4px;\n}\n\n.sidebar__palette-picker .circlebutton {\n    width: 14px;\n    height: 14px;\n    border-radius: 1em;\n    display: inline-block;\n    top: 3px;\n    position: relative;\n}\n\n/*\n * Preset\n */\n.sidebar__item-presets-preset\n{\n    padding:4px;\n    cursor:pointer;\n    padding-left:8px;\n    padding-right:8px;\n    margin-right:4px;\n    background-color:#444;\n}\n\n.sidebar__item-presets-preset:hover\n{\n    background-color:#666;\n}\n\n.sidebar__greyout\n{\n    background: #222;\n    opacity: 0.8;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 1000;\n    right: 0;\n    top: 0;\n}\n\n.sidebar_tabs\n{\n    background-color: #151515;\n    padding-bottom: 0px;\n}\n\n.sidebar_switchs\n{\n    float: right;\n}\n\n.sidebar_tab\n{\n    float:left;\n    background-color: #151515;\n    border-bottom:1px solid transparent;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_tab_active\n{\n    background-color: #272727;\n    color:white;\n}\n\n.sidebar_tab:hover\n{\n    border-bottom:1px solid #777;\n    color:white;\n}\n\n\n.sidebar_switch\n{\n    float:left;\n    background-color: #444;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_switch:last-child\n{\n    border-top-right-radius: 7px;\n    border-bottom-right-radius: 7px;\n}\n\n.sidebar_switch:first-child\n{\n    border-top-left-radius: 7px;\n    border-bottom-left-radius: 7px;\n}\n\n\n.sidebar_switch_active\n{\n    background-color: #999;\n    color:white;\n}\n\n.sidebar_switch:hover\n{\n    color:white;\n}\n\n.sidebar__text-input-input::focus-visible,\n/*.sidebar__text-input-input:active,*/\n.sidebar__button-input:focus-visible,\n.sidebar__text-input:focus-visible\n/*.sidebar__text-input:active*/\n{\n    outline-style: solid;\n    outline-color:white;\n    outline-width: 1px;\n\n}\n\n"};const a="cables-sidebar-style";const i="cables-sidebar-dynamic-style";const o="sidebar-cables";const l="sidebar"+CABLES.uuid();const u="sidebar__items";const m="sidebar__close-button";const r="";const p="";let c=null;let w=null;let d=null;const e=s.inValueBool("Visible",true);const t=s.inValueSlider("Opacity",1);const h=s.inValueBool("Default Minimized");const f=s.inValueSlider("Minimized Opacity",.5);const v=s.inValueBool("Show undo button",false);const g=s.inValueBool("Show Minimize",false);const b=s.inString("Title","");const x=s.inValueBool("Side");const O=s.inValueBool("Default CSS",true);let _=s.patch.cgl.canvas.ownerDocument;const T=s.outObject("childs");T.setUiAttribs({title:"Children"});const I=s.outBool("Opfened");I.setUiAttribs({title:"Opened"});let y=_.querySelector("."+l);if(!y)y=F();const A=y.querySelector("."+u);T.set({parentElement:A,parentOp:s});N();P();M();O.onChange=()=>{P();M()};e.onChange=k;t.onChange=L;h.onChange=N;f.onChange=S;v.onChange=C;s.onDelete=U;function S(){M()}g.onChange=E;function E(e){if(!e||e.uiAttribs)e=_.querySelector(".sidebar-cables .sidebar__group-header");if(!e)return;const t=_.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");if(g.get()){e.classList.add("iconsidebar-chevron-up");e.classList.add("iconsidebar-minimizebutton");if(t)t.style.marginRight="20px"}else{e.classList.remove("iconsidebar-chevron-up");e.classList.remove("iconsidebar-minimizebutton");if(t)t.style.marginRight="initial"}}x.onChange=function(){if(!y)return;if(x.get())y.classList.add("sidebar-cables-right");else y.classList.remove("sidebar-cables-right")};function C(){const e=_.querySelector(".sidebar-cables .sidebar__group-header");if(e){j(e)}}function j(e){if(e){const t=_.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");if(t){if(!v.get()){t.remove()}}else{if(v.get()){const n=_.createElement("span");n.classList.add("sidebar__group-header-undo");n.classList.add("sidebar-icon-undo");n.addEventListener("click",function(e){e.stopPropagation();const t=_.querySelectorAll(".sidebar-cables .sidebar__reloadable");const n=_.createEvent("MouseEvents");n.initEvent("dblclick",true,true);t.forEach(e=>{e.dispatchEvent(n)})});e.appendChild(n)}}}E(e)}function N(){if(!c){return}if(h.get()){y.classList.add("sidebar--closed");if(e.get())I.set(false)}else{y.classList.remove("sidebar--closed");if(e.get())I.set(true)}}function L(){const e=t.get();y.style.opacity=e}function k(){if(!y)return;if(e.get()){y.style.display="block";if(!y.classList.contains("sidebar--closed"))I.set(true)}else{y.style.display="none";I.set(false)}}x.onChanged=function(){};function M(){const e=_.querySelectorAll("."+i);if(e){e.forEach(function(e){e.parentNode.removeChild(e)})}if(!O.get())return;const t=_.createElement("style");t.classList.add("cablesEle");t.classList.add(i);let n=".sidebar--closed .sidebar__close-button { ";n+="opacity: "+f.get();n+="}";const a=_.createTextNode(n);t.appendChild(a);_.body.appendChild(t)}function F(){const e=_.createElement("div");e.classList.add(o);e.classList.add(l);const t=s.patch.cgl.canvas.parentElement;const n=_.createElement("div");n.classList.add("sidebar__group");e.appendChild(n);const a=_.createElement("div");a.classList.add("sidebar__group-header");e.appendChild(a);const i=_.createElement("span");i.classList.add("sidebar__group-header-title");d=_.createElement("span");d.classList.add("sidebar__group-header-title-text");d.innerHTML=b.get();i.appendChild(d);a.appendChild(i);j(a);E(a);n.appendChild(a);e.appendChild(n);n.addEventListener("click",R);if(!t){s.warn("[sidebar] no canvas parentelement found...");return}t.appendChild(e);const r=_.createElement("div");r.classList.add(u);e.appendChild(r);c=_.createElement("div");c.classList.add(m);c.addEventListener("click",R);e.appendChild(c);return e}b.onChange=function(){if(d)d.innerHTML=b.get()};function G(e){}function R(e){e.stopPropagation();if(!y){s.logError("Sidebar could not be closed...");return}y.classList.toggle("sidebar--closed");const t=e.target;let n=r;if(y.classList.contains("sidebar--closed")){n=p;I.set(false)}else{I.set(true)}}function P(){const e=_.querySelectorAll("."+a);if(e){e.forEach(e=>{e.parentNode.removeChild(e)})}if(!O.get())return;const t=_.createElement("style");t.innerHTML=n.style_css;t.classList.add(a);t.classList.add("cablesEle");_.body.appendChild(t)}function U(){B(y)}function B(e){if(e&&e.parentNode&&e.parentNode.removeChild)e.parentNode.removeChild(e)}};Ops.Sidebar.Sidebar.prototype=new CABLES.Op;CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"]={f:Ops.Sidebar.Sidebar,objName:"Ops.Sidebar.Sidebar"};Ops.Sidebar.Group=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};let n=t.inObject("link");let a=t.inString("Text","Group");const i=t.inBool("Show Title",true);let r=t.inValueBool("Default Minimized");const s=t.inBool("Visible",true);let o=t.outObject("next");let l=t.outObject("childs");s.onChange=function(){u.style.display=s.get()?"block":"none"};let u=document.createElement("div");u.dataset.op=t.id;u.classList.add("sidebar__group");f();let m=document.createElement("div");m.classList.add("sidebar__group-header");m.classList.add("cablesEle");u.appendChild(m);m.addEventListener("click",v);let p=document.createElement("div");p.classList.add("sidebar__group-header-title");m.appendChild(p);let c=document.createElement("span");c.textContent=a.get();c.classList.add("sidebar__group-header-title-text");p.appendChild(c);let d=document.createElement("span");d.classList.add("sidebar__group-header-icon");d.classList.add("iconsidebar-chevron-up");p.appendChild(d);let h=document.createElement("div");h.classList.add("sidebar__group-items");u.appendChild(h);t.toWorkPortsNeedToBeLinked(n);n.onChange=b;a.onChange=g;r.onChange=f;t.onDelete=_;i.onChange=()=>{if(i.get())m.style.display="block";else m.style.display="none"};function f(){if(r.get()){u.classList.add("sidebar__group--closed")}else{u.classList.remove("sidebar__group--closed")}}function v(e){e.stopPropagation();u.classList.toggle("sidebar__group--closed")}function g(){let e=a.get();c.textContent=e;if(CABLES.UI)t.setUiAttrib({extendTitle:e})}function b(){l.set(null);let e=n.get();if(e&&e.parentElement){e.parentElement.appendChild(u);l.set({parentElement:h,parentOp:t});o.set(e)}else{if(u.parentElement){u.parentElement.removeChild(u)}}}function x(e){if(e){e.style.display="block"}}function O(e){if(e){e.style.display="none"}}function _(){T(u)}function T(e){if(e&&e.parentNode&&e.parentNode.removeChild){e.parentNode.removeChild(e)}}};Ops.Sidebar.Group.prototype=new CABLES.Op;CABLES.OPS["86ea2333-b51c-48ed-94c2-8b7b6e9ff34c"]={f:Ops.Sidebar.Group,objName:"Ops.Sidebar.Group"};Ops.Sidebar.Slider_v3=function(){CABLES.Op.apply(this,arguments);const i=this;const w=i.attachments={};const e=1e-5;const t=i.inObject("link");const n=i.inString("Text","Slider");const r=i.inValue("Min",0);const s=i.inValue("Max",1);const a=i.inValue("Step",e);const o=i.inString("Suffix","");const l=i.inBool("Grey Out",false);const u=i.inBool("Visible",true);const m=i.inValue("Input",.5);const p=i.inTriggerButton("Set Default");const c=i.inTriggerButton("Reset");let d=null;const h=i.inValue("Default",.5);h.setUiAttribs({hidePort:true,greyout:true});const f=i.outObject("childs");const v=i.outNumber("Result",h.get());i.toWorkNeedsParent("Ops.Sidebar.Sidebar");i.setPortGroup("Range",[r,s,a]);i.setPortGroup("Display",[l,u]);const g=document.createElement("div");g.addEventListener("dblclick",function(){v.set(parseFloat(h.get()));m.set(parseFloat(h.get()));R(h.get())});g.dataset.op=i.id;g.classList.add("cablesEle");g.classList.add("sidebar__item");g.classList.add("sidebar__slider");g.classList.add("sidebar__reloadable");i.patch.on("sidebarStylesChanged",()=>{N()});const b=document.createElement("div");b.classList.add("sidebar__item-label");const x=document.createElement("div");x.classList.add("sidebar__greyout");g.appendChild(x);x.style.display="none";const O=document.createTextNode(n.get());b.appendChild(O);g.appendChild(b);const _=document.createElement("input");_.value=h.get();_.classList.add("sidebar__text-input-input");_.setAttribute("type","text");_.oninput=S;g.appendChild(_);const T=document.createElement("span");g.appendChild(T);o.onChange=()=>{T.innerHTML=o.get()};const I=document.createElement("div");I.classList.add("sidebar__slider-input-wrapper");g.appendChild(I);const y=document.createElement("div");y.classList.add("sidebar__slider-input-active-track");I.appendChild(y);const A=document.createElement("input");A.classList.add("sidebar__slider-input");A.setAttribute("min",r.get());A.setAttribute("max",s.get());A.setAttribute("type","range");A.setAttribute("step",a.get());A.setAttribute("value",h.get());A.style.display="block";I.appendChild(A);N();A.addEventListener("input",j);t.onChange=U;n.onChange=G;m.onChange=E;h.onChange=F;p.onTriggered=C;r.onChange=L;s.onChange=M;a.onChange=k;i.onDelete=V;i.onLoaded=i.onInit=function(){if(i.patch.config.sidebar){i.patch.config.sidebar[n.get()];v.set(i.patch.config.sidebar[n.get()])}else{v.set(parseFloat(h.get()));m.set(parseFloat(h.get()))}};c.onTriggered=function(){const e=parseFloat(h.get());v.set(e);R(e);P(e);m.set(e);N()};l.onChange=function(){x.style.display=l.get()?"block":"none"};u.onChange=function(){g.style.display=u.get()?"block":"none"};function S(e){let t=parseFloat(e.target.value);if(isNaN(t))t=0;const n=r.get();const a=s.get();if(t<n){t=n}else if(t>a){t=a}v.set(t);N();m.set(t);i.refreshParams()}function E(){let e=parseFloat(m.get());const t=r.get();const n=s.get();if(e>n){e=n}else if(e<t){e=t}P(e);v.set(e);N()}function C(){let e=parseFloat(m.get());const t=r.get();const n=s.get();if(e>n){e=n}else if(e<t){e=t}R(e);P(e);v.set(e);h.set(e);i.refreshParams();N()}function j(e){e.preventDefault();e.stopPropagation();R(e.target.value);const t=parseFloat(e.target.value);v.set(t);m.set(t);i.refreshParams();N();return false}function k(){const e=a.get();A.setAttribute("step",e);N()}function N(e){let t=parseFloat(A.value);if(typeof e!=="undefined")t=e;let n=y.parentElement.getBoundingClientRect().width||220;if(d)n=parseInt(getComputedStyle(d.parentElement).getPropertyValue("--sidebar-width"))-20;const a=CABLES.map(t,parseFloat(A.min),parseFloat(A.max),0,n-16);y.style.width=a+"px"}function L(){const e=r.get();A.setAttribute("min",e);N()}function M(){const e=s.get();A.setAttribute("max",e);N()}function F(){const e=h.get();v.set(parseFloat(e));L();M();P(e);R(e);N(e)}function G(){const e=n.get();b.textContent=e;if(CABLES.UI)i.setUiAttrib({extendTitle:e});_.setAttribute("aria-label","slider "+n.get());A.setAttribute("aria-label","slider "+n.get())}function U(){f.set(null);d=t.get();if(d&&d.parentElement){d.parentElement.appendChild(g);f.set(d)}else if(g.parentElement)g.parentElement.removeChild(g);N()}function R(e){_.value=e}function P(e){A.value=e}function B(e){if(e)e.style.display="block"}function D(e){if(e)e.style.display="none"}function V(){z(g)}function z(e){if(e&&e.parentNode&&e.parentNode.removeChild)e.parentNode.removeChild(e)}};Ops.Sidebar.Slider_v3.prototype=new CABLES.Op;CABLES.OPS["74730122-5cba-4d0d-b610-df334ec6220a"]={f:Ops.Sidebar.Slider_v3,objName:"Ops.Sidebar.Slider_v3"};Ops.Vars.VarSetNumber_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inValueFloat("Value",0);e.varName=e.inDropDown("Variable",[],"",true);new CABLES.VarSetOpWrapper(e,"number",n,e.varName)};Ops.Vars.VarSetNumber_v2.prototype=new CABLES.Op;CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"]={f:Ops.Vars.VarSetNumber_v2,objName:"Ops.Vars.VarSetNumber_v2"};Ops.Gl.Matrix.Camera_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const w=e.attachments={};const t=e.inTrigger("render");const n=e.outTrigger("trigger");const a=e.inBool("Identity",true);const i=e.inValueSelect("projection mode",["prespective","ortogonal"],"prespective");const r=e.inValue("frustum near",.01);const s=e.inValue("frustum far",5e3);const o=e.inValue("fov",45);const l=e.inValueBool("Auto Aspect Ratio",true);const u=e.inValue("Aspect Ratio",1);const m=e.inValue("eye X",0);const p=e.inValue("eye Y",0);const c=e.inValue("eye Z",5);const d=e.inValue("center X",0);const h=e.inValue("center Y",0);const f=e.inValue("center Z",0);const v=e.inValue("truck",0);const g=e.inValue("boom",0);const b=e.inValue("dolly",0);const x=e.inValue("tilt",0);const O=e.inValue("pan",0);const _=e.inValue("roll",0);const T=e.outNumber("Aspect");const k=e.outArray("Look At Array");const I=e.patch.cgl;let y=0;const A=vec3.create();const S=vec3.create();const E=vec3.create();const C=mat4.create();mat4.identity(C);const j=[];const N=vec3.create();const L=mat4.create();mat4.identity(L);let M=true;t.onTriggered=function(){if(I.tempData.shadowPass)return n.trigger();if(!l.get())y=u.get();else y=I.getViewPort()[2]/I.getViewPort()[3];T.set(y);I.pushViewMatrix();if(a.get())mat4.identity(I.vMatrix);if(M){mat4.identity(L);vec3.set(N,v.get(),g.get(),b.get());if(v.get()!==0||g.get()!==0||b.get()!==0)mat4.translate(L,L,N);if(x.get()!==0)mat4.rotateX(L,L,x.get()*CGL.DEG2RAD);if(O.get()!==0)mat4.rotateY(L,L,O.get()*CGL.DEG2RAD);if(_.get()!==0)mat4.rotateZ(L,L,_.get()*CGL.DEG2RAD);M=false}mat4.multiply(I.vMatrix,I.vMatrix,L);I.pushPMatrix();I.pushViewMatrix();if(i.get()=="prespective"){mat4.perspective(I.pMatrix,o.get()*.0174533,y,r.get(),s.get())}else if(i.get()=="ortogonal"){mat4.ortho(I.pMatrix,-1*(o.get()/14),1*(o.get()/14),-1*(o.get()/14)/y,1*(o.get()/14)/y,r.get(),s.get())}j[0]=m.get();j[1]=p.get();j[2]=c.get();j[3]=d.get();j[4]=h.get();j[5]=f.get();j[6]=0;j[7]=1;j[8]=0;k.setRef(j);vec3.set(A,0,1,0);vec3.set(S,m.get(),p.get(),c.get());vec3.set(E,d.get(),h.get(),f.get());mat4.lookAt(C,S,E,A);mat4.multiply(I.vMatrix,I.vMatrix,C);n.trigger();I.popViewMatrix();I.popPMatrix();I.popViewMatrix();if(e.isCurrentUiOp())gui.setTransformGizmo({posX:v,posY:g,posZ:b})};const R=function(){if(!l.get()){u.setUiAttribs({greyout:false})}else{u.setUiAttribs({greyout:true})}};const P=function(){M=true};v.onChange=P;g.onChange=P;b.onChange=P;x.onChange=P;O.onChange=P;_.onChange=P;l.onChange=R;R()};Ops.Gl.Matrix.Camera_v2.prototype=new CABLES.Op;CABLES.OPS["f7673a93-7772-4ade-9d3d-df7174f5258b"]={f:Ops.Gl.Matrix.Camera_v2,objName:"Ops.Gl.Matrix.Camera_v2"};Ops.Vars.VarGetNumber_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.outNumber("Value");e.varName=e.inValueSelect("Variable",[],"",true);new CABLES.VarGetOpWrapper(e,"number",e.varName,n)};Ops.Vars.VarGetNumber_v2.prototype=new CABLES.Op;CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"]={f:Ops.Vars.VarGetNumber_v2,objName:"Ops.Vars.VarGetNumber_v2"};Ops.Number.Preset=function(){CABLES.Op.apply(this,arguments);const l=this;const e=l.attachments={};const r=l.inString("data",""),t=l.inString("sets",""),i=l.inString("presetid",CABLES.shortId()),n=l.inSwitch("Interpolation",["None","xfade","a-b"],"None"),u=l.inFloat("Preset A","0"),m=l.inFloat("Preset B","1"),p=l.inFloatSlider("Fade",0),s=l.inDropDown("Preset",[]),a=l.inTriggerButton("Create new"),o=l.inTriggerButton("Update"),c=l.inUiTriggerButtons("move",["",""]),d=l.inTriggerButton("Delete"),h=l.inTriggerButton("Rename"),f=l.addOutPort(new CABLES.Port(l,"Create Variable",CABLES.OP_PORT_TYPE_DYNAMIC)),v=l.outNumber("Num Presets",0),w=l.outNumber("current Preset",0),g=l.outArray("dbg_data"),b=l.outArray("dbg_sets");let x=[];let O=[];const _=[];let T=0;m.changeAlways=true;u.changeAlways=true;l.setPortGroup("Manage Presets",[a,o,d,s,c,h]);r.setUiAttribs({hideParam:true,hidePort:true});i.setUiAttribs({hideParam:true,hidePort:true});t.setUiAttribs({hideParam:true,hidePort:true});a.setUiAttribs({hidePort:true});o.setUiAttribs({hidePort:true});d.setUiAttribs({hidePort:true});h.setUiAttribs({hidePort:true});s.setUiAttribs({showIndex:true});a.setUiAttribs({buttonTitle:"Create New Preset"});d.setUiAttribs({buttonTitleClass:"button-small"});h.setUiAttribs({buttonTitleClass:"button-small"});s.onChange=M;n.onChange=y;u.onChange=m.onChange=p.onChange=A;y();N();M();j();function I(e,t){const n=O.splice(e,1)[0];O.splice(t,0,n)}c.onTriggered=function(e){const t=s.get();const n=s.uiAttribs.values.indexOf(t);if(e=="")I(n,n+1);if(e=="")I(n,Math.max(0,n-1));N();M()};l.init=function(){if(O.length>0&&x.length==0){l.logError("it happened again!!");const t=Object.keys(O[0].values);for(let e=0;e<t.length;e++){x.push({varname:t[e],type:0,title:t[e]})}S()}};function y(){const e=n.get();if(e==="None"){T=0;u.setUiAttribs({greyout:true});m.setUiAttribs({greyout:true});p.setUiAttribs({greyout:true})}else if(e==="xfade"){T=1;u.setUiAttribs({greyout:false});m.setUiAttribs({greyout:false});p.setUiAttribs({greyout:false})}else if(e==="a-b"){T=2;u.setUiAttribs({greyout:false});m.setUiAttribs({greyout:true});p.setUiAttribs({greyout:true})}l.setUiAttrib({extendTitle:e});if(T!==0)A();else M()}function A(){if(T===0)return;let e=0;let t=0;let n=0;if(T===2){const r=u.get();t=Math.floor(r);n=Math.ceil(r);e=r%1;if(t>=O.length)t=O.length-1;if(n>=O.length)n=O.length-1}else if(T===1){e=p.get();t=Math.floor(u.get());n=Math.floor(m.get())}const a=O[t];const i=O[n];if(!a||!i){l.warn("preset not found");return}for(const s in a.values){const o=a.values[s]+(i.values[s]-a.values[s])*e;l.patch.setVarValue(s,o)}}function S(){E()}function E(){r.set(JSON.stringify(x));t.set(JSON.stringify(O));v.set(O.length);P()}function C(t){t.values=t.values||{};for(let e=0;e<_.length;e++)t.values[_[e].name]=_[e].value;return t}function j(){d.setUiAttribs({greyout:s.uiAttribs.values.length==0});o.setUiAttribs({greyout:s.uiAttribs.values.length==0});h.setUiAttribs({greyout:s.uiAttribs.values.length==0});c.setUiAttribs({greyout:s.uiAttribs.values.length==0});const e=L(s.get());if(e){d.setUiAttribs({buttonTitle:"Delete "+e.name});o.setUiAttribs({buttonTitle:"Update "+e.name});h.setUiAttribs({buttonTitle:"Rename "+e.name})}}function N(){s.uiAttribs.values.length=0;for(let e=0;e<O.length;e++)s.uiAttribs.values.push(O[e].name);j();E();P()}function L(t){for(let e=0;e<O.length;e++)if(O[e]&&O[e].name==t)return O[e]}t.onChange=function(){O=JSON.parse(t.get());v.set(O.length);N();t.onChange=null};function M(){const t=L(s.get());if(!t)return;const n=Object.keys(t.values);for(let e=0;e<n.length;e++){const a=l.getPort(n[e]);if(a){a.set(t.values[n[e]]);if(T===0)a.forceChange()}}if(T!==0)A();j();l.refreshParams()}o.onTriggered=function(){let e=L(s.get());e=C(e);E()};a.onTriggered=function(){if(!l.patch.isEditorMode())return;new CABLES.UI.ModalDialog({prompt:true,title:"New Preset",text:"Enter a new preset name",promptValue:"",promptOk:e=>{l.refreshParams();s.set(e);let t={name:e};t=C(t);O.push(t);N();E()}})};d.onTriggered=function(){if(!CABLES.UI)return;const e=s.get();const t=s.uiAttribs.values.indexOf(e);O.splice(t,1);S();if(O.length>0)s.set(O[0].name);l.refreshParams();N();j()};h.onTriggered=function(){if(!CABLES.UI)return;new CABLES.UI.ModalDialog({prompt:true,title:"New Preset",text:"Enter a new preset name",promptValue:"",promptOk:e=>{if(!e)return;const t=s.get();const n=s.uiAttribs.values.indexOf(t);O[n].name=e;s.set(e);S();N();l.refreshParams()}})};r.onChange=function(){x=JSON.parse(r.get());for(let e=0;e<x.length;e++){const t=x[e];const n=t.varname;if(!l.getPort(n)){if(t.type==CABLES.OP_PORT_TYPE_VALUE){const a=l.patch.getVarValue(n);const i=l.inFloat(n,a);i.setUiAttribs({editableTitle:true,title:t.title});R(i,n);i.set(a);i.forceChange()}}}P()};function R(e,n){_.push(e);e.onChange=function(){l.patch.setVarValue(n,e.get())};e.addEventListener("onUiAttrChange",e=>{if(e.title){const t=x.find(e=>{return e.varname===n});if(t){t.title=e.title;S()}}})}l.patch.addEventListener("onOpDelete",a=>{if(a.objName.indexOf("VarGet")==-1)return;const e=[];for(let n=0;n<x.length;n++){let t=false;for(let e=0;e<l.patch.ops.length;e++){const i=l.patch.ops[e];if(i!=a&&i.objName.indexOf("VarGet">-1)&&i.varName&&i.varName.get&&i.varName.get()==x[n].varname){t=true;break}}if(t){e.push(x[n])}else{l.removePort(l.getPort(x[n].varname))}}x=e;S();l.refreshParams();setTimeout(l.refreshParams.bind(this),1e3)});function P(){g.set(x);b.set(O)}f.onLinkChanged=function(){if(f.links.length===0){l.log("no links!");return}const e=f.links[0];const t=e.getOtherPort(f);const n=".preset_"+t.name+"_"+i.get()+"_"+CABLES.shortId();l.log("pilength",l.portsIn.length);x.push({varname:n,title:t.parent.name+" "+t.name,type:t.type});const a=t.get();l.patch.setVarValue(n,a);l.patch.getVar(n).type="preset";f.removeLinks();S();l.refreshParams();t.setVariable(n)};l.onDelete=e=>{if(e)return;for(let e=0;e<x.length;e++)l.patch.deleteVar(x[e].varname)}};Ops.Number.Preset.prototype=new CABLES.Op;CABLES.OPS["ffe981a5-67df-4da5-a6a9-7fcb910fc982"]={f:Ops.Number.Preset,objName:"Ops.Number.Preset"};Ops.Trigger.TriggerNumber=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTriggerButton("Set"),a=e.inValueFloat("Number"),i=e.outTrigger("Next"),r=e.outNumber("Out Value");r.changeAlways=true;n.onTriggered=function(){r.set(a.get());i.trigger()}};Ops.Trigger.TriggerNumber.prototype=new CABLES.Op;CABLES.OPS["9989b1c0-1073-4d5f-bfa0-36dd98b66e27"]={f:Ops.Trigger.TriggerNumber,objName:"Ops.Trigger.TriggerNumber"};Ops.Sidebar.NumberInput_v2=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const t=n.inObject("Link");const a=n.inString("Text","Number");const i=n.inValue("Input",0);const r=n.inTriggerButton("Set Default");const s=n.inValue("Default",0);s.setUiAttribs({hidePort:true,greyout:true});const o=n.outObject("Children");const l=n.outNumber("Result",s.get());const u=document.createElement("div");u.addEventListener("dblclick",function(){l.set(parseFloat(s.get()));i.set(parseFloat(s.get()))});u.dataset.op=n.id;u.classList.add("cablesEle");u.classList.add("sidebar__item");u.classList.add("sidebar__text-input");u.classList.add("sidebar__reloadable");const m=document.createElement("div");m.classList.add("sidebar__item-label");const p=document.createTextNode(a.get());m.appendChild(p);u.appendChild(m);const c=document.createElement("input");c.classList.add("sidebar__text-input-input");c.setAttribute("type","text");c.setAttribute("value",s.get());u.appendChild(c);c.addEventListener("input",f);t.onChange=b;a.onChange=g;s.onChange=v;n.onDelete=_;i.onChange=h;r.onTriggered=d;function d(){s.set(parseFloat(i.get()));n.refreshParams()}function h(){let e=parseFloat(i.get());if(isNaN(e)){e=0}c.value=e;l.set(e)}function f(e){let t=parseFloat(e.target.value);if(isNaN(t)){t=0}l.set(t);i.set(t);n.refreshParams()}function v(){}function g(){const e=a.get();m.textContent=e;if(CABLES.UI)n.setUiAttrib({extendTitle:e})}function b(){o.set(null);const e=t.get();if(e&&e.parentElement){e.parentElement.appendChild(u);o.set(e)}else{if(u.parentElement){u.parentElement.removeChild(u)}}}function x(e){if(e){e.style.display="block"}}function O(e){if(e){e.style.display="none"}}function _(){T(u)}function T(e){if(e&&e.parentNode&&e.parentNode.removeChild){e.parentNode.removeChild(e)}}};Ops.Sidebar.NumberInput_v2.prototype=new CABLES.Op;CABLES.OPS["c4f3f1d7-de07-4c06-921e-32baeef4fc68"]={f:Ops.Sidebar.NumberInput_v2,objName:"Ops.Sidebar.NumberInput_v2"};Ops.Devices.Mouse.MouseWheel_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inValue("Speed",1),a=e.inValueBool("prevent scroll",true),i=e.inValueBool("Flip Direction"),r=e.inBool("Simple Delta",true),s=e.inSwitch("Area",["Canvas","Document","Parent"],"Document"),o=e.inValueBool("active",true),l=e.outNumber("delta",0),u=e.outNumber("delta X",0),m=e.outNumber("browser event delta",0),p=e.outTrigger("Wheel Action");const c=e.patch.cgl;const d=0;const h=CABLES.now()/1e3;const f=0;let v=1;let g=null;s.onChange=I;const b=0;y();i.onChange=function(){if(i.get())v=-1;else v=1};function x(e){let t=0;if("detail"in e){t=e.detail}if("deltaY"in e){t=e.deltaY;if(e.deltaY>20)t=20;else if(e.deltaY<-20)t=-20}return t*v}function O(e){let t=0;if("deltaX"in e){t=e.deltaX;if(e.deltaX>20)t=20;else if(e.deltaX<-20)t=-20}return t}let _=0;function T(t){if(Date.now()-_<10)return;_=Date.now();m.set(t.wheelDelta||t.deltaY);if(t.deltaY){let e=x(t);if(r.get()){if(e>0)e=n.get();else e=-n.get()}else e*=.01*n.get();l.set(0);l.set(e)}if(t.deltaX){let e=O(t);e*=.01*n.get();u.set(0);u.set(e)}if(a.get())t.preventDefault();p.trigger()}function I(){A();if(s.get()=="Document")g=document;if(s.get()=="Parent")g=c.canvas.parentElement;else g=c.canvas;if(o.get())y()}function y(){if(!g)I();g.addEventListener("wheel",T,{passive:false})}function A(){if(g)g.removeEventListener("wheel",T)}o.onChange=function(){I()}};Ops.Devices.Mouse.MouseWheel_v2.prototype=new CABLES.Op;CABLES.OPS["7b9626db-536b-4bb4-85c3-95401bc60d1b"]={f:Ops.Devices.Mouse.MouseWheel_v2,objName:"Ops.Devices.Mouse.MouseWheel_v2"};Ops.Math.Accumulator=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTrigger("Trigger in"),a=e.inValueFloat("Add to number",0),i=e.inValueFloat("Multiplier to add number",1),r=e.inValueFloat("Default Value",1),s=e.inTriggerButton("Set Default Value"),o=e.outNumber("Current value");let l=performance.now();let u=0;let m=true;s.onTriggered=p;function p(){u=r.get();o.set(u);m=true}n.onTriggered=function(){if(!m){let e=(performance.now()-l)/100;u+=a.get()*e*i.get();o.set(u)}l=performance.now();m=false}};Ops.Math.Accumulator.prototype=new CABLES.Op;CABLES.OPS["460574ca-dca2-4283-8c37-57a8c446a51f"]={f:Ops.Math.Accumulator,objName:"Ops.Math.Accumulator"};Ops.Trigger.TriggerExtender=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTriggerButton("Execute"),a=e.outTrigger("Next");n.onTriggered=function(){a.trigger()}};Ops.Trigger.TriggerExtender.prototype=new CABLES.Op;CABLES.OPS["7ef594f3-4907-47b0-a2d3-9854eda1679d"]={f:Ops.Trigger.TriggerExtender,objName:"Ops.Trigger.TriggerExtender"};Ops.Graphics.Geometry.FlipNormals=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const a=e.inObject("Geometry"),i=e.outObject("Result"),r=e.inValueBool("Flip",true),s=e.inValueBool("Normalize",true);r.onChange=s.onChange=a.onChange=n;function n(){let e=a.get();if(!e){i.set(null);return}let n=e.copy();if(r.get()){for(let e=0;e<n.vertexNormals.length;e++)n.vertexNormals[e]*=-1;if(s.get()){let t=vec3.create();for(let e=0;e<n.vertexNormals.length;e+=3){vec3.set(t,n.vertexNormals[e+0],n.vertexNormals[e+1],n.vertexNormals[e+2]);vec3.normalize(t,t);n.vertexNormals[e+0]=t[0];n.vertexNormals[e+1]=t[1];n.vertexNormals[e+2]=t[2]}}}i.set(n)}};Ops.Graphics.Geometry.FlipNormals.prototype=new CABLES.Op;CABLES.OPS["0055f588-dde6-4232-958b-4c19cdc67abd"]={f:Ops.Graphics.Geometry.FlipNormals,objName:"Ops.Graphics.Geometry.FlipNormals"};Ops.Graphics.Geometry.GeometryExtrude=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const p=e.inObject("Geometry",null,"geometry"),c=e.inFloat("Height",.5),d=e.inBool("Smooth",true),h=e.inBool("Walls",true),f=e.inBool("Top",true),v=e.inBool("Bottom",true),g=e.outObject("Result Geometry",null,"geometry");function b(t){let n=0;for(let e=0;e<t.length-3;e+=3){n+=(t[e+3]-t[e])*(t[e+3+1]+t[e])}return n>0}d.onChange=h.onChange=f.onChange=v.onChange=c.onChange=p.onChange=()=>{const i=p.get();if(!i){g.set(null);return}function t(t,n){let a=0;for(let e=0;e<i.verticesIndices.length;e+=3){if((i.verticesIndices[e]==t||i.verticesIndices[e+1]==t||i.verticesIndices[e+2]==t)&&(i.verticesIndices[e]==n||i.verticesIndices[e+1]==n||i.verticesIndices[e+2]==n)){a++;if(a==2)return true}}return false}let n=[];const e=[];const a=c.get();if(h.get())for(let e=0;e<i.verticesIndices.length;e+=3){const s=i.verticesIndices[e];const o=i.verticesIndices[e+1];const l=i.verticesIndices[e+2];if(!t(s,o)){const u=[];u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]]);u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]+a]);u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]]);if(!b(u))n=n.concat(u);else n=n.concat(u.reverse());u.length=0;u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]+a]);u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]]);u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]+a]);if(!b(u))n=n.concat(u);else n=n.concat(u.reverse())}if(!t(l,o)){const u=[];u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]]);u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]+a]);u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]]);if(b(u))n=n.concat(u);else n=n.concat(u.reverse());u.length=0;u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]+a]);u.push([i.vertices[o*3+0],i.vertices[o*3+1],i.vertices[o*3+2]]);u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]+a]);if(b(u))n=n.concat(u);else n=n.concat(u.reverse())}if(!t(l,s)){const u=[];u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]]);u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]+a]);u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]]);if(!b(u))n=n.concat(u);else n=n.concat(u.reverse());u.length=0;u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]+a]);u.push([i.vertices[s*3+0],i.vertices[s*3+1],i.vertices[s*3+2]]);u.push([i.vertices[l*3+0],i.vertices[l*3+1],i.vertices[l*3+2]+a]);if(!b(u))n=n.concat(u);else n=n.concat(u.reverse())}}const r=CGL.Geometry.buildFromFaces(n,"extrude",true);r.calculateNormals();r.calcTangentsBitangents();if(v.get()){r.merge(i)}if(f.get()){const m=i.copy();for(let e=0;e<m.vertices.length;e+=3)m.vertices[e+2]+=a;m.flipVertDir();m.flipNormals();r.merge(m)}r.flipVertDir();if(!d.get()){r.unIndex();r.calculateNormals({forceZUp:true});r.flipNormals()}g.set(null);g.set(r)}};Ops.Graphics.Geometry.GeometryExtrude.prototype=new CABLES.Op;CABLES.OPS["64a34a29-000d-4350-875f-5b72b97a314f"]={f:Ops.Graphics.Geometry.GeometryExtrude,objName:"Ops.Graphics.Geometry.GeometryExtrude"};Ops.Extension.OpenType.OpentypeToSvgPath=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const r=e.inObject("Opentype Font"),s=e.inString("Text","cables"),o=e.inFloat("Letter Spacing",0),l=e.outString("Path String");s.onChange=o.onChange=r.onChange=async function(){const e=r.get();if(!e||!e.getPath){l.set("");return}const n=e.getPaths(s.get(),0,0,72);let a="";let i=o.get();for(let t=0;t<n.length;t++){for(let e=0;e<n[t].commands.length;e++){if(n[t].commands[e].hasOwnProperty("x"))n[t].commands[e].x+=t*i;if(n[t].commands[e].hasOwnProperty("x1"))n[t].commands[e].x1+=t*i}a+=n[t].toPathData()}l.set(a)}};Ops.Extension.OpenType.OpentypeToSvgPath.prototype=new CABLES.Op;CABLES.OPS["4d901c72-b8dc-45dc-ac2e-608e5da40677"]={f:Ops.Extension.OpenType.OpentypeToSvgPath,objName:"Ops.Extension.OpenType.OpentypeToSvgPath"};Ops.Graphics.Geometry.SvgPathToGeometry_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const h=e.inString("SVG Path"),n=e.inFloat("Bezier Stepsize",3),f=e.inFloat("Rescale",1),v=e.outObject("Geometry",null,"geometry");n.onChange=f.onChange=h.onChange=()=>{let e=h.get();if(!e||e.length<2){v.set(null);return}e=e.replace(/([A-Z,a-z])/g," $1 ");const t=g(e);const o=[];t.forEach(({type:e,x:t,y:n,x1:a,y1:i,x2:r,y2:s})=>{switch(e){case"M":o.push(new b);o[o.length-1].moveTo({x:t,y:n});break;case"L":o[o.length-1].moveTo({x:t,y:n});break;case"C":o[o.length-1].cubicTo({x:t,y:n},{x:a,y:i},{x:r,y:s});break;case"Q":o[o.length-1].conicTo({x:t,y:n},{x:a,y:i});break;case"Z":o[o.length-1].close();break}});o.sort((e,t)=>{return Math.abs(t.area)-Math.abs(e.area)});const a=[];for(let n=0;n<o.length;++n){let t=null;for(let e=n-1;e>=0;--e){if(o[e].inside(o[n].points[0])&&o[n].area*o[e].area<0){t=o[e];break}}if(t){t.children.push(o[n])}else{a.push(o[n])}}const n=o.reduce((e,t)=>{return e+t.points.length},0);const i=new Float32Array(n*2);let r=0;const s=[];function l(e){const n=[];const t=[];e.points.forEach(({x:e,y:t})=>{return n.push(e,t)});e.children.forEach(e=>{e.children.forEach(l);t.push(n.length/2);e.points.forEach(({x:e,y:t})=>{return n.push(e,t)})});i.set(n,r*2);earcut(n,t).forEach(e=>{return s.push(e+r)});r+=n.length/2}a.forEach(l);const u=new Float32Array(n*3);let m=-99999;for(let e=0;e<u.length/3;e++){u[e*3+0]=i[e*2+0];u[e*3+1]=i[e*2+1]*-1;m=Math.max(u[e*3+1],m);u[e*3+2]=0}let p=f.get();let c=new CGL.Geometry("circle");c.setVertices(u);c.verticesIndices=s;if(p!=0){const d=c.getBounds();for(let e=0;e<u.length/3;e++){u[e*3+0]=u[e*3+0]/(d.size[0]/2)*p;u[e*3+1]=u[e*3+1]/(d.size[0]/2)*p}c.setVertices(u)}c.mapTexCoords2d();c.flipVertDir();c.calculateNormals();c.calcTangentsBitangents();v.set(c)};const s={M:["x","y"],m:["dx","dy"],H:["x"],h:["dx"],V:["y"],v:["dy"],L:["x","y"],l:["dx","dy"],Z:[],C:["x1","y1","x2","y2","x","y"],c:["dx1","dy1","dx2","dy2","dx","dy"],S:["x2","y2","x","y"],s:["dx2","dy2","dx","dy"],Q:["x1","y1","x","y"],q:["dx1","dy1","dx","dy"],T:["x","y"],t:["dx","dy"],A:["rx","ry","rotation","large-arc","sweep","x","y"],a:["rx","ry","rotation","large-arc","sweep","dx","dy"]};function g(e){const n=e.replace(/[\n\r]/g,"").replace(/-/g," -").replace(/(\d*\.)(\d+)(?=\.)/g,"$1$2 ").trim().split(/\s*,|\s+/);const a=[];let i="";let r={};while(n.length>0){let t=n.shift();if(s.hasOwnProperty(t)){i=t}else{n.unshift(t)}r={type:i};s[i].forEach(e=>{t=n.shift();r[e]=parseFloat(t)});if(i==="M"){i="L"}else if(i==="m"){i="l"}a.push(r)}return a}const u=15;const o=1e-6;class b{constructor(){this.points=[];this.children=[];this.area=0;this.BEZIER_STEP_SIZE=n.get()}moveTo(e){this.points.push(e)}lineTo(e){this.points.push(e)}close(){let t=this.points[this.points.length-1];this.points.forEach(e=>{this.area+=.5*a(t,e);t=e})}conicTo(t,n){const a=this.points[this.points.length-1];const e=m(a,n)+m(n,t);const i=Math.max(2,Math.min(u,e/this.BEZIER_STEP_SIZE));for(let e=1;e<=i;++e){const r=e/i;this.points.push(p(p(a,n,r),p(n,t,r),r))}}cubicTo(t,n,a){const i=this.points[this.points.length-1];const e=m(i,n)+m(n,a)+m(a,t);const r=Math.max(2,Math.min(u,e/this.BEZIER_STEP_SIZE));for(let e=1;e<=r;++e){const s=e/r;const o=p(p(i,n,s),p(n,a,s),s);const l=p(p(n,a,s),p(a,t,s),s);this.points.push(p(o,l,s))}}inside(a){let i=0,r=this.points[this.points.length-1];this.points.forEach(e=>{const t=r.y<e.y?r:e;const n=r.y<e.y?e:r;if(t.y<a.y+o&&n.y>a.y+o){if((n.x-t.x)*(a.y-t.y)>(a.x-t.x)*(n.y-t.y)){i+=1}}r=e});return i%2!==0}}function m(e,t){const n=e.x-t.x,a=e.y-t.y;return Math.sqrt(n*n+a*a)}function p(e,t,n){return{x:(1-n)*e.x+n*t.x,y:(1-n)*e.y+n*t.y}}function a(e,t){return e.x*t.y-e.y*t.x}};Ops.Graphics.Geometry.SvgPathToGeometry_v2.prototype=new CABLES.Op;CABLES.OPS["4267b3e7-1285-4a3e-acc8-ea92a72a6bc0"]={f:Ops.Graphics.Geometry.SvgPathToGeometry_v2,objName:"Ops.Graphics.Geometry.SvgPathToGeometry_v2"};Ops.Gl.RenderGeometry_v2=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.inTrigger("render"),a=t.inObject("Geometry",null,"geometry"),i=t.inBool("Render Mesh",true),r=t.inBool("Add Vertex Numbers",true),s=t.outTrigger("trigger");t.toWorkPortsNeedToBeLinked(a,n);a.ignoreValueSerialize=true;let o=null;let l=true;a.onLinkChanged=r.onChange=a.onChange=()=>{l=true};n.onTriggered=function(){if(l)u();if(o&&i.get())o.render(t.patch.cgl.getShader());s.trigger()};function u(){l=false;const e=a.get();if(e&&e.isGeometry){if(o){o.dispose();o=null}if(!o){o=new CGL.Mesh(t.patch.cgl,e);o.addVertexNumbers=r.get();o.setGeom(e)}}else{o=null}}};Ops.Gl.RenderGeometry_v2.prototype=new CABLES.Op;CABLES.OPS["0a9bdb39-8250-460e-8d99-50fe6825d956"]={f:Ops.Gl.RenderGeometry_v2,objName:"Ops.Gl.RenderGeometry_v2"};Ops.Gl.Shader.MatCapMaterial_v3=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={matcap_frag:"{{MODULES_HEAD}}\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n#endif\n\nIN vec3 transformedNormal;\nIN vec3 viewSpacePosition;\n\nUNI vec4 inColor;\n\nUNI sampler2D texMatcap;\n\n#ifdef HAS_DIFFUSE_TEXTURE\n   UNI sampler2D texDiffuse;\n#endif\n\n#ifdef USE_SPECULAR_TEXTURE\n   UNI sampler2D texSpec;\n   UNI sampler2D texSpecMatCap;\n#endif\n\n#ifdef HAS_AO_TEXTURE\n    UNI sampler2D texAo;\n    UNI float aoIntensity;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 vBiTangent;\n    IN vec3 vTangent;\n    IN mat3 normalMatrix;\n\n    UNI sampler2D texNormal;\n    UNI float normalMapIntensity;\n#endif\n\n#ifdef HAS_TEXTURE_OPACITY\n    UNI sampler2D texOpacity;\n#endif\n\n#ifdef CALC_SSNORMALS\n    IN vec3 eye_relative_pos;\n\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    vec3 CalculateScreenSpaceNormals() {\n    \tvec3 dFdxPos = dFdx(eye_relative_pos);\n    \tvec3 dFdyPos = dFdy(eye_relative_pos);\n    \tvec3 screenSpaceNormal = normalize( cross(dFdxPos, dFdyPos));\n        return normalize(screenSpaceNormal);\n    }\n#endif\n\n// * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\nvec2 getMatCapUV(vec3 viewSpacePosition, vec3 normal) {\n    vec3 viewDir = normalize(-viewSpacePosition);\n\tvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n\tvec3 y = normalize(cross(viewDir, x));\n\tvec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\treturn uv;\n}\n\nvoid main()\n{\n    vec3 viewSpaceNormal = normalize(transformedNormal);\n\n\n\n    #ifdef HAS_TEXTURES\n        vec2 texCoords = texCoord;\n        {{MODULE_BEGIN_FRAG}}\n    #endif\n\n\n\n    #ifdef DOUBLE_SIDED\n        if(!gl_FrontFacing) viewSpaceNormal *= -1.0;\n    #endif\n\n    #ifdef CALC_SSNORMALS\n        viewSpaceNormal = CalculateScreenSpaceNormals();\n    #endif\n\n\n\n   #ifdef HAS_NORMAL_TEXTURE\n        vec3 normalFromMap = texture( texNormal, texCoord ).xyz * 2.0 - 1.0;\n        normalFromMap = normalize(normalFromMap);\n\n        vec3 tangent;\n        vec3 binormal;\n\n        #ifdef CALC_TANGENT\n            vec3 c1 = cross(normalFromMap, vec3(0.0, 0.0, 1.0));\n            vec3 c2 = cross(normalFromMap, vec3(0.0, 1.0, 0.0));\n\n            tangent = c1;\n            tangent = normalize(tangent);\n            binormal = cross(viewSpaceNormal, tangent);\n            binormal = normalize(binormal);\n        #endif\n\n        #ifndef CALC_TANGENT\n            tangent = normalize(normalMatrix * vTangent);\n            vec3 bitangent = normalize(normalMatrix * vBiTangent);\n            binormal = normalize(cross(viewSpaceNormal, bitangent));\n        #endif\n\n        normalFromMap = normalize(\n            tangent * normalFromMap.x\n            + binormal * normalFromMap.y\n            + viewSpaceNormal * normalFromMap.z\n        );\n\n        vec3 mixedNormal = normalize(viewSpaceNormal + normalFromMap * normalMapIntensity);\n\n        viewSpaceNormal = mixedNormal;\n    #endif\n\n    vec4 col = texture(texMatcap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n\n    #ifdef HAS_DIFFUSE_TEXTURE\n        col = col*texture(texDiffuse, texCoords);\n    #endif\n\n    col.rgb *= inColor.rgb;\n\n\n    #ifdef HAS_AO_TEXTURE\n        col = col\n            * mix(\n                vec4(1.0,1.0,1.0,1.0),\n                texture(texAo, texCoords),\n                aoIntensity\n            );\n    #endif\n\n    #ifdef USE_SPECULAR_TEXTURE\n        vec4 spec = texture(texSpecMatCap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n        spec *= texture(texSpec, texCoords);\n        col += spec;\n    #endif\n\n    col.a *= inColor.a;\n\n    #ifdef HAS_TEXTURE_OPACITY\n        #ifdef TRANSFORMALPHATEXCOORDS\n            texCoords=vec2(texCoord.s,1.0-texCoord.t);\n            texCoords.y = 1. - texCoords.y;\n        #endif\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texOpacity,texCoords).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,texCoords).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texOpacity,texCoords).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texOpacity,texCoords).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texOpacity,texCoords).b;\n        #endif\n\n        #ifdef DISCARDTRANS\n            if(col.a < 0.2) discard;\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}",matcap_vert:"IN vec3 vPosition;\n\n#ifdef HAS_TEXTURES\n    IN vec2 attrTexCoord;\n#endif\n\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 attrTangent;\n    IN vec3 attrBiTangent;\n    OUT vec3 vBiTangent;\n    OUT vec3 vTangent;\n#endif\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI vec3 camPos;\n\n#ifdef HAS_TEXTURES\n    UNI vec2 texOffset;\n    UNI vec2 texRepeat;\n    OUT vec2 texCoord;\n#endif\n\nOUT mat3 normalMatrix;\nOUT vec3 viewSpacePosition;\nOUT vec3 transformedNormal;\n\n{{MODULES_HEAD}}\n\n#ifdef CALC_SSNORMALS\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    OUT vec3 eye_relative_pos;\n#endif\n\nmat3 transposeMat3(mat3 m) {\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n mat3 inverseMat3(mat3 m) {\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    #ifdef HAS_TEXTURES\n        texCoord = texRepeat * vec2(attrTexCoord.x, attrTexCoord.y) + texOffset;\n        texCoord.y = 1. - texCoord.y;\n    #endif\n\n    mat4 mMatrix = modelMatrix;\n    mat4 mvMatrix;\n\n    #ifdef HAS_NORMAL_TEXTURE\n        vec3 tangent = attrTangent;\n        vec3 bitangent = attrBiTangent;\n        vTangent = attrTangent;\n        vBiTangent = attrBiTangent;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.);\n    vec3 norm = attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mvMatrix = viewMatrix * mMatrix;\n    vec3 normal = norm;\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n\n    vec3 fragPos = vec3((mvMatrix) * pos);\n    viewSpacePosition = normalize(fragPos);\n\n    #ifdef CALC_SSNORMALS\n        eye_relative_pos = -(vec3(viewMatrix * vec4(camPos, 1.)) - fragPos);\n    #endif\n\n    transformedNormal = normalize(mat3(normalMatrix) * normal);\n\n    mat4 modelViewMatrix=mvMatrix;\n    {{MODULE_VERTEX_MODELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n\n}\n"};const n=e.patch.cgl;const k=e.inTrigger("Render"),a=e.inTexture("MatCap"),i=e.inTexture("Diffuse"),r=e.inTexture("Normal"),s=e.inTexture("Specular Mask"),o=e.inTexture("Specular MatCap"),l=e.inTexture("AO Texture"),u=e.inTexture("Opacity Texture"),m=e.inValueSlider("r",1),p=e.inValueSlider("g",1),c=e.inValueSlider("b",1),d=e.inValueSlider("Opacity",1),h=e.inValueSlider("AO Intensity",1),f=e.inFloatSlider("Normal Map Intensity",1),v=e.inValue("Repeat X",1),g=e.inValue("Repeat Y",1),b=e.inValue("Offset X",0),x=e.inValue("Offset Y",0),O=e.inValueBool("Double Sided"),_=e.inValueBool("Screen Space Normals"),T=e.inValueBool("Calc normal tangents",true),I=e.inValueBool("Opacity TexCoords Transform",false),y=e.inValueBool("Discard Transparent Pixels"),F=e.outTrigger("Next"),G=e.outObject("Shader");m.setUiAttribs({colorPick:true});const A=e.inSwitch("Alpha Mask Source",["Luminance","R","G","B","A"],"Luminance");A.setUiAttribs({greyout:true});e.setPortGroup("Normals",[T,_,O]);e.setPortGroup("Texture Opacity",[A,I,y]);e.setPortGroup("Texture Transforms",[h,f,v,g,b,x]);e.setPortGroup("Texture Maps",[i,r,s,o,l,u]);e.setPortGroup("Color",[m,p,c,d]);const S=new CGL.Shader(n,"MatCapMaterialNew3");const U=new CGL.Uniform(S,"f","opacity",d);S.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG","MODULE_VERTEX_MODELVIEW"]);S.setSource(t.matcap_vert,t.matcap_frag);G.set(S);const B=new CGL.Uniform(S,"t","texMatcap");let E=null;let C=null;let j=null;let N=null;let L=null;let M=null;const D=new CGL.Uniform(S,"2f","texOffset",b,x);const V=new CGL.Uniform(S,"2f","texRepeat",v,g);const z=new CGL.Uniform(S,"f","aoIntensity",h);const X=new CGL.Uniform(S,"4f","inColor",m,p,c,d);O.onChange=T.onChange=R;R();function R(){S.toggleDefine("DOUBLE_SIDED",O.get());if(T.get())S.define("CALC_TANGENT");else S.removeDefine("CALC_TANGENT")}_.onChange=function(){if(_.get()){if(n.glVersion<2){n.gl.getExtension("OES_standard_derivatives");S.enableExtension("GL_OES_standard_derivatives")}S.define("CALC_SSNORMALS")}else S.removeDefine("CALC_SSNORMALS")};a.onChange=P;function P(){if(!n.defaultMatcapTex3){const a=new Uint8Array(256*4);for(let n=0;n<16;n++){for(let t=0;t<16;t++){let e=t*16;e*=Math.min(1,(n+t/3)/8);a[(n+t*16)*4+0]=a[(n+t*16)*4+1]=a[(n+t*16)*4+2]=e;a[(n+t*16)*4+3]=255}}n.defaultMatcapTex3=new CGL.Texture(n);n.defaultMatcapTex3.initFromData(a,16,16,CGL.Texture.FILTER_LINEAR,CGL.Texture.WRAP_REPEAT)}}i.onChange=function(){if(i.get()){if(E!==null)return;S.define("HAS_DIFFUSE_TEXTURE");S.removeUniform("texDiffuse");E=new CGL.Uniform(S,"t","texDiffuse")}else{S.removeDefine("HAS_DIFFUSE_TEXTURE");S.removeUniform("texDiffuse");E=null}};r.onChange=function(){if(r.get()){if(C!==null)return;S.define("HAS_NORMAL_TEXTURE");S.removeUniform("texNormal");C=new CGL.Uniform(S,"t","texNormal");if(!j)j=new CGL.Uniform(S,"f","normalMapIntensity",f)}else{S.removeDefine("HAS_NORMAL_TEXTURE");S.removeUniform("texNormal");C=null}};l.onChange=function(){if(l.get()){if(M!==null)return;S.define("HAS_AO_TEXTURE");S.removeUniform("texAo");M=new CGL.Uniform(S,"t","texAo")}else{S.removeDefine("HAS_AO_TEXTURE");S.removeUniform("texAo");M=null}};s.onChange=o.onChange=function(){if(s.get()&&o.get()){if(N!==null)return;S.define("USE_SPECULAR_TEXTURE");S.removeUniform("texSpec");S.removeUniform("texSpecMatCap");N=new CGL.Uniform(S,"t","texSpec");L=new CGL.Uniform(S,"t","texSpecMatCap")}else{S.removeDefine("USE_SPECULAR_TEXTURE");S.removeUniform("texSpec");S.removeUniform("texSpecMatCap");N=null;L=null}};function q(){if(A.get()=="Alpha Channel")S.define("ALPHA_MASK_ALPHA");else S.removeDefine("ALPHA_MASK_ALPHA");if(A.get()=="Luminance")S.define("ALPHA_MASK_LUMI");else S.removeDefine("ALPHA_MASK_LUMI");if(A.get()=="R")S.define("ALPHA_MASK_R");else S.removeDefine("ALPHA_MASK_R");if(A.get()=="G")S.define("ALPHA_MASK_G");else S.removeDefine("ALPHA_MASK_G");if(A.get()=="B")S.define("ALPHA_MASK_B");else S.removeDefine("ALPHA_MASK_B")}A.onChange=q;u.onChange=H;let w=null;function H(){if(u.get()){if(w!==null)return;S.removeUniform("texOpacity");S.define("HAS_TEXTURE_OPACITY");if(!w)w=new CGL.Uniform(S,"t","texOpacity");A.setUiAttribs({greyout:false});y.setUiAttribs({greyout:false});I.setUiAttribs({greyout:false})}else{S.removeUniform("texOpacity");S.removeDefine("HAS_TEXTURE_OPACITY");w=null;A.setUiAttribs({greyout:true});y.setUiAttribs({greyout:true});I.setUiAttribs({greyout:true})}q()}y.onChange=function(){if(y.get())S.define("DISCARDTRANS");else S.removeDefine("DISCARDTRANS")};I.onChange=function(){if(I.get())S.define("TRANSFORMALPHATEXCOORDS");else S.removeDefine("TRANSFORMALPHATEXCOORDS")};function Y(){if(s.get()&&!o.get()){e.setUiError("specNoMatCapSpec","You connected a specular texture but have not connected a specular matcap texture. You need to connect both texture inputs for the specular input to work.",1);e.setUiError("noSpecMatCapSpec",null)}else if(!s.get()&&o.get()){e.setUiError("noSpecMatCapSpec","You connected a specular matcap texture but have not connected a specular texture. You need to connect both texture inputs for the specular input to work.",1);e.setUiError("specNoMatCapSpec",null)}else if(s.get()&&o.get()){e.setUiError("specNoMatCapSpec",null);e.setUiError("noSpecMatCapSpec",null)}else{e.setUiError("specNoMatCapSpec",null);e.setUiError("noSpecMatCapSpec",null)}}k.onTriggered=function(){Y();if(!n.defaultMatcapTex3)P();S.popTextures();const e=a.get()||n.defaultMatcapTex3;S.pushTexture(B,e.tex);if(i.get()&&E)S.pushTexture(E,i.get().tex);if(r.get()&&C)S.pushTexture(C,r.get().tex);if(s.get()&&N)S.pushTexture(N,s.get().tex);if(o.get()&&L)S.pushTexture(L,o.get().tex);if(l.get()&&M)S.pushTexture(M,l.get().tex);if(u.get()&&w)S.pushTexture(w,u.get().tex);n.pushShader(S);F.trigger();n.popShader()}};Ops.Gl.Shader.MatCapMaterial_v3.prototype=new CABLES.Op;CABLES.OPS["c1dd6e76-61b4-471a-b8d1-f550a5a9a4f4"]={f:Ops.Gl.Shader.MatCapMaterial_v3,objName:"Ops.Gl.Shader.MatCapMaterial_v3"};Ops.String.String_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inString("value",""),a=e.outString("String");n.onChange=function(){if(!n.isLinked())e.setUiAttrib({extendTitle:n.get()});a.set(n.get())}};Ops.String.String_v2.prototype=new CABLES.Op;CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"]={f:Ops.String.String_v2,objName:"Ops.String.String_v2"};Ops.Gl.Matrix.Scale=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.inTrigger("render"),a=t.inValueFloat("scale",1),i=t.inValueFloat("x",1),r=t.inValueFloat("y",1),s=t.inValueFloat("z",1),o=t.outTrigger("trigger");t.setPortGroup("Axis",[i,r,s]);const l=vec3.create();i.onChange=r.onChange=s.onChange=a.onChange=u;u();n.onTriggered=function(){const e=t.patch.cg||t.patch.cgl;e.pushModelMatrix();mat4.scale(e.mMatrix,e.mMatrix,l);o.trigger();e.popModelMatrix()};function u(){const e=a.get();vec3.set(l,e*i.get(),e*r.get(),e*s.get())}};Ops.Gl.Matrix.Scale.prototype=new CABLES.Op;CABLES.OPS["50e7f565-0cdb-47ca-912b-87c04e2f00e3"]={f:Ops.Gl.Matrix.Scale,objName:"Ops.Gl.Matrix.Scale"};Ops.Anim.LFO=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inValue("Time"),a=e.inValueSelect("Type",["sine","triangle","ramp up","ramp down","block"],"sine"),i=e.inValue("Phase",0),r=e.inValue("Amplitude",1),s=e.outNumber("Result");let o=0;a.onChange=u;u();const l=Math.PI/2;function u(){if(a.get()=="sine")n.onChange=f;if(a.get()=="ramp up")n.onChange=c;if(a.get()=="ramp down")n.onChange=d;if(a.get()=="block")n.onChange=p;if(a.get()=="triangle")n.onChange=h}function m(){return n.get()+i.get()}function p(){let e=m()+.5;o=e%2;if(o<=1)o=-1;else o=1;o*=r.get();s.set(o)}function c(){let e=m()+1;e*=.5;o=e%1;o-=.5;o*=2;o*=r.get();s.set(o)}function d(){let e=m();o=e%1;o-=.5;o*=-2;o*=r.get();s.set(o)}function h(){let e=m();o=e%2;if(o>1)o=2-o;o-=.5;o*=2;o*=r.get();s.set(o)}function f(){let e=m()*Math.PI-l;o=Math.sin(e);o*=r.get();s.set(o)}};Ops.Anim.LFO.prototype=new CABLES.Op;CABLES.OPS["559bb980-78fb-47a7-a199-16f10808b150"]={f:Ops.Anim.LFO,objName:"Ops.Anim.LFO"};Ops.Anim.Timer_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const r=e.inValue("Speed",1),n=e.inValueBool("Play",true),a=e.inTriggerButton("Reset"),i=e.inValueBool("Sync to timeline",false),s=e.outNumber("Time");e.setPortGroup("Controls",[n,a,r]);const o=new CABLES.Timer;let l=null;let u=0;let m=false;n.onChange=p;p();function p(){if(n.get()){o.play();e.patch.addOnAnimFrame(e)}else{o.pause();e.patch.removeOnAnimFrame(e)}}a.onTriggered=c;function c(){u=0;l=null;o.setTime(0);s.set(0)}i.onChange=function(){m=i.get();n.setUiAttribs({greyout:m});a.setUiAttribs({greyout:m})};e.onAnimFrame=function(e,t,n){if(o.isPlaying()){if(CABLES.overwriteTime!==undefined){s.set(CABLES.overwriteTime*r.get())}else if(m){s.set(e*r.get())}else{o.update();const a=o.get();if(l===null){l=a;return}const i=Math.abs(a-l);l=a;u+=i*r.get();if(u!=u)u=0;s.set(u)}}}};Ops.Anim.Timer_v2.prototype=new CABLES.Op;CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"]={f:Ops.Anim.Timer_v2,objName:"Ops.Anim.Timer_v2"};Ops.Gl.Phong.DirectionalLight_v5=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.patch.cgl;const F=t.inTrigger("Trigger In");const a=t.inBool("Cast Light",true);const i=t.inFloat("Intensity",1);const G=[a,i];t.setPortGroup("Light Attributes",G);const r=t.inFloat("X",0);const s=t.inFloat("Y",3);const o=t.inFloat("Z",5);const l=[r,s,o];t.setPortGroup("Direction",l);const u=t.inFloat("R",1);const m=t.inFloat("G",1);const p=t.inFloat("B",1);u.setUiAttribs({colorPick:true});const c=[u,m,p];t.setPortGroup("Color",c);const d=t.inFloat("Specular R",.2);const h=t.inFloat("Specular G",.2);const f=t.inFloat("Specular B",.2);d.setUiAttribs({colorPick:true});const v=[d,h,f];t.setPortGroup("Specular Color",v);const g=t.inBool("Cast Shadow",false);const b=t.inBool("Rendering Active",true);const x=t.inSwitch("Map Size",[256,512,1024,2048],512);const O=t.inFloatSlider("Shadow Strength",1);const _=t.inFloat("LR-BottomTop",8);const T=t.inFloat("Near",.1);const I=t.inFloat("Far",30);const y=t.inFloatSlider("Bias",.004);const A=t.inInt("Polygon Offset",0);const S=t.inFloatSlider("Normal Offset",0);const E=t.inFloatSlider("Blur Amount",0);t.setPortGroup("",[g]);t.setPortGroup("Shadow Map Settings",[x,b,O,_,T,I,y,A,S,E]);x.setUiAttribs({greyout:true});b.setUiAttribs({greyout:true});O.setUiAttribs({greyout:true});_.setUiAttribs({greyout:true,hidePort:true});T.setUiAttribs({greyout:true,hidePort:true});I.setUiAttribs({greyout:true,hidePort:true});y.setUiAttribs({greyout:true,hidePort:true});S.setUiAttribs({greyout:true,hidePort:true});A.setUiAttribs({greyout:true,hidePort:true});E.setUiAttribs({greyout:true});const C=t.inBool("Enable Advanced",false);const j=t.inSwitch("MSAA",["none","2x","4x","8x"],"none");const N=t.inSwitch("Texture Filter",["Linear","Nearest","Mip Map"],"Linear");const L=t.inSwitch("Anisotropic",[0,1,2,4,8,16],"0");j.setUiAttribs({greyout:true,hidePort:true});N.setUiAttribs({greyout:true,hidePort:true});L.setUiAttribs({greyout:true,hidePort:true});t.setPortGroup("Advanced Options",[C,j,N,L]);C.onChange=function(){j.setUiAttribs({greyout:!C.get()});N.setUiAttribs({greyout:!C.get()});L.setUiAttribs({greyout:!C.get()})};const U=t.outTrigger("Trigger Out");const M=t.outTexture("Shadow Map");let B=1/Number(x.get());const R=new CGL.Light(n,{type:"directional",position:[0,1,2].map(function(e){return l[e].get()}),color:[0,1,2].map(function(e){return c[e].get()}),specular:[0,1,2].map(function(e){return v[e].get()}),intensity:i.get(),castShadow:false,shadowStrength:O.get()});R.castLight=a.get();let P=false;function D(){P=true;const e=Number(j.get().charAt(0));let t=null;const n=Number(L.get());if(N.get()=="Linear"){t=CGL.Texture.FILTER_LINEAR}else if(N.get()=="Nearest"){t=CGL.Texture.FILTER_NEAREST}else if(N.get()=="Mip Map"){t=CGL.Texture.FILTER_MIPMAP}const a=Number(x.get());const i={isFloatingPointTexture:true,filter:t};if(e)Object.assign(i,{multisampling:true,multisamplingSamples:e});Object.assign(i,{anisotropic:n});R.createFramebuffer(a,a,i);R.createBlurEffect(i);P=false}function V(){const e=Number(x.get());B=1/e;if(g.get()){R.createFramebuffer(Number(x.get()),Number(x.get()),{});R.createShadowMapShader();R.createBlurEffect({});R.createBlurShader();R.updateProjectionMatrix(_.get(),T.get(),I.get(),null)}if(C.get())D();P=false;w=true}j.onChange=L.onChange=N.onChange=x.onChange=function(){P=true};u.onChange=m.onChange=p.onChange=d.onChange=h.onChange=f.onChange=r.onChange=s.onChange=o.onChange=y.onChange=i.onChange=a.onChange=O.onChange=S.onChange=z;let w=false;function z(e){w=true}g.onChange=function(){P=true;w=true;const e=g.get();x.setUiAttribs({greyout:!e});b.setUiAttribs({greyout:!e});O.setUiAttribs({greyout:!e});_.setUiAttribs({greyout:!e});T.setUiAttribs({greyout:!e});I.setUiAttribs({greyout:!e});E.setUiAttribs({greyout:!e});y.setUiAttribs({greyout:!e});S.setUiAttribs({greyout:!e});A.setUiAttribs({greyout:!e})};_.onChange=T.onChange=I.onChange=function(){w=true};function X(){if(n.shouldDrawHelpers(t)){gui.setTransformGizmo({posX:r,posY:s,posZ:o});CABLES.GL_MARKER.drawLineSourceDest(t,-200*R.position[0],-200*R.position[1],-200*R.position[2],200*R.position[0],200*R.position[1],200*R.position[2])}}let k=false;F.onTriggered=function(){if(P){if(n.tempData.shadowPass)return;V()}if(!n.tempData.shadowPass){if(!R.isUsed&&!k){t.setUiError("lightUsed","No operator is using this light. Make sure this op is positioned before an operator that uses lights. Also make sure there is an operator that uses lights after this.",1);k=true}else if(!R.isUsed&&k){}else if(R.isUsed&&k){t.setUiError("lightUsed",null);k=false}else if(R.isUsed&&!k){}R.isUsed=false}if(w){R.color=[u.get(),m.get(),p.get()];R.specular=[d.get(),h.get(),f.get()];R.intensity=i.get();R.castLight=a.get();R.position=[r.get(),s.get(),o.get()];R.updateProjectionMatrix(_.get(),T.get(),I.get(),null);R.castShadow=g.get();R.normalOffset=S.get();R.shadowBias=y.get();R.shadowStrength=O.get();w=false}if(!n.tempData.lightStack)n.tempData.lightStack=[];if(!n.tempData.shadowPass)X();n.tempData.lightStack.push(R);if(g.get()){const e=1.5*E.get()*B;if(b.get())R.renderPasses(A.get(),e,function(){U.trigger()});R.blurAmount=E.get();M.set(null);M.set(R.getShadowMapDepth());n.tempData.lightStack.pop();n.tempData.lightStack.push(R)}else{M.set(null)}U.trigger();n.tempData.lightStack.pop()}};Ops.Gl.Phong.DirectionalLight_v5.prototype=new CABLES.Op;CABLES.OPS["9f41bf91-f4e0-4ce4-89d8-72627b76261e"]={f:Ops.Gl.Phong.DirectionalLight_v5,objName:"Ops.Gl.Phong.DirectionalLight_v5"};Ops.Gl.Pbr.PbrEnvironmentLight=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={IBLLUT_frag:"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n#ifndef WEBGL1\n#define NUM_SAMPLES 1024u\n#else\n#define NUM_SAMPLES 1024\n#endif\n#define PI 3.14159265358\n\nIN vec3 P;\n{{MODULES_HEAD}}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables\n#if NUM_SAMPLES > 0\n    #ifndef WEBGL1\n        // https://learnopengl.com/PBR/IBL/Specular-IBL\n        // Hammersley\n        float radicalInverse_VdC(uint bits)\n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n\n        vec2 hammersley(uint i, uint N)\n        {\n            return vec2(float(i)/float(N), radicalInverse_VdC(i));\n        }\n    #else\n        float vanDerCorpus(int n, int base)\n        {\n            float invBase = 1.0 / float(base);\n            float denom   = 1.0;\n            float result  = 0.0;\n\n            for(int i = 0; i < 32; ++i)\n            {\n                if(n > 0)\n                {\n                    denom   = mod(float(n), 2.0);\n                    result += denom * invBase;\n                    invBase = invBase / 2.0;\n                    n       = int(float(n) / 2.0);\n                }\n            }\n\n            return result;\n        }\n\n        vec2 hammersley(int i, int N)\n        {\n            return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n        }\n    #endif\n\n\t// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\n\tvec3 hemisphereImportanceSampleDggx(vec2 u, float a) {\n\t\t// pdf = D(a) * cosTheta\n\t\tfloat phi = 2. * PI * u.x;\n\n\t\t// NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy\n\t\tfloat cosTheta2 = (1. - u.y) / (1. + (a + 1.) * ((a - 1.) * u.y));\n\t\tfloat cosTheta = sqrt(cosTheta2);\n\t\tfloat sinTheta = sqrt(1. - cosTheta2);\n\n\t\treturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t}\n\n\t// from https://google.github.io/filament/Filament.md.html#toc9.5\n\t// modified to use different syntax for a number of variables\n    const float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\n    const float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n    const float NUM_SAMPLES_FLOAT_INVERSED4 = 4. / NUM_SAMPLES_FLOAT;\n\n    float Visibility(float NdotV, float NdotL, float alphaG)\n    {\n        // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\n        #ifdef WEBGL1\n            // Appply simplification as all squared root terms are below 1 and squared\n            float GGXV = NdotL * (NdotV * (1.0 - alphaG) + alphaG);\n            float GGXL = NdotV * (NdotL * (1.0 - alphaG) + alphaG);\n            return 0.5 / (GGXV + GGXL);\n        #else\n            float a2 = alphaG * alphaG;\n            float GGXV = NdotL * sqrt(NdotV * (NdotV - a2 * NdotV) + a2);\n            float GGXL = NdotV * sqrt(NdotL * (NdotL - a2 * NdotL) + a2);\n            return 0.5 / (GGXV + GGXL);\n        #endif\n    }\n\n\tvoid main()\n\t{\n\t    // actual implementation (not documentation) here: https://github.com/google/filament/blob/94ff2ea6b1e39d909e9066459f2ce8c2942eb876/libs/ibl/src/CubemapIBL.cpp\n\t\t{{MODULE_BEGIN_FRAG}}\n\t\tfloat NoV = P.x;\n\t\tfloat a   = P.y;\n\n\t\tvec3 V;\n\t\tV.x = sqrt(1.0 - NoV*NoV);\n\t\tV.y = 0.0;\n\t\tV.z = NoV;\n\n\t\tvec2 r = vec2(0.0);\n\n        #ifndef WEBGL1\n        for(uint i = 0u; i < NUM_SAMPLES; i++)\n        #else\n        for(int i = 0; i < NUM_SAMPLES; i++)\n        #endif\n        {\n\t\t\tvec2 Xi = hammersley(i, NUM_SAMPLES);\n\t\t\tvec3 H  = hemisphereImportanceSampleDggx(Xi, a);\n\t\t\tvec3 L  = 2.0 * dot(V, H) * H - V;\n\n\t\t\tfloat VoH = clamp(dot(V, H), 0.0, 1.0);\n\t\t\tfloat NoL = clamp(L.z, 0.0, 1.0);\n\t\t\tfloat NoH = clamp(H.z, 0.0, 1.0);\n\n\t\t\tif (NoL > 0.0) {\n\t\t\t\tfloat Gv = Visibility(NoV, NoL, a) * NoL * (VoH / NoH);\n\t\t\t\tfloat Fc = pow(1.0 - VoH, 5.0);\n\n\t\t\t\t// modified for multiscattering https://google.github.io/filament/Filament.md.html#toc5.3.4.7\n\t\t\t    r.x += Gv * Fc;\n\t\t\t\tr.y += Gv;\n\t\t\t}\n\t\t}\n\t\tr *= NUM_SAMPLES_FLOAT_INVERSED4;\n\n\t\t{{MODULE_COLOR}}\n\t\toutColor = vec4(r.x, r.y, 0.0, 1.0);\n\t}\n#endif\n",IBLLUT_vert:"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nOUT vec3 P;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n   vec4 pos     = vec4(vPosition,  1.0);\n   mat4 mMatrix = modelMatrix;\n\n   {{MODULE_VERTEX_POSITION}}\n\n   gl_Position  = pos;\n\n   P            = (vPosition + 1.0) * 0.5;\n}\n",irradiance_frag:'precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables, equirectangular projection and rgbe encoding\n{{MODULES_HEAD}}\n#ifndef WEBGL1\n#define NUM_SAMPLES 2048u\n#else\n#define NUM_SAMPLES 2048\n#endif\n#define PI 3.14159265358\n#define PI_TWO 2.*PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod texture2DLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\n// set by cables\nUNI vec3 camPos;\n\nIN  vec3 FragPos;\nUNI float rotation;\nUNI vec2 filteringInfo;\nUNI sampler2D EquiCubemap;\n\nvec2 SampleSphericalMap(vec3 direction, float rotation)\n{\n    #ifndef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV;\n\t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5);\n\t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n    #endif\n\n    #ifdef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n        sampleUV *= vec2(-0.1591, 0.3183);\n        sampleUV += 0.5;\n    #endif\n    sampleUV.x += rotation;\n    return sampleUV * vec2(-1.,1.);\n}\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nvec4 EncodeRGBE8(vec3 rgb)\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nvec3 DecodeRGBE8(vec4 rgbe)\n{\n    vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\nvec3 hemisphereCosSample(vec2 u) {\n    // pdf = cosTheta / M_PI;\n    float phi = 2. * PI * u.x;\n\n    float cosTheta2 = 1. - u.y;\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(1. - cosTheta2);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n#ifndef WEBGL1\n    // https://learnopengl.com/PBR/IBL/Specular-IBL\n    // Hammersley\n    float radicalInverse_VdC(uint bits)\n    {\n        bits = (bits << 16u) | (bits >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n    }\n\n    vec2 hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), radicalInverse_VdC(i));\n    }\n#else\n    float vanDerCorpus(int n, int base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(int i = 0; i < 32; ++i)\n        {\n            if(n > 0)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = int(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n\n    vec2 hammersley(int i, int N)\n    {\n        return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n    }\n#endif\n\n// from https://github.com/google/filament/blob/main/shaders/src/light_indirect.fs\nfloat prefilteredImportanceSampling(float ipdf, float omegaP)\n{\n    // See: "Real-time Shading with Filtered Importance Sampling", Jaroslav Krivanek\n    // Prefiltering doesn\'t work with anisotropy\n    const float numSamples = float(NUM_SAMPLES);\n    const float invNumSamples = 1.0 / float(numSamples);\n    const float K = 4.0;\n    float omegaS = invNumSamples * ipdf;\n    float mipLevel = log2(K * omegaS / omegaP) * 0.5;    // log4\n    return mipLevel;\n}\n\nconst float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n\nconst float K = 4.;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n\n    vec3 n = normalize(FragPos);\n    vec3 tangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n    vec3 bitangent = cross(n, tangent);\n    mat3 tbn = mat3(tangent, bitangent, n);\n\n    float maxLevel = filteringInfo.y;\n    float dim0 = filteringInfo.x;\n    float omegaP = (4. * PI) / (6. * dim0 * dim0);\n\n    #ifndef WEBGL1\n    for(uint i = 0u; i < NUM_SAMPLES; ++i)\n    #else\n    for(int i = 0; i < NUM_SAMPLES; ++i)\n    #endif\n    {\n        vec2 Xi = hammersley(i, NUM_SAMPLES);\n        vec3 Ls = hemisphereCosSample(Xi);\n\n        Ls = normalize(Ls);\n\n        vec3 Ns = vec3(0., 0., 1.);\n\n        float NoL = dot(Ns, Ls);\n\n        if (NoL > 0.) {\n            float pdf_inversed = PI / NoL;\n\n            float omegaS = NUM_SAMPLES_FLOAT_INVERSED * pdf_inversed;\n            // from https://github.com/google/filament/blob/main/shaders/src/light_indirect.fs\n            float l = log2(K * omegaS / omegaP) * 0.5;\n            float mipLevel = clamp(l + 1.0, 0.0, maxLevel);\n\n            #ifndef DONT_USE_RGBE_CUBEMAPS\n            vec3 c = DecodeRGBE8(SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * Ls, rotation), mipLevel)).rgb;\n            #else\n            vec3 c = SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * Ls, rotation), mipLevel).rgb;\n            #endif\n            col.rgb += c;\n        }\n    }\n\n    col = EncodeRGBE8(col.rgb * PI * NUM_SAMPLES_FLOAT_INVERSED);\n\n    {{MODULE_COLOR}}\n    outColor = col;\n}\n',irradiance_vert:"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN float attrVertIndex;\n\nOUT vec3 FragPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n\nvoid main()\n{\n    FragPos     = vPosition;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vPosition, 1.0);\n    gl_Position = gl_Position.xyww;\n}\n",prefiltering_frag:"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables, equirectangular projection and rgbe encoding\n{{MODULES_HEAD}}\n#ifndef WEBGL1\n#define NUM_SAMPLES 2048u\n#else\n#define NUM_SAMPLES 2048\n#endif\n#define PI 3.14159265358\n#define PI_TWO 2.*PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n#define MINIMUMVARIANCE 0.0005\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod texture2DLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\nIN  vec3 FragPos;\nUNI float roughness;\nUNI float rotation;\nUNI vec2 filteringInfo;\nUNI sampler2D EquiCubemap;\n\nvec2 SampleSphericalMap(vec3 direction, float rotation)\n{\n    #ifndef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV;\n\t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5);\n\t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n    #endif\n\n    #ifdef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n        sampleUV *= vec2(-0.1591, 0.3183);\n        sampleUV += 0.5;\n    #endif\n    sampleUV.x += rotation;\n    return sampleUV * vec2(-1.,1.);\n}\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nvec4 EncodeRGBE8(vec3 rgb)\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nvec3 DecodeRGBE8(vec4 rgbe)\n{\n    vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\nvec3 hemisphereImportanceSampleDggx(vec2 u, float a) {\n    // pdf = D(a) * cosTheta\n    float phi = 2. * PI * u.x;\n\n    // NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy\n    float cosTheta2 = (1. - u.y) / (1. + (a + 1.) * ((a - 1.) * u.y));\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(1. - cosTheta2);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n    // Note: alphaG is average slope (gradient) of the normals in slope-space.\n    // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n    // a tangent (gradient) closer to the macrosurface than this slope.\n    float a2 = alphaG * alphaG;\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * d * d);\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrHelperFunctions.fx\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n    // Calculate AlphaG as square of roughness (add epsilon to avoid numerical issues)\n    return (roughness * roughness) + MINIMUMVARIANCE;\n}\n\n\n#ifndef WEBGL1\n    // https://learnopengl.com/PBR/IBL/Specular-IBL\n    // Hammersley\n    float radicalInverse_VdC(uint bits)\n    {\n        bits = (bits << 16u) | (bits >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n    }\n\n    vec2 hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), radicalInverse_VdC(i));\n    }\n#else\n    float vanDerCorpus(int n, int base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(int i = 0; i < 32; ++i)\n        {\n            if(n > 0)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = int(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n\n    vec2 hammersley(int i, int N)\n    {\n        return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n    }\n#endif\n\nfloat log4(float x)\n{\n    return log2(x) / 2.;\n}\n\nconst float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n\nconst float K = 4.;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec3 n = normalize(FragPos);\n    float alphaG = convertRoughnessToAverageSlope(roughness);\n    vec4 result = vec4(0.);\n\n    if (alphaG == 0.)\n    {\n        result = SAMPLETEX(EquiCubemap, SampleSphericalMap(n, rotation), 0.0);\n    }\n    else\n    {\n        vec3 tangent = abs(n.z) < 0.999 ? vec3(0., 0., 1.) : vec3(1., 0., 0.);\n        tangent = normalize(cross(tangent, n));\n        vec3 bitangent = cross(n, tangent);\n        mat3 tbn = mat3(tangent, bitangent, n);\n\n        float maxLevel = filteringInfo.y;\n        float dim0 = filteringInfo.x;\n        float omegaP = (4. * PI) / (6. * dim0 * dim0);\n\n        float weight = 0.;\n        #if defined(WEBGL2)\n        for(uint i = 0u; i < NUM_SAMPLES; ++i)\n        #else\n        for(int i = 0; i < NUM_SAMPLES; ++i)\n        #endif\n        {\n            vec2 Xi = hammersley(i, NUM_SAMPLES);\n            vec3 H = hemisphereImportanceSampleDggx(Xi, alphaG);\n\n            float NoV = 1.;\n            float NoH = H.z;\n            float NoH2 = H.z * H.z;\n            float NoL = 2. * NoH2 - 1.;\n            vec3 L = vec3(2. * NoH * H.x, 2. * NoH * H.y, NoL);\n            L = normalize(L);\n\n            if (NoL > 0.)\n            {\n                float pdf_inversed = 4. / normalDistributionFunction_TrowbridgeReitzGGX(NoH, alphaG);\n\n                float omegaS = NUM_SAMPLES_FLOAT_INVERSED * pdf_inversed;\n                float l = log4(omegaS) - log4(omegaP) + log4(K);\n                float mipLevel = clamp(l, 0.0, maxLevel);\n\n                weight += NoL;\n\n                #ifndef DONT_USE_RGBE_CUBEMAPS\n                vec3 c = DecodeRGBE8(SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * L, rotation), mipLevel)).rgb;\n                #else\n                vec3 c = SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * L, rotation), mipLevel).rgb;\n                #endif\n                result.rgb += c * NoL;\n            }\n        }\n\n        result = result / weight;\n        result = EncodeRGBE8(result.rgb);\n    }\n\n    {{MODULE_COLOR}}\n    outColor = result;\n}\n",prefiltering_vert:"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN float attrVertIndex;\n\nOUT vec3 FragPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n\nvoid main()\n{\n    FragPos     = vPosition;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vPosition, 1.0);\n    gl_Position = gl_Position.xyww;\n}\n"};const r=e.patch.cgl;const k=r.glVersion==1;const F=new CABLES.CG.BoundingBox;const n=new CGL.Geometry("unit cube");n.vertices=new Float32Array([-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1]);const s=new CGL.Mesh(r,n);const G=CGL.MESHES.getSimpleRect(r,"fullscreenRectangle");const U=e.inTrigger("render");const B=e.inFloatSlider("Intensity",1);const o=e.inTexture("RGBE Environment map");const a=e.inDropDown("Size Irradiance map",[16,32,64],64);const i=e.inDropDown("Size pre-filtered environment",[64,128],128);const l=e.inDropDown("Size IBL LUT",[128,256,512,1024],256);const u=e.inBool("Force 8bit IBL",true);const m=e.inBool("Environment map does not contain RGBE data",false);const p=e.inFloat("Rotation",0);const c=e.inValueBool("Use parallax correction",false);const d=e.inFloat("center X",0);const h=e.inFloat("center Y",1.8);const f=e.inFloat("center Z",0);const v=e.inFloat("Box min X",-1);const g=e.inFloat("Box min Y",-1);const b=e.inFloat("Box min Z",-1);const x=e.inFloat("Box max X",1);const O=e.inFloat("Box max Y",1);const _=e.inFloat("Box max Z",1);e.setPortGroup("Parallax Correction",[c,d,h,f,v,g,b,x,O,_]);let T=true;let I=true;let y=true;a.onChange=()=>{T=true};i.onChange=()=>{I=true};l.onChange=u.onChange=()=>{y=true};const A=e.outTrigger("next");const D=e.outTexture("IBL LUT");const V=e.outTexture("cubemap (diffuse irradiance)");const z=e.outTexture("cubemap (pre-filtered environment map)");const X=e.outNumber("Number of Pre-filtered mip levels");e.toWorkPortsNeedToBeLinked(o);let S=null;let q=null;let E=null;let C=null;let j=null;const N={};const L=new CGL.Shader(r,"IrradianceShader");const M=new CGL.Shader(r,"PrefilteringShader");L.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);M.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);if(r.glVersion==1){if(!r.gl.getExtension("EXT_shader_texture_lod")){e.log("no EXT_shader_texture_lod texture extension");throw"no EXT_shader_texture_lod texture extension"}else{L.enableExtension("GL_EXT_shader_texture_lod");M.enableExtension("GL_EXT_shader_texture_lod");r.gl.getExtension("OES_texture_float");r.gl.getExtension("OES_texture_float_linear");r.gl.getExtension("OES_texture_half_float");r.gl.getExtension("OES_texture_half_float_linear");r.gl.getExtension("WEBGL_color_buffer_float");L.enableExtension("GL_OES_standard_derivatives");L.enableExtension("GL_OES_texture_float");L.enableExtension("GL_OES_texture_float_linear");L.enableExtension("GL_OES_texture_half_float");L.enableExtension("GL_OES_texture_half_float_linear");M.enableExtension("GL_OES_standard_derivatives");M.enableExtension("GL_OES_texture_float");M.enableExtension("GL_OES_texture_float_linear");M.enableExtension("GL_OES_texture_half_float");M.enableExtension("GL_OES_texture_half_float_linear")}}let R=[0,0];L.offScreenPass=true;const H=new CGL.Uniform(L,"t","EquiCubemap",0);const Y=new CGL.Uniform(L,"2f","filteringInfo",R);const W=new CGL.Uniform(L,"f","rotation",0);L.setSource(t.irradiance_vert,t.irradiance_frag);let P=[0,0];M.offScreenPass=true;const Z=new CGL.Uniform(M,"t","EquiCubemap",0);const K=new CGL.Uniform(M,"f","roughness",0);const J=new CGL.Uniform(M,"f","rotation",0);const Q=new CGL.Uniform(M,"2f","filteringInfo",P);M.setSource(t.prefiltering_vert,t.prefiltering_frag);const w=new CGL.Shader(r,"IBLLUTShader");w.offScreenPass=true;w.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);w.setSource(t.IBLLUT_vert,t.IBLLUT_frag);m.onChange=()=>{L.toggleDefine("DONT_USE_RGBE_CUBEMAPS",m);M.toggleDefine("DONT_USE_RGBE_CUBEMAPS",m);T=true;I=true};p.onChange=()=>{I=T=true};function $(e){if(S)S.dispose();S=new CGL.CubemapFramebuffer(r,Number(e),Number(e),{clear:false,filter:CGL.Texture.FILTER_NEAREST,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE});R[0]=e;R[1]=1+Math.floor(Math.log(e)*1.4426950408889634);L.popTextures();L.pushTexture(H,o.get().tex);W.setValue(p.get()/360);S.renderStart(r);for(let e=0;e<6;e+=1){S.renderStartCubemapFace(e);s.render(L);S.renderEndCubemapFace()}S.renderEnd();V.set(S.getTextureColor())}function ee(e){e=Number(e);let n=new CGL.CubemapFramebuffer(r,e,e,{isFloatingPointTexture:false,clear:false,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE});if(E)E.dispose();E=new CGL.CubemapFramebuffer(r,e,e,{clear:false,filter:CGL.Texture.FILTER_MIPMAP,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE});r.gl.bindTexture(r.gl.TEXTURE_CUBE_MAP,E.getTextureColor().tex);r.gl.texParameteri(r.gl.TEXTURE_CUBE_MAP,r.gl.TEXTURE_WRAP_S,r.gl.CLAMP_TO_EDGE);r.gl.texParameteri(r.gl.TEXTURE_CUBE_MAP,r.gl.TEXTURE_WRAP_T,r.gl.CLAMP_TO_EDGE);if(r.glVersion==2)r.gl.texParameteri(r.gl.TEXTURE_CUBE_MAP,r.gl.TEXTURE_WRAP_R,r.gl.CLAMP_TO_EDGE);r.gl.texParameteri(r.gl.TEXTURE_CUBE_MAP,r.gl.TEXTURE_MIN_FILTER,r.gl.LINEAR_MIPMAP_LINEAR);r.gl.texParameteri(r.gl.TEXTURE_CUBE_MAP,r.gl.TEXTURE_MAG_FILTER,r.gl.LINEAR);r.gl.generateMipmap(r.gl.TEXTURE_CUBE_MAP);j=1+Math.floor(Math.log(e)*1.4426950408889634);X.set(j);P[0]=e;P[1]=j;M.popTextures();M.pushTexture(Z,o.get().tex);J.setValue(p.get()/360);let t=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)&&navigator.userAgent.match(/iPhone/i);if(t){j=0}for(let t=0;t<=j;++t){const a=e*.5**t;const i=t/(j-1);K.setValue(i);n.setSize(a,a);n.renderStart(r);for(let e=0;e<6;e++){n.renderStartCubemapFace(e);s.render(M);r.gl.bindTexture(r.gl.TEXTURE_CUBE_MAP,E.getTextureColor().tex);r.gl.copyTexImage2D(r.gl.TEXTURE_CUBE_MAP_POSITIVE_X+e,t,r.gl.RGBA8,0,0,a,a,0);n.renderEndCubemapFace()}n.renderEnd()}if(t){r.gl.bindTexture(r.gl.TEXTURE_CUBE_MAP,E.getTextureColor().tex);r.gl.generateMipmap(r.gl.TEXTURE_CUBE_MAP)}n.delete();r.setTexture(0,null);z.setRef(E.getTextureColor())}function te(t){t=Number(t);if(C)C.dispose();if(k){C=new CGL.Framebuffer(r,t,t,{isFloatingPointTexture:true,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE})}else{let e=!u.get()&&!r.glUseHalfFloatTex;if(e){C=new CGL.Framebuffer2(r,t,t,{pixelFormat:CGL.Texture.PFORMATSTR_RG16F,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE})}else{C=new CGL.Framebuffer2(r,t,t,{filter:CGL.Texture.FILTER_LINEAR,pixelFormat:CGL.Texture.PFORMATSTR_RGBA8UB,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE})}}r.tempData.renderOffscreen=true;C.renderStart(r);G.render(w);C.renderEnd();r.tempData.renderOffscreen=false;D.set(C.getTextureColor())}o.onChange=()=>{if(o.get())e.setUiError("nocubemapinput",null);I=T=true};function ne(){gui.setTransformGizmo({posX:d,posY:h,posZ:f});gui.setTransformGizmo({posX:v,posY:g,posZ:b},1);gui.setTransformGizmo({posX:x,posY:O,posZ:_},2);if(CABLES.UI&&gui.shouldDrawOverlay){r.pushShader(CABLES.GL_MARKER.getDefaultShader(r))}else{r.pushShader(CABLES.GL_MARKER.getSelectedShader(r))}r.pushModelMatrix();mat4.translate(r.mMatrix,r.mMatrix,[(v.get()+x.get())/2,(g.get()+O.get())/2,(b.get()+_.get())/2]);mat4.scale(r.mMatrix,r.mMatrix,[(x.get()-v.get())/2,(O.get()-g.get())/2,(_.get()-b.get())/2]);F.render(r);r.popShader();r.popModelMatrix()}c.onChange=()=>{const e=c.get();d.setUiAttribs({greyout:!e});h.setUiAttribs({greyout:!e});f.setUiAttribs({greyout:!e});v.setUiAttribs({greyout:!e});g.setUiAttribs({greyout:!e});b.setUiAttribs({greyout:!e});x.setUiAttribs({greyout:!e});O.setUiAttribs({greyout:!e});_.setUiAttribs({greyout:!e})};U.onTriggered=function(){if(!o.get()){A.trigger();e.setUiError("nocubemapinput","No Environment Texture connected");return}Y.setValue(R);Q.setValue(P);if(!r.tempData.shadowPass){if(y){te(Number(l.get()));y=false}if(I){ee(Number(i.get()));I=false}if(T){$(Number(a.get()));T=false}}N.texIBLLUT=C.getTextureColor();N.texDiffIrr=S.getTextureColor();N.texPreFiltered=E.getTextureColor();N.texPreFilteredMipLevels=X.get();N.intensity=B.get();N.UseParallaxCorrection=c.get();N.PCOrigin=[d.get(),h.get(),f.get()];N.PCboxMin=[v.get(),g.get(),b.get()];N.PCboxMax=[x.get(),O.get(),_.get()];r.tempData.pbrEnvStack=r.tempData.pbrEnvStack||[];r.tempData.pbrEnvStack.push(N);if(r.shouldDrawHelpers(e)&&N.UseParallaxCorrection&&!r.tempData.shadowPass)ne();A.trigger();r.tempData.pbrEnvStack.pop()}};Ops.Gl.Pbr.PbrEnvironmentLight.prototype=new CABLES.Op;CABLES.OPS["7110f169-adfd-4649-a77a-c825751eaa9b"]={f:Ops.Gl.Pbr.PbrEnvironmentLight,objName:"Ops.Gl.Pbr.PbrEnvironmentLight"};Ops.Gl.Texture_v2=function(){CABLES.Op.apply(this,arguments);const i=this;const e=i.attachments={};const r=i.inUrl("File",[".jpg",".png",".webp",".jpeg",".avif"]),t=i.inSwitch("Filter",["nearest","linear","mipmap"]),n=i.inValueSelect("Wrap",["repeat","mirrored repeat","clamp to edge"],"clamp to edge"),a=i.inSwitch("Anisotropic",["0","1","2","4","8","16"],"0"),s=i.inSwitch("Data Format",["R","RG","RGB","RGBA","SRGBA"],"RGBA"),o=i.inValueBool("Flip",false),l=i.inValueBool("Pre Multiplied Alpha",false),u=i.inValueBool("Active",true),m=i.inBool("Save Memory",true),p=i.outTexture("Texture"),c=i.inBool("Add Cachebuster",false),d=i.inTriggerButton("Reload"),h=i.outNumber("Width"),f=i.outNumber("Height"),v=i.outNumber("Aspect Ratio"),g=i.outBoolNum("Loaded",0),b=i.outBoolNum("Loading",0);const x=i.patch.cgl;i.toWorkPortsNeedToBeLinked(p);i.setPortGroup("Size",[h,f]);let O=null;let _=null;let T=null;let I=CGL.Texture.FILTER_MIPMAP;let y=CGL.Texture.WRAP_REPEAT;let A=0;let S=0;l.setUiAttribs({hidePort:true});l.onChange=r.onChange=s.onChange=c.onChange=o.onChange=C;a.onChange=t.onChange=L;n.onChange=M;t.set("mipmap");n.set("repeat");p.setRef(CGL.Texture.getEmptyTexture(x));d.onTriggered=C;u.onChange=function(){if(u.get()){if(O!=r.get()||!T)C();else p.setRef(T)}else{p.setRef(CGL.Texture.getEmptyTexture(x));h.set(CGL.Texture.getEmptyTexture(x).width);f.set(CGL.Texture.getEmptyTexture(x).height);if(T)T.delete();i.setUiAttrib({extendTitle:""});T=null}};const E=function(){const e=CGL.Texture.getTempTexture(x);p.setRef(e)};function C(e){clearTimeout(S);S=setTimeout(function(){N(e)},1)}function j(){if(s.get()=="R")return CGL.Texture.PFORMATSTR_R8UB;if(s.get()=="RG")return CGL.Texture.PFORMATSTR_RG8UB;if(s.get()=="RGB")return CGL.Texture.PFORMATSTR_RGB8UB;if(s.get()=="SRGBA")return CGL.Texture.PFORMATSTR_SRGBA8;return CGL.Texture.PFORMATSTR_RGBA8UB}function N(e){i.checkMainloopExists();if(!u.get())return;if(_)_=x.patch.loading.finished(_);_=x.patch.loading.start(i.objName,r.get(),i);let t=i.patch.getFilePath(String(r.get()));if(c.get()||e===true)t=CABLES.cacheBust(t);if(String(r.get()).indexOf("data:")==0)t=r.get();let n=false;O=r.get();if(r.get()&&r.get().length>1){g.set(false);b.set(true);const a=r.get();i.setUiAttrib({extendTitle:CABLES.basename(t)});if(n)i.refreshParams();x.patch.loading.addAssetLoadingTask(()=>{i.setUiError("urlerror",null);CGL.Texture.load(x,t,function(e,t){x.checkFrameStarted("texture inittexture");if(r.get()!=a){_=x.patch.loading.finished(_);return}if(T)T.delete();if(e){const n=CGL.Texture.getErrorTexture(x);p.setRef(n);i.setUiError("urlerror",'could not load texture: "'+r.get()+'"',2);_=x.patch.loading.finished(_);return}h.set(t.width);f.set(t.height);v.set(t.width/t.height);T=t;p.setRef(T);b.set(false);g.set(true);if(m.get())T.image=null;if(_){_=x.patch.loading.finished(_)}i.checkMainloopExists()},{anisotropic:A,wrap:y,flip:o.get(),unpackAlpha:l.get(),pixelFormat:j(),filter:I});i.checkMainloopExists()})}else{E();_=x.patch.loading.finished(_)}}function L(){if(t.get()=="nearest")I=CGL.Texture.FILTER_NEAREST;else if(t.get()=="linear")I=CGL.Texture.FILTER_LINEAR;else if(t.get()=="mipmap")I=CGL.Texture.FILTER_MIPMAP;else if(t.get()=="Anisotropic")I=CGL.Texture.FILTER_ANISOTROPIC;a.setUiAttribs({greyout:I!=CGL.Texture.FILTER_MIPMAP});A=parseFloat(a.get());C()}function M(){if(n.get()=="repeat")y=CGL.Texture.WRAP_REPEAT;if(n.get()=="mirrored repeat")y=CGL.Texture.WRAP_MIRRORED_REPEAT;if(n.get()=="clamp to edge")y=CGL.Texture.WRAP_CLAMP_TO_EDGE;C()}i.onFileChanged=function(e){if(r.get()&&r.get().indexOf(e)>-1){p.setRef(CGL.Texture.getEmptyTexture(i.patch.cgl));p.setRef(CGL.Texture.getTempTexture(x));N(true)}}};Ops.Gl.Texture_v2.prototype=new CABLES.Op;CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"]={f:Ops.Gl.Texture_v2,objName:"Ops.Gl.Texture_v2"};Ops.Gl.CubeMap.Skybox=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={skybox_frag:"#define PI 3.14159265358 //97932384626433832795\n#define PI_TWO 2. * PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\nUNI vec2 expGamma;\n\n\n#ifdef TEX_FORMAT_CUBEMAP\n    UNI samplerCube skybox;\n    #ifndef WEBGL1\n        #define SAMPLETEX texture\n    #endif\n    #ifdef WEBGL1\n        #define SAMPLETEX textureCubeLodEXT\n    #endif\n#endif\n\n#ifndef TEX_FORMAT_CUBEMAP\n    #define TEX_FORMAT_EQUIRECT\n    UNI sampler2D skybox;\n    #ifdef WEBGL1\n        #ifdef GL_EXT_shader_texture_lod\n            #define textureLod texture2DLodEXT\n        #endif\n    #endif\n    #define SAMPLETEX sampleEquirect\n\n#endif\n\nIN vec3 worldPos;\n\nvec4 sampleEquirect(sampler2D tex, vec3 direction,float lod) {\n    vec2 sampleUV;\n    vec3 newDirection = normalize(direction);\n\n    sampleUV.x = atan( newDirection.z, newDirection.x ) * RECIPROCAL_PI2 + 0.75;\n    sampleUV.y = asin( clamp(newDirection.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n\n    return texture(tex, sampleUV);\n}\n\nvec4 sampleEquirect(sampler2D tex, vec3 direction) {\n    return sampleEquirect(tex,direction,0.0);\n}\n\nhighp vec3 DecodeRGBE8(highp vec4 rgbe)\n{\n    highp vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\nvoid main() {\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = vec4(1.);\n\n    {{MODULE_COLOR}}\n\n    vec3 newPos = worldPos;\n\n    vec4 finalColor;\n    #ifndef RGBE\n        finalColor = vec4(SAMPLETEX(skybox, newPos,0.0));\n    #endif\n\n    #ifdef RGBE\n        finalColor.rgb=DecodeRGBE8(SAMPLETEX(skybox, newPos));\n    #endif\n\n    float gamma=expGamma.x;\n    float exposure=expGamma.y;\n    finalColor.rgb = vec3(1.0) - exp(-finalColor.rgb * exposure);\n\n    finalColor.rgb = pow(finalColor.rgb, vec3(1.0 / gamma));\n    outColor=vec4(finalColor.rgb,1.0);\n\n}\n",skybox_vert:"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nOUT vec3 worldPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mMatrix=modelMatrix;\n    worldPos = vec3(mMatrix * pos);\n    mat4 rotView = mat4(mat3(viewMatrix)); // remove translation from the view matrix\n    vec4 clipPos = projMatrix * rotView * pos;\n\n    gl_Position = clipPos.xyww;\n}"};const n=e.patch.cgl,a=e.inTrigger("Trigger In"),i=e.inBool("Render",true),r=e.inTexture("Skybox"),s=e.inFloat("Rotate",0),o=e.inBool("RGBE Format",false),l=e.inFloat("Exposure",1),u=e.inFloat("Gamma",2.2),m=e.outTrigger("Trigger Out");const p=new CGL.Geometry("unit cube");p.vertices=new Float32Array([-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1]);const c=new CGL.Mesh(n,p);const d=new CGL.Shader(n,"skybox");const h=new CGL.Uniform(d,"t","skybox",0);const f=new CGL.Uniform(d,"2f","expGamma",l,u);if(n.glVersion==1)d.enableExtension("GL_EXT_shader_texture_lod");d.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);d.setSource(t.skybox_vert,t.skybox_frag);d.offScreenPass=true;r.onChange=o.onChange=v;v();function v(){d.toggleDefine("RGBE",o.get());const e=r.get()&&r.get().cubemap;d.toggleDefine("TEX_FORMAT_CUBEMAP",e);d.toggleDefine("TEX_FORMAT_EQUIRECT",!e)}a.onTriggered=()=>{if(!r.get()||!i.get()){m.trigger();return}d.popTextures();n.pushModelMatrix();if(!r.get().cubemap&&r.get().filter!==CGL.Texture.FILTER_LINEAR)e.setUiError("linearFilter","If there is a seam in the skybox, try changing the texture filter to linear!",0);else e.setUiError("linearFilter",null);mat4.rotateY(n.mMatrix,n.mMatrix,s.get()*CGL.DEG2RAD);if(r.get().tex)d.pushTexture(h,r.get().tex);else if(r.get().cubemap)d.pushTexture(h,r.get().cubemap,n.gl.TEXTURE_CUBE_MAP);c.render(d);n.popModelMatrix();n.popDepthFunc();m.trigger()}};Ops.Gl.CubeMap.Skybox.prototype=new CABLES.Op;CABLES.OPS["97ce1d35-bd7a-43cb-a2bf-5b7e37fb8925"]={f:Ops.Gl.CubeMap.Skybox,objName:"Ops.Gl.CubeMap.Skybox"};Ops.Gl.Meshes.FloorGrid=function(){CABLES.Op.apply(this,arguments);const r=this;const e=r.attachments={grid_frag:"IN vec4 posColor;\nIN vec3 posFrag;\n\nvoid main()\n{\n    outColor=posColor;\n    outColor.a*=clamp(1.0-(length(posFrag)/30.0),0.0,1.0);\n}",grid_vert:"IN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec2 attrTexCoord;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nOUT vec4 posColor;\nOUT vec3 posFrag;\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n\n    mat4 mvMatrix=viewMatrix*mMatrix;\n    posFrag=vPosition;\n    posColor=vec4(0.6,0.6,0.6,0.4);\n\n    if(pos.x==0.0) posColor=vec4(0.3,0.3,1.0,1.0);\n    else if(pos.y==0.0 && pos.z==0.0) posColor=vec4(1.0,0.3,0.3,1.0);\n    else if(mod(pos.z,10.0)==0.0 && mod(pos.x,10.0)==0.0 ) posColor.a=1.0;\n\n    if(pos.y>0.0 && pos.x==0.0) posColor=vec4(0.3,1.0,0.3,1.0);\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n"};const t=r.inTrigger("Render"),n=r.inBool("Active",true),a=r.outTrigger("Next");const s=100;const o=r.patch.cgl;let l=null;const i=new CGL.Shader(o,"gridMaterial",this);i.setSource(e.grid_vert,e.grid_frag);function u(){let e=new CGL.Geometry(r.name);const t=1;let n=t*s/2;let a=[];for(var i=-s/2;i<s/2+1;i++){e.vertices.push(-n);e.vertices.push(0);e.vertices.push(i*t);e.vertices.push(n);e.vertices.push(0);e.vertices.push(i*t);e.vertices.push(i*t);e.vertices.push(0);e.vertices.push(-n);e.vertices.push(i*t);e.vertices.push(0);e.vertices.push(n);if(i==0){a.push(0,1);a.push(0,1);a.push(0,.5);a.push(0,.5)}else{a.push(0,0);a.push(0,0);a.push(0,0);a.push(0,0)}}e.vertices.push(0);e.vertices.push(.001);e.vertices.push(0);e.vertices.push(0);e.vertices.push(10);e.vertices.push(0);a.push(0,0,0,0);for(var i=0;i<=10;i++){e.vertices.push(-.25);e.vertices.push(i);e.vertices.push(0);e.vertices.push(.25);e.vertices.push(i);e.vertices.push(0);a.push(0,0,0,0)}e.setTexCoords(a);e.calculateNormals();if(!l)l=new CGL.Mesh(o,e);else l.setGeom(e)}t.onTriggered=function(){if(!l)u();if(o.tempData.shadowPass)return a.trigger();o.pushShader(i);if(!i)return;let e=i.glPrimitive;i.glPrimitive=o.gl.LINES;if(n.get())l.render(i);o.popShader();i.glPrimitive=e;a.trigger()}};Ops.Gl.Meshes.FloorGrid.prototype=new CABLES.Op;CABLES.OPS["645b3877-4fdd-42e5-a369-d9506a65e2f0"]={f:Ops.Gl.Meshes.FloorGrid,objName:"Ops.Gl.Meshes.FloorGrid"};Ops.Extension.OpenType.OpentypeFont=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const a=n.inUrl("Font File",[".otf",".ttf",".woff",".woff2"]),i=n.outObject("Opentype Font",null,"opentype");a.onChange=async function(){const e=n.patch.getFilePath(String(a.get()));n.setUiError("exc",null);try{const t=await opentype.load(e);i.set(t)}catch(e){console.log(e);let t=e.toString();t=t.replaceAll("<","&lt;");t=t.replaceAll(">","&gt;");n.setUiError("exc","opentype error "+t)}}};Ops.Extension.OpenType.OpentypeFont.prototype=new CABLES.Op;CABLES.OPS["f85574bb-3869-4a14-8dcc-70414bd8cfcd"]={f:Ops.Extension.OpenType.OpentypeFont,objName:"Ops.Extension.OpenType.OpentypeFont"};Ops.Sidebar.Button_v2=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.inObject("link");const a=t.inString("Text","Button");const i=t.outObject("childs");const r=t.outTrigger("Pressed Trigger");const s=t.inBool("Grey Out",false);const o=t.inBool("Visible",true);const l=document.createElement("div");l.dataset.op=t.id;l.classList.add("cablesEle");l.classList.add("sidebar__item");l.classList.add("sidebar--button");const u=document.createElement("button");u.classList.add("sidebar__button-input");l.appendChild(u);u.addEventListener("click",c);const m=document.createTextNode(a.get());u.appendChild(m);t.toWorkNeedsParent("Ops.Sidebar.Sidebar");n.onChange=h;a.onChange=d;t.onDelete=g;const p=document.createElement("div");p.classList.add("sidebar__greyout");l.appendChild(p);p.style.display="none";s.onChange=function(){p.style.display=s.get()?"block":"none"};o.onChange=function(){l.style.display=o.get()?"block":"none"};function c(){r.trigger()}function d(){const e=a.get();u.textContent=e;u.setAttribute("aria-label","button "+a.get());if(CABLES.UI)t.setUiAttrib({extendTitle:e})}function h(){i.set(null);const e=n.get();if(e&&e.parentElement){e.parentElement.appendChild(l);i.set(e)}else{if(l.parentElement){l.parentElement.removeChild(l)}}}function f(e){if(e){e.style.display="block"}}function v(e){if(e){e.style.display="none"}}function g(){b(l)}function b(e){if(e&&e.parentNode&&e.parentNode.removeChild){e.parentNode.removeChild(e)}}};Ops.Sidebar.Button_v2.prototype=new CABLES.Op;CABLES.OPS["5e9c6933-0605-4bf7-8671-a016d917f327"]={f:Ops.Sidebar.Button_v2,objName:"Ops.Sidebar.Button_v2"};Ops.Ui.VizNumber=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const a=n.inFloat("Number",0);const i=n.outNumber("Result");n.setUiAttrib({widthOnlyGrow:true});a.onChange=t;t();function t(){let t=a.get();if(n.patch.isEditorMode()){let e="";if(t===null)e="null";else if(t===undefined)e="undefined";else{e=""+Math.round(t*1e4)/1e4;if(e[0]!="-")e=" "+e}n.setUiAttribs({extendTitle:e})}i.set(t)}};Ops.Ui.VizNumber.prototype=new CABLES.Op;CABLES.OPS["2b60d12d-2884-4ad0-bda4-0caeb6882f5c"]={f:Ops.Ui.VizNumber,objName:"Ops.Ui.VizNumber"};Ops.String.StringEditor=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inStringEditor("value",""),a=e.inValueSelect("Syntax",["text","glsl","css","html","xml","json","javascript","inline-css","sql"],"text"),i=e.outString("Result");a.onChange=r;function r(){let e=a.get();if(e=="javascript")e="js";n.setUiAttribs({editorSyntax:e})}n.onChange=function(){i.set(n.get())}};Ops.String.StringEditor.prototype=new CABLES.Op;CABLES.OPS["6468b7c1-f63e-4db4-b809-4b203d27ead3"]={f:Ops.String.StringEditor,objName:"Ops.String.StringEditor"};Ops.Gl.Meshes.TextMesh_v2=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={textmesh_frag:"{{MODULES_HEAD}}\n\n#define INSTANCING\n\nUNI sampler2D tex;\n#ifdef DO_MULTEX\n    UNI sampler2D texMul;\n#endif\n#ifdef DO_MULTEX_MASK\n    UNI sampler2D texMulMask;\n#endif\nIN vec2 texCoord;\nIN vec2 texPos;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nflat IN float frag_instIndex;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col=texture(tex,texCoord);\n    col.a=col.r;\n    col.r*=r;\n    col.g*=g;\n    col.b*=b;\n    col*=a;\n\n    if(col.a==0.0)discard;\n\n    #ifdef DO_MULTEX\n        col*=texture(texMul,texPos);\n    #endif\n\n    #ifdef DO_MULTEX_MASK\n        col*=texture(texMulMask,texPos).r;\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor=col;\n}",textmesh_vert:"{{MODULES_HEAD}}\n\nUNI sampler2D tex;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI float scale;\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN mat4 instMat;\nIN vec2 attrTexOffsets;\nIN vec2 attrTexSize;\nIN vec2 attrTexPos;\nIN float attrVertIndex;\nIN float instanceIndex;\nflat OUT float frag_instIndex;\n\nOUT vec2 texPos;\n\nOUT vec2 texCoord;\nOUT vec4 modelPos;\n\nvoid main()\n{\n\n    texCoord=(attrTexCoord*(attrTexSize)) + attrTexOffsets;\n    mat4 instMVMat=instMat;\n    instMVMat[3][0]*=scale;\n\n    texPos=attrTexPos;\n\n    vec4 pos=vec4( vPosition.x*(attrTexSize.x/attrTexSize.y)*scale,vPosition.y*scale,vPosition.z*scale, 1. );\n\n    mat4 mvMatrix=viewMatrix * modelMatrix * instMVMat;\n    frag_instIndex=instanceIndex;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n\n"};const n=t.inTrigger("Render"),b=t.inString("Text","cables"),a=t.inFloat("Scale Text",1),i=t.inValueFloat("Scale",1),m=t.inString("Font","Arial"),x=t.inValueSelect("align",["left","center","right"],"center"),r=t.inValueSelect("vertical align",["Top","Middle","Bottom"],"Middle"),O=t.inValueFloat("Line Height",1),_=t.inValueFloat("Letter Spacing"),o=t.inSwitch("filter",["nearest","linear","mipmap"],"mipmap"),l=t.inSwitch("Anisotropic",[0,1,2,4,8,16],0),s=t.inTexture("Texture Color"),u=t.inTexture("Texture Mask"),k=t.outTrigger("Next"),T=t.outTexture("texture"),F=t.outNumber("Total Lines",0),G=t.outNumber("Width",0),U=t.outBoolNum("Font Available",0);const I=t.patch.cgl;const p=vec3.create();vec3.set(p,1,1,1);t.toWorkPortsNeedToBeLinked(n);t.setPortGroup("Masking",[s,u]);i.setUiAttribs({title:"Line Scale"});T.setUiAttribs({hidePort:true});const c=1024;let d=false;let h=true;x.onChange=b.onChange=O.onChange=B;function B(){h=true}let f=null;CABLES.OpTextureMeshCanvas={};let v=0;const D=null;let y=null;let A=true;let S=true;a.onChange=()=>{vec3.set(p,a.get(),a.get(),a.get())};l.onChange=o.onChange=()=>{E().texture=null;S=true};u.onChange=s.onChange=function(){C.toggleDefine("DO_MULTEX",s.get());C.toggleDefine("DO_MULTEX_MASK",u.get())};T.set(null);m.onChange=function(){S=true;A=true;g()};t.patch.on("fontLoaded",e=>{if(e==m.get()){S=true;A=true}});function g(){const e=d;try{d=document.fonts.check('20px "'+m.get()+'"')}catch(e){t.logError(e)}if(!e&&d){U.set(true);S=true;A=true}if(!d)setTimeout(g,250)}r.onChange=function(){if(r.get()=="Middle")v=0;else if(r.get()=="Top")v=1;else if(r.get()=="Bottom")v=2};function E(){f=""+m.get();if(CABLES.OpTextureMeshCanvas.hasOwnProperty(f))return CABLES.OpTextureMeshCanvas[f];const e=document.createElement("canvas");e.dataset.font=m.get();e.id="texturetext_"+CABLES.generateUUID();e.style.display="none";const t=document.getElementsByTagName("body")[0];t.appendChild(e);const n=e.getContext("2d");CABLES.OpTextureMeshCanvas[f]={ctx:n,canvas:e,chars:{},characters:"",fontSize:320};return CABLES.OpTextureMeshCanvas[f]}t.onDelete=function(){if(f&&CABLES.OpTextureMeshCanvas[f])CABLES.OpTextureMeshCanvas[f].canvas.remove()};const C=new CGL.Shader(I,"TextMesh",this);C.setSource(e.textmesh_vert,e.textmesh_frag);const V=new CGL.Uniform(C,"t","tex",0);const z=new CGL.Uniform(C,"t","texMul",1);const X=new CGL.Uniform(C,"t","texMulMask",2);const q=new CGL.Uniform(C,"f","scale",i);const j=t.inValueSlider("r",1),N=t.inValueSlider("g",1),L=t.inValueSlider("b",1),H=t.inValueSlider("a",1),Y=new CGL.Uniform(C,"f","r",j),W=new CGL.Uniform(C,"f","g",N),Z=new CGL.Uniform(C,"f","b",L),K=new CGL.Uniform(C,"f","a",H);j.setUiAttribs({colorPick:true});t.setPortGroup("Display",[i,m]);t.setPortGroup("Alignment",[x,r]);t.setPortGroup("Color",[j,N,L,H]);let M=0;const R=vec3.create();let J=-1;let P=false;n.onTriggered=function(){if(h){Q();h=false}const e=E();if(e.lastChange!=J){A=true;J=e.lastChange}if(S)$();if(A)Q();if(y&&y.numInstances>0){I.pushBlendMode(CGL.BLEND_NORMAL,true);I.pushShader(C);I.setTexture(0,T.get().tex);const t=s.get();if(t)I.setTexture(1,t.tex);const n=u.get();if(n)I.setTexture(2,n.tex);if(v===2)vec3.set(R,0,M,0);else if(v===1)vec3.set(R,0,0,0);else if(v===0)vec3.set(R,0,M/2,0);R[1]-=O.get();I.pushModelMatrix();mat4.translate(I.mMatrix,I.mMatrix,R);mat4.scale(I.mMatrix,I.mMatrix,p);if(!P)y.render(I.getShader());I.popModelMatrix();I.setTexture(0,null);I.popShader();I.popBlendMode()}k.trigger()};_.onChange=function(){A=true};function Q(){const e=String(b.get()+"");if(!T.get())return;const r=E();if(!r.geom){r.geom=new CGL.Geometry("textmesh");r.geom.vertices=[1,1,0,0,1,0,1,0,0,0,0,0];r.geom.texCoords=new Float32Array([1,1,0,1,1,0,0,0]);r.geom.verticesIndices=[0,1,2,2,1,3]}if(!y)y=new CGL.Mesh(I,r.geom);const s=e.split("\n");F.set(s.length);const o=[];const l=[];const u=[];const m=[];const p=mat4.create();let c=0;let d=0;S=false;for(let i=0;i<s.length;i++){const h=s[i];const f=h.length;let t=0;let n=0;let a=0;for(let e=0;e<f;e++){const v=h.substring(e,e+1);const g=r.chars[String(v)];if(g){a+=g.texCoordWidth/g.texCoordHeight;a+=_.get()}}a-=_.get();M=0;if(x.get()=="left")n=0;else if(x.get()=="right")n=a;else if(x.get()=="center")n=a/2;M=(i+1)*O.get();for(let e=0;e<f;e++){const v=h.substring(e,e+1);const g=r.chars[String(v)];if(!g){S=true;return}else{m.push(t/a*.99+.005,(1-i/(s.length-1))*.99+.005);l.push(g.texCoordX,1-g.texCoordY-g.texCoordHeight);u.push(g.texCoordWidth,g.texCoordHeight);mat4.identity(p);mat4.translate(p,p,[t-n,0-i*O.get(),0]);t+=g.texCoordWidth/g.texCoordHeight+_.get();d=Math.max(d,t-n);o.push(Array.prototype.slice.call(p));c++}}}const t=[].concat.apply([],o);P=false;if(t.length==0)P=true;const n=t.length/16;y.setNumInstances(n);if(y.numInstances==0){P=true;return}G.set(d*i.get());y.setAttribute("instMat",new Float32Array(t),16,{instanced:true});y.setAttribute("attrTexOffsets",new Float32Array(l),2,{instanced:true});y.setAttribute("attrTexSize",new Float32Array(u),2,{instanced:true});y.setAttribute("attrTexPos",new Float32Array(m),2,{instanced:true});A=false;if(S)$()}function w(t,n){const a=E();if(!n)a.chars={};const i=a.ctx;i.font=t+"px "+m.get();i.textAlign="left";let r=0;let s=0;const o=t*1.4;const e={fits:true};for(let e=0;e<a.characters.length;e++){const l=String(a.characters.substring(e,e+1));const u=i.measureText(l).width;if(s+u>=c){r+=o+2;s=0}if(!n){a.chars[l]={str:l,texCoordX:s/c,texCoordY:r/c,texCoordWidth:u/c,texCoordHeight:o/c};i.fillText(l,s,r+t)}s+=u+12}if(r>c-o){e.fits=false}e.spaceLeft=c-r;return e}function $(){let e=CGL.Texture.FILTER_LINEAR;if(o.get()=="nearest")e=CGL.Texture.FILTER_NEAREST;if(o.get()=="mipmap")e=CGL.Texture.FILTER_MIPMAP;const t=E();let n=String(b.get());if(n==null||n==undefined)n="";for(let e=0;e<n.length;e++){const s=n.substring(e,e+1);if(t.characters.indexOf(s)==-1){t.characters+=s;S=true}}const a=t.ctx;t.canvas.width=t.canvas.height=c;if(!t.texture)t.texture=CGL.Texture.createFromImage(I,t.canvas,{filter:e,anisotropic:parseFloat(l.get())});t.texture.setSize(c,c);a.fillStyle="transparent";a.clearRect(0,0,c,c);a.fillStyle="rgba(255,255,255,255)";let i=t.fontSize+40;let r=w(i,true);while(!r.fits){i-=5;r=w(i,true)}w(i,false);a.restore();t.texture.initTexture(t.canvas,e);t.texture.unpackAlpha=true;T.set(t.texture);t.lastChange=CABLES.now();A=true;S=false}};Ops.Gl.Meshes.TextMesh_v2.prototype=new CABLES.Op;CABLES.OPS["2390f6b3-2122-412e-8c8d-5c2f574e8bd1"]={f:Ops.Gl.Meshes.TextMesh_v2,objName:"Ops.Gl.Meshes.TextMesh_v2"};Ops.Html.FontFile_v2=function(){CABLES.Op.apply(this,arguments);const i=this;const e=i.attachments={};const r=i.inUrl("file",[".otf",".ttf",".woff",".woff2"]),s=i.inString("family"),o=i.inBool("Active",true),l=i.outBoolNum("Loaded"),u=i.outTrigger("Loaded Trigger");let m=null;let p;let c=null;let t=null;let d=null;let h="";r.onChange=function(){l.set(false);a(null)};o.onChange=s.onChange=()=>{n()};function n(){clearTimeout(t);t=setTimeout(()=>{a(null)},50)}i.patch.on("windowChanged",e=>{p=null;a(e.document)});function a(e){if(d)d.remove();if(p){const t=c.fonts.delete(p);p=null;setTimeout(()=>{i.patch.emitEvent("fontLoaded",h)},100)}if(!o.get())return;c=e||c||i.patch.cgl.canvas.ownerDocument||document;if(m)m=i.patch.cgl.patch.loading.finished(m);i.setUiError("loadingerror",null);h=s.get();if(r.get()&&s.get()){if(c.fonts){let e="url("+i.patch.getFilePath(String(r.get()))+")";p=new FontFace(s.get(),e);m=i.patch.cgl.patch.loading.start("FontFile",r.get(),i);c.fonts.add(p);p.loaded.then(e=>{l.set(true);u.trigger();m=i.patch.cgl.patch.loading.finished(m);i.patch.emitEvent("fontLoaded",s.get())},e=>{i.setUiError("loadingerror","Font loading error: "+p.status+"("+r.get()+")");m=i.patch.cgl.patch.loading.finished(m);l.set(true)}).catch(e=>{m=i.patch.cgl.patch.loading.finished(m);console.error("catch ",e)});p.load()}else{const n=i.patch.getFilePath(String(r.get()));const a="".endl()+"@font-face".endl()+"{".endl()+'  font-family: "'+s.get()+'";'.endl()+'  src: url("'+n+'") format("truetype");'.endl()+"}";d=document.createElement("style");d.classList.add("cablesEle");d.type="text/css";d.innerHTML=a;document.getElementsByTagName("head")[document.getElementsByTagName("head").length-1].appendChild(d)}}}};Ops.Html.FontFile_v2.prototype=new CABLES.Op;CABLES.OPS["68177370-116e-4c76-aef3-3b10d68e7227"]={f:Ops.Html.FontFile_v2,objName:"Ops.Html.FontFile_v2"};Ops.Gl.ImageCompose.ImageCompose=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTrigger("render");const a=e.inBool("use viewport size");const i=e.inValueInt("width");const r=e.inValueInt("height");const s=e.inSwitch("filter",["nearest","linear","mipmap"],"linear");const o=e.inValueSelect("wrap",["clamp to edge","repeat","mirrored repeat"]);const l=e.inValueBool("HDR");const u=e.outTrigger("trigger");const m=e.outTexture("texture_out");const p=e.inValueSlider("Background Alpha",0);const c=e.outValue("Aspect Ratio");e.setPortGroup("Texture Size",[a,i,r]);e.setPortGroup("Texture Settings",[o,s,l]);const d=e.patch.cgl;m.set(CGL.Texture.getEmptyTexture(d));let h=null;let f=null;let v=8,g=8;const b=[0,0,0,0];let x=true;const O="".endl()+"uniform float a;".endl()+"void main()".endl()+"{".endl()+"   outColor= vec4(0.0,0.0,0.0,a);".endl()+"}";const _=new CGL.Shader(d,"imgcompose bg");_.setSource(_.getDefaultVertexShader(),O);const T=new CGL.Uniform(_,"f","a",p);let I=CGL.Texture.FILTER_LINEAR;let y=CGL.Texture.WRAP_CLAMP_TO_EDGE;function A(){if(h)h.delete();if(f)f.delete();h=new CGL.TextureEffect(d,{isFloatingPointTexture:l.get()});f=new CGL.Texture(d,{name:"image compose",isFloatingPointTexture:l.get(),filter:I,wrap:y,width:Math.ceil(i.get()),height:Math.ceil(r.get())});h.setSourceTexture(f);m.set(CGL.Texture.getEmptyTexture(d));x=false}l.onChange=function(){x=true};function S(){if(!h)A();if(a.get()){v=d.getViewPort()[2];g=d.getViewPort()[3]}else{v=Math.ceil(i.get());g=Math.ceil(r.get())}if((v!=f.width||g!=f.height)&&(v!==0&&g!==0)){r.set(g);i.set(v);f.setSize(v,g);c.set(v/g);h.setSourceTexture(f);m.set(CGL.Texture.getEmptyTexture(d));m.set(f)}if(m.get()&&I!=CGL.Texture.FILTER_NEAREST){if(!m.get().isPowerOfTwo())e.setUiError("hintnpot","texture dimensions not power of two! - texture filtering when scaling will not work on ios devices.",0);else e.setUiError("hintnpot",null,0)}else e.setUiError("hintnpot",null,0)}function E(){if(a.get()){i.setUiAttribs({greyout:true});r.setUiAttribs({greyout:true})}else{i.setUiAttribs({greyout:false});r.setUiAttribs({greyout:false})}}a.onChange=function(){E();if(a.get()){i.onChange=null;r.onChange=null}else{i.onChange=S;r.onChange=S}S()};e.preRender=function(){C();_.bind()};var C=function(){if(!h||x){A()}const e=d.getViewPort();b[0]=e[0];b[1]=e[1];b[2]=e[2];b[3]=e[3];d.gl.blendFunc(d.gl.SRC_ALPHA,d.gl.ONE_MINUS_SRC_ALPHA);S();d.currentTextureEffect=h;h.setSourceTexture(f);h.startEffect();d.pushShader(_);d.currentTextureEffect.bind();d.setTexture(0,d.currentTextureEffect.getCurrentSourceTexture().tex);d.currentTextureEffect.finish();d.popShader();u.trigger();m.set(h.getCurrentSourceTexture());h.endEffect();d.setViewPort(b[0],b[1],b[2],b[3]);d.gl.blendFunc(d.gl.SRC_ALPHA,d.gl.ONE_MINUS_SRC_ALPHA);d.currentTextureEffect=null};function j(){if(o.get()=="repeat")y=CGL.Texture.WRAP_REPEAT;if(o.get()=="mirrored repeat")y=CGL.Texture.WRAP_MIRRORED_REPEAT;if(o.get()=="clamp to edge")y=CGL.Texture.WRAP_CLAMP_TO_EDGE;x=true;S()}o.set("repeat");o.onChange=j;function N(){if(s.get()=="nearest")I=CGL.Texture.FILTER_NEAREST;if(s.get()=="linear")I=CGL.Texture.FILTER_LINEAR;if(s.get()=="mipmap")I=CGL.Texture.FILTER_MIPMAP;x=true;S()}s.set("linear");s.onChange=N;a.set(true);n.onTriggered=C;e.preRender=C;i.set(640);r.set(360);N();j();E()};Ops.Gl.ImageCompose.ImageCompose.prototype=new CABLES.Op;CABLES.OPS["5c04608d-1e42-4e36-be00-1be4a81fc309"]={f:Ops.Gl.ImageCompose.ImageCompose,objName:"Ops.Gl.ImageCompose.ImageCompose"};Ops.Gl.ShaderEffects.VertexDisplacementMap=function(){CABLES.Op.apply(this,arguments);const t=this;const e=t.attachments={};const n=t.patch.cgl;t.render=t.inTrigger("render");t.trigger=t.outTrigger("trigger");const a=t.inTexture("texture");const i=t.inValue("extrude",.5);const r=t.inValueBool("flip",true);const s=t.inValueBool("Ignore Zero Values");const o=t.inValueBool("invert");const l=t.inValueFloat("offset X");const u=t.inValueFloat("offset Y");const m=t.inValueBool("colorize");const p=t.inValueSlider("colorize add");const c=t.inValueSelect("mode",["normal","normal xy","mul xyz","sub x","add x","add y","add z","mul y","mul z","sub z"]);m.set(false);function d(){if(g)g.toggleDefine("MOD_HEIGHTMAP_COLORIZE",m.get())}function h(){if(g)g.toggleDefine("MOD_HEIGHTMAP_INVERT",o.get())}function f(){if(g)g.toggleDefine("MOD_DISPLACE_REMOVE_ZERO",s.get())}m.onChange=d;o.onChange=h;s.onChange=f;const v=function(){if(g){g.toggleDefine(A.prefix+"FLIPY",r.get());g.toggleDefine(A.prefix+"DISPLACE_METH_MULXYZ",c.get()=="mul xyz");g.toggleDefine(A.prefix+"DISPLACE_METH_ADDZ",c.get()=="add z");g.toggleDefine(A.prefix+"DISPLACE_METH_ADDY",c.get()=="add y");g.toggleDefine(A.prefix+"DISPLACE_METH_ADDX",c.get()=="add x");g.toggleDefine(A.prefix+"DISPLACE_METH_SUBX",c.get()=="sub x");g.toggleDefine(A.prefix+"DISPLACE_METH_MULY",c.get()=="mul y");g.toggleDefine(A.prefix+"DISPLACE_METH_MULZ",c.get()=="mul z");g.toggleDefine(A.prefix+"DISPLACE_METH_NORMAL",c.get()=="normal");g.toggleDefine(A.prefix+"DISPLACE_METH_NORMAL_XY",c.get()=="normal xy");f()}};r.onChange=v;c.onChange=v;c.set("normal");var g=null;var b,x;const O="".endl()+"UNI float MOD_extrude;".endl()+"UNI sampler2D MOD_texture;".endl()+"UNI float MOD_offsetX;".endl()+"UNI float MOD_offsetY;".endl()+"OUT float MOD_displHeightMapColor;".endl();const _="".endl()+"vec2 MOD_tc=texCoord;".endl()+"#ifdef MOD_FLIPY".endl()+"    MOD_tc.y=1.0-MOD_tc.y;".endl()+"#endif".endl()+"float MOD_texVal=texture2D( MOD_texture, vec2(MOD_tc.x+MOD_offsetX,MOD_tc.y+MOD_offsetY) ).b;".endl()+"#ifdef MOD_HEIGHTMAP_INVERT".endl()+"   MOD_texVal=1.0-MOD_texVal;".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_MULXYZ".endl()+"   MOD_texVal+=1.0;".endl()+"   pos.xyz *= MOD_texVal * MOD_extrude;".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_ADDZ".endl()+"   pos.z+=(MOD_texVal * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_ADDY".endl()+"   pos.y+=(MOD_texVal * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_ADDX".endl()+"   pos.x+=(MOD_texVal * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_SUBX".endl()+"   pos.x-=(MOD_texVal * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_MULY".endl()+"   pos.y+=((MOD_texVal-0.5) * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_MULZ".endl()+"   pos.z+=((MOD_texVal-0.5) * MOD_extrude);".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_NORMAL".endl()+"   pos.xyz+=norm*MOD_texVal*MOD_extrude;".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_METH_NORMAL_XY".endl()+"   pos.xy+=(pos.xy*MOD_texVal*MOD_extrude).xy;".endl()+"#endif".endl()+"MOD_displHeightMapColor=MOD_texVal;".endl();const T="".endl()+"UNI float MOD_colorizeAdd;".endl()+"IN float MOD_displHeightMapColor;".endl()+"UNI sampler2D MOD_texture;".endl();const I="".endl()+"#ifdef MOD_HEIGHTMAP_COLORIZE".endl()+"   col.rgb*=MOD_displHeightMapColor*(1.0-MOD_colorizeAdd);".endl()+"   col+=MOD_colorizeAdd;".endl()+"#endif".endl()+"#ifdef MOD_DISPLACE_REMOVE_ZERO".endl()+"if(MOD_displHeightMapColor==0.0)discard;".endl()+"#endif".endl();let y=null;let A=null;function S(){if(g&&y)g.removeModule(y);if(g&&A)g.removeModule(A);g=null}var x=null;let E=null;var b=null;let C=null;let j=null;let N=null;t.render.onLinkChanged=S;t.render.onTriggered=function(){if(!n.getShader()){t.trigger.trigger();return}if(n.getShader()!=g){if(g)S();g=n.getShader();A=g.addModule({title:t.objName,name:"MODULE_VERTEX_POSITION",srcHeadVert:O,srcBodyVert:_});x=new CGL.Uniform(g,"t",A.prefix+"texture",0);b=new CGL.Uniform(g,"f",A.prefix+"extrude",i);C=new CGL.Uniform(g,"f",A.prefix+"offsetX",l);j=new CGL.Uniform(g,"f",A.prefix+"offsetY",u);y=g.addModule({title:t.objName,name:"MODULE_COLOR",srcHeadFrag:T,srcBodyFrag:I});E=new CGL.Uniform(g,"t",A.prefix+"texture",0);N=new CGL.Uniform(g,"f",A.prefix+"colorizeAdd",p);v();h();d()}if(!g)return;const e=A.num+7;if(a.get()){x.setValue(e);E.setValue(e);n.setTexture(0+e,a.get().tex)}t.trigger.trigger()}};Ops.Gl.ShaderEffects.VertexDisplacementMap.prototype=new CABLES.Op;CABLES.OPS["94ffa0de-2926-4d02-842e-a1ad6f5846c2"]={f:Ops.Gl.ShaderEffects.VertexDisplacementMap,objName:"Ops.Gl.ShaderEffects.VertexDisplacementMap"};Ops.Extension.Deprecated.RelativeTime=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inTrigger("exe"),a=e.inValue("Multiply",1),i=e.outTrigger("Trigger out"),r=e.outNumber("result");n.onTriggered=s;s();function s(){r.set(e.patch.freeTimer.get()*a.get());i.trigger()}};Ops.Extension.Deprecated.RelativeTime.prototype=new CABLES.Op;CABLES.OPS["917df27b-7cc3-465f-986d-bcf5a7e125a7"]={f:Ops.Extension.Deprecated.RelativeTime,objName:"Ops.Extension.Deprecated.RelativeTime"};Ops.Gl.ImageCompose.Noise.PerlinNoise=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={perlinnoise3d_frag:'UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nUNI float rangeMul;\nUNI float harmonics;\nUNI float aspect;\n\nIN vec2 texCoord;\nUNI sampler2D tex;\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n#ifdef HAS_TEX_MASK\n    UNI sampler2D texMask;\n#endif\n\nUNI float amount;\n\n{{CGL.BLENDMODES}}\n\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( vec3 gridcell, out vec4 lowz_hash, out vec4 highz_hash )\t//\tgenerates a random number for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const float SOMELARGEFLOAT = 635.298681;\n    const float ZINC = 48.500388;\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    highz_hash.xy = vec2( 1.0 / ( SOMELARGEFLOAT + vec2( gridcell.z, gridcell_inc1.z ) * ZINC ) );\n    lowz_hash = fract( P * highz_hash.xxxx );\n    highz_hash = fract( P * highz_hash.yyyy );\n}\n\n\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\nfloat Falloff_Xsq_C1( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq; }\t// ( 1.0 - x*x )^2   ( Used by Humus for lighting falloff in Just Cause 2.  GPUPro 1 )\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\t// ( 1.0 - x*x )^3.   NOTE: 2nd derivative is 0.0 at x=1.0, but non-zero at x=0.0\nvec4 Falloff_Xsq_C2( vec4 xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t"improved" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause "clumping", but we\'ll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec2 p=vec2(texCoord.x-0.5,texCoord.y-0.5);\n\n    p=p*scale;\n    p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n        offset*=offMul;\n    #endif\n\n\n\n    float aa=texture(tex,texCoord).r;\n    // float v=(Perlin3D(vec3(p.x,p.y,z)+offset));\n\n\n    float v = 0.0;\n    p.x*=aspect;\n\n    v+=Perlin3D(vec3(p.x,p.y,z)+offset);\n\n    if (harmonics >= 2.0) v += Perlin3D(vec3(p.x,p.y,z)*2.2+offset) * 0.5;\n    if (harmonics >= 3.0) v += Perlin3D(vec3(p.x,p.y,z)*4.3+offset) * 0.25;\n    if (harmonics >= 4.0) v += Perlin3D(vec3(p.x,p.y,z)*8.4+offset) * 0.125;\n    if (harmonics >= 5.0) v += Perlin3D(vec3(p.x,p.y,z)*16.5+offset) * 0.0625;\n\n\n    v*=rangeMul;\n    v=v*0.5+0.5;\n    float v2=v;\n    float v3=v;\n\n    #ifdef RGB\n        v2=Perlin3D(vec3(p.x*2.0,p.y*2.0,z))*0.5+0.5;\n        v3=Perlin3D(vec3(p.x*3.0,p.y*3.0,z))*0.5+0.5;\n    #endif\n\n    vec4 col=vec4(v,v2,v3,1.0);\n\n    float str=1.0;\n    #ifdef HAS_TEX_MASK\n        str=texture(texMask,texCoord).r;\n    #endif\n\n    col=cgl_blend(base,col,amount*str);\n\n\n    #ifdef NO_CHANNEL_R\n        col.r=base.r;\n    #endif\n    #ifdef NO_CHANNEL_G\n        col.g=base.g;\n    #endif\n    #ifdef NO_CHANNEL_B\n        col.b=base.b;\n    #endif\n\n\n\n    outColor=col;\n}\n'};const n=e.inTrigger("render"),a=e.inTexture("Mask"),i=CGL.TextureEffect.AddBlendSelect(e),r=CGL.TextureEffect.AddBlendAlphaMask(e),s=e.inValueSlider("Amount",1),o=e.inSwitch("Color",["Mono","RGB","R","G","B"],"Mono"),l=e.inValue("Scale",22),u=e.inBool("Aspect",false),m=e.inValue("Multiply",1),p=e.inSwitch("Harmonics",["1","2","3","4","5"],"1"),c=e.inValue("X",0),d=e.inValue("Y",0),h=e.inValue("Z",0),f=e.outTrigger("trigger");const v=e.patch.cgl;const g=new CGL.Shader(v,"perlinnoise");e.setPortGroup("Position",[c,d,h]);g.setSource(g.getDefaultVertexShader(),t.perlinnoise3d_frag);const b=new CGL.Uniform(g,"t","tex",0),x=new CGL.Uniform(g,"t","texOffsetZ",1),O=new CGL.Uniform(g,"t","texMask",2),_=new CGL.Uniform(g,"f","z",h),T=new CGL.Uniform(g,"f","x",c),I=new CGL.Uniform(g,"f","y",d),y=new CGL.Uniform(g,"f","scale",l),A=new CGL.Uniform(g,"f","amount",s),S=new CGL.Uniform(g,"f","rangeMul",m);CGL.TextureEffect.setupBlending(e,g,i,s,r);const E=e.inTexture("Offset"),C=e.inFloat("Offset Multiply",1),j=e.inSwitch("Offset X",["None","R","G","B"],"None"),N=e.inSwitch("Offset Y",["None","R","G","B"],"None"),L=e.inSwitch("Offset Z",["None","R","G","B"],"R");e.setPortGroup("Offset Map",[E,L,N,j,C]);const w=new CGL.Uniform(g,"f","offMul",C);const M=new CGL.Uniform(g,"f","aspect",1);const R=new CGL.Uniform(g,"f","harmonics",0);p.onChange=()=>{R.setValue(parseFloat(p.get()))};j.onChange=N.onChange=L.onChange=a.onChange=o.onChange=E.onChange=P;P();function P(){g.toggleDefine("NO_CHANNEL_R",o.get()=="G"||o.get()=="B");g.toggleDefine("NO_CHANNEL_G",o.get()=="R"||o.get()=="B");g.toggleDefine("NO_CHANNEL_B",o.get()=="R"||o.get()=="G");g.toggleDefine("HAS_TEX_OFFSETMAP",E.get());g.toggleDefine("HAS_TEX_MASK",a.get());g.toggleDefine("OFFSET_X_R",j.get()=="R");g.toggleDefine("OFFSET_X_G",j.get()=="G");g.toggleDefine("OFFSET_X_B",j.get()=="B");g.toggleDefine("OFFSET_Y_R",N.get()=="R");g.toggleDefine("OFFSET_Y_G",N.get()=="G");g.toggleDefine("OFFSET_Y_B",N.get()=="B");g.toggleDefine("OFFSET_Z_R",L.get()=="R");g.toggleDefine("OFFSET_Z_G",L.get()=="G");g.toggleDefine("OFFSET_Z_B",L.get()=="B");j.setUiAttribs({greyout:!E.isLinked()});N.setUiAttribs({greyout:!E.isLinked()});L.setUiAttribs({greyout:!E.isLinked()});C.setUiAttribs({greyout:!E.isLinked()});g.toggleDefine("RGB",o.get()=="RGB")}n.onTriggered=function(){if(!CGL.TextureEffect.checkOpInEffect(e))return;v.pushShader(g);v.currentTextureEffect.bind();if(u.get())M.setValue(v.currentTextureEffect.getWidth()/v.currentTextureEffect.getHeight());else M.setValue(1);v.setTexture(0,v.currentTextureEffect.getCurrentSourceTexture().tex);if(E.get())v.setTexture(1,E.get().tex);if(a.get())v.setTexture(2,a.get().tex);v.currentTextureEffect.finish();v.popShader();f.trigger()}};Ops.Gl.ImageCompose.Noise.PerlinNoise.prototype=new CABLES.Op;CABLES.OPS["446442ba-1a7e-4c71-bb43-b12005aa6511"]={f:Ops.Gl.ImageCompose.Noise.PerlinNoise,objName:"Ops.Gl.ImageCompose.Noise.PerlinNoise"};Ops.Gl.Shader.BasicMaterial=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={shader_frag:"{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=vec4(r,g,b,a);\n\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n\n           col=texture(tex,vec2(texCoord.x,(1.0-texCoord.y)));\n\n           #ifdef COLORIZE_TEXTURE\n               col.r*=r;\n               col.g*=g;\n               col.b*=b;\n           #endif\n        #endif\n\n        col.a*=a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                col.a*=texture(texOpacity,vec2(texCoordOrig.s,1.0-texCoordOrig.t)).g;\n            #endif\n            #ifndef TRANSFORMALPHATEXCOORDS\n                col.a*=texture(texOpacity,vec2(texCoord.s,1.0-texCoord.t)).g;\n            #endif\n       #endif\n\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n\n\n}\n",shader_vert:"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec2 attrTexCoord;\n\nOUT vec3 norm;\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    #ifdef TEXTURE_REPEAT\n        UNI float diffuseRepeatX;\n        UNI float diffuseRepeatY;\n        UNI float texOffsetX;\n        UNI float texOffsetY;\n    #endif\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix;\n\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        #ifdef TEXTURE_REPEAT\n            texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n            texCoord.y=texCoord.y*diffuseRepeatY+texOffsetY;\n        #endif\n    #endif\n\n    vec4 pos = vec4( vPosition, 1. );\n\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        mvMatrix=viewMatrix * mMatrix;\n    #endif\n\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n"};const n=e.inTrigger("render"),a=e.outTrigger("trigger"),i=e.outObject("shader");i.ignoreValueSerialize=true;const r=e.patch.cgl;var s=new CGL.Shader(r,"BasicMaterial");s.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);s.bindTextures=u;s.setSource(t.shader_vert,t.shader_frag);i.set(s);n.onTriggered=m;var o=null;var l=null;function u(){if(p.get())r.setTexture(0,p.get().tex);if(o.get())r.setTexture(1,o.get().tex)}e.preRender=function(){s.bind();m()};function m(){if(!s)return;r.pushShader(s);s.bindTextures();a.trigger();r.popShader()}{const y=e.inValueSlider("r",Math.random()),A=e.inValueSlider("g",Math.random()),S=e.inValueSlider("b",Math.random()),E=e.inValueSlider("a",1);y.setUiAttribs({colorPick:true});E.uniform=new CGL.Uniform(s,"f","a",E);S.uniform=new CGL.Uniform(s,"f","b",S);y.uniform=new CGL.Uniform(s,"f","r",y);A.uniform=new CGL.Uniform(s,"f","g",A);e.setPortGroup("Color",[y,A,S,E])}{var p=e.inTexture("texture");var c=null;s.bindTextures=u;p.onChange=function(){if(p.get()){if(!s.hasDefine("HAS_TEXTURE_DIFFUSE"))s.define("HAS_TEXTURE_DIFFUSE");if(!c)c=new CGL.Uniform(s,"t","texDiffuse",0);f()}else{s.removeUniform("texDiffuse");s.removeDefine("HAS_TEXTURE_DIFFUSE");c=null}}}{o=e.inTexture("textureOpacity");o.onChange=function(){if(o.get()){if(l!==null)return;s.removeUniform("texOpacity");s.define("HAS_TEXTURE_OPACITY");if(!l)l=new CGL.Uniform(s,"t","texOpacity",1)}else{s.removeUniform("texOpacity");s.removeDefine("HAS_TEXTURE_OPACITY");l=null}}}e.colorizeTexture=e.inValueBool("colorizeTexture");e.colorizeTexture.set(false);e.colorizeTexture.onChange=function(){if(e.colorizeTexture.get())s.define("COLORIZE_TEXTURE");else s.removeDefine("COLORIZE_TEXTURE")};e.doBillboard=e.inValueBool("billboard");e.doBillboard.set(false);e.doBillboard.onChange=function(){if(e.doBillboard.get())s.define("BILLBOARD");else s.removeDefine("BILLBOARD")};var d=e.inValueBool("Opacity TexCoords Transform",false);d.onChange=function(){if(d.get())s.define("TRANSFORMALPHATEXCOORDS");else s.removeDefine("TRANSFORMALPHATEXCOORDS")};var h=e.inValueBool("preMultiplied alpha");function f(){if(!O){O=new CGL.Uniform(s,"f","diffuseRepeatX",v);_=new CGL.Uniform(s,"f","diffuseRepeatY",g);T=new CGL.Uniform(s,"f","texOffsetX",b);I=new CGL.Uniform(s,"f","texOffsetY",x)}O.setValue(v.get());_.setValue(g.get());T.setValue(b.get());I.setValue(x.get())}{var v=e.inValueFloat("diffuseRepeatX",1);var g=e.inValueFloat("diffuseRepeatY",1);var b=e.inValueFloat("Tex Offset X");var x=e.inValueFloat("Tex Offset Y");e.setPortGroup("Transform Texture",[v,g,b,x]);v.onChange=f;g.onChange=f;x.onChange=f;b.onChange=f;var O=null;var _=null;var T=null;var I=null;s.define("TEXTURE_REPEAT");b.set(0);x.set(0);v.set(1);g.set(1)}f()};Ops.Gl.Shader.BasicMaterial.prototype=new CABLES.Op;CABLES.OPS["85ae5cfa-5eca-4dd8-8b30-850ac34f7cd5"]={f:Ops.Gl.Shader.BasicMaterial,objName:"Ops.Gl.Shader.BasicMaterial"};Ops.Gl.Texture=function(){CABLES.Op.apply(this,arguments);const n=this;const e=n.attachments={};const a=n.inFile("file","image");const t=n.inSwitch("filter",["nearest","linear","mipmap"]);const i=n.inValueSelect("wrap",["repeat","mirrored repeat","clamp to edge"],"clamp to edge");const r=n.inValueBool("flip",false);const s=n.inValueBool("unpackPreMultipliedAlpha",false);const o=n.inSwitch("Anisotropic",[0,1,2,4,8,16],0);const l=n.outTexture("texture");const u=n.outValue("width");const m=n.outValue("height");const p=n.outValue("loading");const c=n.outValue("Aspect Ratio");n.setPortGroup("Size",[u,m]);s.setUiAttribs({hidePort:true});n.toWorkPortsNeedToBeLinked(l);const d=n.patch.cgl;let h=0;let f=0;let v=0;a.onChange=r.onChange=function(){_()};o.onChange=t.onChange=I;i.onChange=y;s.onChange=function(){_()};let g=0;t.set("mipmap");i.set("repeat");l.set(CGL.Texture.getEmptyTexture(d));const b=function(){const e=CGL.Texture.getTempTexture(d);l.set(e)};let x=null;let O=null;function _(e){clearTimeout(g);g=setTimeout(function(){T(e)},30)}function T(e){if(!x)x=d.patch.loading.start(n.objName,a.get(),n);let t=n.patch.getFilePath(String(a.get()));if(e)t+="?rnd="+CABLES.generateUUID();if(a.get()&&a.get().length>1){p.set(true);if(O)O.delete();O=CGL.Texture.load(d,t,function(e){if(e){b();n.setUiError("errorload",'could not load texture "'+a.get()+'"',2);d.patch.loading.finished(x);x=null;return}else n.setUiError("errorload",null);l.set(O);u.set(O.width);m.set(O.height);c.set(O.width/O.height);if(!O.isPowerOfTwo())n.setUiError("hintnpot","texture dimensions not power of two! - texture filtering will not work.",0);else n.setUiError("hintnpot",null);l.set(null);l.set(O)},{anisotropic:v,wrap:f,flip:r.get(),unpackAlpha:s.get(),filter:h});l.set(null);l.set(O);if(!l.get()&&e){}d.patch.loading.finished(x)}else{d.patch.loading.finished(x);b()}}function I(){if(t.get()=="nearest")h=CGL.Texture.FILTER_NEAREST;else if(t.get()=="linear")h=CGL.Texture.FILTER_LINEAR;else if(t.get()=="mipmap")h=CGL.Texture.FILTER_MIPMAP;else if(t.get()=="Anisotropic")h=CGL.Texture.FILTER_ANISOTROPIC;v=parseFloat(o.get());_()}function y(){if(i.get()=="repeat")f=CGL.Texture.WRAP_REPEAT;if(i.get()=="mirrored repeat")f=CGL.Texture.WRAP_MIRRORED_REPEAT;if(i.get()=="clamp to edge")f=CGL.Texture.WRAP_CLAMP_TO_EDGE;_()}n.onFileChanged=function(e){if(a.get()&&a.get().indexOf(e)>-1){l.set(null);l.set(CGL.Texture.getTempTexture(d));T(true);n.refreshParams()}}};Ops.Gl.Texture.prototype=new CABLES.Op;CABLES.OPS["466394d4-6c1a-4e5d-a057-0063ab0f096a"]={f:Ops.Gl.Texture,objName:"Ops.Gl.Texture"};Ops.Math.Multiply=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inValueFloat("number1",1),a=e.inValueFloat("number2",1),i=e.outNumber("result");e.setUiAttribs({mathTitle:true});n.onChange=a.onChange=r;r();function r(){const e=n.get();const t=a.get();i.set(e*t)}};Ops.Math.Multiply.prototype=new CABLES.Op;CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"]={f:Ops.Math.Multiply,objName:"Ops.Math.Multiply"};Ops.Math.Compare.LessThan=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inValue("number1");const a=e.inValue("number2");const i=e.outBoolNum("result");e.setUiAttribs({mathTitle:true});n.onChange=r;a.onChange=r;r();function r(){i.set(n.get()<a.get())}};Ops.Math.Compare.LessThan.prototype=new CABLES.Op;CABLES.OPS["04fd113f-ade1-43fb-99fa-f8825f8814c0"]={f:Ops.Math.Compare.LessThan,objName:"Ops.Math.Compare.LessThan"};Ops.Boolean.TriggerChangedTrue=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};let n=e.inValueBool("Value",false);let a=e.outTrigger("Next");let i=0;n.onChange=function(){let e=n.get();if(!i&&e){i=true;a.trigger()}else{i=false}}};Ops.Boolean.TriggerChangedTrue.prototype=new CABLES.Op;CABLES.OPS["385197e1-8b34-4d1c-897f-d1386d99e3b3"]={f:Ops.Boolean.TriggerChangedTrue,objName:"Ops.Boolean.TriggerChangedTrue"};Ops.Gl.Matrix.OrbitControls_v3=function(){CABLES.Op.apply(this,arguments);const i=this;const k=i.attachments={};const F=i.inTrigger("render"),r=i.inValueFloat("min distance",1),s=i.inValueFloat("max distance",999999),o=i.inValue("min rot y",0),l=i.inValue("max rot y",0),t=i.inValue("initial radius",2),n=i.inValueSlider("initial axis y",.5),a=i.inValueSlider("initial axis x",.25),e=i.inValueSlider("Smoothness",1),G=i.inValue("Speed X",1),U=i.inValue("Speed Y",1),u=i.inValueBool("Active",true),B=i.inValueBool("Allow Panning",true),D=i.inValueBool("Allow Zooming",true),V=i.inValueBool("Allow Rotation",true),z=i.inValueBool("restricted",true),X=i.inBool("Identity",true),q=i.inTriggerButton("Reset"),H=i.outTrigger("trigger"),Y=i.outNumber("radius"),W=i.outNumber("Rot X"),Z=i.outNumber("Rot Y");i.setPortGroup("Initial Values",[n,a,t]);i.setPortGroup("Interaction",[e,G,U]);i.setPortGroup("Boundaries",[o,l,r,s]);const K=Math.PI;const m=Math.PI*2;const p=vec3.create(),c=vec3.create(),d=mat4.create(),J=mat4.create(),h=vec3.create(),Q=vec3.create(),f=vec3.create(),v=vec3.create(),g=vec3.create(),b=vec3.create();let x=vec3.create(),O=false,_=5,T=0,I=0,y=0,A=0,S=0,E=0,$=1,C=null,ee=true,te=[0,0,0,0,0,0],j=0;i.onDelete=w;e.onChange=ae;t.onChange=q.onTriggered=ne;x=L(0);vec3.set(c,0,0,0);vec3.set(p,0,1,0);ae();ne();function ne(){let e=0;if(S%m<-K){e=-m;S%=-m}else if(S%m>K){e=m;S%=m}else S%=m;E%=Math.PI;vec3.set(h,0,0,0);vec3.set(c,0,0,0);vec3.set(p,0,1,0);y=a.get()*Math.PI*2+e;A=n.get()-.5;_=t.get();x=L(A)}function ae(){$=e.get()*10+1}function N(e,t){if(ee)return t;return e+(t-e)/$}F.onTriggered=function(){const e=i.patch.cg;if(!e)return;if(!C){pe(e.canvas);ce()}e.pushViewMatrix();S=N(S,y);E=N(E,A);let t=(E+.5)*180;if(o.get()!==0&&t<o.get()){t=o.get();E=j}else if(l.get()!==0&&t>l.get()){t=l.get();E=j}else{j=E}const n=S*CGL.RAD2DEG;Z.set(t);W.set(n);ie(x,E);vec3.add(f,x,h);vec3.add(g,c,h);v[0]=N(v[0],f[0]);v[1]=N(v[1],f[1]);v[2]=N(v[2],f[2]);b[0]=N(b[0],g[0]);b[1]=N(b[1],g[1]);b[2]=N(b[2],g[2]);const a=vec3.create();if(X.get())mat4.identity(e.vMatrix);mat4.lookAt(d,v,b,p);mat4.rotate(d,d,S,p);mat4.multiply(e.vMatrix,e.vMatrix,d);H.trigger();e.popViewMatrix();ee=false};function ie(e,t){if(_<r.get())_=r.get();if(_>s.get())_=s.get();Y.set(_);let n=0,a=0;a=360*t/2*CGL.DEG2RAD;vec3.set(e,Math.cos(a)*_,Math.sin(a)*_,0);return e}function L(e){if(_<r.get())_=r.get();if(_>s.get())_=s.get();Y.set(_);let t=0,n=0;const a=vec3.create();n=360*e/2*CGL.DEG2RAD;vec3.set(a,Math.cos(n)*_,Math.sin(n)*_,0);return a}function M(e){if(!O)return;const t=e.clientX;const n=e.clientY;let a=t-T;let i=n-I;a*=G.get();i*=U.get();if(e.buttons==2&&B.get()){h[2]+=a*.01;h[1]+=i*.01}else if(e.buttons==4&&D.get()){_+=i*.05;x=L(A)}else{if(V.get()){y+=a*.003;A+=i*.002;if(z.get()){if(A>.5)A=.5;if(A<-.5)A=-.5}}}T=t;I=n}function R(e){T=e.clientX;I=e.clientY;O=true;try{C.setPointerCapture(e.pointerId)}catch(e){}}function P(e){O=false;try{C.releasePointerCapture(e.pointerId)}catch(e){}}function re(){const e=i.patch.cg.canvas;if(document.pointerLockElement===e||document.mozPointerLockElement===e||document.webkitPointerLockElement===e)document.addEventListener("mousemove",M,false)}function se(e){}a.onChange=function(){S=y=a.get()*Math.PI*2};n.onChange=function(){E=A=n.get()-.5;x=L(A)};const oe=function(e){if(D.get()){const t=CGL.getWheelSpeed(e)*.06;_+=parseFloat(t)*1.2;x=L(A)}};const le=function(e){if(e.touches&&e.touches.length>0)R(e.touches[0])};const ue=function(e){P()};const me=function(e){if(e.touches&&e.touches.length>0)M(e.touches[0])};u.onChange=function(){if(u.get())ce();else w()};function pe(e){w();C=e;ce()}function ce(){if(!C)return;if(!u.get())return w();C.addEventListener("pointermove",M);C.addEventListener("pointerdown",R);C.addEventListener("pointerup",P);C.addEventListener("pointerleave",P);C.addEventListener("pointerenter",se);C.addEventListener("contextmenu",function(e){e.preventDefault()});C.addEventListener("wheel",oe,{passive:true})}function w(){if(!C)return;C.removeEventListener("pointermove",M);C.removeEventListener("pointerdown",R);C.removeEventListener("pointerup",P);C.removeEventListener("pointerleave",P);C.removeEventListener("pointerenter",P);C.removeEventListener("wheel",oe)}};Ops.Gl.Matrix.OrbitControls_v3.prototype=new CABLES.Op;CABLES.OPS["0655b098-d2a8-4ce2-a0b9-ecb2c78f873a"]={f:Ops.Gl.Matrix.OrbitControls_v3,objName:"Ops.Gl.Matrix.OrbitControls_v3"};Ops.Gl.Textures.TextureSVG_v2=function(){CABLES.Op.apply(this,arguments);const i=this;const e=i.attachments={};const r=i.inUrl("File"),n=i.inValueInt("Texture width"),a=i.inValueInt("Texture height"),t=i.inValueSelect("Wrap",["repeat","mirrored repeat","clamp to edge"],"repeat"),s=i.inValueSelect("Filter",["nearest","linear","mipmap"],"mipmap"),o=i.outTexture("Texture"),l=i.outBoolNum("Loaded");s.onChange=b;t.onChange=x;n.set(1024);a.set(1024);const u=i.patch.cgl;let m=null;let p=null;function c(){if(!m)return;m.remove();m=null}function d(){if(m)c();m=document.createElement("canvas");m.id="svgcanvas";p=m.getContext("2d",{alpha:true});p.canvas.width=m.width=n.get();p.canvas.height=m.height=a.get();m.style.display="none";const e=document.getElementsByTagName("body")[0];e.appendChild(m)}o.set(new CGL.Texture(u));function h(){T()}let f="data:image/svg+xml,"+'<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">'+'<foreignObject width="100%" height="100%">'+'<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:40px">'+"</div>"+"</foreignObject>"+"</svg>";let v=CGL.Texture.FILTER_MIPMAP;let g=CGL.Texture.WRAP_REPEAT;function b(){if(s.get()=="nearest")v=CGL.Texture.FILTER_NEAREST;else if(s.get()=="linear")v=CGL.Texture.FILTER_LINEAR;else if(s.get()=="mipmap")v=CGL.Texture.FILTER_MIPMAP;O()}function x(){if(t.get()=="repeat")g=CGL.Texture.WRAP_REPEAT;else if(t.get()=="mirrored repeat")g=CGL.Texture.WRAP_MIRRORED_REPEAT;else if(t.get()=="clamp to edge")g=CGL.Texture.WRAP_CLAMP_TO_EDGE;O()}function O(){i.setUiError("error",null);const a=i.patch.loading.start("svg file",r.get(),i);CABLES.ajax(i.patch.getFilePath(r.get()),function(e,t,n){i.patch.loading.finished(a);if(!e){f="data:image/svg+xml,"+t;f=f.replace(/#/g,"%23");T()}else{l.set(false);i.logError("could not load file",i.patch.getFilePath(r.get()),e);i.setUiError("error","Could not load SVG file!")}})}let _=0;function T(){i.setUiError("error",null);const e=new Image;const t=i.patch.loading.start("svg2texture",r.get(),i);e.onabort=e.onerror=function(e){l.set(false);i.logError("could not load file");i.patch.loading.finished(t);i.setUiError("error","Could not load SVG file!")};l.set(false);e.onload=function(){u.addNextFrameOnceCallback(()=>{d();i.patch.loading.finished(t);m.width=n.get();m.height=a.get();p.clearRect(0,0,m.width,m.height);p.drawImage(e,0,0,m.width,m.height);o.set(new CGL.Texture.createFromImage(u,m,{wrap:g,filter:v,width:m.width,height:m.height,unpackAlpha:true}));c();l.set(true)})};e.src=f;_=performance.now()}i.onFileChanged=function(e){if(r.get()&&r.get().endsWith(e)){O()}};r.onChange=O;n.onChange=a.onChange=h;d();h();s.set("mipmap")};Ops.Gl.Textures.TextureSVG_v2.prototype=new CABLES.Op;CABLES.OPS["e4f3d8f1-8a49-460a-896c-4d7adcda2494"]={f:Ops.Gl.Textures.TextureSVG_v2,objName:"Ops.Gl.Textures.TextureSVG_v2"};Ops.Gl.Textures.TextureInfo_v2=function(){CABLES.Op.apply(this,arguments);const e=this;const t=e.attachments={};const n=e.inObject("Texture",null,"texture"),a=e.outString("Name"),i=e.outString("PixelFormat"),r=e.outNumber("Width"),s=e.outNumber("Height"),o=e.outNumber("Ratio"),l=e.outNumber("Filter"),u=e.outNumber("Wrap"),m=e.outBoolNum("Flipped"),p=e.outBoolNum("HDR"),c=e.outBoolNum("Is Empty Default Texture",false),d=e.outBoolNum("Is Default Texture",false),h=e.outBoolNum("Is Cubemap"),f=e.outNumber("Id");p.setUiAttribs({title:"Float Texture"});const v=CGL.Texture.getEmptyTexture(e.patch.cgl);const g=CGL.Texture.getTempTexture(e.patch.cgl);n.onChange=function(){if(n.get()){a.set(n.get().name);r.set(n.get().width);s.set(n.get().height);o.set(n.get().width/n.get().height);let e="unknown";if(n.get().filter==CGL.Texture.FILTER_NEAREST)e="nearest";else if(n.get().filter==CGL.Texture.FILTER_LINEAR)e="linear";else if(n.get().filter==CGL.Texture.FILTER_MIPMAP)e="mipmap";l.set(n.get().filter+" "+e);let t="unknown";if(n.get().wrap==CGL.Texture.WRAP_CLAMP_TO_EDGE)t="clamp to edge";else if(n.get().wrap==CGL.Texture.WRAP_REPEAT)t="repeat";else if(n.get().wrap==CGL.Texture.WRAP_MIRRORED_REPEAT)t="mirrored repeat";u.set(n.get().wrap+" "+t);i.set(n.get().pixelFormat);f.set(n.get().id);m.set(n.get().flipped);p.set(n.get().isFloatingPoint&&n.get().isFloatingPoint());h.set(n.get().cubemap)}else{a.set("no texture");r.set(0);s.set(0);o.set(0);l.set(null);u.set(null);f.set(null);m.set(false);p.set(false);h.set(false)}c.set(n.get()==v);d.set(n.get()==g)}};Ops.Gl.Textures.TextureInfo_v2.prototype=new CABLES.Op;CABLES.OPS["63d5ac1d-a21b-4449-ab93-1fae5c791cf2"]={f:Ops.Gl.Textures.TextureInfo_v2,objName:"Ops.Gl.Textures.TextureInfo_v2"};window.addEventListener("load",function(e){CABLES.jsLoaded=new Event("CABLES.jsLoaded");document.dispatchEvent(CABLES.jsLoaded)});(function(e,t){typeof exports==="object"&&typeof module!=="undefined"?t(exports):typeof define==="function"&&define.amd?define(["exports"],t):(e=e||self,t(e.opentype={}))})(this,function(A){"use strict";if(!String.prototype.codePointAt){(function(){var e=function(){try{var e={};var t=Object.defineProperty;var n=t(e,e,e)&&t}catch(e){}return n}();var t=function(e){if(this==null){throw TypeError()}var t=String(this);var n=t.length;var a=e?Number(e):0;if(a!=a){a=0}if(a<0||a>=n){return undefined}var i=t.charCodeAt(a);var r;if(i>=55296&&i<=56319&&n>a+1){r=t.charCodeAt(a+1);if(r>=56320&&r<=57343){return(i-55296)*1024+r-56320+65536}}return i};if(e){e(String.prototype,"codePointAt",{value:t,configurable:true,writable:true})}else{String.prototype.codePointAt=t}})()}var R=0;var P=-3;function w(){this.table=new Uint16Array(16);this.trans=new Uint16Array(288)}function k(e,t){this.source=e;this.sourceIndex=0;this.tag=0;this.bitcount=0;this.dest=t;this.destLen=0;this.ltree=new w;this.dtree=new w}var F=new w;var D=new w;var V=new Uint8Array(30);var z=new Uint16Array(30);var X=new Uint8Array(30);var q=new Uint16Array(30);var H=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);var Y=new w;var c=new Uint8Array(288+32);function W(e,t,n,a){var i,r;for(i=0;i<n;++i){e[i]=0}for(i=0;i<30-n;++i){e[i+n]=i/n|0}for(r=a,i=0;i<30;++i){t[i]=r;r+=1<<e[i]}}function Z(e,t){var n;for(n=0;n<7;++n){e.table[n]=0}e.table[7]=24;e.table[8]=152;e.table[9]=112;for(n=0;n<24;++n){e.trans[n]=256+n}for(n=0;n<144;++n){e.trans[24+n]=n}for(n=0;n<8;++n){e.trans[24+144+n]=280+n}for(n=0;n<112;++n){e.trans[24+144+8+n]=144+n}for(n=0;n<5;++n){t.table[n]=0}t.table[5]=32;for(n=0;n<32;++n){t.trans[n]=n}}var K=new Uint16Array(16);function J(e,t,n,a){var i,r;for(i=0;i<16;++i){e.table[i]=0}for(i=0;i<a;++i){e.table[t[n+i]]++}e.table[0]=0;for(r=0,i=0;i<16;++i){K[i]=r;r+=e.table[i]}for(i=0;i<a;++i){if(t[n+i]){e.trans[K[t[n+i]]++]=i}}}function Q(e){if(!e.bitcount--){e.tag=e.source[e.sourceIndex++];e.bitcount=7}var t=e.tag&1;e.tag>>>=1;return t}function d(e,t,n){if(!t){return n}while(e.bitcount<24){e.tag|=e.source[e.sourceIndex++]<<e.bitcount;e.bitcount+=8}var a=e.tag&65535>>>16-t;e.tag>>>=t;e.bitcount-=t;return a+n}function $(e,t){while(e.bitcount<24){e.tag|=e.source[e.sourceIndex++]<<e.bitcount;e.bitcount+=8}var n=0,a=0,i=0;var r=e.tag;do{a=2*a+(r&1);r>>>=1;++i;n+=t.table[i];a-=t.table[i]}while(a>=0);e.tag=r;e.bitcount-=i;return t.trans[n+a]}function ee(e,t,n){var a,i,r;var s,o,l;a=d(e,5,257);i=d(e,5,1);r=d(e,4,4);for(s=0;s<19;++s){c[s]=0}for(s=0;s<r;++s){var u=d(e,3,0);c[H[s]]=u}J(Y,c,0,19);for(o=0;o<a+i;){var m=$(e,Y);switch(m){case 16:var p=c[o-1];for(l=d(e,2,3);l;--l){c[o++]=p}break;case 17:for(l=d(e,3,3);l;--l){c[o++]=0}break;case 18:for(l=d(e,7,11);l;--l){c[o++]=0}break;default:c[o++]=m;break}}J(t,c,0,a);J(n,c,a,i)}function te(e,t,n){while(1){var a=$(e,t);if(a===256){return R}if(a<256){e.dest[e.destLen++]=a}else{var i,r,s;var o;a-=257;i=d(e,V[a],z[a]);r=$(e,n);s=e.destLen-d(e,X[r],q[r]);for(o=s;o<s+i;++o){e.dest[e.destLen++]=e.dest[o]}}}}function ne(e){var t,n;var a;while(e.bitcount>8){e.sourceIndex--;e.bitcount-=8}t=e.source[e.sourceIndex+1];t=256*t+e.source[e.sourceIndex];n=e.source[e.sourceIndex+3];n=256*n+e.source[e.sourceIndex+2];if(t!==(~n&65535)){return P}e.sourceIndex+=4;for(a=t;a;--a){e.dest[e.destLen++]=e.source[e.sourceIndex++]}e.bitcount=0;return R}function ae(e,t){var n=new k(e,t);var a,i,r;do{a=Q(n);i=d(n,2,0);switch(i){case 0:r=ne(n);break;case 1:r=te(n,F,D);break;case 2:ee(n,n.ltree,n.dtree);r=te(n,n.ltree,n.dtree);break;default:r=P}if(r!==R){throw new Error("Data error")}}while(!a);if(n.destLen<n.dest.length){if(typeof n.dest.slice==="function"){return n.dest.slice(0,n.destLen)}else{return n.dest.subarray(0,n.destLen)}}return n.dest}Z(F,D);W(V,z,4,3);W(X,q,2,1);V[28]=0;z[28]=258;var ie=ae;function re(e,t,n,a,i){return Math.pow(1-i,3)*e+3*Math.pow(1-i,2)*i*t+3*(1-i)*Math.pow(i,2)*n+Math.pow(i,3)*a}function o(){this.x1=Number.NaN;this.y1=Number.NaN;this.x2=Number.NaN;this.y2=Number.NaN}o.prototype.isEmpty=function(){return isNaN(this.x1)||isNaN(this.y1)||isNaN(this.x2)||isNaN(this.y2)};o.prototype.addPoint=function(e,t){if(typeof e==="number"){if(isNaN(this.x1)||isNaN(this.x2)){this.x1=e;this.x2=e}if(e<this.x1){this.x1=e}if(e>this.x2){this.x2=e}}if(typeof t==="number"){if(isNaN(this.y1)||isNaN(this.y2)){this.y1=t;this.y2=t}if(t<this.y1){this.y1=t}if(t>this.y2){this.y2=t}}};o.prototype.addX=function(e){this.addPoint(e,null)};o.prototype.addY=function(e){this.addPoint(null,e)};o.prototype.addBezier=function(e,t,n,a,i,r,s,o){var l=[e,t];var u=[n,a];var m=[i,r];var p=[s,o];this.addPoint(e,t);this.addPoint(s,o);for(var c=0;c<=1;c++){var d=6*l[c]-12*u[c]+6*m[c];var h=-3*l[c]+9*u[c]-9*m[c]+3*p[c];var f=3*u[c]-3*l[c];if(h===0){if(d===0){continue}var v=-f/d;if(0<v&&v<1){if(c===0){this.addX(re(l[c],u[c],m[c],p[c],v))}if(c===1){this.addY(re(l[c],u[c],m[c],p[c],v))}}continue}var g=Math.pow(d,2)-4*f*h;if(g<0){continue}var b=(-d+Math.sqrt(g))/(2*h);if(0<b&&b<1){if(c===0){this.addX(re(l[c],u[c],m[c],p[c],b))}if(c===1){this.addY(re(l[c],u[c],m[c],p[c],b))}}var x=(-d-Math.sqrt(g))/(2*h);if(0<x&&x<1){if(c===0){this.addX(re(l[c],u[c],m[c],p[c],x))}if(c===1){this.addY(re(l[c],u[c],m[c],p[c],x))}}}};o.prototype.addQuad=function(e,t,n,a,i,r){var s=e+2/3*(n-e);var o=t+2/3*(a-t);var l=s+1/3*(i-e);var u=o+1/3*(r-t);this.addBezier(e,t,s,o,l,u,i,r)};function h(){this.commands=[];this.fill="black";this.stroke=null;this.strokeWidth=1}h.prototype.moveTo=function(e,t){this.commands.push({type:"M",x:e,y:t})};h.prototype.lineTo=function(e,t){this.commands.push({type:"L",x:e,y:t})};h.prototype.curveTo=h.prototype.bezierCurveTo=function(e,t,n,a,i,r){this.commands.push({type:"C",x1:e,y1:t,x2:n,y2:a,x:i,y:r})};h.prototype.quadTo=h.prototype.quadraticCurveTo=function(e,t,n,a){this.commands.push({type:"Q",x1:e,y1:t,x:n,y:a})};h.prototype.close=h.prototype.closePath=function(){this.commands.push({type:"Z"})};h.prototype.extend=function(e){if(e.commands){e=e.commands}else if(e instanceof o){var t=e;this.moveTo(t.x1,t.y1);this.lineTo(t.x2,t.y1);this.lineTo(t.x2,t.y2);this.lineTo(t.x1,t.y2);this.close();return}Array.prototype.push.apply(this.commands,e)};h.prototype.getBoundingBox=function(){var e=new o;var t=0;var n=0;var a=0;var i=0;for(var r=0;r<this.commands.length;r++){var s=this.commands[r];switch(s.type){case"M":e.addPoint(s.x,s.y);t=a=s.x;n=i=s.y;break;case"L":e.addPoint(s.x,s.y);a=s.x;i=s.y;break;case"Q":e.addQuad(a,i,s.x1,s.y1,s.x,s.y);a=s.x;i=s.y;break;case"C":e.addBezier(a,i,s.x1,s.y1,s.x2,s.y2,s.x,s.y);a=s.x;i=s.y;break;case"Z":a=t;i=n;break;default:throw new Error("Unexpected path command "+s.type)}}if(e.isEmpty()){e.addPoint(0,0)}return e};h.prototype.draw=function(e){e.beginPath();for(var t=0;t<this.commands.length;t+=1){var n=this.commands[t];if(n.type==="M"){e.moveTo(n.x,n.y)}else if(n.type==="L"){e.lineTo(n.x,n.y)}else if(n.type==="C"){e.bezierCurveTo(n.x1,n.y1,n.x2,n.y2,n.x,n.y)}else if(n.type==="Q"){e.quadraticCurveTo(n.x1,n.y1,n.x,n.y)}else if(n.type==="Z"){e.closePath()}}if(this.fill){e.fillStyle=this.fill;e.fill()}if(this.stroke){e.strokeStyle=this.stroke;e.lineWidth=this.strokeWidth;e.stroke()}};h.prototype.toPathData=function(t){t=t!==undefined?t:2;function i(e){if(Math.round(e)===e){return""+Math.round(e)}else{return e.toFixed(t)}}function e(){var e=arguments;var t="";for(var n=0;n<arguments.length;n+=1){var a=e[n];if(a>=0&&n>0){t+=" "}t+=i(a)}return t}var n="";for(var a=0;a<this.commands.length;a+=1){var r=this.commands[a];if(r.type==="M"){n+="M"+e(r.x,r.y)}else if(r.type==="L"){n+="L"+e(r.x,r.y)}else if(r.type==="C"){n+="C"+e(r.x1,r.y1,r.x2,r.y2,r.x,r.y)}else if(r.type==="Q"){n+="Q"+e(r.x1,r.y1,r.x,r.y)}else if(r.type==="Z"){n+="Z"}}return n};h.prototype.toSVG=function(e){var t='<path d="';t+=this.toPathData(e);t+='"';if(this.fill&&this.fill!=="black"){if(this.fill===null){t+=' fill="none"'}else{t+=' fill="'+this.fill+'"'}}if(this.stroke){t+=' stroke="'+this.stroke+'" stroke-width="'+this.strokeWidth+'"'}t+="/>";return t};h.prototype.toDOMElement=function(e){var t=this.toPathData(e);var n=document.createElementNS("http://www.w3.org/2000/svg","path");n.setAttribute("d",t);return n};function se(e){throw new Error(e)}function oe(e,t){if(!e){se(t)}}var I={fail:se,argument:oe,assert:oe};var le=32768;var ue=2147483648;var me={};var E={};var l={};function e(e){return function(){return e}}E.BYTE=function(e){I.argument(e>=0&&e<=255,"Byte value should be between 0 and 255.");return[e]};l.BYTE=e(1);E.CHAR=function(e){return[e.charCodeAt(0)]};l.CHAR=e(1);E.CHARARRAY=function(e){if(typeof e==="undefined"){e="";console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.")}var t=[];for(var n=0;n<e.length;n+=1){t[n]=e.charCodeAt(n)}return t};l.CHARARRAY=function(e){if(typeof e==="undefined"){return 0}return e.length};E.USHORT=function(e){return[e>>8&255,e&255]};l.USHORT=e(2);E.SHORT=function(e){if(e>=le){e=-(2*le-e)}return[e>>8&255,e&255]};l.SHORT=e(2);E.UINT24=function(e){return[e>>16&255,e>>8&255,e&255]};l.UINT24=e(3);E.ULONG=function(e){return[e>>24&255,e>>16&255,e>>8&255,e&255]};l.ULONG=e(4);E.LONG=function(e){if(e>=ue){e=-(2*ue-e)}return[e>>24&255,e>>16&255,e>>8&255,e&255]};l.LONG=e(4);E.FIXED=E.ULONG;l.FIXED=l.ULONG;E.FWORD=E.SHORT;l.FWORD=l.SHORT;E.UFWORD=E.USHORT;l.UFWORD=l.USHORT;E.LONGDATETIME=function(e){return[0,0,0,0,e>>24&255,e>>16&255,e>>8&255,e&255]};l.LONGDATETIME=e(8);E.TAG=function(e){I.argument(e.length===4,"Tag should be exactly 4 ASCII characters.");return[e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]};l.TAG=e(4);E.Card8=E.BYTE;l.Card8=l.BYTE;E.Card16=E.USHORT;l.Card16=l.USHORT;E.OffSize=E.BYTE;l.OffSize=l.BYTE;E.SID=E.USHORT;l.SID=l.USHORT;E.NUMBER=function(e){if(e>=-107&&e<=107){return[e+139]}else if(e>=108&&e<=1131){e=e-108;return[(e>>8)+247,e&255]}else if(e>=-1131&&e<=-108){e=-e-108;return[(e>>8)+251,e&255]}else if(e>=-32768&&e<=32767){return E.NUMBER16(e)}else{return E.NUMBER32(e)}};l.NUMBER=function(e){return E.NUMBER(e).length};E.NUMBER16=function(e){return[28,e>>8&255,e&255]};l.NUMBER16=e(3);E.NUMBER32=function(e){return[29,e>>24&255,e>>16&255,e>>8&255,e&255]};l.NUMBER32=e(5);E.REAL=function(e){var t=e.toString();var n=/\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t);if(n){var a=parseFloat("1e"+((n[2]?+n[2]:0)+n[1].length));t=(Math.round(e*a)/a).toString()}var i="";for(var r=0,s=t.length;r<s;r+=1){var o=t[r];if(o==="e"){i+=t[++r]==="-"?"c":"b"}else if(o==="."){i+="a"}else if(o==="-"){i+="e"}else{i+=o}}i+=i.length&1?"f":"ff";var l=[30];for(var u=0,m=i.length;u<m;u+=2){l.push(parseInt(i.substr(u,2),16))}return l};l.REAL=function(e){return E.REAL(e).length};E.NAME=E.CHARARRAY;l.NAME=l.CHARARRAY;E.STRING=E.CHARARRAY;l.STRING=l.CHARARRAY;me.UTF8=function(e,t,n){var a=[];var i=n;for(var r=0;r<i;r++,t+=1){a[r]=e.getUint8(t)}return String.fromCharCode.apply(null,a)};me.UTF16=function(e,t,n){var a=[];var i=n/2;for(var r=0;r<i;r++,t+=2){a[r]=e.getUint16(t)}return String.fromCharCode.apply(null,a)};E.UTF16=function(e){var t=[];for(var n=0;n<e.length;n+=1){var a=e.charCodeAt(n);t[t.length]=a>>8&255;t[t.length]=a&255}return t};l.UTF16=function(e){return e.length*2};var pe={"x-mac-croatian":""+" ","x-mac-cyrillic":""+" ","x-mac-gaelic":""+" ","x-mac-greek":""+" ","x-mac-icelandic":""+" ","x-mac-inuit":""+" ","x-mac-ce":""+" ",macintosh:""+" ","x-mac-romanian":""+" ","x-mac-turkish":""+" "};me.MACSTRING=function(e,t,n,a){var i=pe[a];if(i===undefined){return undefined}var r="";for(var s=0;s<n;s++){var o=e.getUint8(t+s);if(o<=127){r+=String.fromCharCode(o)}else{r+=i[o&127]}}return r};var ce=typeof WeakMap==="function"&&new WeakMap;var de;var he=function(e){if(!de){de={};for(var t in pe){de[t]=new String(t)}}var n=de[e];if(n===undefined){return undefined}if(ce){var a=ce.get(n);if(a!==undefined){return a}}var i=pe[e];if(i===undefined){return undefined}var r={};for(var s=0;s<i.length;s++){r[i.charCodeAt(s)]=s+128}if(ce){ce.set(n,r)}return r};E.MACSTRING=function(e,t){var n=he(t);if(n===undefined){return undefined}var a=[];for(var i=0;i<e.length;i++){var r=e.charCodeAt(i);if(r>=128){r=n[r];if(r===undefined){return undefined}}a[i]=r}return a};l.MACSTRING=function(e,t){var n=E.MACSTRING(e,t);if(n!==undefined){return n.length}else{return 0}};function fe(e){return e>=-128&&e<=127}function ve(e,t,n){var a=0;var i=e.length;while(t<i&&a<64&&e[t]===0){++t;++a}n.push(128|a-1);return t}function ge(e,t,n){var a=0;var i=e.length;var r=t;while(r<i&&a<64){var s=e[r];if(!fe(s)){break}if(s===0&&r+1<i&&e[r+1]===0){break}++r;++a}n.push(a-1);for(var o=t;o<r;++o){n.push(e[o]+256&255)}return r}function be(e,t,n){var a=0;var i=e.length;var r=t;while(r<i&&a<64){var s=e[r];if(s===0){break}if(fe(s)&&r+1<i&&fe(e[r+1])){break}++r;++a}n.push(64|a-1);for(var o=t;o<r;++o){var l=e[o];n.push(l+65536>>8&255,l+256&255)}return r}E.VARDELTAS=function(e){var t=0;var n=[];while(t<e.length){var a=e[t];if(a===0){t=ve(e,t,n)}else if(a>=-128&&a<=127){t=ge(e,t,n)}else{t=be(e,t,n)}}return n};E.INDEX=function(e){var t=1;var n=[t];var a=[];for(var i=0;i<e.length;i+=1){var r=E.OBJECT(e[i]);Array.prototype.push.apply(a,r);t+=r.length;n.push(t)}if(a.length===0){return[0,0]}var s=[];var o=1+Math.floor(Math.log(t)/Math.log(2))/8|0;var l=[undefined,E.BYTE,E.USHORT,E.UINT24,E.ULONG][o];for(var u=0;u<n.length;u+=1){var m=l(n[u]);Array.prototype.push.apply(s,m)}return Array.prototype.concat(E.Card16(e.length),E.OffSize(o),s,a)};l.INDEX=function(e){return E.INDEX(e).length};E.DICT=function(e){var t=[];var n=Object.keys(e);var a=n.length;for(var i=0;i<a;i+=1){var r=parseInt(n[i],0);var s=e[r];t=t.concat(E.OPERAND(s.value,s.type));t=t.concat(E.OPERATOR(r))}return t};l.DICT=function(e){return E.DICT(e).length};E.OPERATOR=function(e){if(e<1200){return[e]}else{return[12,e-1200]}};E.OPERAND=function(e,t){var n=[];if(Array.isArray(t)){for(var a=0;a<t.length;a+=1){I.argument(e.length===t.length,"Not enough arguments given for type"+t);n=n.concat(E.OPERAND(e[a],t[a]))}}else{if(t==="SID"){n=n.concat(E.NUMBER(e))}else if(t==="offset"){n=n.concat(E.NUMBER32(e))}else if(t==="number"){n=n.concat(E.NUMBER(e))}else if(t==="real"){n=n.concat(E.REAL(e))}else{throw new Error("Unknown operand type "+t)}}return n};E.OP=E.BYTE;l.OP=l.BYTE;var xe=typeof WeakMap==="function"&&new WeakMap;E.CHARSTRING=function(e){if(xe){var t=xe.get(e);if(t!==undefined){return t}}var n=[];var a=e.length;for(var i=0;i<a;i+=1){var r=e[i];n=n.concat(E[r.type](r.value))}if(xe){xe.set(e,n)}return n};l.CHARSTRING=function(e){return E.CHARSTRING(e).length};E.OBJECT=function(e){var t=E[e.type];I.argument(t!==undefined,"No encoding function for type "+e.type);return t(e.value)};l.OBJECT=function(e){var t=l[e.type];I.argument(t!==undefined,"No sizeOf function for type "+e.type);return t(e.value)};E.TABLE=function(e){var t=[];var n=e.fields.length;var a=[];var i=[];for(var r=0;r<n;r+=1){var s=e.fields[r];var o=E[s.type];I.argument(o!==undefined,"No encoding function for field type "+s.type+" ("+s.name+")");var l=e[s.name];if(l===undefined){l=s.value}var u=o(l);if(s.type==="TABLE"){i.push(t.length);t=t.concat([0,0]);a.push(u)}else{t=t.concat(u)}}for(var m=0;m<a.length;m+=1){var p=i[m];var c=t.length;I.argument(c<65536,"Table "+e.tableName+" too big.");t[p]=c>>8;t[p+1]=c&255;t=t.concat(a[m])}return t};l.TABLE=function(e){var t=0;var n=e.fields.length;for(var a=0;a<n;a+=1){var i=e.fields[a];var r=l[i.type];I.argument(r!==undefined,"No sizeOf function for field type "+i.type+" ("+i.name+")");var s=e[i.name];if(s===undefined){s=i.value}t+=r(s);if(i.type==="TABLE"){t+=2}}return t};E.RECORD=E.TABLE;l.RECORD=l.TABLE;E.LITERAL=function(e){return e};l.LITERAL=function(e){return e.length};function i(e,t,n){if(t.length&&(t[0].name!=="coverageFormat"||t[0].value===1)){for(var a=0;a<t.length;a+=1){var i=t[a];this[i.name]=i.value}}this.tableName=e;this.fields=t;if(n){var r=Object.keys(n);for(var s=0;s<r.length;s+=1){var o=r[s];var l=n[o];if(this[o]!==undefined){this[o]=l}}}}i.prototype.encode=function(){return E.TABLE(this)};i.prototype.sizeOf=function(){return l.TABLE(this)};function Oe(e,t,n){if(n===undefined){n=t.length}var a=new Array(t.length+1);a[0]={name:e+"Count",type:"USHORT",value:n};for(var i=0;i<t.length;i++){a[i+1]={name:e+i,type:"USHORT",value:t[i]}}return a}function _e(e,t,n){var a=t.length;var i=new Array(a+1);i[0]={name:e+"Count",type:"USHORT",value:a};for(var r=0;r<a;r++){i[r+1]={name:e+r,type:"TABLE",value:n(t[r],r)}}return i}function Te(e,t,n){var a=t.length;var i=[];i[0]={name:e+"Count",type:"USHORT",value:a};for(var r=0;r<a;r++){i=i.concat(n(t[r],r))}return i}function Ie(e){if(e.format===1){i.call(this,"coverageTable",[{name:"coverageFormat",type:"USHORT",value:1}].concat(Oe("glyph",e.glyphs)))}else if(e.format===2){i.call(this,"coverageTable",[{name:"coverageFormat",type:"USHORT",value:2}].concat(Te("rangeRecord",e.ranges,function(e){return[{name:"startGlyphID",type:"USHORT",value:e.start},{name:"endGlyphID",type:"USHORT",value:e.end},{name:"startCoverageIndex",type:"USHORT",value:e.index}]})))}else{I.assert(false,"Coverage format must be 1 or 2.")}}Ie.prototype=Object.create(i.prototype);Ie.prototype.constructor=Ie;function ye(e){i.call(this,"scriptListTable",Te("scriptRecord",e,function(e,t){var n=e.script;var a=n.defaultLangSys;I.assert(!!a,"Unable to write GSUB: script "+e.tag+" has no default language system.");return[{name:"scriptTag"+t,type:"TAG",value:e.tag},{name:"script"+t,type:"TABLE",value:new i("scriptTable",[{name:"defaultLangSys",type:"TABLE",value:new i("defaultLangSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:a.reqFeatureIndex}].concat(Oe("featureIndex",a.featureIndexes)))}].concat(Te("langSys",n.langSysRecords,function(e,t){var n=e.langSys;return[{name:"langSysTag"+t,type:"TAG",value:e.tag},{name:"langSys"+t,type:"TABLE",value:new i("langSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:n.reqFeatureIndex}].concat(Oe("featureIndex",n.featureIndexes)))}]})))}]}))}ye.prototype=Object.create(i.prototype);ye.prototype.constructor=ye;function Ae(e){i.call(this,"featureListTable",Te("featureRecord",e,function(e,t){var n=e.feature;return[{name:"featureTag"+t,type:"TAG",value:e.tag},{name:"feature"+t,type:"TABLE",value:new i("featureTable",[{name:"featureParams",type:"USHORT",value:n.featureParams}].concat(Oe("lookupListIndex",n.lookupListIndexes)))}]}))}Ae.prototype=Object.create(i.prototype);Ae.prototype.constructor=Ae;function Se(e,n){i.call(this,"lookupListTable",_e("lookup",e,function(e){var t=n[e.lookupType];I.assert(!!t,"Unable to write GSUB lookup type "+e.lookupType+" tables.");return new i("lookupTable",[{name:"lookupType",type:"USHORT",value:e.lookupType},{name:"lookupFlag",type:"USHORT",value:e.lookupFlag}].concat(_e("subtable",e.subtables,t)))}))}Se.prototype=Object.create(i.prototype);Se.prototype.constructor=Se;var C={Table:i,Record:i,Coverage:Ie,ScriptList:ye,FeatureList:Ae,LookupList:Se,ushortList:Oe,tableList:_e,recordList:Te};function Ee(e,t){return e.getUint8(t)}function Ce(e,t){return e.getUint16(t,false)}function je(e,t){return e.getInt16(t,false)}function Ne(e,t){return e.getUint32(t,false)}function Le(e,t){var n=e.getInt16(t,false);var a=e.getUint16(t+2,false);return n+a/65535}function Me(e,t){var n="";for(var a=t;a<t+4;a+=1){n+=String.fromCharCode(e.getInt8(a))}return n}function Re(e,t,n){var a=0;for(var i=0;i<n;i+=1){a<<=8;a+=e.getUint8(t+i)}return a}function Pe(e,t,n){var a=[];for(var i=t;i<n;i+=1){a.push(e.getUint8(i))}return a}function we(e){var t="";for(var n=0;n<e.length;n+=1){t+=String.fromCharCode(e[n])}return t}var ke={byte:1,uShort:2,short:2,uLong:4,fixed:4,longDateTime:8,tag:4};function m(e,t){this.data=e;this.offset=t;this.relativeOffset=0}m.prototype.parseByte=function(){var e=this.data.getUint8(this.offset+this.relativeOffset);this.relativeOffset+=1;return e};m.prototype.parseChar=function(){var e=this.data.getInt8(this.offset+this.relativeOffset);this.relativeOffset+=1;return e};m.prototype.parseCard8=m.prototype.parseByte;m.prototype.parseUShort=function(){var e=this.data.getUint16(this.offset+this.relativeOffset);this.relativeOffset+=2;return e};m.prototype.parseCard16=m.prototype.parseUShort;m.prototype.parseSID=m.prototype.parseUShort;m.prototype.parseOffset16=m.prototype.parseUShort;m.prototype.parseShort=function(){var e=this.data.getInt16(this.offset+this.relativeOffset);this.relativeOffset+=2;return e};m.prototype.parseF2Dot14=function(){var e=this.data.getInt16(this.offset+this.relativeOffset)/16384;this.relativeOffset+=2;return e};m.prototype.parseULong=function(){var e=Ne(this.data,this.offset+this.relativeOffset);this.relativeOffset+=4;return e};m.prototype.parseOffset32=m.prototype.parseULong;m.prototype.parseFixed=function(){var e=Le(this.data,this.offset+this.relativeOffset);this.relativeOffset+=4;return e};m.prototype.parseString=function(e){var t=this.data;var n=this.offset+this.relativeOffset;var a="";this.relativeOffset+=e;for(var i=0;i<e;i++){a+=String.fromCharCode(t.getUint8(n+i))}return a};m.prototype.parseTag=function(){return this.parseString(4)};m.prototype.parseLongDateTime=function(){var e=Ne(this.data,this.offset+this.relativeOffset+4);e-=2082844800;this.relativeOffset+=8;return e};m.prototype.parseVersion=function(e){var t=Ce(this.data,this.offset+this.relativeOffset);var n=Ce(this.data,this.offset+this.relativeOffset+2);this.relativeOffset+=4;if(e===undefined){e=4096}return t+n/e/10};m.prototype.skip=function(e,t){if(t===undefined){t=1}this.relativeOffset+=ke[e]*t};m.prototype.parseULongList=function(e){if(e===undefined){e=this.parseULong()}var t=new Array(e);var n=this.data;var a=this.offset+this.relativeOffset;for(var i=0;i<e;i++){t[i]=n.getUint32(a);a+=4}this.relativeOffset+=e*4;return t};m.prototype.parseOffset16List=m.prototype.parseUShortList=function(e){if(e===undefined){e=this.parseUShort()}var t=new Array(e);var n=this.data;var a=this.offset+this.relativeOffset;for(var i=0;i<e;i++){t[i]=n.getUint16(a);a+=2}this.relativeOffset+=e*2;return t};m.prototype.parseShortList=function(e){var t=new Array(e);var n=this.data;var a=this.offset+this.relativeOffset;for(var i=0;i<e;i++){t[i]=n.getInt16(a);a+=2}this.relativeOffset+=e*2;return t};m.prototype.parseByteList=function(e){var t=new Array(e);var n=this.data;var a=this.offset+this.relativeOffset;for(var i=0;i<e;i++){t[i]=n.getUint8(a++)}this.relativeOffset+=e;return t};m.prototype.parseList=function(e,t){if(!t){t=e;e=this.parseUShort()}var n=new Array(e);for(var a=0;a<e;a++){n[a]=t.call(this)}return n};m.prototype.parseList32=function(e,t){if(!t){t=e;e=this.parseULong()}var n=new Array(e);for(var a=0;a<e;a++){n[a]=t.call(this)}return n};m.prototype.parseRecordList=function(e,t){if(!t){t=e;e=this.parseUShort()}var n=new Array(e);var a=Object.keys(t);for(var i=0;i<e;i++){var r={};for(var s=0;s<a.length;s++){var o=a[s];var l=t[o];r[o]=l.call(this)}n[i]=r}return n};m.prototype.parseRecordList32=function(e,t){if(!t){t=e;e=this.parseULong()}var n=new Array(e);var a=Object.keys(t);for(var i=0;i<e;i++){var r={};for(var s=0;s<a.length;s++){var o=a[s];var l=t[o];r[o]=l.call(this)}n[i]=r}return n};m.prototype.parseStruct=function(e){if(typeof e==="function"){return e.call(this)}else{var t=Object.keys(e);var n={};for(var a=0;a<t.length;a++){var i=t[a];var r=e[i];n[i]=r.call(this)}return n}};m.prototype.parseValueRecord=function(e){if(e===undefined){e=this.parseUShort()}if(e===0){return}var t={};if(e&1){t.xPlacement=this.parseShort()}if(e&2){t.yPlacement=this.parseShort()}if(e&4){t.xAdvance=this.parseShort()}if(e&8){t.yAdvance=this.parseShort()}if(e&16){t.xPlaDevice=undefined;this.parseShort()}if(e&32){t.yPlaDevice=undefined;this.parseShort()}if(e&64){t.xAdvDevice=undefined;this.parseShort()}if(e&128){t.yAdvDevice=undefined;this.parseShort()}return t};m.prototype.parseValueRecordList=function(){var e=this.parseUShort();var t=this.parseUShort();var n=new Array(t);for(var a=0;a<t;a++){n[a]=this.parseValueRecord(e)}return n};m.prototype.parsePointer=function(e){var t=this.parseOffset16();if(t>0){return new m(this.data,this.offset+t).parseStruct(e)}return undefined};m.prototype.parsePointer32=function(e){var t=this.parseOffset32();if(t>0){return new m(this.data,this.offset+t).parseStruct(e)}return undefined};m.prototype.parseListOfLists=function(e){var t=this.parseOffset16List();var n=t.length;var a=this.relativeOffset;var i=new Array(n);for(var r=0;r<n;r++){var s=t[r];if(s===0){i[r]=undefined;continue}this.relativeOffset=s;if(e){var o=this.parseOffset16List();var l=new Array(o.length);for(var u=0;u<o.length;u++){this.relativeOffset=s+o[u];l[u]=e.call(this)}i[r]=l}else{i[r]=this.parseUShortList()}}this.relativeOffset=a;return i};m.prototype.parseCoverage=function(){var e=this.offset+this.relativeOffset;var t=this.parseUShort();var n=this.parseUShort();if(t===1){return{format:1,glyphs:this.parseUShortList(n)}}else if(t===2){var a=new Array(n);for(var i=0;i<n;i++){a[i]={start:this.parseUShort(),end:this.parseUShort(),index:this.parseUShort()}}return{format:2,ranges:a}}throw new Error("0x"+e.toString(16)+": Coverage format must be 1 or 2.")};m.prototype.parseClassDef=function(){var e=this.offset+this.relativeOffset;var t=this.parseUShort();if(t===1){return{format:1,startGlyph:this.parseUShort(),classes:this.parseUShortList()}}else if(t===2){return{format:2,ranges:this.parseRecordList({start:m.uShort,end:m.uShort,classId:m.uShort})}}throw new Error("0x"+e.toString(16)+": ClassDef format must be 1 or 2.")};m.list=function(e,t){return function(){return this.parseList(e,t)}};m.list32=function(e,t){return function(){return this.parseList32(e,t)}};m.recordList=function(e,t){return function(){return this.parseRecordList(e,t)}};m.recordList32=function(e,t){return function(){return this.parseRecordList32(e,t)}};m.pointer=function(e){return function(){return this.parsePointer(e)}};m.pointer32=function(e){return function(){return this.parsePointer32(e)}};m.tag=m.prototype.parseTag;m.byte=m.prototype.parseByte;m.uShort=m.offset16=m.prototype.parseUShort;m.uShortList=m.prototype.parseUShortList;m.uLong=m.offset32=m.prototype.parseULong;m.uLongList=m.prototype.parseULongList;m.struct=m.prototype.parseStruct;m.coverage=m.prototype.parseCoverage;m.classDef=m.prototype.parseClassDef;var Fe={reserved:m.uShort,reqFeatureIndex:m.uShort,featureIndexes:m.uShortList};m.prototype.parseScriptList=function(){return this.parsePointer(m.recordList({tag:m.tag,script:m.pointer({defaultLangSys:m.pointer(Fe),langSysRecords:m.recordList({tag:m.tag,langSys:m.pointer(Fe)})})}))||[]};m.prototype.parseFeatureList=function(){return this.parsePointer(m.recordList({tag:m.tag,feature:m.pointer({featureParams:m.offset16,lookupListIndexes:m.uShortList})}))||[]};m.prototype.parseLookupList=function(a){return this.parsePointer(m.list(m.pointer(function(){var e=this.parseUShort();I.argument(1<=e&&e<=9,"GPOS/GSUB lookup type "+e+" unknown.");var t=this.parseUShort();var n=t&16;return{lookupType:e,lookupFlag:t,subtables:this.parseList(m.pointer(a[e])),markFilteringSet:n?this.parseUShort():undefined}})))||[]};m.prototype.parseFeatureVariationsList=function(){return this.parsePointer32(function(){var e=this.parseUShort();var t=this.parseUShort();I.argument(e===1&&t<1,"GPOS/GSUB feature variations table unknown.");var n=this.parseRecordList32({conditionSetOffset:m.offset32,featureTableSubstitutionOffset:m.offset32});return n})||[]};var G={getByte:Ee,getCard8:Ee,getUShort:Ce,getCard16:Ce,getShort:je,getULong:Ne,getFixed:Le,getTag:Me,getOffset:Re,getBytes:Pe,bytesToString:we,Parser:m};function Ge(e,t){t.parseUShort();e.length=t.parseULong();e.language=t.parseULong();var n;e.groupCount=n=t.parseULong();e.glyphIndexMap={};for(var a=0;a<n;a+=1){var i=t.parseULong();var r=t.parseULong();var s=t.parseULong();for(var o=i;o<=r;o+=1){e.glyphIndexMap[o]=s;s++}}}function Ue(e,t,n,a,i){e.length=t.parseUShort();e.language=t.parseUShort();var r;e.segCount=r=t.parseUShort()>>1;t.skip("uShort",3);e.glyphIndexMap={};var s=new G.Parser(n,a+i+14);var o=new G.Parser(n,a+i+16+r*2);var l=new G.Parser(n,a+i+16+r*4);var u=new G.Parser(n,a+i+16+r*6);var m=a+i+16+r*8;for(var p=0;p<r-1;p+=1){var c=void 0;var d=s.parseUShort();var h=o.parseUShort();var f=l.parseShort();var v=u.parseUShort();for(var g=h;g<=d;g+=1){if(v!==0){m=u.offset+u.relativeOffset-2;m+=v;m+=(g-h)*2;c=G.getUShort(n,m);if(c!==0){c=c+f&65535}}else{c=g+f&65535}e.glyphIndexMap[g]=c}}}function Be(e,t){var n={};n.version=G.getUShort(e,t);I.argument(n.version===0,"cmap table version should be 0.");n.numTables=G.getUShort(e,t+2);var a=-1;for(var i=n.numTables-1;i>=0;i-=1){var r=G.getUShort(e,t+4+i*8);var s=G.getUShort(e,t+4+i*8+2);if(r===3&&(s===0||s===1||s===10)||r===0&&(s===0||s===1||s===2||s===3||s===4)){a=G.getULong(e,t+4+i*8+4);break}}if(a===-1){throw new Error("No valid cmap sub-tables found.")}var o=new G.Parser(e,t+a);n.format=o.parseUShort();if(n.format===12){Ge(n,o)}else if(n.format===4){Ue(n,o,e,t,a)}else{throw new Error("Only format 4 and 12 cmap tables are supported (found format "+n.format+").")}return n}function De(e,t,n){e.segments.push({end:t,start:t,delta:-(t-n),offset:0,glyphIndex:n})}function Ve(e){e.segments.push({end:65535,start:65535,delta:1,offset:0})}function ze(e){var t=true;var n;for(n=e.length-1;n>0;n-=1){var a=e.get(n);if(a.unicode>65535){console.log("Adding CMAP format 12 (needed!)");t=false;break}}var i=[{name:"version",type:"USHORT",value:0},{name:"numTables",type:"USHORT",value:t?1:2},{name:"platformID",type:"USHORT",value:3},{name:"encodingID",type:"USHORT",value:1},{name:"offset",type:"ULONG",value:t?12:12+8}];if(!t){i=i.concat([{name:"cmap12PlatformID",type:"USHORT",value:3},{name:"cmap12EncodingID",type:"USHORT",value:10},{name:"cmap12Offset",type:"ULONG",value:0}])}i=i.concat([{name:"format",type:"USHORT",value:4},{name:"cmap4Length",type:"USHORT",value:0},{name:"language",type:"USHORT",value:0},{name:"segCountX2",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0}]);var r=new C.Table("cmap",i);r.segments=[];for(n=0;n<e.length;n+=1){var s=e.get(n);for(var o=0;o<s.unicodes.length;o+=1){De(r,s.unicodes[o],n)}r.segments=r.segments.sort(function(e,t){return e.start-t.start})}Ve(r);var l=r.segments.length;var u=0;var m=[];var p=[];var c=[];var d=[];var h=[];var f=[];for(n=0;n<l;n+=1){var v=r.segments[n];if(v.end<=65535&&v.start<=65535){m=m.concat({name:"end_"+n,type:"USHORT",value:v.end});p=p.concat({name:"start_"+n,type:"USHORT",value:v.start});c=c.concat({name:"idDelta_"+n,type:"SHORT",value:v.delta});d=d.concat({name:"idRangeOffset_"+n,type:"USHORT",value:v.offset});if(v.glyphId!==undefined){h=h.concat({name:"glyph_"+n,type:"USHORT",value:v.glyphId})}}else{u+=1}if(!t&&v.glyphIndex!==undefined){f=f.concat({name:"cmap12Start_"+n,type:"ULONG",value:v.start});f=f.concat({name:"cmap12End_"+n,type:"ULONG",value:v.end});f=f.concat({name:"cmap12Glyph_"+n,type:"ULONG",value:v.glyphIndex})}}r.segCountX2=(l-u)*2;r.searchRange=Math.pow(2,Math.floor(Math.log(l-u)/Math.log(2)))*2;r.entrySelector=Math.log(r.searchRange/2)/Math.log(2);r.rangeShift=r.segCountX2-r.searchRange;r.fields=r.fields.concat(m);r.fields.push({name:"reservedPad",type:"USHORT",value:0});r.fields=r.fields.concat(p);r.fields=r.fields.concat(c);r.fields=r.fields.concat(d);r.fields=r.fields.concat(h);r.cmap4Length=14+m.length*2+2+p.length*2+c.length*2+d.length*2+h.length*2;if(!t){var g=16+f.length*4;r.cmap12Offset=12+2*2+4+r.cmap4Length;r.fields=r.fields.concat([{name:"cmap12Format",type:"USHORT",value:12},{name:"cmap12Reserved",type:"USHORT",value:0},{name:"cmap12Length",type:"ULONG",value:g},{name:"cmap12Language",type:"ULONG",value:0},{name:"cmap12nGroups",type:"ULONG",value:f.length/3}]);r.fields=r.fields.concat(f)}return r}var Xe={parse:Be,make:ze};var qe=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","266 ff","onedotenleader","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall","001.000","001.001","001.002","001.003","Black","Bold","Book","Light","Medium","Regular","Roman","Semibold"];var He=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","","endash","dagger","daggerdbl","periodcentered","","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","","questiondown","","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","","ring","cedilla","","hungarumlaut","ogonek","caron","emdash","","","","","","","","","","","","","","","","","AE","","ordfeminine","","","","","Lslash","Oslash","OE","ordmasculine","","","","","","ae","","","","dotlessi","","","lslash","oslash","oe","germandbls"];var Ye=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclamsmall","Hungarumlautsmall","","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","questionsmall","","asuperior","bsuperior","centsuperior","dsuperior","esuperior","","","isuperior","","","lsuperior","msuperior","nsuperior","osuperior","","","rsuperior","ssuperior","tsuperior","","ff","fi","fl","ffi","ffl","parenleftinferior","","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdownsmall","centoldstyle","Lslashsmall","","","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","","Dotaccentsmall","","","Macronsmall","","","figuredash","hypheninferior","","","Ogoneksmall","Ringsmall","Cedillasmall","","","","onequarter","onehalf","threequarters","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","","","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall"];var u=[".notdef",".null","nonmarkingreturn","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","Adieresis","Aring","Ccedilla","Eacute","Ntilde","Odieresis","Udieresis","aacute","agrave","acircumflex","adieresis","atilde","aring","ccedilla","eacute","egrave","ecircumflex","edieresis","iacute","igrave","icircumflex","idieresis","ntilde","oacute","ograve","ocircumflex","odieresis","otilde","uacute","ugrave","ucircumflex","udieresis","dagger","degree","cent","sterling","section","bullet","paragraph","germandbls","registered","copyright","trademark","acute","dieresis","notequal","AE","Oslash","infinity","plusminus","lessequal","greaterequal","yen","mu","partialdiff","summation","product","pi","integral","ordfeminine","ordmasculine","Omega","ae","oslash","questiondown","exclamdown","logicalnot","radical","florin","approxequal","Delta","guillemotleft","guillemotright","ellipsis","nonbreakingspace","Agrave","Atilde","Otilde","OE","oe","endash","emdash","quotedblleft","quotedblright","quoteleft","quoteright","divide","lozenge","ydieresis","Ydieresis","fraction","currency","guilsinglleft","guilsinglright","fi","fl","daggerdbl","periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex","Ecircumflex","Aacute","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex","apple","Ograve","Uacute","Ucircumflex","Ugrave","dotlessi","circumflex","tilde","macron","breve","dotaccent","ring","cedilla","hungarumlaut","ogonek","caron","Lslash","lslash","Scaron","scaron","Zcaron","zcaron","brokenbar","Eth","eth","Yacute","yacute","Thorn","thorn","minus","multiply","onesuperior","twosuperior","threesuperior","onehalf","onequarter","threequarters","franc","Gbreve","gbreve","Idotaccent","Scedilla","scedilla","Cacute","cacute","Ccaron","ccaron","dcroat"];function We(e){this.font=e}We.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0);var n=this.font.glyphs;if(n){for(var a=0;a<n.length;a+=1){var i=n.get(a);for(var r=0;r<i.unicodes.length;r+=1){if(i.unicodes[r]===t){return a}}}}return null};function Ze(e){this.cmap=e}Ze.prototype.charToGlyphIndex=function(e){return this.cmap.glyphIndexMap[e.codePointAt(0)]||0};function Ke(e,t){this.encoding=e;this.charset=t}Ke.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0);var n=this.encoding[t];return this.charset.indexOf(n)};function Je(e){switch(e.version){case 1:this.names=u.slice();break;case 2:this.names=new Array(e.numberOfGlyphs);for(var t=0;t<e.numberOfGlyphs;t++){if(e.glyphNameIndex[t]<u.length){this.names[t]=u[e.glyphNameIndex[t]]}else{this.names[t]=e.names[e.glyphNameIndex[t]-u.length]}}break;case 2.5:this.names=new Array(e.numberOfGlyphs);for(var n=0;n<e.numberOfGlyphs;n++){this.names[n]=u[n+e.glyphNameIndex[n]]}break;case 3:this.names=[];break;default:this.names=[];break}}Je.prototype.nameToGlyphIndex=function(e){return this.names.indexOf(e)};Je.prototype.glyphIndexToName=function(e){return this.names[e]};function Qe(e){var t;var n=e.tables.cmap.glyphIndexMap;var a=Object.keys(n);for(var i=0;i<a.length;i+=1){var r=a[i];var s=n[r];t=e.glyphs.get(s);t.addUnicode(parseInt(r))}for(var o=0;o<e.glyphs.length;o+=1){t=e.glyphs.get(o);if(e.cffEncoding){if(e.isCIDFont){t.name="gid"+o}else{t.name=e.cffEncoding.charset[o]}}else if(e.glyphNames.names){t.name=e.glyphNames.glyphIndexToName(o)}}}function $e(e){e._IndexToUnicodeMap={};var t=e.tables.cmap.glyphIndexMap;var n=Object.keys(t);for(var a=0;a<n.length;a+=1){var i=n[a];var r=t[i];if(e._IndexToUnicodeMap[r]===undefined){e._IndexToUnicodeMap[r]={unicodes:[parseInt(i)]}}else{e._IndexToUnicodeMap[r].unicodes.push(parseInt(i))}}}function et(e,t){if(t.lowMemory){$e(e)}else{Qe(e)}}function tt(e,t,n,a,i){e.beginPath();e.moveTo(t,n);e.lineTo(a,i);e.stroke()}var p={line:tt};function nt(e,t){var n=t||new h;return{configurable:true,get:function(){if(typeof n==="function"){n=n()}return n},set:function(e){n=e}}}function f(e){this.bindConstructorValues(e)}f.prototype.bindConstructorValues=function(e){this.index=e.index||0;this.name=e.name||null;this.unicode=e.unicode||undefined;this.unicodes=e.unicodes||e.unicode!==undefined?[e.unicode]:[];if("xMin"in e){this.xMin=e.xMin}if("yMin"in e){this.yMin=e.yMin}if("xMax"in e){this.xMax=e.xMax}if("yMax"in e){this.yMax=e.yMax}if("advanceWidth"in e){this.advanceWidth=e.advanceWidth}Object.defineProperty(this,"path",nt(this,e.path))};f.prototype.addUnicode=function(e){if(this.unicodes.length===0){this.unicode=e}this.unicodes.push(e)};f.prototype.getBoundingBox=function(){return this.path.getBoundingBox()};f.prototype.getPath=function(e,t,n,a,i){e=e!==undefined?e:0;t=t!==undefined?t:0;n=n!==undefined?n:72;var r;var s;if(!a){a={}}var o=a.xScale;var l=a.yScale;if(a.hinting&&i&&i.hinting){s=this.path&&i.hinting.exec(this,n)}if(s){r=i.hinting.getCommands(s);e=Math.round(e);t=Math.round(t);o=l=1}else{r=this.path.commands;var u=1/(this.path.unitsPerEm||1e3)*n;if(o===undefined){o=u}if(l===undefined){l=u}}var m=new h;for(var p=0;p<r.length;p+=1){var c=r[p];if(c.type==="M"){m.moveTo(e+c.x*o,t+-c.y*l)}else if(c.type==="L"){m.lineTo(e+c.x*o,t+-c.y*l)}else if(c.type==="Q"){m.quadraticCurveTo(e+c.x1*o,t+-c.y1*l,e+c.x*o,t+-c.y*l)}else if(c.type==="C"){m.curveTo(e+c.x1*o,t+-c.y1*l,e+c.x2*o,t+-c.y2*l,e+c.x*o,t+-c.y*l)}else if(c.type==="Z"){m.closePath()}}return m};f.prototype.getContours=function(){if(this.points===undefined){return[]}var e=[];var t=[];for(var n=0;n<this.points.length;n+=1){var a=this.points[n];t.push(a);if(a.lastPointOfContour){e.push(t);t=[]}}I.argument(t.length===0,"There are still points left in the current contour.");return e};f.prototype.getMetrics=function(){var e=this.path.commands;var t=[];var n=[];for(var a=0;a<e.length;a+=1){var i=e[a];if(i.type!=="Z"){t.push(i.x);n.push(i.y)}if(i.type==="Q"||i.type==="C"){t.push(i.x1);n.push(i.y1)}if(i.type==="C"){t.push(i.x2);n.push(i.y2)}}var r={xMin:Math.min.apply(null,t),yMin:Math.min.apply(null,n),xMax:Math.max.apply(null,t),yMax:Math.max.apply(null,n),leftSideBearing:this.leftSideBearing};if(!isFinite(r.xMin)){r.xMin=0}if(!isFinite(r.xMax)){r.xMax=this.advanceWidth}if(!isFinite(r.yMin)){r.yMin=0}if(!isFinite(r.yMax)){r.yMax=0}r.rightSideBearing=this.advanceWidth-r.leftSideBearing-(r.xMax-r.xMin);return r};f.prototype.draw=function(e,t,n,a,i){this.getPath(t,n,a,i).draw(e)};f.prototype.drawPoints=function(r,e,t,n){function a(e,t,n,a){r.beginPath();for(var i=0;i<e.length;i+=1){r.moveTo(t+e[i].x*a,n+e[i].y*a);r.arc(t+e[i].x*a,n+e[i].y*a,2,0,Math.PI*2,false)}r.closePath();r.fill()}e=e!==undefined?e:0;t=t!==undefined?t:0;n=n!==undefined?n:24;var i=1/this.path.unitsPerEm*n;var s=[];var o=[];var l=this.path;for(var u=0;u<l.commands.length;u+=1){var m=l.commands[u];if(m.x!==undefined){s.push({x:m.x,y:-m.y})}if(m.x1!==undefined){o.push({x:m.x1,y:-m.y1})}if(m.x2!==undefined){o.push({x:m.x2,y:-m.y2})}}r.fillStyle="blue";a(s,e,t,i);r.fillStyle="red";a(o,e,t,i)};f.prototype.drawMetrics=function(e,t,n,a){var i;t=t!==undefined?t:0;n=n!==undefined?n:0;a=a!==undefined?a:24;i=1/this.path.unitsPerEm*a;e.lineWidth=1;e.strokeStyle="black";p.line(e,t,-1e4,t,1e4);p.line(e,-1e4,n,1e4,n);var r=this.xMin||0;var s=this.yMin||0;var o=this.xMax||0;var l=this.yMax||0;var u=this.advanceWidth||0;e.strokeStyle="blue";p.line(e,t+r*i,-1e4,t+r*i,1e4);p.line(e,t+o*i,-1e4,t+o*i,1e4);p.line(e,-1e4,n+-s*i,1e4,n+-s*i);p.line(e,-1e4,n+-l*i,1e4,n+-l*i);e.strokeStyle="green";p.line(e,t+u*i,-1e4,t+u*i,1e4)};function at(t,e,n){Object.defineProperty(t,e,{get:function(){t.path;return t[n]},set:function(e){t[n]=e},enumerable:true,configurable:true})}function it(e,t){this.font=e;this.glyphs={};if(Array.isArray(t)){for(var n=0;n<t.length;n++){var a=t[n];a.path.unitsPerEm=e.unitsPerEm;this.glyphs[n]=a}}this.length=t&&t.length||0}it.prototype.get=function(e){if(this.glyphs[e]===undefined){this.font._push(e);if(typeof this.glyphs[e]==="function"){this.glyphs[e]=this.glyphs[e]()}var t=this.glyphs[e];var n=this.font._IndexToUnicodeMap[e];if(n){for(var a=0;a<n.unicodes.length;a++){t.addUnicode(n.unicodes[a])}}if(this.font.cffEncoding){if(this.font.isCIDFont){t.name="gid"+e}else{t.name=this.font.cffEncoding.charset[e]}}else if(this.font.glyphNames.names){t.name=this.font.glyphNames.glyphIndexToName(e)}this.glyphs[e].advanceWidth=this.font._hmtxTableData[e].advanceWidth;this.glyphs[e].leftSideBearing=this.font._hmtxTableData[e].leftSideBearing}else{if(typeof this.glyphs[e]==="function"){this.glyphs[e]=this.glyphs[e]()}}return this.glyphs[e]};it.prototype.push=function(e,t){this.glyphs[e]=t;this.length++};function rt(e,t){return new f({index:t,font:e})}function st(n,e,a,i,r,s){return function(){var t=new f({index:e,font:n});t.path=function(){a(t,i,r);var e=s(n.glyphs,t);e.unitsPerEm=n.unitsPerEm;return e};at(t,"xMin","_xMin");at(t,"xMax","_xMax");at(t,"yMin","_yMin");at(t,"yMax","_yMax");return t}}function ot(n,e,a,i){return function(){var t=new f({index:e,font:n});t.path=function(){var e=a(n,t,i);e.unitsPerEm=n.unitsPerEm;return e};return t}}var y={GlyphSet:it,glyphLoader:rt,ttfGlyphLoader:st,cffGlyphLoader:ot};function lt(e,t){if(e===t){return true}else if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length){return false}for(var n=0;n<e.length;n+=1){if(!lt(e[n],t[n])){return false}}return true}else{return false}}function ut(e){var t;if(e.length<1240){t=107}else if(e.length<33900){t=1131}else{t=32768}return t}function S(e,t,n){var a=[];var i=[];var r=G.getCard16(e,t);var s;var o;if(r!==0){var l=G.getByte(e,t+2);s=t+(r+1)*l+2;var u=t+3;for(var m=0;m<r+1;m+=1){a.push(G.getOffset(e,u,l));u+=l}o=s+a[r]}else{o=t+2}for(var p=0;p<a.length-1;p+=1){var c=G.getBytes(e,s+a[p],s+a[p+1]);if(n){c=n(c)}i.push(c)}return{objects:i,startOffset:t,endOffset:o}}function mt(e,t){var n=[];var a=G.getCard16(e,t);var i;var r;if(a!==0){var s=G.getByte(e,t+2);i=t+(a+1)*s+2;var o=t+3;for(var l=0;l<a+1;l+=1){n.push(G.getOffset(e,o,s));o+=s}r=i+n[a]}else{r=t+2}return{offsets:n,startOffset:t,endOffset:r}}function pt(e,t,n,a,i){var r=G.getCard16(n,a);var s=0;if(r!==0){var o=G.getByte(n,a+2);s=a+(r+1)*o+2}var l=G.getBytes(n,s+t[e],s+t[e+1]);if(i){l=i(l)}return l}function ct(e){var t="";var n=15;var a=["0","1","2","3","4","5","6","7","8","9",".","E","E-",null,"-"];while(true){var i=e.parseByte();var r=i>>4;var s=i&15;if(r===n){break}t+=a[r];if(s===n){break}t+=a[s]}return parseFloat(t)}function dt(e,t){var n;var a;var i;var r;if(t===28){n=e.parseByte();a=e.parseByte();return n<<8|a}if(t===29){n=e.parseByte();a=e.parseByte();i=e.parseByte();r=e.parseByte();return n<<24|a<<16|i<<8|r}if(t===30){return ct(e)}if(t>=32&&t<=246){return t-139}if(t>=247&&t<=250){n=e.parseByte();return(t-247)*256+n+108}if(t>=251&&t<=254){n=e.parseByte();return-(t-251)*256-n-108}throw new Error("Invalid b0 "+t)}function ht(e){var t={};for(var n=0;n<e.length;n+=1){var a=e[n][0];var i=e[n][1];var r=void 0;if(i.length===1){r=i[0]}else{r=i}if(t.hasOwnProperty(a)&&!isNaN(t[a])){throw new Error("Object "+t+" already has key "+a)}t[a]=r}return t}function ft(e,t,n){t=t!==undefined?t:0;var a=new G.Parser(e,t);var i=[];var r=[];n=n!==undefined?n:e.length;while(a.relativeOffset<n){var s=a.parseByte();if(s<=21){if(s===12){s=1200+a.parseByte()}i.push([s,r]);r=[]}else{r.push(dt(a,s))}}return ht(i)}function vt(e,t){if(t<=390){t=qe[t]}else{t=e[t-391]}return t}function gt(e,t,n){var a={};var i;for(var r=0;r<t.length;r+=1){var s=t[r];if(Array.isArray(s.type)){var o=[];o.length=s.type.length;for(var l=0;l<s.type.length;l++){i=e[s.op]!==undefined?e[s.op][l]:undefined;if(i===undefined){i=s.value!==undefined&&s.value[l]!==undefined?s.value[l]:null}if(s.type[l]==="SID"){i=vt(n,i)}o[l]=i}a[s.name]=o}else{i=e[s.op];if(i===undefined){i=s.value!==undefined?s.value:null}if(s.type==="SID"){i=vt(n,i)}a[s.name]=i}}return a}function bt(e,t){var n={};n.formatMajor=G.getCard8(e,t);n.formatMinor=G.getCard8(e,t+1);n.size=G.getCard8(e,t+2);n.offsetSize=G.getCard8(e,t+3);n.startOffset=t;n.endOffset=t+4;return n}var xt=[{name:"version",op:0,type:"SID"},{name:"notice",op:1,type:"SID"},{name:"copyright",op:1200,type:"SID"},{name:"fullName",op:2,type:"SID"},{name:"familyName",op:3,type:"SID"},{name:"weight",op:4,type:"SID"},{name:"isFixedPitch",op:1201,type:"number",value:0},{name:"italicAngle",op:1202,type:"number",value:0},{name:"underlinePosition",op:1203,type:"number",value:-100},{name:"underlineThickness",op:1204,type:"number",value:50},{name:"paintType",op:1205,type:"number",value:0},{name:"charstringType",op:1206,type:"number",value:2},{name:"fontMatrix",op:1207,type:["real","real","real","real","real","real"],value:[.001,0,0,.001,0,0]},{name:"uniqueId",op:13,type:"number"},{name:"fontBBox",op:5,type:["number","number","number","number"],value:[0,0,0,0]},{name:"strokeWidth",op:1208,type:"number",value:0},{name:"xuid",op:14,type:[],value:null},{name:"charset",op:15,type:"offset",value:0},{name:"encoding",op:16,type:"offset",value:0},{name:"charStrings",op:17,type:"offset",value:0},{name:"private",op:18,type:["number","offset"],value:[0,0]},{name:"ros",op:1230,type:["SID","SID","number"]},{name:"cidFontVersion",op:1231,type:"number",value:0},{name:"cidFontRevision",op:1232,type:"number",value:0},{name:"cidFontType",op:1233,type:"number",value:0},{name:"cidCount",op:1234,type:"number",value:8720},{name:"uidBase",op:1235,type:"number"},{name:"fdArray",op:1236,type:"offset"},{name:"fdSelect",op:1237,type:"offset"},{name:"fontName",op:1238,type:"SID"}];var Ot=[{name:"subrs",op:19,type:"offset",value:0},{name:"defaultWidthX",op:20,type:"number",value:0},{name:"nominalWidthX",op:21,type:"number",value:0}];function _t(e,t){var n=ft(e,0,e.byteLength);return gt(n,xt,t)}function Tt(e,t,n,a){var i=ft(e,t,n);return gt(i,Ot,a)}function It(e,t,n,a){var i=[];for(var r=0;r<n.length;r+=1){var s=new DataView(new Uint8Array(n[r]).buffer);var o=_t(s,a);o._subrs=[];o._subrsBias=0;o._defaultWidthX=0;o._nominalWidthX=0;var l=o.private[0];var u=o.private[1];if(l!==0&&u!==0){var m=Tt(e,u+t,l,a);o._defaultWidthX=m.defaultWidthX;o._nominalWidthX=m.nominalWidthX;if(m.subrs!==0){var p=u+m.subrs;var c=S(e,p+t);o._subrs=c.objects;o._subrsBias=ut(o._subrs)}o._privateDict=m}i.push(o)}return i}function yt(e,t,n,a){var i;var r;var s=new G.Parser(e,t);n-=1;var o=[".notdef"];var l=s.parseCard8();if(l===0){for(var u=0;u<n;u+=1){i=s.parseSID();o.push(vt(a,i))}}else if(l===1){while(o.length<=n){i=s.parseSID();r=s.parseCard8();for(var m=0;m<=r;m+=1){o.push(vt(a,i));i+=1}}}else if(l===2){while(o.length<=n){i=s.parseSID();r=s.parseCard16();for(var p=0;p<=r;p+=1){o.push(vt(a,i));i+=1}}}else{throw new Error("Unknown charset format "+l)}return o}function At(e,t,n){var a;var i={};var r=new G.Parser(e,t);var s=r.parseCard8();if(s===0){var o=r.parseCard8();for(var l=0;l<o;l+=1){a=r.parseCard8();i[a]=l}}else if(s===1){var u=r.parseCard8();a=1;for(var m=0;m<u;m+=1){var p=r.parseCard8();var c=r.parseCard8();for(var d=p;d<=p+c;d+=1){i[d]=a;a+=1}}}else{throw new Error("Unknown encoding format "+s)}return new Ke(i,n)}function St(f,v,e){var g;var b;var x;var O;var _=new h;var T=[];var I=0;var y=false;var A=false;var S=0;var E=0;var C;var j;var t;var N;if(f.isCIDFont){var n=f.tables.cff.topDict._fdSelect[v.index];var a=f.tables.cff.topDict._fdArray[n];C=a._subrs;j=a._subrsBias;t=a._defaultWidthX;N=a._nominalWidthX}else{C=f.tables.cff.topDict._subrs;j=f.tables.cff.topDict._subrsBias;t=f.tables.cff.topDict._defaultWidthX;N=f.tables.cff.topDict._nominalWidthX}var L=t;function M(e,t){if(A){_.closePath()}_.moveTo(e,t);A=true}function R(){var e;e=T.length%2!==0;if(e&&!y){L=T.shift()+N}I+=T.length>>1;T.length=0;y=true}function P(e){var t;var n;var a;var i;var r;var s;var o;var l;var u;var m;var p;var c;var d=0;while(d<e.length){var h=e[d];d+=1;switch(h){case 1:R();break;case 3:R();break;case 4:if(T.length>1&&!y){L=T.shift()+N;y=true}E+=T.pop();M(S,E);break;case 5:while(T.length>0){S+=T.shift();E+=T.shift();_.lineTo(S,E)}break;case 6:while(T.length>0){S+=T.shift();_.lineTo(S,E);if(T.length===0){break}E+=T.shift();_.lineTo(S,E)}break;case 7:while(T.length>0){E+=T.shift();_.lineTo(S,E);if(T.length===0){break}S+=T.shift();_.lineTo(S,E)}break;case 8:while(T.length>0){g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O+T.shift();_.curveTo(g,b,x,O,S,E)}break;case 10:r=T.pop()+j;s=C[r];if(s){P(s)}break;case 11:return;case 12:h=e[d];d+=1;switch(h){case 35:g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();o=x+T.shift();l=O+T.shift();u=o+T.shift();m=l+T.shift();p=u+T.shift();c=m+T.shift();S=p+T.shift();E=c+T.shift();T.shift();_.curveTo(g,b,x,O,o,l);_.curveTo(u,m,p,c,S,E);break;case 34:g=S+T.shift();b=E;x=g+T.shift();O=b+T.shift();o=x+T.shift();l=O;u=o+T.shift();m=O;p=u+T.shift();c=E;S=p+T.shift();_.curveTo(g,b,x,O,o,l);_.curveTo(u,m,p,c,S,E);break;case 36:g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();o=x+T.shift();l=O;u=o+T.shift();m=O;p=u+T.shift();c=m+T.shift();S=p+T.shift();_.curveTo(g,b,x,O,o,l);_.curveTo(u,m,p,c,S,E);break;case 37:g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();o=x+T.shift();l=O+T.shift();u=o+T.shift();m=l+T.shift();p=u+T.shift();c=m+T.shift();if(Math.abs(p-S)>Math.abs(c-E)){S=p+T.shift()}else{E=c+T.shift()}_.curveTo(g,b,x,O,o,l);_.curveTo(u,m,p,c,S,E);break;default:console.log("Glyph "+v.index+": unknown operator "+1200+h);T.length=0}break;case 14:if(T.length>0&&!y){L=T.shift()+N;y=true}if(A){_.closePath();A=false}break;case 18:R();break;case 19:case 20:R();d+=I+7>>3;break;case 21:if(T.length>2&&!y){L=T.shift()+N;y=true}E+=T.pop();S+=T.pop();M(S,E);break;case 22:if(T.length>1&&!y){L=T.shift()+N;y=true}S+=T.pop();M(S,E);break;case 23:R();break;case 24:while(T.length>2){g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O+T.shift();_.curveTo(g,b,x,O,S,E)}S+=T.shift();E+=T.shift();_.lineTo(S,E);break;case 25:while(T.length>6){S+=T.shift();E+=T.shift();_.lineTo(S,E)}g=S+T.shift();b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O+T.shift();_.curveTo(g,b,x,O,S,E);break;case 26:if(T.length%2){S+=T.shift()}while(T.length>0){g=S;b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x;E=O+T.shift();_.curveTo(g,b,x,O,S,E)}break;case 27:if(T.length%2){E+=T.shift()}while(T.length>0){g=S+T.shift();b=E;x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O;_.curveTo(g,b,x,O,S,E)}break;case 28:t=e[d];n=e[d+1];T.push((t<<24|n<<16)>>16);d+=2;break;case 29:r=T.pop()+f.gsubrsBias;s=f.gsubrs[r];if(s){P(s)}break;case 30:while(T.length>0){g=S;b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O+(T.length===1?T.shift():0);_.curveTo(g,b,x,O,S,E);if(T.length===0){break}g=S+T.shift();b=E;x=g+T.shift();O=b+T.shift();E=O+T.shift();S=x+(T.length===1?T.shift():0);_.curveTo(g,b,x,O,S,E)}break;case 31:while(T.length>0){g=S+T.shift();b=E;x=g+T.shift();O=b+T.shift();E=O+T.shift();S=x+(T.length===1?T.shift():0);_.curveTo(g,b,x,O,S,E);if(T.length===0){break}g=S;b=E+T.shift();x=g+T.shift();O=b+T.shift();S=x+T.shift();E=O+(T.length===1?T.shift():0);_.curveTo(g,b,x,O,S,E)}break;default:if(h<32){console.log("Glyph "+v.index+": unknown operator "+h)}else if(h<247){T.push(h-139)}else if(h<251){t=e[d];d+=1;T.push((h-247)*256+t+108)}else if(h<255){t=e[d];d+=1;T.push(-(h-251)*256-t-108)}else{t=e[d];n=e[d+1];a=e[d+2];i=e[d+3];d+=4;T.push((t<<24|n<<16|a<<8|i)/65536)}}}}P(e);v.advanceWidth=L;return _}function Et(e,t,n,a){var i=[];var r;var s=new G.Parser(e,t);var o=s.parseCard8();if(o===0){for(var l=0;l<n;l++){r=s.parseCard8();if(r>=a){throw new Error("CFF table CID Font FDSelect has bad FD index value "+r+" (FD count "+a+")")}i.push(r)}}else if(o===3){var u=s.parseCard16();var m=s.parseCard16();if(m!==0){throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID "+m)}var p;for(var c=0;c<u;c++){r=s.parseCard8();p=s.parseCard16();if(r>=a){throw new Error("CFF table CID Font FDSelect has bad FD index value "+r+" (FD count "+a+")")}if(p>n){throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID "+p)}for(;m<p;m++){i.push(r)}m=p}if(p!==n){throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID "+p)}}else{throw new Error("CFF Table CID Font FDSelect table has unsupported format "+o)}return i}function Ct(n,a,i,e){i.tables.cff={};var t=bt(n,a);var r=S(n,t.endOffset,G.bytesToString);var s=S(n,r.endOffset);var o=S(n,s.endOffset,G.bytesToString);var l=S(n,o.endOffset);i.gsubrs=l.objects;i.gsubrsBias=ut(i.gsubrs);var u=It(n,a,s.objects,o.objects);if(u.length!==1){throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = "+u.length)}var m=u[0];i.tables.cff.topDict=m;if(m._privateDict){i.defaultWidthX=m._privateDict.defaultWidthX;i.nominalWidthX=m._privateDict.nominalWidthX}if(m.ros[0]!==undefined&&m.ros[1]!==undefined){i.isCIDFont=true}if(i.isCIDFont){var p=m.fdArray;var c=m.fdSelect;if(p===0||c===0){throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing")}p+=a;var d=S(n,p);var h=It(n,a,d.objects,o.objects);m._fdArray=h;c+=a;m._fdSelect=Et(n,c,i.numGlyphs,h.length)}var f=a+m.private[1];var v=Tt(n,f,m.private[0],o.objects);i.defaultWidthX=v.defaultWidthX;i.nominalWidthX=v.nominalWidthX;if(v.subrs!==0){var g=f+v.subrs;var b=S(n,g);i.subrs=b.objects;i.subrsBias=ut(i.subrs)}else{i.subrs=[];i.subrsBias=0}var x;if(e.lowMemory){x=mt(n,a+m.charStrings);i.nGlyphs=x.offsets.length}else{x=S(n,a+m.charStrings);i.nGlyphs=x.objects.length}var O=yt(n,a+m.charset,i.nGlyphs,o.objects);if(m.encoding===0){i.cffEncoding=new Ke(He,O)}else if(m.encoding===1){i.cffEncoding=new Ke(Ye,O)}else{i.cffEncoding=At(n,a+m.encoding,O)}i.encoding=i.encoding||i.cffEncoding;i.glyphs=new y.GlyphSet(i);if(e.lowMemory){i._push=function(e){var t=pt(e,x.offsets,n,a+m.charStrings);i.glyphs.push(e,y.cffGlyphLoader(i,e,St,t))}}else{for(var _=0;_<i.nGlyphs;_+=1){var T=x.objects[_];i.glyphs.push(_,y.cffGlyphLoader(i,_,St,T))}}}function jt(e,t){var n;var a=qe.indexOf(e);if(a>=0){n=a}a=t.indexOf(e);if(a>=0){n=a+qe.length}else{n=qe.length+t.length;t.push(e)}return n}function Nt(){return new C.Record("Header",[{name:"major",type:"Card8",value:1},{name:"minor",type:"Card8",value:0},{name:"hdrSize",type:"Card8",value:4},{name:"major",type:"Card8",value:1}])}function Lt(e){var t=new C.Record("Name INDEX",[{name:"names",type:"INDEX",value:[]}]);t.names=[];for(var n=0;n<e.length;n+=1){t.names.push({name:"name_"+n,type:"NAME",value:e[n]})}return t}function Mt(e,t,n){var a={};for(var i=0;i<e.length;i+=1){var r=e[i];var s=t[r.name];if(s!==undefined&&!lt(s,r.value)){if(r.type==="SID"){s=jt(s,n)}a[r.op]={name:r.name,type:r.type,value:s}}}return a}function Rt(e,t){var n=new C.Record("Top DICT",[{name:"dict",type:"DICT",value:{}}]);n.dict=Mt(xt,e,t);return n}function Pt(e){var t=new C.Record("Top DICT INDEX",[{name:"topDicts",type:"INDEX",value:[]}]);t.topDicts=[{name:"topDict_0",type:"TABLE",value:e}];return t}function wt(e){var t=new C.Record("String INDEX",[{name:"strings",type:"INDEX",value:[]}]);t.strings=[];for(var n=0;n<e.length;n+=1){t.strings.push({name:"string_"+n,type:"STRING",value:e[n]})}return t}function kt(){return new C.Record("Global Subr INDEX",[{name:"subrs",type:"INDEX",value:[]}])}function Ft(e,t){var n=new C.Record("Charsets",[{name:"format",type:"Card8",value:0}]);for(var a=0;a<e.length;a+=1){var i=e[a];var r=jt(i,t);n.fields.push({name:"glyph_"+a,type:"SID",value:r})}return n}function Gt(e){var t=[];var n=e.path;t.push({name:"width",type:"NUMBER",value:e.advanceWidth});var a=0;var i=0;for(var r=0;r<n.commands.length;r+=1){var s=void 0;var o=void 0;var l=n.commands[r];if(l.type==="Q"){var u=1/3;var m=2/3;l={type:"C",x:l.x,y:l.y,x1:Math.round(u*a+m*l.x1),y1:Math.round(u*i+m*l.y1),x2:Math.round(u*l.x+m*l.x1),y2:Math.round(u*l.y+m*l.y1)}}if(l.type==="M"){s=Math.round(l.x-a);o=Math.round(l.y-i);t.push({name:"dx",type:"NUMBER",value:s});t.push({name:"dy",type:"NUMBER",value:o});t.push({name:"rmoveto",type:"OP",value:21});a=Math.round(l.x);i=Math.round(l.y)}else if(l.type==="L"){s=Math.round(l.x-a);o=Math.round(l.y-i);t.push({name:"dx",type:"NUMBER",value:s});t.push({name:"dy",type:"NUMBER",value:o});t.push({name:"rlineto",type:"OP",value:5});a=Math.round(l.x);i=Math.round(l.y)}else if(l.type==="C"){var p=Math.round(l.x1-a);var c=Math.round(l.y1-i);var d=Math.round(l.x2-l.x1);var h=Math.round(l.y2-l.y1);s=Math.round(l.x-l.x2);o=Math.round(l.y-l.y2);t.push({name:"dx1",type:"NUMBER",value:p});t.push({name:"dy1",type:"NUMBER",value:c});t.push({name:"dx2",type:"NUMBER",value:d});t.push({name:"dy2",type:"NUMBER",value:h});t.push({name:"dx",type:"NUMBER",value:s});t.push({name:"dy",type:"NUMBER",value:o});t.push({name:"rrcurveto",type:"OP",value:8});a=Math.round(l.x);i=Math.round(l.y)}}t.push({name:"endchar",type:"OP",value:14});return t}function Ut(e){var t=new C.Record("CharStrings INDEX",[{name:"charStrings",type:"INDEX",value:[]}]);for(var n=0;n<e.length;n+=1){var a=e.get(n);var i=Gt(a);t.charStrings.push({name:a.name,type:"CHARSTRING",value:i})}return t}function Bt(e,t){var n=new C.Record("Private DICT",[{name:"dict",type:"DICT",value:{}}]);n.dict=Mt(Ot,e,t);return n}function Dt(e,t){var n=new C.Table("CFF ",[{name:"header",type:"RECORD"},{name:"nameIndex",type:"RECORD"},{name:"topDictIndex",type:"RECORD"},{name:"stringIndex",type:"RECORD"},{name:"globalSubrIndex",type:"RECORD"},{name:"charsets",type:"RECORD"},{name:"charStringsIndex",type:"RECORD"},{name:"privateDict",type:"RECORD"}]);var a=1/t.unitsPerEm;var i={version:t.version,fullName:t.fullName,familyName:t.familyName,weight:t.weightName,fontBBox:t.fontBBox||[0,0,0,0],fontMatrix:[a,0,0,a,0,0],charset:999,encoding:0,charStrings:999,private:[0,999]};var r={};var s=[];var o;for(var l=1;l<e.length;l+=1){o=e.get(l);s.push(o.name)}var u=[];n.header=Nt();n.nameIndex=Lt([t.postScriptName]);var m=Rt(i,u);n.topDictIndex=Pt(m);n.globalSubrIndex=kt();n.charsets=Ft(s,u);n.charStringsIndex=Ut(e);n.privateDict=Bt(r,u);n.stringIndex=wt(u);var p=n.header.sizeOf()+n.nameIndex.sizeOf()+n.topDictIndex.sizeOf()+n.stringIndex.sizeOf()+n.globalSubrIndex.sizeOf();i.charset=p;i.encoding=0;i.charStrings=i.charset+n.charsets.sizeOf();i.private[1]=i.charStrings+n.charStringsIndex.sizeOf();m=Rt(i,u);n.topDictIndex=Pt(m);return n}var Vt={parse:Ct,make:Dt};function zt(e,t){var n={};var a=new G.Parser(e,t);n.version=a.parseVersion();n.fontRevision=Math.round(a.parseFixed()*1e3)/1e3;n.checkSumAdjustment=a.parseULong();n.magicNumber=a.parseULong();I.argument(n.magicNumber===1594834165,"Font header has wrong magic number.");n.flags=a.parseUShort();n.unitsPerEm=a.parseUShort();n.created=a.parseLongDateTime();n.modified=a.parseLongDateTime();n.xMin=a.parseShort();n.yMin=a.parseShort();n.xMax=a.parseShort();n.yMax=a.parseShort();n.macStyle=a.parseUShort();n.lowestRecPPEM=a.parseUShort();n.fontDirectionHint=a.parseShort();n.indexToLocFormat=a.parseShort();n.glyphDataFormat=a.parseShort();return n}function Xt(e){var t=Math.round((new Date).getTime()/1e3)+2082844800;var n=t;if(e.createdTimestamp){n=e.createdTimestamp+2082844800}return new C.Table("head",[{name:"version",type:"FIXED",value:65536},{name:"fontRevision",type:"FIXED",value:65536},{name:"checkSumAdjustment",type:"ULONG",value:0},{name:"magicNumber",type:"ULONG",value:1594834165},{name:"flags",type:"USHORT",value:0},{name:"unitsPerEm",type:"USHORT",value:1e3},{name:"created",type:"LONGDATETIME",value:n},{name:"modified",type:"LONGDATETIME",value:t},{name:"xMin",type:"SHORT",value:0},{name:"yMin",type:"SHORT",value:0},{name:"xMax",type:"SHORT",value:0},{name:"yMax",type:"SHORT",value:0},{name:"macStyle",type:"USHORT",value:0},{name:"lowestRecPPEM",type:"USHORT",value:0},{name:"fontDirectionHint",type:"SHORT",value:2},{name:"indexToLocFormat",type:"SHORT",value:0},{name:"glyphDataFormat",type:"SHORT",value:0}],e)}var qt={parse:zt,make:Xt};function Ht(e,t){var n={};var a=new G.Parser(e,t);n.version=a.parseVersion();n.ascender=a.parseShort();n.descender=a.parseShort();n.lineGap=a.parseShort();n.advanceWidthMax=a.parseUShort();n.minLeftSideBearing=a.parseShort();n.minRightSideBearing=a.parseShort();n.xMaxExtent=a.parseShort();n.caretSlopeRise=a.parseShort();n.caretSlopeRun=a.parseShort();n.caretOffset=a.parseShort();a.relativeOffset+=8;n.metricDataFormat=a.parseShort();n.numberOfHMetrics=a.parseUShort();return n}function Yt(e){return new C.Table("hhea",[{name:"version",type:"FIXED",value:65536},{name:"ascender",type:"FWORD",value:0},{name:"descender",type:"FWORD",value:0},{name:"lineGap",type:"FWORD",value:0},{name:"advanceWidthMax",type:"UFWORD",value:0},{name:"minLeftSideBearing",type:"FWORD",value:0},{name:"minRightSideBearing",type:"FWORD",value:0},{name:"xMaxExtent",type:"FWORD",value:0},{name:"caretSlopeRise",type:"SHORT",value:1},{name:"caretSlopeRun",type:"SHORT",value:0},{name:"caretOffset",type:"SHORT",value:0},{name:"reserved1",type:"SHORT",value:0},{name:"reserved2",type:"SHORT",value:0},{name:"reserved3",type:"SHORT",value:0},{name:"reserved4",type:"SHORT",value:0},{name:"metricDataFormat",type:"SHORT",value:0},{name:"numberOfHMetrics",type:"USHORT",value:0}],e)}var Wt={parse:Ht,make:Yt};function Zt(e,t,n,a,i){var r;var s;var o=new G.Parser(e,t);for(var l=0;l<a;l+=1){if(l<n){r=o.parseUShort();s=o.parseShort()}var u=i.get(l);u.advanceWidth=r;u.leftSideBearing=s}}function Kt(e,t,n,a,i){e._hmtxTableData={};var r;var s;var o=new G.Parser(t,n);for(var l=0;l<i;l+=1){if(l<a){r=o.parseUShort();s=o.parseShort()}e._hmtxTableData[l]={advanceWidth:r,leftSideBearing:s}}}function Jt(e,t,n,a,i,r,s){if(s.lowMemory){Kt(e,t,n,a,i)}else{Zt(t,n,a,i,r)}}function Qt(e){var t=new C.Table("hmtx",[]);for(var n=0;n<e.length;n+=1){var a=e.get(n);var i=a.advanceWidth||0;var r=a.leftSideBearing||0;t.fields.push({name:"advanceWidth_"+n,type:"USHORT",value:i});t.fields.push({name:"leftSideBearing_"+n,type:"SHORT",value:r})}return t}var $t={parse:Jt,make:Qt};function en(e){var t=new C.Table("ltag",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"numTags",type:"ULONG",value:e.length}]);var n="";var a=12+e.length*4;for(var i=0;i<e.length;++i){var r=n.indexOf(e[i]);if(r<0){r=n.length;n+=e[i]}t.fields.push({name:"offset "+i,type:"USHORT",value:a+r});t.fields.push({name:"length "+i,type:"USHORT",value:e[i].length})}t.fields.push({name:"stringPool",type:"CHARARRAY",value:n});return t}function tn(e,t){var n=new G.Parser(e,t);var a=n.parseULong();I.argument(a===1,"Unsupported ltag table version.");n.skip("uLong",1);var i=n.parseULong();var r=[];for(var s=0;s<i;s++){var o="";var l=t+n.parseUShort();var u=n.parseUShort();for(var m=l;m<l+u;++m){o+=String.fromCharCode(e.getInt8(m))}r.push(o)}return r}var nn={make:en,parse:tn};function an(e,t){var n={};var a=new G.Parser(e,t);n.version=a.parseVersion();n.numGlyphs=a.parseUShort();if(n.version===1){n.maxPoints=a.parseUShort();n.maxContours=a.parseUShort();n.maxCompositePoints=a.parseUShort();n.maxCompositeContours=a.parseUShort();n.maxZones=a.parseUShort();n.maxTwilightPoints=a.parseUShort();n.maxStorage=a.parseUShort();n.maxFunctionDefs=a.parseUShort();n.maxInstructionDefs=a.parseUShort();n.maxStackElements=a.parseUShort();n.maxSizeOfInstructions=a.parseUShort();n.maxComponentElements=a.parseUShort();n.maxComponentDepth=a.parseUShort()}return n}function rn(e){return new C.Table("maxp",[{name:"version",type:"FIXED",value:20480},{name:"numGlyphs",type:"USHORT",value:e}])}var sn={parse:an,make:rn};var on=["copyright","fontFamily","fontSubfamily","uniqueID","fullName","version","postScriptName","trademark","manufacturer","designer","description","manufacturerURL","designerURL","license","licenseURL","reserved","preferredFamily","preferredSubfamily","compatibleFullName","sampleText","postScriptFindFontName","wwsFamily","wwsSubfamily"];var ln={0:"en",1:"fr",2:"de",3:"it",4:"nl",5:"sv",6:"es",7:"da",8:"pt",9:"no",10:"he",11:"ja",12:"ar",13:"fi",14:"el",15:"is",16:"mt",17:"tr",18:"hr",19:"zh-Hant",20:"ur",21:"hi",22:"th",23:"ko",24:"lt",25:"pl",26:"hu",27:"es",28:"lv",29:"se",30:"fo",31:"fa",32:"ru",33:"zh",34:"nl-BE",35:"ga",36:"sq",37:"ro",38:"cz",39:"sk",40:"si",41:"yi",42:"sr",43:"mk",44:"bg",45:"uk",46:"be",47:"uz",48:"kk",49:"az-Cyrl",50:"az-Arab",51:"hy",52:"ka",53:"mo",54:"ky",55:"tg",56:"tk",57:"mn-CN",58:"mn",59:"ps",60:"ks",61:"ku",62:"sd",63:"bo",64:"ne",65:"sa",66:"mr",67:"bn",68:"as",69:"gu",70:"pa",71:"or",72:"ml",73:"kn",74:"ta",75:"te",76:"si",77:"my",78:"km",79:"lo",80:"vi",81:"id",82:"tl",83:"ms",84:"ms-Arab",85:"am",86:"ti",87:"om",88:"so",89:"sw",90:"rw",91:"rn",92:"ny",93:"mg",94:"eo",128:"cy",129:"eu",130:"ca",131:"la",132:"qu",133:"gn",134:"ay",135:"tt",136:"ug",137:"dz",138:"jv",139:"su",140:"gl",141:"af",142:"br",143:"iu",144:"gd",145:"gv",146:"ga",147:"to",148:"el-polyton",149:"kl",150:"az",151:"nn"};var un={0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:5,11:1,12:4,13:0,14:6,15:0,16:0,17:0,18:0,19:2,20:4,21:9,22:21,23:3,24:29,25:29,26:29,27:29,28:29,29:0,30:0,31:4,32:7,33:25,34:0,35:0,36:0,37:0,38:29,39:29,40:0,41:5,42:7,43:7,44:7,45:7,46:7,47:7,48:7,49:7,50:4,51:24,52:23,53:7,54:7,55:7,56:7,57:27,58:7,59:4,60:4,61:4,62:4,63:26,64:9,65:9,66:9,67:13,68:13,69:11,70:10,71:12,72:17,73:16,74:14,75:15,76:18,77:19,78:20,79:22,80:30,81:0,82:0,83:0,84:4,85:28,86:28,87:28,88:0,89:0,90:0,91:0,92:0,93:0,94:0,128:0,129:0,130:0,131:0,132:0,133:0,134:0,135:7,136:4,137:26,138:0,139:0,140:0,141:0,142:0,143:28,144:0,145:0,146:0,147:0,148:6,149:0,150:0,151:0};var mn={1078:"af",1052:"sq",1156:"gsw",1118:"am",5121:"ar-DZ",15361:"ar-BH",3073:"ar",2049:"ar-IQ",11265:"ar-JO",13313:"ar-KW",12289:"ar-LB",4097:"ar-LY",6145:"ary",8193:"ar-OM",16385:"ar-QA",1025:"ar-SA",10241:"ar-SY",7169:"aeb",14337:"ar-AE",9217:"ar-YE",1067:"hy",1101:"as",2092:"az-Cyrl",1068:"az",1133:"ba",1069:"eu",1059:"be",2117:"bn",1093:"bn-IN",8218:"bs-Cyrl",5146:"bs",1150:"br",1026:"bg",1027:"ca",3076:"zh-HK",5124:"zh-MO",2052:"zh",4100:"zh-SG",1028:"zh-TW",1155:"co",1050:"hr",4122:"hr-BA",1029:"cs",1030:"da",1164:"prs",1125:"dv",2067:"nl-BE",1043:"nl",3081:"en-AU",10249:"en-BZ",4105:"en-CA",9225:"en-029",16393:"en-IN",6153:"en-IE",8201:"en-JM",17417:"en-MY",5129:"en-NZ",13321:"en-PH",18441:"en-SG",7177:"en-ZA",11273:"en-TT",2057:"en-GB",1033:"en",12297:"en-ZW",1061:"et",1080:"fo",1124:"fil",1035:"fi",2060:"fr-BE",3084:"fr-CA",1036:"fr",5132:"fr-LU",6156:"fr-MC",4108:"fr-CH",1122:"fy",1110:"gl",1079:"ka",3079:"de-AT",1031:"de",5127:"de-LI",4103:"de-LU",2055:"de-CH",1032:"el",1135:"kl",1095:"gu",1128:"ha",1037:"he",1081:"hi",1038:"hu",1039:"is",1136:"ig",1057:"id",1117:"iu",2141:"iu-Latn",2108:"ga",1076:"xh",1077:"zu",1040:"it",2064:"it-CH",1041:"ja",1099:"kn",1087:"kk",1107:"km",1158:"quc",1159:"rw",1089:"sw",1111:"kok",1042:"ko",1088:"ky",1108:"lo",1062:"lv",1063:"lt",2094:"dsb",1134:"lb",1071:"mk",2110:"ms-BN",1086:"ms",1100:"ml",1082:"mt",1153:"mi",1146:"arn",1102:"mr",1148:"moh",1104:"mn",2128:"mn-CN",1121:"ne",1044:"nb",2068:"nn",1154:"oc",1096:"or",1123:"ps",1045:"pl",1046:"pt",2070:"pt-PT",1094:"pa",1131:"qu-BO",2155:"qu-EC",3179:"qu",1048:"ro",1047:"rm",1049:"ru",9275:"smn",4155:"smj-NO",5179:"smj",3131:"se-FI",1083:"se",2107:"se-SE",8251:"sms",6203:"sma-NO",7227:"sms",1103:"sa",7194:"sr-Cyrl-BA",3098:"sr",6170:"sr-Latn-BA",2074:"sr-Latn",1132:"nso",1074:"tn",1115:"si",1051:"sk",1060:"sl",11274:"es-AR",16394:"es-BO",13322:"es-CL",9226:"es-CO",5130:"es-CR",7178:"es-DO",12298:"es-EC",17418:"es-SV",4106:"es-GT",18442:"es-HN",2058:"es-MX",19466:"es-NI",6154:"es-PA",15370:"es-PY",10250:"es-PE",20490:"es-PR",3082:"es",1034:"es",21514:"es-US",14346:"es-UY",8202:"es-VE",2077:"sv-FI",1053:"sv",1114:"syr",1064:"tg",2143:"tzm",1097:"ta",1092:"tt",1098:"te",1054:"th",1105:"bo",1055:"tr",1090:"tk",1152:"ug",1058:"uk",1070:"hsb",1056:"ur",2115:"uz-Cyrl",1091:"uz",1066:"vi",1106:"cy",1160:"wo",1157:"sah",1144:"ii",1130:"yo"};function pn(e,t,n){switch(e){case 0:if(t===65535){return"und"}else if(n){return n[t]}break;case 1:return ln[t];case 3:return mn[t]}return undefined}var cn="utf-16";var dn={0:"macintosh",1:"x-mac-japanese",2:"x-mac-chinesetrad",3:"x-mac-korean",6:"x-mac-greek",7:"x-mac-cyrillic",9:"x-mac-devanagai",10:"x-mac-gurmukhi",11:"x-mac-gujarati",12:"x-mac-oriya",13:"x-mac-bengali",14:"x-mac-tamil",15:"x-mac-telugu",16:"x-mac-kannada",17:"x-mac-malayalam",18:"x-mac-sinhalese",19:"x-mac-burmese",20:"x-mac-khmer",21:"x-mac-thai",22:"x-mac-lao",23:"x-mac-georgian",24:"x-mac-armenian",25:"x-mac-chinesesimp",26:"x-mac-tibetan",27:"x-mac-mongolian",28:"x-mac-ethiopic",29:"x-mac-ce",30:"x-mac-vietnamese",31:"x-mac-extarabic"};var hn={15:"x-mac-icelandic",17:"x-mac-turkish",18:"x-mac-croatian",24:"x-mac-ce",25:"x-mac-ce",26:"x-mac-ce",27:"x-mac-ce",28:"x-mac-ce",30:"x-mac-icelandic",37:"x-mac-romanian",38:"x-mac-ce",39:"x-mac-ce",40:"x-mac-ce",143:"x-mac-inuit",146:"x-mac-gaelic"};function fn(e,t,n){switch(e){case 0:return cn;case 1:return hn[n]||dn[t];case 3:if(t===1||t===10){return cn}break}return undefined}function vn(e,t,n){var a={};var i=new G.Parser(e,t);var r=i.parseUShort();var s=i.parseUShort();var o=i.offset+i.parseUShort();for(var l=0;l<s;l++){var u=i.parseUShort();var m=i.parseUShort();var p=i.parseUShort();var c=i.parseUShort();var d=on[c]||c;var h=i.parseUShort();var f=i.parseUShort();var v=pn(u,p,n);var g=fn(u,m,p);if(g!==undefined&&v!==undefined){var b=void 0;if(g===cn){b=me.UTF16(e,o+f,h)}else{b=me.MACSTRING(e,o+f,h,g)}if(b){var x=a[d];if(x===undefined){x=a[d]={}}x[v]=b}}}var O=0;if(r===1){O=i.parseUShort()}return a}function gn(e){var t={};for(var n in e){t[e[n]]=parseInt(n)}return t}function bn(e,t,n,a,i,r){return new C.Record("NameRecord",[{name:"platformID",type:"USHORT",value:e},{name:"encodingID",type:"USHORT",value:t},{name:"languageID",type:"USHORT",value:n},{name:"nameID",type:"USHORT",value:a},{name:"length",type:"USHORT",value:i},{name:"offset",type:"USHORT",value:r}])}function xn(e,t){var n=e.length;var a=t.length-n+1;e:for(var i=0;i<a;i++){for(;i<a;i++){for(var r=0;r<n;r++){if(t[i+r]!==e[r]){continue e}}return i}}return-1}function On(e,t){var n=xn(e,t);if(n<0){n=t.length;var a=0;var i=e.length;for(;a<i;++a){t.push(e[a])}}return n}function _n(e,t){var n;var a=[];var i={};var r=gn(on);for(var s in e){var o=r[s];if(o===undefined){o=s}n=parseInt(o);if(isNaN(n)){throw new Error('Name table entry "'+s+'" does not exist, see nameTableNames for complete list.')}i[n]=e[s];a.push(n)}var l=gn(ln);var u=gn(mn);var m=[];var p=[];for(var c=0;c<a.length;c++){n=a[c];var d=i[n];for(var h in d){var f=d[h];var v=1;var g=l[h];var b=un[g];var x=fn(v,b,g);var O=E.MACSTRING(f,x);if(O===undefined){v=0;g=t.indexOf(h);if(g<0){g=t.length;t.push(h)}b=4;O=E.UTF16(f)}var _=On(O,p);m.push(bn(v,b,g,n,O.length,_));var T=u[h];if(T!==undefined){var I=E.UTF16(f);var y=On(I,p);m.push(bn(3,1,T,n,I.length,y))}}}m.sort(function(e,t){return e.platformID-t.platformID||e.encodingID-t.encodingID||e.languageID-t.languageID||e.nameID-t.nameID});var A=new C.Table("name",[{name:"format",type:"USHORT",value:0},{name:"count",type:"USHORT",value:m.length},{name:"stringOffset",type:"USHORT",value:6+m.length*12}]);for(var S=0;S<m.length;S++){A.fields.push({name:"record_"+S,type:"RECORD",value:m[S]})}A.fields.push({name:"strings",type:"LITERAL",value:p});return A}var Tn={parse:vn,make:_n};var In=[{begin:0,end:127},{begin:128,end:255},{begin:256,end:383},{begin:384,end:591},{begin:592,end:687},{begin:688,end:767},{begin:768,end:879},{begin:880,end:1023},{begin:11392,end:11519},{begin:1024,end:1279},{begin:1328,end:1423},{begin:1424,end:1535},{begin:42240,end:42559},{begin:1536,end:1791},{begin:1984,end:2047},{begin:2304,end:2431},{begin:2432,end:2559},{begin:2560,end:2687},{begin:2688,end:2815},{begin:2816,end:2943},{begin:2944,end:3071},{begin:3072,end:3199},{begin:3200,end:3327},{begin:3328,end:3455},{begin:3584,end:3711},{begin:3712,end:3839},{begin:4256,end:4351},{begin:6912,end:7039},{begin:4352,end:4607},{begin:7680,end:7935},{begin:7936,end:8191},{begin:8192,end:8303},{begin:8304,end:8351},{begin:8352,end:8399},{begin:8400,end:8447},{begin:8448,end:8527},{begin:8528,end:8591},{begin:8592,end:8703},{begin:8704,end:8959},{begin:8960,end:9215},{begin:9216,end:9279},{begin:9280,end:9311},{begin:9312,end:9471},{begin:9472,end:9599},{begin:9600,end:9631},{begin:9632,end:9727},{begin:9728,end:9983},{begin:9984,end:10175},{begin:12288,end:12351},{begin:12352,end:12447},{begin:12448,end:12543},{begin:12544,end:12591},{begin:12592,end:12687},{begin:43072,end:43135},{begin:12800,end:13055},{begin:13056,end:13311},{begin:44032,end:55215},{begin:55296,end:57343},{begin:67840,end:67871},{begin:19968,end:40959},{begin:57344,end:63743},{begin:12736,end:12783},{begin:64256,end:64335},{begin:64336,end:65023},{begin:65056,end:65071},{begin:65040,end:65055},{begin:65104,end:65135},{begin:65136,end:65279},{begin:65280,end:65519},{begin:65520,end:65535},{begin:3840,end:4095},{begin:1792,end:1871},{begin:1920,end:1983},{begin:3456,end:3583},{begin:4096,end:4255},{begin:4608,end:4991},{begin:5024,end:5119},{begin:5120,end:5759},{begin:5760,end:5791},{begin:5792,end:5887},{begin:6016,end:6143},{begin:6144,end:6319},{begin:10240,end:10495},{begin:40960,end:42127},{begin:5888,end:5919},{begin:66304,end:66351},{begin:66352,end:66383},{begin:66560,end:66639},{begin:118784,end:119039},{begin:119808,end:120831},{begin:1044480,end:1048573},{begin:65024,end:65039},{begin:917504,end:917631},{begin:6400,end:6479},{begin:6480,end:6527},{begin:6528,end:6623},{begin:6656,end:6687},{begin:11264,end:11359},{begin:11568,end:11647},{begin:19904,end:19967},{begin:43008,end:43055},{begin:65536,end:65663},{begin:65856,end:65935},{begin:66432,end:66463},{begin:66464,end:66527},{begin:66640,end:66687},{begin:66688,end:66735},{begin:67584,end:67647},{begin:68096,end:68191},{begin:119552,end:119647},{begin:73728,end:74751},{begin:119648,end:119679},{begin:7040,end:7103},{begin:7168,end:7247},{begin:7248,end:7295},{begin:43136,end:43231},{begin:43264,end:43311},{begin:43312,end:43359},{begin:43520,end:43615},{begin:65936,end:65999},{begin:66e3,end:66047},{begin:66208,end:66271},{begin:127024,end:127135}];function yn(e){for(var t=0;t<In.length;t+=1){var n=In[t];if(e>=n.begin&&e<n.end){return t}}return-1}function An(e,t){var n={};var a=new G.Parser(e,t);n.version=a.parseUShort();n.xAvgCharWidth=a.parseShort();n.usWeightClass=a.parseUShort();n.usWidthClass=a.parseUShort();n.fsType=a.parseUShort();n.ySubscriptXSize=a.parseShort();n.ySubscriptYSize=a.parseShort();n.ySubscriptXOffset=a.parseShort();n.ySubscriptYOffset=a.parseShort();n.ySuperscriptXSize=a.parseShort();n.ySuperscriptYSize=a.parseShort();n.ySuperscriptXOffset=a.parseShort();n.ySuperscriptYOffset=a.parseShort();n.yStrikeoutSize=a.parseShort();n.yStrikeoutPosition=a.parseShort();n.sFamilyClass=a.parseShort();n.panose=[];for(var i=0;i<10;i++){n.panose[i]=a.parseByte()}n.ulUnicodeRange1=a.parseULong();n.ulUnicodeRange2=a.parseULong();n.ulUnicodeRange3=a.parseULong();n.ulUnicodeRange4=a.parseULong();n.achVendID=String.fromCharCode(a.parseByte(),a.parseByte(),a.parseByte(),a.parseByte());n.fsSelection=a.parseUShort();n.usFirstCharIndex=a.parseUShort();n.usLastCharIndex=a.parseUShort();n.sTypoAscender=a.parseShort();n.sTypoDescender=a.parseShort();n.sTypoLineGap=a.parseShort();n.usWinAscent=a.parseUShort();n.usWinDescent=a.parseUShort();if(n.version>=1){n.ulCodePageRange1=a.parseULong();n.ulCodePageRange2=a.parseULong()}if(n.version>=2){n.sxHeight=a.parseShort();n.sCapHeight=a.parseShort();n.usDefaultChar=a.parseUShort();n.usBreakChar=a.parseUShort();n.usMaxContent=a.parseUShort()}return n}function Sn(e){return new C.Table("OS/2",[{name:"version",type:"USHORT",value:3},{name:"xAvgCharWidth",type:"SHORT",value:0},{name:"usWeightClass",type:"USHORT",value:0},{name:"usWidthClass",type:"USHORT",value:0},{name:"fsType",type:"USHORT",value:0},{name:"ySubscriptXSize",type:"SHORT",value:650},{name:"ySubscriptYSize",type:"SHORT",value:699},{name:"ySubscriptXOffset",type:"SHORT",value:0},{name:"ySubscriptYOffset",type:"SHORT",value:140},{name:"ySuperscriptXSize",type:"SHORT",value:650},{name:"ySuperscriptYSize",type:"SHORT",value:699},{name:"ySuperscriptXOffset",type:"SHORT",value:0},{name:"ySuperscriptYOffset",type:"SHORT",value:479},{name:"yStrikeoutSize",type:"SHORT",value:49},{name:"yStrikeoutPosition",type:"SHORT",value:258},{name:"sFamilyClass",type:"SHORT",value:0},{name:"bFamilyType",type:"BYTE",value:0},{name:"bSerifStyle",type:"BYTE",value:0},{name:"bWeight",type:"BYTE",value:0},{name:"bProportion",type:"BYTE",value:0},{name:"bContrast",type:"BYTE",value:0},{name:"bStrokeVariation",type:"BYTE",value:0},{name:"bArmStyle",type:"BYTE",value:0},{name:"bLetterform",type:"BYTE",value:0},{name:"bMidline",type:"BYTE",value:0},{name:"bXHeight",type:"BYTE",value:0},{name:"ulUnicodeRange1",type:"ULONG",value:0},{name:"ulUnicodeRange2",type:"ULONG",value:0},{name:"ulUnicodeRange3",type:"ULONG",value:0},{name:"ulUnicodeRange4",type:"ULONG",value:0},{name:"achVendID",type:"CHARARRAY",value:"XXXX"},{name:"fsSelection",type:"USHORT",value:0},{name:"usFirstCharIndex",type:"USHORT",value:0},{name:"usLastCharIndex",type:"USHORT",value:0},{name:"sTypoAscender",type:"SHORT",value:0},{name:"sTypoDescender",type:"SHORT",value:0},{name:"sTypoLineGap",type:"SHORT",value:0},{name:"usWinAscent",type:"USHORT",value:0},{name:"usWinDescent",type:"USHORT",value:0},{name:"ulCodePageRange1",type:"ULONG",value:0},{name:"ulCodePageRange2",type:"ULONG",value:0},{name:"sxHeight",type:"SHORT",value:0},{name:"sCapHeight",type:"SHORT",value:0},{name:"usDefaultChar",type:"USHORT",value:0},{name:"usBreakChar",type:"USHORT",value:0},{name:"usMaxContext",type:"USHORT",value:0}],e)}var En={parse:An,make:Sn,unicodeRanges:In,getUnicodeRange:yn};function Cn(e,t){var n={};var a=new G.Parser(e,t);n.version=a.parseVersion();n.italicAngle=a.parseFixed();n.underlinePosition=a.parseShort();n.underlineThickness=a.parseShort();n.isFixedPitch=a.parseULong();n.minMemType42=a.parseULong();n.maxMemType42=a.parseULong();n.minMemType1=a.parseULong();n.maxMemType1=a.parseULong();switch(n.version){case 1:n.names=u.slice();break;case 2:n.numberOfGlyphs=a.parseUShort();n.glyphNameIndex=new Array(n.numberOfGlyphs);for(var i=0;i<n.numberOfGlyphs;i++){n.glyphNameIndex[i]=a.parseUShort()}n.names=[];for(var r=0;r<n.numberOfGlyphs;r++){if(n.glyphNameIndex[r]>=u.length){var s=a.parseChar();n.names.push(a.parseString(s))}}break;case 2.5:n.numberOfGlyphs=a.parseUShort();n.offset=new Array(n.numberOfGlyphs);for(var o=0;o<n.numberOfGlyphs;o++){n.offset[o]=a.parseChar()}break}return n}function jn(){return new C.Table("post",[{name:"version",type:"FIXED",value:196608},{name:"italicAngle",type:"FIXED",value:0},{name:"underlinePosition",type:"FWORD",value:0},{name:"underlineThickness",type:"FWORD",value:0},{name:"isFixedPitch",type:"ULONG",value:0},{name:"minMemType42",type:"ULONG",value:0},{name:"maxMemType42",type:"ULONG",value:0},{name:"minMemType1",type:"ULONG",value:0},{name:"maxMemType1",type:"ULONG",value:0}])}var Nn={parse:Cn,make:jn};var r=new Array(9);r[1]=function e(){var t=this.offset+this.relativeOffset;var n=this.parseUShort();if(n===1){return{substFormat:1,coverage:this.parsePointer(m.coverage),deltaGlyphId:this.parseUShort()}}else if(n===2){return{substFormat:2,coverage:this.parsePointer(m.coverage),substitute:this.parseOffset16List()}}I.assert(false,"0x"+t.toString(16)+": lookup type 1 format must be 1 or 2.")};r[2]=function e(){var t=this.parseUShort();I.argument(t===1,"GSUB Multiple Substitution Subtable identifier-format must be 1");return{substFormat:t,coverage:this.parsePointer(m.coverage),sequences:this.parseListOfLists()}};r[3]=function e(){var t=this.parseUShort();I.argument(t===1,"GSUB Alternate Substitution Subtable identifier-format must be 1");return{substFormat:t,coverage:this.parsePointer(m.coverage),alternateSets:this.parseListOfLists()}};r[4]=function e(){var t=this.parseUShort();I.argument(t===1,"GSUB ligature table identifier-format must be 1");return{substFormat:t,coverage:this.parsePointer(m.coverage),ligatureSets:this.parseListOfLists(function(){return{ligGlyph:this.parseUShort(),components:this.parseUShortList(this.parseUShort()-1)}})}};var Ln={sequenceIndex:m.uShort,lookupListIndex:m.uShort};r[5]=function e(){var t=this.offset+this.relativeOffset;var n=this.parseUShort();if(n===1){return{substFormat:n,coverage:this.parsePointer(m.coverage),ruleSets:this.parseListOfLists(function(){var e=this.parseUShort();var t=this.parseUShort();return{input:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,Ln)}})}}else if(n===2){return{substFormat:n,coverage:this.parsePointer(m.coverage),classDef:this.parsePointer(m.classDef),classSets:this.parseListOfLists(function(){var e=this.parseUShort();var t=this.parseUShort();return{classes:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,Ln)}})}}else if(n===3){var a=this.parseUShort();var i=this.parseUShort();return{substFormat:n,coverages:this.parseList(a,m.pointer(m.coverage)),lookupRecords:this.parseRecordList(i,Ln)}}I.assert(false,"0x"+t.toString(16)+": lookup type 5 format must be 1, 2 or 3.")};r[6]=function e(){var t=this.offset+this.relativeOffset;var n=this.parseUShort();if(n===1){return{substFormat:1,coverage:this.parsePointer(m.coverage),chainRuleSets:this.parseListOfLists(function(){return{backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(Ln)}})}}else if(n===2){return{substFormat:2,coverage:this.parsePointer(m.coverage),backtrackClassDef:this.parsePointer(m.classDef),inputClassDef:this.parsePointer(m.classDef),lookaheadClassDef:this.parsePointer(m.classDef),chainClassSet:this.parseListOfLists(function(){return{backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(Ln)}})}}else if(n===3){return{substFormat:3,backtrackCoverage:this.parseList(m.pointer(m.coverage)),inputCoverage:this.parseList(m.pointer(m.coverage)),lookaheadCoverage:this.parseList(m.pointer(m.coverage)),lookupRecords:this.parseRecordList(Ln)}}I.assert(false,"0x"+t.toString(16)+": lookup type 6 format must be 1, 2 or 3.")};r[7]=function e(){var t=this.parseUShort();I.argument(t===1,"GSUB Extension Substitution subtable identifier-format must be 1");var n=this.parseUShort();var a=new m(this.data,this.offset+this.parseULong());return{substFormat:1,lookupType:n,extension:r[n].call(a)}};r[8]=function e(){var t=this.parseUShort();I.argument(t===1,"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");return{substFormat:t,coverage:this.parsePointer(m.coverage),backtrackCoverage:this.parseList(m.pointer(m.coverage)),lookaheadCoverage:this.parseList(m.pointer(m.coverage)),substitutes:this.parseUShortList()}};function Mn(e,t){t=t||0;var n=new m(e,t);var a=n.parseVersion(1);I.argument(a===1||a===1.1,"Unsupported GSUB table version.");if(a===1){return{version:a,scripts:n.parseScriptList(),features:n.parseFeatureList(),lookups:n.parseLookupList(r)}}else{return{version:a,scripts:n.parseScriptList(),features:n.parseFeatureList(),lookups:n.parseLookupList(r),variations:n.parseFeatureVariationsList()}}}var Rn=new Array(9);Rn[1]=function e(t){if(t.substFormat===1){return new C.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)},{name:"deltaGlyphID",type:"USHORT",value:t.deltaGlyphId}])}else{return new C.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:2},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)}].concat(C.ushortList("substitute",t.substitute)))}};Rn[2]=function e(t){I.assert(t.substFormat===1,"Lookup type 2 substFormat must be 1.");return new C.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)}].concat(C.tableList("seqSet",t.sequences,function(e){return new C.Table("sequenceSetTable",C.ushortList("sequence",e))})))};Rn[3]=function e(t){I.assert(t.substFormat===1,"Lookup type 3 substFormat must be 1.");return new C.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)}].concat(C.tableList("altSet",t.alternateSets,function(e){return new C.Table("alternateSetTable",C.ushortList("alternate",e))})))};Rn[4]=function e(t){I.assert(t.substFormat===1,"Lookup type 4 substFormat must be 1.");return new C.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)}].concat(C.tableList("ligSet",t.ligatureSets,function(e){return new C.Table("ligatureSetTable",C.tableList("ligature",e,function(e){return new C.Table("ligatureTable",[{name:"ligGlyph",type:"USHORT",value:e.ligGlyph}].concat(C.ushortList("component",e.components,e.components.length+1)))}))})))};Rn[6]=function e(t){if(t.substFormat===1){var n=new C.Table("chainContextTable",[{name:"substFormat",type:"USHORT",value:t.substFormat},{name:"coverage",type:"TABLE",value:new C.Coverage(t.coverage)}].concat(C.tableList("chainRuleSet",t.chainRuleSets,function(e){return new C.Table("chainRuleSetTable",C.tableList("chainRule",e,function(e){var n=C.ushortList("backtrackGlyph",e.backtrack,e.backtrack.length).concat(C.ushortList("inputGlyph",e.input,e.input.length+1)).concat(C.ushortList("lookaheadGlyph",e.lookahead,e.lookahead.length)).concat(C.ushortList("substitution",[],e.lookupRecords.length));e.lookupRecords.forEach(function(e,t){n=n.concat({name:"sequenceIndex"+t,type:"USHORT",value:e.sequenceIndex}).concat({name:"lookupListIndex"+t,type:"USHORT",value:e.lookupListIndex})});return new C.Table("chainRuleTable",n)}))})));return n}else if(t.substFormat===2){I.assert(false,"lookup type 6 format 2 is not yet supported.")}else if(t.substFormat===3){var a=[{name:"substFormat",type:"USHORT",value:t.substFormat}];a.push({name:"backtrackGlyphCount",type:"USHORT",value:t.backtrackCoverage.length});t.backtrackCoverage.forEach(function(e,t){a.push({name:"backtrackCoverage"+t,type:"TABLE",value:new C.Coverage(e)})});a.push({name:"inputGlyphCount",type:"USHORT",value:t.inputCoverage.length});t.inputCoverage.forEach(function(e,t){a.push({name:"inputCoverage"+t,type:"TABLE",value:new C.Coverage(e)})});a.push({name:"lookaheadGlyphCount",type:"USHORT",value:t.lookaheadCoverage.length});t.lookaheadCoverage.forEach(function(e,t){a.push({name:"lookaheadCoverage"+t,type:"TABLE",value:new C.Coverage(e)})});a.push({name:"substitutionCount",type:"USHORT",value:t.lookupRecords.length});t.lookupRecords.forEach(function(e,t){a=a.concat({name:"sequenceIndex"+t,type:"USHORT",value:e.sequenceIndex}).concat({name:"lookupListIndex"+t,type:"USHORT",value:e.lookupListIndex})});var i=new C.Table("chainContextTable",a);return i}I.assert(false,"lookup type 6 format must be 1, 2 or 3.")};function Pn(e){return new C.Table("GSUB",[{name:"version",type:"ULONG",value:65536},{name:"scripts",type:"TABLE",value:new C.ScriptList(e.scripts)},{name:"features",type:"TABLE",value:new C.FeatureList(e.features)},{name:"lookups",type:"TABLE",value:new C.LookupList(e.lookups,Rn)}])}var wn={parse:Mn,make:Pn};function kn(e,t){var n=new G.Parser(e,t);var a=n.parseULong();I.argument(a===1,"Unsupported META table version.");n.parseULong();n.parseULong();var i=n.parseULong();var r={};for(var s=0;s<i;s++){var o=n.parseTag();var l=n.parseULong();var u=n.parseULong();var m=me.UTF8(e,t+l,u);r[o]=m}return r}function Fn(e){var t=Object.keys(e).length;var n="";var a=16+t*12;var i=new C.Table("meta",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"offset",type:"ULONG",value:a},{name:"numTags",type:"ULONG",value:t}]);for(var r in e){var s=n.length;n+=e[r];i.fields.push({name:"tag "+r,type:"TAG",value:r});i.fields.push({name:"offset "+r,type:"ULONG",value:a+s});i.fields.push({name:"length "+r,type:"ULONG",value:e[r].length})}i.fields.push({name:"stringPool",type:"CHARARRAY",value:n});return i}var Gn={parse:kn,make:Fn};function Un(e){return Math.log(e)/Math.log(2)|0}function Bn(e){while(e.length%4!==0){e.push(0)}var t=0;for(var n=0;n<e.length;n+=4){t+=(e[n]<<24)+(e[n+1]<<16)+(e[n+2]<<8)+e[n+3]}t%=Math.pow(2,32);return t}function Dn(e,t,n,a){return new C.Record("Table Record",[{name:"tag",type:"TAG",value:e!==undefined?e:""},{name:"checkSum",type:"ULONG",value:t!==undefined?t:0},{name:"offset",type:"ULONG",value:n!==undefined?n:0},{name:"length",type:"ULONG",value:a!==undefined?a:0}])}function Vn(e){var t=new C.Table("sfnt",[{name:"version",type:"TAG",value:"OTTO"},{name:"numTables",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0}]);t.tables=e;t.numTables=e.length;var n=Math.pow(2,Un(t.numTables));t.searchRange=16*n;t.entrySelector=Un(n);t.rangeShift=t.numTables*16-t.searchRange;var a=[];var i=[];var r=t.sizeOf()+Dn().sizeOf()*t.numTables;while(r%4!==0){r+=1;i.push({name:"padding",type:"BYTE",value:0})}for(var s=0;s<e.length;s+=1){var o=e[s];I.argument(o.tableName.length===4,"Table name"+o.tableName+" is invalid.");var l=o.sizeOf();var u=Dn(o.tableName,Bn(o.encode()),r,l);a.push({name:u.tag+" Table Record",type:"RECORD",value:u});i.push({name:o.tableName+" table",type:"RECORD",value:o});r+=l;I.argument(!isNaN(r),"Something went wrong calculating the offset.");while(r%4!==0){r+=1;i.push({name:"padding",type:"BYTE",value:0})}}a.sort(function(e,t){if(e.value.tag>t.value.tag){return 1}else{return-1}});t.fields=t.fields.concat(a);t.fields=t.fields.concat(i);return t}function zn(e,t,n){for(var a=0;a<t.length;a+=1){var i=e.charToGlyphIndex(t[a]);if(i>0){var r=e.glyphs.get(i);return r.getMetrics()}}return n}function Xn(e){var t=0;for(var n=0;n<e.length;n+=1){t+=e[n]}return t/e.length}function qn(e){var t=[];var n=[];var a=[];var i=[];var r=[];var s=[];var o=[];var l;var u=0;var m=0;var p=0;var c=0;var d=0;for(var h=0;h<e.glyphs.length;h+=1){var f=e.glyphs.get(h);var v=f.unicode|0;if(isNaN(f.advanceWidth)){throw new Error("Glyph "+f.name+" ("+h+"): advanceWidth is not a number.")}if(l>v||l===undefined){if(v>0){l=v}}if(u<v){u=v}var g=En.getUnicodeRange(v);if(g<32){m|=1<<g}else if(g<64){p|=1<<g-32}else if(g<96){c|=1<<g-64}else if(g<123){d|=1<<g-96}else{throw new Error("Unicode ranges bits > 123 are reserved for internal usage")}if(f.name===".notdef"){continue}var b=f.getMetrics();t.push(b.xMin);n.push(b.yMin);a.push(b.xMax);i.push(b.yMax);s.push(b.leftSideBearing);o.push(b.rightSideBearing);r.push(f.advanceWidth)}var x={xMin:Math.min.apply(null,t),yMin:Math.min.apply(null,n),xMax:Math.max.apply(null,a),yMax:Math.max.apply(null,i),advanceWidthMax:Math.max.apply(null,r),advanceWidthAvg:Xn(r),minLeftSideBearing:Math.min.apply(null,s),maxLeftSideBearing:Math.max.apply(null,s),minRightSideBearing:Math.min.apply(null,o)};x.ascender=e.ascender;x.descender=e.descender;var O=qt.make({flags:3,unitsPerEm:e.unitsPerEm,xMin:x.xMin,yMin:x.yMin,xMax:x.xMax,yMax:x.yMax,lowestRecPPEM:3,createdTimestamp:e.createdTimestamp});var _=Wt.make({ascender:x.ascender,descender:x.descender,advanceWidthMax:x.advanceWidthMax,minLeftSideBearing:x.minLeftSideBearing,minRightSideBearing:x.minRightSideBearing,xMaxExtent:x.maxLeftSideBearing+(x.xMax-x.xMin),numberOfHMetrics:e.glyphs.length});var k=sn.make(e.glyphs.length);var F=En.make(Object.assign({xAvgCharWidth:Math.round(x.advanceWidthAvg),usFirstCharIndex:l,usLastCharIndex:u,ulUnicodeRange1:m,ulUnicodeRange2:p,ulUnicodeRange3:c,ulUnicodeRange4:d,sTypoAscender:x.ascender,sTypoDescender:x.descender,sTypoLineGap:0,usWinAscent:x.yMax,usWinDescent:Math.abs(x.yMin),ulCodePageRange1:1,sxHeight:zn(e,"xyvw",{yMax:Math.round(x.ascender/2)}).yMax,sCapHeight:zn(e,"HIKLEFJMNTZBDPRAGOQSUVWXY",x).yMax,usDefaultChar:e.hasChar(" ")?32:0,usBreakChar:e.hasChar(" ")?32:0},e.tables.os2));var G=$t.make(e.glyphs);var U=Xe.make(e.glyphs);var T=e.getEnglishName("fontFamily");var I=e.getEnglishName("fontSubfamily");var y=T+" "+I;var A=e.getEnglishName("postScriptName");if(!A){A=T.replace(/\s/g,"")+"-"+I}var S={};for(var E in e.names){S[E]=e.names[E]}if(!S.uniqueID){S.uniqueID={en:e.getEnglishName("manufacturer")+":"+y}}if(!S.postScriptName){S.postScriptName={en:A}}if(!S.preferredFamily){S.preferredFamily=e.names.fontFamily}if(!S.preferredSubfamily){S.preferredSubfamily=e.names.fontSubfamily}var C=[];var B=Tn.make(S,C);var j=C.length>0?nn.make(C):undefined;var D=Nn.make();var V=Vt.make(e.glyphs,{version:e.getEnglishName("version"),fullName:y,familyName:T,weightName:I,postScriptName:A,unitsPerEm:e.unitsPerEm,fontBBox:[0,x.yMin,x.ascender,x.advanceWidthMax]});var N=e.metas&&Object.keys(e.metas).length>0?Gn.make(e.metas):undefined;var L=[O,_,k,F,B,U,D,V,G];if(j){L.push(j)}if(e.tables.gsub){L.push(wn.make(e.tables.gsub))}if(N){L.push(N)}var M=Vn(L);var z=M.encode();var X=Bn(z);var R=M.fields;var P=false;for(var w=0;w<R.length;w+=1){if(R[w].name==="head table"){R[w].value.checkSumAdjustment=2981146554-X;P=true;break}}if(!P){throw new Error("Could not find head table with checkSum to adjust.")}return M}var Hn={make:Vn,fontToTable:qn,computeCheckSum:Bn};function Yn(e,t){var n=0;var a=e.length-1;while(n<=a){var i=n+a>>>1;var r=e[i].tag;if(r===t){return i}else if(r<t){n=i+1}else{a=i-1}}return-n-1}function Wn(e,t){var n=0;var a=e.length-1;while(n<=a){var i=n+a>>>1;var r=e[i];if(r===t){return i}else if(r<t){n=i+1}else{a=i-1}}return-n-1}function Zn(e,t){var n;var a=0;var i=e.length-1;while(a<=i){var r=a+i>>>1;n=e[r];var s=n.start;if(s===t){return n}else if(s<t){a=r+1}else{i=r-1}}if(a>0){n=e[a-1];if(t>n.end){return 0}return n}}function Kn(e,t){this.font=e;this.tableName=t}Kn.prototype={searchTag:Yn,binSearch:Wn,getTable:function(e){var t=this.font.tables[this.tableName];if(!t&&e){t=this.font.tables[this.tableName]=this.createDefaultTable()}return t},getScriptNames:function(){var e=this.getTable();if(!e){return[]}return e.scripts.map(function(e){return e.tag})},getDefaultScriptName:function(){var e=this.getTable();if(!e){return}var t=false;for(var n=0;n<e.scripts.length;n++){var a=e.scripts[n].tag;if(a==="DFLT"){return a}if(a==="latn"){t=true}}if(t){return"latn"}},getScriptTable:function(e,t){var n=this.getTable(t);if(n){e=e||"DFLT";var a=n.scripts;var i=Yn(n.scripts,e);if(i>=0){return a[i].script}else if(t){var r={tag:e,script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}};a.splice(-1-i,0,r);return r.script}}},getLangSysTable:function(e,t,n){var a=this.getScriptTable(e,n);if(a){if(!t||t==="dflt"||t==="DFLT"){return a.defaultLangSys}var i=Yn(a.langSysRecords,t);if(i>=0){return a.langSysRecords[i].langSys}else if(n){var r={tag:t,langSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]}};a.langSysRecords.splice(-1-i,0,r);return r.langSys}}},getFeatureTable:function(e,t,n,a){var i=this.getLangSysTable(e,t,a);if(i){var r;var s=i.featureIndexes;var o=this.font.tables[this.tableName].features;for(var l=0;l<s.length;l++){r=o[s[l]];if(r.tag===n){return r.feature}}if(a){var u=o.length;I.assert(u===0||n>=o[u-1].tag,"Features must be added in alphabetical order.");r={tag:n,feature:{params:0,lookupListIndexes:[]}};o.push(r);s.push(u);return r.feature}}},getLookupTables:function(e,t,n,a,i){var r=this.getFeatureTable(e,t,n,i);var s=[];if(r){var o;var l=r.lookupListIndexes;var u=this.font.tables[this.tableName].lookups;for(var m=0;m<l.length;m++){o=u[l[m]];if(o.lookupType===a){s.push(o)}}if(s.length===0&&i){o={lookupType:a,lookupFlag:0,subtables:[],markFilteringSet:undefined};var p=u.length;u.push(o);l.push(p);return[o]}}return s},getGlyphClass:function(e,t){switch(e.format){case 1:if(e.startGlyph<=t&&t<e.startGlyph+e.classes.length){return e.classes[t-e.startGlyph]}return 0;case 2:var n=Zn(e.ranges,t);return n?n.classId:0}},getCoverageIndex:function(e,t){switch(e.format){case 1:var n=Wn(e.glyphs,t);return n>=0?n:-1;case 2:var a=Zn(e.ranges,t);return a?a.index+t-a.start:-1}},expandCoverage:function(e){if(e.format===1){return e.glyphs}else{var t=[];var n=e.ranges;for(var a=0;a<n.length;a++){var i=n[a];var r=i.start;var s=i.end;for(var o=r;o<=s;o++){t.push(o)}}return t}}};function Jn(e){Kn.call(this,e,"gpos")}Jn.prototype=Kn.prototype;Jn.prototype.init=function(){var e=this.getDefaultScriptName();this.defaultKerningTables=this.getKerningTables(e)};Jn.prototype.getKerningValue=function(e,t,n){for(var a=0;a<e.length;a++){var i=e[a].subtables;for(var r=0;r<i.length;r++){var s=i[r];var o=this.getCoverageIndex(s.coverage,t);if(o<0){continue}switch(s.posFormat){case 1:var l=s.pairSets[o];for(var u=0;u<l.length;u++){var m=l[u];if(m.secondGlyph===n){return m.value1&&m.value1.xAdvance||0}}break;case 2:var p=this.getGlyphClass(s.classDef1,t);var c=this.getGlyphClass(s.classDef2,n);var d=s.classRecords[p][c];return d.value1&&d.value1.xAdvance||0}}}return 0};Jn.prototype.getKerningTables=function(e,t){if(this.font.tables.gpos){return this.getLookupTables(e,t,"kern",2)}};function t(e){Kn.call(this,e,"gsub")}function Qn(e,t){var n=e.length;if(n!==t.length){return false}for(var a=0;a<n;a++){if(e[a]!==t[a]){return false}}return true}function $n(e,t,n){var a=e.subtables;for(var i=0;i<a.length;i++){var r=a[i];if(r.substFormat===t){return r}}if(n){a.push(n);return n}return undefined}t.prototype=Kn.prototype;t.prototype.createDefaultTable=function(){return{version:1,scripts:[{tag:"DFLT",script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}}],features:[],lookups:[]}};t.prototype.getSingle=function(e,t,n){var a=[];var i=this.getLookupTables(t,n,e,1);for(var r=0;r<i.length;r++){var s=i[r].subtables;for(var o=0;o<s.length;o++){var l=s[o];var u=this.expandCoverage(l.coverage);var m=void 0;if(l.substFormat===1){var p=l.deltaGlyphId;for(m=0;m<u.length;m++){var c=u[m];a.push({sub:c,by:c+p})}}else{var d=l.substitute;for(m=0;m<u.length;m++){a.push({sub:u[m],by:d[m]})}}}}return a};t.prototype.getMultiple=function(e,t,n){var a=[];var i=this.getLookupTables(t,n,e,2);for(var r=0;r<i.length;r++){var s=i[r].subtables;for(var o=0;o<s.length;o++){var l=s[o];var u=this.expandCoverage(l.coverage);var m=void 0;for(m=0;m<u.length;m++){var p=u[m];var c=l.sequences[m];a.push({sub:p,by:c})}}}return a};t.prototype.getAlternates=function(e,t,n){var a=[];var i=this.getLookupTables(t,n,e,3);for(var r=0;r<i.length;r++){var s=i[r].subtables;for(var o=0;o<s.length;o++){var l=s[o];var u=this.expandCoverage(l.coverage);var m=l.alternateSets;for(var p=0;p<u.length;p++){a.push({sub:u[p],by:m[p]})}}}return a};t.prototype.getLigatures=function(e,t,n){var a=[];var i=this.getLookupTables(t,n,e,4);for(var r=0;r<i.length;r++){var s=i[r].subtables;for(var o=0;o<s.length;o++){var l=s[o];var u=this.expandCoverage(l.coverage);var m=l.ligatureSets;for(var p=0;p<u.length;p++){var c=u[p];var d=m[p];for(var h=0;h<d.length;h++){var f=d[h];a.push({sub:[c].concat(f.components),by:f.ligGlyph})}}}}return a};t.prototype.addSingle=function(e,t,n,a){var i=this.getLookupTables(n,a,e,1,true)[0];var r=$n(i,2,{substFormat:2,coverage:{format:1,glyphs:[]},substitute:[]});I.assert(r.coverage.format===1,"Single: unable to modify coverage table format "+r.coverage.format);var s=t.sub;var o=this.binSearch(r.coverage.glyphs,s);if(o<0){o=-1-o;r.coverage.glyphs.splice(o,0,s);r.substitute.splice(o,0,0)}r.substitute[o]=t.by};t.prototype.addMultiple=function(e,t,n,a){I.assert(t.by instanceof Array&&t.by.length>1,'Multiple: "by" must be an array of two or more ids');var i=this.getLookupTables(n,a,e,2,true)[0];var r=$n(i,1,{substFormat:1,coverage:{format:1,glyphs:[]},sequences:[]});I.assert(r.coverage.format===1,"Multiple: unable to modify coverage table format "+r.coverage.format);var s=t.sub;var o=this.binSearch(r.coverage.glyphs,s);if(o<0){o=-1-o;r.coverage.glyphs.splice(o,0,s);r.sequences.splice(o,0,0)}r.sequences[o]=t.by};t.prototype.addAlternate=function(e,t,n,a){var i=this.getLookupTables(n,a,e,3,true)[0];var r=$n(i,1,{substFormat:1,coverage:{format:1,glyphs:[]},alternateSets:[]});I.assert(r.coverage.format===1,"Alternate: unable to modify coverage table format "+r.coverage.format);var s=t.sub;var o=this.binSearch(r.coverage.glyphs,s);if(o<0){o=-1-o;r.coverage.glyphs.splice(o,0,s);r.alternateSets.splice(o,0,0)}r.alternateSets[o]=t.by};t.prototype.addLigature=function(e,t,n,a){var i=this.getLookupTables(n,a,e,4,true)[0];var r=i.subtables[0];if(!r){r={substFormat:1,coverage:{format:1,glyphs:[]},ligatureSets:[]};i.subtables[0]=r}I.assert(r.coverage.format===1,"Ligature: unable to modify coverage table format "+r.coverage.format);var s=t.sub[0];var o=t.sub.slice(1);var l={ligGlyph:t.by,components:o};var u=this.binSearch(r.coverage.glyphs,s);if(u>=0){var m=r.ligatureSets[u];for(var p=0;p<m.length;p++){if(Qn(m[p].components,o)){return}}m.push(l)}else{u=-1-u;r.coverage.glyphs.splice(u,0,s);r.ligatureSets.splice(u,0,[l])}};t.prototype.getFeature=function(e,t,n){if(/ss\d\d/.test(e)){return this.getSingle(e,t,n)}switch(e){case"aalt":case"salt":return this.getSingle(e,t,n).concat(this.getAlternates(e,t,n));case"dlig":case"liga":case"rlig":return this.getLigatures(e,t,n);case"ccmp":return this.getMultiple(e,t,n).concat(this.getLigatures(e,t,n));case"stch":return this.getMultiple(e,t,n)}return undefined};t.prototype.add=function(e,t,n,a){if(/ss\d\d/.test(e)){return this.addSingle(e,t,n,a)}switch(e){case"aalt":case"salt":if(typeof t.by==="number"){return this.addSingle(e,t,n,a)}return this.addAlternate(e,t,n,a);case"dlig":case"liga":case"rlig":return this.addLigature(e,t,n,a);case"ccmp":if(t.by instanceof Array){return this.addMultiple(e,t,n,a)}return this.addLigature(e,t,n,a)}return undefined};function ea(){return typeof window!=="undefined"}function ta(e){var t=new ArrayBuffer(e.length);var n=new Uint8Array(t);for(var a=0;a<e.length;++a){n[a]=e[a]}return t}function na(e){var t=new Buffer(e.byteLength);var n=new Uint8Array(e);for(var a=0;a<t.length;++a){t[a]=n[a]}return t}function aa(e,t){if(!e){throw t}}function ia(e,t,n,a,i){var r;if((t&a)>0){r=e.parseByte();if((t&i)===0){r=-r}r=n+r}else{if((t&i)>0){r=n}else{r=n+e.parseShort()}}return r}function ra(e,t,n){var a=new G.Parser(t,n);e.numberOfContours=a.parseShort();e._xMin=a.parseShort();e._yMin=a.parseShort();e._xMax=a.parseShort();e._yMax=a.parseShort();var i;var r;if(e.numberOfContours>0){var s=e.endPointIndices=[];for(var o=0;o<e.numberOfContours;o+=1){s.push(a.parseUShort())}e.instructionLength=a.parseUShort();e.instructions=[];for(var l=0;l<e.instructionLength;l+=1){e.instructions.push(a.parseByte())}var u=s[s.length-1]+1;i=[];for(var m=0;m<u;m+=1){r=a.parseByte();i.push(r);if((r&8)>0){var p=a.parseByte();for(var c=0;c<p;c+=1){i.push(r);m+=1}}}I.argument(i.length===u,"Bad flags.");if(s.length>0){var d=[];var h;if(u>0){for(var f=0;f<u;f+=1){r=i[f];h={};h.onCurve=!!(r&1);h.lastPointOfContour=s.indexOf(f)>=0;d.push(h)}var v=0;for(var g=0;g<u;g+=1){r=i[g];h=d[g];h.x=ia(a,r,v,2,16);v=h.x}var b=0;for(var x=0;x<u;x+=1){r=i[x];h=d[x];h.y=ia(a,r,b,4,32);b=h.y}}e.points=d}else{e.points=[]}}else if(e.numberOfContours===0){e.points=[]}else{e.isComposite=true;e.points=[];e.components=[];var O=true;while(O){i=a.parseUShort();var _={glyphIndex:a.parseUShort(),xScale:1,scale01:0,scale10:0,yScale:1,dx:0,dy:0};if((i&1)>0){if((i&2)>0){_.dx=a.parseShort();_.dy=a.parseShort()}else{_.matchedPoints=[a.parseUShort(),a.parseUShort()]}}else{if((i&2)>0){_.dx=a.parseChar();_.dy=a.parseChar()}else{_.matchedPoints=[a.parseByte(),a.parseByte()]}}if((i&8)>0){_.xScale=_.yScale=a.parseF2Dot14()}else if((i&64)>0){_.xScale=a.parseF2Dot14();_.yScale=a.parseF2Dot14()}else if((i&128)>0){_.xScale=a.parseF2Dot14();_.scale01=a.parseF2Dot14();_.scale10=a.parseF2Dot14();_.yScale=a.parseF2Dot14()}e.components.push(_);O=!!(i&32)}if(i&256){e.instructionLength=a.parseUShort();e.instructions=[];for(var T=0;T<e.instructionLength;T+=1){e.instructions.push(a.parseByte())}}}}function sa(e,t){var n=[];for(var a=0;a<e.length;a+=1){var i=e[a];var r={x:t.xScale*i.x+t.scale01*i.y+t.dx,y:t.scale10*i.x+t.yScale*i.y+t.dy,onCurve:i.onCurve,lastPointOfContour:i.lastPointOfContour};n.push(r)}return n}function oa(e){var t=[];var n=[];for(var a=0;a<e.length;a+=1){var i=e[a];n.push(i);if(i.lastPointOfContour){t.push(n);n=[]}}I.argument(n.length===0,"There are still points left in the current contour.");return t}function la(e){var t=new h;if(!e){return t}var n=oa(e);for(var a=0;a<n.length;++a){var i=n[a];var r=null;var s=i[i.length-1];var o=i[0];if(s.onCurve){t.moveTo(s.x,s.y)}else{if(o.onCurve){t.moveTo(o.x,o.y)}else{var l={x:(s.x+o.x)*.5,y:(s.y+o.y)*.5};t.moveTo(l.x,l.y)}}for(var u=0;u<i.length;++u){r=s;s=o;o=i[(u+1)%i.length];if(s.onCurve){t.lineTo(s.x,s.y)}else{var m=r;var p=o;if(!r.onCurve){m={x:(s.x+r.x)*.5,y:(s.y+r.y)*.5}}if(!o.onCurve){p={x:(s.x+o.x)*.5,y:(s.y+o.y)*.5}}t.quadraticCurveTo(s.x,s.y,p.x,p.y)}}t.closePath()}return t}function ua(e,t){if(t.isComposite){for(var n=0;n<t.components.length;n+=1){var a=t.components[n];var i=e.get(a.glyphIndex);i.getPath();if(i.points){var r=void 0;if(a.matchedPoints===undefined){r=sa(i.points,a)}else{if(a.matchedPoints[0]>t.points.length-1||a.matchedPoints[1]>i.points.length-1){throw Error("Matched points out of range in "+t.name)}var s=t.points[a.matchedPoints[0]];var o=i.points[a.matchedPoints[1]];var l={xScale:a.xScale,scale01:a.scale01,scale10:a.scale10,yScale:a.yScale,dx:0,dy:0};o=sa([o],l)[0];l.dx=s.x-o.x;l.dy=s.y-o.y;r=sa(i.points,l)}t.points=t.points.concat(r)}}}return la(t.points)}function ma(e,t,n,a){var i=new y.GlyphSet(a);for(var r=0;r<n.length-1;r+=1){var s=n[r];var o=n[r+1];if(s!==o){i.push(r,y.ttfGlyphLoader(a,r,ra,e,t+s,ua))}else{i.push(r,y.glyphLoader(a,r))}}return i}function pa(a,i,r,s){var o=new y.GlyphSet(s);s._push=function(e){var t=r[e];var n=r[e+1];if(t!==n){o.push(e,y.ttfGlyphLoader(s,e,ra,a,i+t,ua))}else{o.push(e,y.glyphLoader(s,e))}};return o}function ca(e,t,n,a,i){if(i.lowMemory){return pa(e,t,n,a)}else{return ma(e,t,n,a)}}var da={getPath:la,parse:ca};var ha;var fa;var va;var ga;function ba(e){this.font=e;this.getCommands=function(e){return da.getPath(e).commands};this._fpgmState=this._prepState=undefined;this._errorState=0}function xa(e){return e}function Oa(e){return Math.sign(e)*Math.round(Math.abs(e))}function _a(e){return Math.sign(e)*Math.round(Math.abs(e*2))/2}function Ta(e){return Math.sign(e)*(Math.round(Math.abs(e)+.5)-.5)}function Ia(e){return Math.sign(e)*Math.ceil(Math.abs(e))}function ya(e){return Math.sign(e)*Math.floor(Math.abs(e))}var Aa=function(e){var t=this.srPeriod;var n=this.srPhase;var a=this.srThreshold;var i=1;if(e<0){e=-e;i=-1}e+=a-n;e=Math.trunc(e/t)*t;e+=n;if(e<0){return n*i}return e*i};var v={x:1,y:0,axis:"x",distance:function(e,t,n,a){return(n?e.xo:e.x)-(a?t.xo:t.x)},interpolate:function(e,t,n,a){var i;var r;var s;var o;var l;var u;var m;if(!a||a===this){i=e.xo-t.xo;r=e.xo-n.xo;l=t.x-t.xo;u=n.x-n.xo;s=Math.abs(i);o=Math.abs(r);m=s+o;if(m===0){e.x=e.xo+(l+u)/2;return}e.x=e.xo+(l*o+u*s)/m;return}i=a.distance(e,t,true,true);r=a.distance(e,n,true,true);l=a.distance(t,t,false,true);u=a.distance(n,n,false,true);s=Math.abs(i);o=Math.abs(r);m=s+o;if(m===0){v.setRelative(e,e,(l+u)/2,a,true);return}v.setRelative(e,e,(l*o+u*s)/m,a,true)},normalSlope:Number.NEGATIVE_INFINITY,setRelative:function(e,t,n,a,i){if(!a||a===this){e.x=(i?t.xo:t.x)+n;return}var r=i?t.xo:t.x;var s=i?t.yo:t.y;var o=r+n*a.x;var l=s+n*a.y;e.x=o+(e.y-l)/a.normalSlope},slope:0,touch:function(e){e.xTouched=true},touched:function(e){return e.xTouched},untouch:function(e){e.xTouched=false}};var g={x:0,y:1,axis:"y",distance:function(e,t,n,a){return(n?e.yo:e.y)-(a?t.yo:t.y)},interpolate:function(e,t,n,a){var i;var r;var s;var o;var l;var u;var m;if(!a||a===this){i=e.yo-t.yo;r=e.yo-n.yo;l=t.y-t.yo;u=n.y-n.yo;s=Math.abs(i);o=Math.abs(r);m=s+o;if(m===0){e.y=e.yo+(l+u)/2;return}e.y=e.yo+(l*o+u*s)/m;return}i=a.distance(e,t,true,true);r=a.distance(e,n,true,true);l=a.distance(t,t,false,true);u=a.distance(n,n,false,true);s=Math.abs(i);o=Math.abs(r);m=s+o;if(m===0){g.setRelative(e,e,(l+u)/2,a,true);return}g.setRelative(e,e,(l*o+u*s)/m,a,true)},normalSlope:0,setRelative:function(e,t,n,a,i){if(!a||a===this){e.y=(i?t.yo:t.y)+n;return}var r=i?t.xo:t.x;var s=i?t.yo:t.y;var o=r+n*a.x;var l=s+n*a.y;e.y=l+a.normalSlope*(e.x-o)},slope:Number.POSITIVE_INFINITY,touch:function(e){e.yTouched=true},touched:function(e){return e.yTouched},untouch:function(e){e.yTouched=false}};Object.freeze(v);Object.freeze(g);function Sa(e,t){this.x=e;this.y=t;this.axis=undefined;this.slope=t/e;this.normalSlope=-e/t;Object.freeze(this)}Sa.prototype.distance=function(e,t,n,a){return this.x*v.distance(e,t,n,a)+this.y*g.distance(e,t,n,a)};Sa.prototype.interpolate=function(e,t,n,a){var i;var r;var s;var o;var l;var u;var m;s=a.distance(e,t,true,true);o=a.distance(e,n,true,true);i=a.distance(t,t,false,true);r=a.distance(n,n,false,true);l=Math.abs(s);u=Math.abs(o);m=l+u;if(m===0){this.setRelative(e,e,(i+r)/2,a,true);return}this.setRelative(e,e,(i*u+r*l)/m,a,true)};Sa.prototype.setRelative=function(e,t,n,a,i){a=a||this;var r=i?t.xo:t.x;var s=i?t.yo:t.y;var o=r+n*a.x;var l=s+n*a.y;var u=a.normalSlope;var m=this.slope;var p=e.x;var c=e.y;e.x=(m*p-u*o+l-c)/(m-u);e.y=m*(e.x-p)+c};Sa.prototype.touch=function(e){e.xTouched=true;e.yTouched=true};function Ea(e,t){var n=Math.sqrt(e*e+t*t);e/=n;t/=n;if(e===1&&t===0){return v}else if(e===0&&t===1){return g}else{return new Sa(e,t)}}function O(e,t,n,a){this.x=this.xo=Math.round(e*64)/64;this.y=this.yo=Math.round(t*64)/64;this.lastPointOfContour=n;this.onCurve=a;this.prevPointOnContour=undefined;this.nextPointOnContour=undefined;this.xTouched=false;this.yTouched=false;Object.preventExtensions(this)}O.prototype.nextTouched=function(e){var t=this.nextPointOnContour;while(!e.touched(t)&&t!==this){t=t.nextPointOnContour}return t};O.prototype.prevTouched=function(e){var t=this.prevPointOnContour;while(!e.touched(t)&&t!==this){t=t.prevPointOnContour}return t};var Ca=Object.freeze(new O(0,0));var ja={cvCutIn:17/16,deltaBase:9,deltaShift:.125,loop:1,minDis:1,autoFlip:true};function _(e,t){this.env=e;this.stack=[];this.prog=t;switch(e){case"glyf":this.zp0=this.zp1=this.zp2=1;this.rp0=this.rp1=this.rp2=0;case"prep":this.fv=this.pv=this.dpv=v;this.round=Oa}}ba.prototype.exec=function(e,t){if(typeof t!=="number"){throw new Error("Point size is not a number!")}if(this._errorState>2){return}var n=this.font;var a=this._prepState;if(!a||a.ppem!==t){var i=this._fpgmState;if(!i){_.prototype=ja;i=this._fpgmState=new _("fpgm",n.tables.fpgm);i.funcs=[];i.font=n;if(A.DEBUG){console.log("---EXEC FPGM---");i.step=-1}try{fa(i)}catch(e){console.log("Hinting error in FPGM:"+e);this._errorState=3;return}}_.prototype=i;a=this._prepState=new _("prep",n.tables.prep);a.ppem=t;var r=n.tables.cvt;if(r){var s=a.cvt=new Array(r.length);var o=t/n.unitsPerEm;for(var l=0;l<r.length;l++){s[l]=r[l]*o}}else{a.cvt=[]}if(A.DEBUG){console.log("---EXEC PREP---");a.step=-1}try{fa(a)}catch(e){if(this._errorState<2){console.log("Hinting error in PREP:"+e)}this._errorState=2}}if(this._errorState>1){return}try{return va(e,a)}catch(e){if(this._errorState<1){console.log("Hinting error:"+e);console.log("Note: further hinting errors are silenced")}this._errorState=1;return undefined}};va=function(e,t){var n=t.ppem/t.font.unitsPerEm;var a=n;var i=e.components;var r;var s;var o;_.prototype=t;if(!i){o=new _("glyf",e.instructions);if(A.DEBUG){console.log("---EXEC GLYPH---");o.step=-1}ga(e,o,n,a);s=o.gZone}else{var l=t.font;s=[];r=[];for(var u=0;u<i.length;u++){var m=i[u];var p=l.glyphs.get(m.glyphIndex);o=new _("glyf",p.instructions);if(A.DEBUG){console.log("---EXEC COMP "+u+"---");o.step=-1}ga(p,o,n,a);var c=Math.round(m.dx*n);var d=Math.round(m.dy*a);var h=o.gZone;var f=o.contours;for(var v=0;v<h.length;v++){var g=h[v];g.xTouched=g.yTouched=false;g.xo=g.x=g.x+c;g.yo=g.y=g.y+d}var b=s.length;s.push.apply(s,h);for(var x=0;x<f.length;x++){r.push(f[x]+b)}}if(e.instructions&&!o.inhibitGridFit){o=new _("glyf",e.instructions);o.gZone=o.z0=o.z1=o.z2=s;o.contours=r;s.push(new O(0,0),new O(Math.round(e.advanceWidth*n),0));if(A.DEBUG){console.log("---EXEC COMPOSITE---");o.step=-1}fa(o);s.length-=2}}return s};ga=function(e,t,n,a){var i=e.points||[];var r=i.length;var s=t.gZone=t.z0=t.z1=t.z2=[];var o=t.contours=[];var l;for(var u=0;u<r;u++){l=i[u];s[u]=new O(l.x*n,l.y*a,l.lastPointOfContour,l.onCurve)}var m;var p;for(var c=0;c<r;c++){l=s[c];if(!m){m=l;o.push(c)}if(l.lastPointOfContour){l.nextPointOnContour=m;m.prevPointOnContour=l;m=undefined}else{p=s[c+1];l.nextPointOnContour=p;p.prevPointOnContour=l}}if(t.inhibitGridFit){return}if(A.DEBUG){console.log("PROCESSING GLYPH",t.stack);for(var d=0;d<r;d++){console.log(d,s[d].x,s[d].y)}}s.push(new O(0,0),new O(Math.round(e.advanceWidth*n),0));fa(t);s.length-=2;if(A.DEBUG){console.log("FINISHED GLYPH",t.stack);for(var h=0;h<r;h++){console.log(h,s[h].x,s[h].y)}}};fa=function(e){var t=e.prog;if(!t){return}var n=t.length;var a;for(e.ip=0;e.ip<n;e.ip++){if(A.DEBUG){e.step++}a=ha[t[e.ip]];if(!a){throw new Error("unknown instruction: 0x"+Number(t[e.ip]).toString(16))}a(e)}};function Na(e){var t=e.tZone=new Array(e.gZone.length);for(var n=0;n<t.length;n++){t[n]=new O(0,0)}}function La(e,t){var n=e.prog;var a=e.ip;var i=1;var r;do{r=n[++a];if(r===88){i++}else if(r===89){i--}else if(r===64){a+=n[a+1]+1}else if(r===65){a+=2*n[a+1]+1}else if(r>=176&&r<=183){a+=r-176+1}else if(r>=184&&r<=191){a+=(r-184+1)*2}else if(t&&i===1&&r===27){break}}while(i>0);e.ip=a}function Ma(e,t){if(A.DEBUG){console.log(t.step,"SVTCA["+e.axis+"]")}t.fv=t.pv=t.dpv=e}function Ra(e,t){if(A.DEBUG){console.log(t.step,"SPVTCA["+e.axis+"]")}t.pv=t.dpv=e}function Pa(e,t){if(A.DEBUG){console.log(t.step,"SFVTCA["+e.axis+"]")}t.fv=e}function wa(e,t){var n=t.stack;var a=n.pop();var i=n.pop();var r=t.z2[a];var s=t.z1[i];if(A.DEBUG){console.log("SPVTL["+e+"]",a,i)}var o;var l;if(!e){o=s.x-r.x;l=s.y-r.y}else{o=r.y-s.y;l=s.x-r.x}t.pv=t.dpv=Ea(o,l)}function ka(e,t){var n=t.stack;var a=n.pop();var i=n.pop();var r=t.z2[a];var s=t.z1[i];if(A.DEBUG){console.log("SFVTL["+e+"]",a,i)}var o;var l;if(!e){o=s.x-r.x;l=s.y-r.y}else{o=r.y-s.y;l=s.x-r.x}t.fv=Ea(o,l)}function Fa(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"SPVFS[]",n,a)}e.pv=e.dpv=Ea(a,n)}function Ga(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"SPVFS[]",n,a)}e.fv=Ea(a,n)}function Ua(e){var t=e.stack;var n=e.pv;if(A.DEBUG){console.log(e.step,"GPV[]")}t.push(n.x*16384);t.push(n.y*16384)}function Ba(e){var t=e.stack;var n=e.fv;if(A.DEBUG){console.log(e.step,"GFV[]")}t.push(n.x*16384);t.push(n.y*16384)}function Da(e){e.fv=e.pv;if(A.DEBUG){console.log(e.step,"SFVTPV[]")}}function Va(e){var t=e.stack;var n=t.pop();var a=t.pop();var i=t.pop();var r=t.pop();var s=t.pop();var o=e.z0;var l=e.z1;var u=o[n];var m=o[a];var p=l[i];var c=l[r];var d=e.z2[s];if(A.DEBUG){console.log("ISECT[], ",n,a,i,r,s)}var h=u.x;var f=u.y;var v=m.x;var g=m.y;var b=p.x;var x=p.y;var O=c.x;var _=c.y;var T=(h-v)*(x-_)-(f-g)*(b-O);var I=h*g-f*v;var y=b*_-x*O;d.x=(I*(b-O)-y*(h-v))/T;d.y=(I*(x-_)-y*(f-g))/T}function za(e){e.rp0=e.stack.pop();if(A.DEBUG){console.log(e.step,"SRP0[]",e.rp0)}}function Xa(e){e.rp1=e.stack.pop();if(A.DEBUG){console.log(e.step,"SRP1[]",e.rp1)}}function qa(e){e.rp2=e.stack.pop();if(A.DEBUG){console.log(e.step,"SRP2[]",e.rp2)}}function Ha(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SZP0[]",t)}e.zp0=t;switch(t){case 0:if(!e.tZone){Na(e)}e.z0=e.tZone;break;case 1:e.z0=e.gZone;break;default:throw new Error("Invalid zone pointer")}}function Ya(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SZP1[]",t)}e.zp1=t;switch(t){case 0:if(!e.tZone){Na(e)}e.z1=e.tZone;break;case 1:e.z1=e.gZone;break;default:throw new Error("Invalid zone pointer")}}function Wa(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SZP2[]",t)}e.zp2=t;switch(t){case 0:if(!e.tZone){Na(e)}e.z2=e.tZone;break;case 1:e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}}function Za(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SZPS[]",t)}e.zp0=e.zp1=e.zp2=t;switch(t){case 0:if(!e.tZone){Na(e)}e.z0=e.z1=e.z2=e.tZone;break;case 1:e.z0=e.z1=e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}}function Ka(e){e.loop=e.stack.pop();if(A.DEBUG){console.log(e.step,"SLOOP[]",e.loop)}}function Ja(e){if(A.DEBUG){console.log(e.step,"RTG[]")}e.round=Oa}function Qa(e){if(A.DEBUG){console.log(e.step,"RTHG[]")}e.round=Ta}function $a(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SMD[]",t)}e.minDis=t/64}function ei(e){if(A.DEBUG){console.log(e.step,"ELSE[]")}La(e,false)}function ti(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"JMPR[]",t)}e.ip+=t-1}function ni(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SCVTCI[]",t)}e.cvCutIn=t/64}function ai(e){var t=e.stack;if(A.DEBUG){console.log(e.step,"DUP[]")}t.push(t[t.length-1])}function ii(e){if(A.DEBUG){console.log(e.step,"POP[]")}e.stack.pop()}function ri(e){if(A.DEBUG){console.log(e.step,"CLEAR[]")}e.stack.length=0}function si(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"SWAP[]")}t.push(n);t.push(a)}function oi(e){var t=e.stack;if(A.DEBUG){console.log(e.step,"DEPTH[]")}t.push(t.length)}function li(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"LOOPCALL[]",n,a)}var i=e.ip;var r=e.prog;e.prog=e.funcs[n];for(var s=0;s<a;s++){fa(e);if(A.DEBUG){console.log(++e.step,s+1<a?"next loopcall":"done loopcall",s)}}e.ip=i;e.prog=r}function ui(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"CALL[]",t)}var n=e.ip;var a=e.prog;e.prog=e.funcs[t];fa(e);e.ip=n;e.prog=a;if(A.DEBUG){console.log(++e.step,"returning from",t)}}function mi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"CINDEX[]",n)}t.push(t[t.length-n])}function pi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"MINDEX[]",n)}t.push(t.splice(t.length-n,1)[0])}function ci(e){if(e.env!=="fpgm"){throw new Error("FDEF not allowed here")}var t=e.stack;var n=e.prog;var a=e.ip;var i=t.pop();var r=a;if(A.DEBUG){console.log(e.step,"FDEF[]",i)}while(n[++a]!==45){}e.ip=a;e.funcs[i]=n.slice(r+1,a)}function di(e,t){var n=t.stack.pop();var a=t.z0[n];var i=t.fv;var r=t.pv;if(A.DEBUG){console.log(t.step,"MDAP["+e+"]",n)}var s=r.distance(a,Ca);if(e){s=t.round(s)}i.setRelative(a,Ca,s,r);i.touch(a);t.rp0=t.rp1=n}function hi(e,t){var n=t.z2;var a=n.length-2;var i;var r;var s;if(A.DEBUG){console.log(t.step,"IUP["+e.axis+"]")}for(var o=0;o<a;o++){i=n[o];if(e.touched(i)){continue}r=i.prevTouched(e);if(r===i){continue}s=i.nextTouched(e);if(r===s){e.setRelative(i,i,e.distance(r,r,false,true),e,true)}e.interpolate(i,r,s,e)}}function fi(e,t){var n=t.stack;var a=e?t.rp1:t.rp2;var i=(e?t.z0:t.z1)[a];var r=t.fv;var s=t.pv;var o=t.loop;var l=t.z2;while(o--){var u=n.pop();var m=l[u];var p=s.distance(i,i,false,true);r.setRelative(m,m,p,s);r.touch(m);if(A.DEBUG){console.log(t.step,(t.loop>1?"loop "+(t.loop-o)+": ":"")+"SHP["+(e?"rp1":"rp2")+"]",u)}}t.loop=1}function vi(e,t){var n=t.stack;var a=e?t.rp1:t.rp2;var i=(e?t.z0:t.z1)[a];var r=t.fv;var s=t.pv;var o=n.pop();var l=t.z2[t.contours[o]];var u=l;if(A.DEBUG){console.log(t.step,"SHC["+e+"]",o)}var m=s.distance(i,i,false,true);do{if(u!==i){r.setRelative(u,u,m,s)}u=u.nextPointOnContour}while(u!==l)}function gi(e,t){var n=t.stack;var a=e?t.rp1:t.rp2;var i=(e?t.z0:t.z1)[a];var r=t.fv;var s=t.pv;var o=n.pop();if(A.DEBUG){console.log(t.step,"SHZ["+e+"]",o)}var l;switch(o){case 0:l=t.tZone;break;case 1:l=t.gZone;break;default:throw new Error("Invalid zone")}var u;var m=s.distance(i,i,false,true);var p=l.length-2;for(var c=0;c<p;c++){u=l[c];r.setRelative(u,u,m,s)}}function bi(e){var t=e.stack;var n=e.loop;var a=e.fv;var i=t.pop()/64;var r=e.z2;while(n--){var s=t.pop();var o=r[s];if(A.DEBUG){console.log(e.step,(e.loop>1?"loop "+(e.loop-n)+": ":"")+"SHPIX[]",s,i)}a.setRelative(o,o,i);a.touch(o)}e.loop=1}function xi(e){var t=e.stack;var n=e.rp1;var a=e.rp2;var i=e.loop;var r=e.z0[n];var s=e.z1[a];var o=e.fv;var l=e.dpv;var u=e.z2;while(i--){var m=t.pop();var p=u[m];if(A.DEBUG){console.log(e.step,(e.loop>1?"loop "+(e.loop-i)+": ":"")+"IP[]",m,n,"<->",a)}o.interpolate(p,r,s,l);o.touch(p)}e.loop=1}function Oi(e,t){var n=t.stack;var a=n.pop()/64;var i=n.pop();var r=t.z1[i];var s=t.z0[t.rp0];var o=t.fv;var l=t.pv;o.setRelative(r,s,a,l);o.touch(r);if(A.DEBUG){console.log(t.step,"MSIRP["+e+"]",a,i)}t.rp1=t.rp0;t.rp2=i;if(e){t.rp0=i}}function _i(e){var t=e.stack;var n=e.rp0;var a=e.z0[n];var i=e.loop;var r=e.fv;var s=e.pv;var o=e.z1;while(i--){var l=t.pop();var u=o[l];if(A.DEBUG){console.log(e.step,(e.loop>1?"loop "+(e.loop-i)+": ":"")+"ALIGNRP[]",l)}r.setRelative(u,a,0,s);r.touch(u)}e.loop=1}function Ti(e){if(A.DEBUG){console.log(e.step,"RTDG[]")}e.round=_a}function Ii(e,t){var n=t.stack;var a=n.pop();var i=n.pop();var r=t.z0[i];var s=t.fv;var o=t.pv;var l=t.cvt[a];if(A.DEBUG){console.log(t.step,"MIAP["+e+"]",a,"(",l,")",i)}var u=o.distance(r,Ca);if(e){if(Math.abs(u-l)<t.cvCutIn){u=l}u=t.round(u)}s.setRelative(r,Ca,u,o);if(t.zp0===0){r.xo=r.x;r.yo=r.y}s.touch(r);t.rp0=t.rp1=i}function yi(e){var t=e.prog;var n=e.ip;var a=e.stack;var i=t[++n];if(A.DEBUG){console.log(e.step,"NPUSHB[]",i)}for(var r=0;r<i;r++){a.push(t[++n])}e.ip=n}function Ai(e){var t=e.ip;var n=e.prog;var a=e.stack;var i=n[++t];if(A.DEBUG){console.log(e.step,"NPUSHW[]",i)}for(var r=0;r<i;r++){var s=n[++t]<<8|n[++t];if(s&32768){s=-((s^65535)+1)}a.push(s)}e.ip=t}function Si(e){var t=e.stack;var n=e.store;if(!n){n=e.store=[]}var a=t.pop();var i=t.pop();if(A.DEBUG){console.log(e.step,"WS",a,i)}n[i]=a}function Ei(e){var t=e.stack;var n=e.store;var a=t.pop();if(A.DEBUG){console.log(e.step,"RS",a)}var i=n&&n[a]||0;t.push(i)}function Ci(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"WCVTP",n,a)}e.cvt[a]=n/64}function ji(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"RCVT",n)}t.push(e.cvt[n]*64)}function Ni(e,t){var n=t.stack;var a=n.pop();var i=t.z2[a];if(A.DEBUG){console.log(t.step,"GC["+e+"]",a)}n.push(t.dpv.distance(i,Ca,e,false)*64)}function Li(e,t){var n=t.stack;var a=n.pop();var i=n.pop();var r=t.z1[a];var s=t.z0[i];var o=t.dpv.distance(s,r,e,e);if(A.DEBUG){console.log(t.step,"MD["+e+"]",a,i,"->",o)}t.stack.push(Math.round(o*64))}function Mi(e){if(A.DEBUG){console.log(e.step,"MPPEM[]")}e.stack.push(e.ppem)}function Ri(e){if(A.DEBUG){console.log(e.step,"FLIPON[]")}e.autoFlip=true}function Pi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"LT[]",n,a)}t.push(a<n?1:0)}function wi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"LTEQ[]",n,a)}t.push(a<=n?1:0)}function ki(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"GT[]",n,a)}t.push(a>n?1:0)}function Fi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"GTEQ[]",n,a)}t.push(a>=n?1:0)}function Gi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"EQ[]",n,a)}t.push(n===a?1:0)}function Ui(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"NEQ[]",n,a)}t.push(n!==a?1:0)}function Bi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"ODD[]",n)}t.push(Math.trunc(n)%2?1:0)}function Di(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"EVEN[]",n)}t.push(Math.trunc(n)%2?0:1)}function Vi(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"IF[]",t)}if(!t){La(e,true);if(A.DEBUG){console.log(e.step,"EIF[]")}}}function zi(e){if(A.DEBUG){console.log(e.step,"EIF[]")}}function Xi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"AND[]",n,a)}t.push(n&&a?1:0)}function qi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"OR[]",n,a)}t.push(n||a?1:0)}function Hi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"NOT[]",n)}t.push(n?0:1)}function Yi(e,t){var n=t.stack;var a=n.pop();var i=t.fv;var r=t.pv;var s=t.ppem;var o=t.deltaBase+(e-1)*16;var l=t.deltaShift;var u=t.z0;if(A.DEBUG){console.log(t.step,"DELTAP["+e+"]",a,n)}for(var m=0;m<a;m++){var p=n.pop();var c=n.pop();var d=o+((c&240)>>4);if(d!==s){continue}var h=(c&15)-8;if(h>=0){h++}if(A.DEBUG){console.log(t.step,"DELTAPFIX",p,"by",h*l)}var f=u[p];i.setRelative(f,f,h*l,r)}}function Wi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"SDB[]",n)}e.deltaBase=n}function Zi(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"SDS[]",n)}e.deltaShift=Math.pow(.5,n)}function Ki(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"ADD[]",n,a)}t.push(a+n)}function Ji(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"SUB[]",n,a)}t.push(a-n)}function Qi(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"DIV[]",n,a)}t.push(a*64/n)}function $i(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"MUL[]",n,a)}t.push(a*n/64)}function er(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"ABS[]",n)}t.push(Math.abs(n))}function tr(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"NEG[]",n)}t.push(-n)}function nr(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"FLOOR[]",n)}t.push(Math.floor(n/64)*64)}function ar(e){var t=e.stack;var n=t.pop();if(A.DEBUG){console.log(e.step,"CEILING[]",n)}t.push(Math.ceil(n/64)*64)}function ir(e,t){var n=t.stack;var a=n.pop();if(A.DEBUG){console.log(t.step,"ROUND[]")}n.push(t.round(a/64)*64)}function rr(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"WCVTF[]",n,a)}e.cvt[a]=n*e.ppem/e.font.unitsPerEm}function sr(e,t){var n=t.stack;var a=n.pop();var i=t.ppem;var r=t.deltaBase+(e-1)*16;var s=t.deltaShift;if(A.DEBUG){console.log(t.step,"DELTAC["+e+"]",a,n)}for(var o=0;o<a;o++){var l=n.pop();var u=n.pop();var m=r+((u&240)>>4);if(m!==i){continue}var p=(u&15)-8;if(p>=0){p++}var c=p*s;if(A.DEBUG){console.log(t.step,"DELTACFIX",l,"by",c)}t.cvt[l]+=c}}function or(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SROUND[]",t)}e.round=Aa;var n;switch(t&192){case 0:n=.5;break;case 64:n=1;break;case 128:n=2;break;default:throw new Error("invalid SROUND value")}e.srPeriod=n;switch(t&48){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*n;break;case 32:e.srPhase=.5*n;break;case 48:e.srPhase=.75*n;break;default:throw new Error("invalid SROUND value")}t&=15;if(t===0){e.srThreshold=0}else{e.srThreshold=(t/8-.5)*n}}function lr(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"S45ROUND[]",t)}e.round=Aa;var n;switch(t&192){case 0:n=Math.sqrt(2)/2;break;case 64:n=Math.sqrt(2);break;case 128:n=2*Math.sqrt(2);break;default:throw new Error("invalid S45ROUND value")}e.srPeriod=n;switch(t&48){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*n;break;case 32:e.srPhase=.5*n;break;case 48:e.srPhase=.75*n;break;default:throw new Error("invalid S45ROUND value")}t&=15;if(t===0){e.srThreshold=0}else{e.srThreshold=(t/8-.5)*n}}function ur(e){if(A.DEBUG){console.log(e.step,"ROFF[]")}e.round=xa}function mr(e){if(A.DEBUG){console.log(e.step,"RUTG[]")}e.round=Ia}function pr(e){if(A.DEBUG){console.log(e.step,"RDTG[]")}e.round=ya}function cr(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SCANCTRL[]",t)}}function dr(e,t){var n=t.stack;var a=n.pop();var i=n.pop();var r=t.z2[a];var s=t.z1[i];if(A.DEBUG){console.log(t.step,"SDPVTL["+e+"]",a,i)}var o;var l;if(!e){o=s.x-r.x;l=s.y-r.y}else{o=r.y-s.y;l=s.x-r.x}t.dpv=Ea(o,l)}function hr(e){var t=e.stack;var n=t.pop();var a=0;if(A.DEBUG){console.log(e.step,"GETINFO[]",n)}if(n&1){a=35}if(n&32){a|=4096}t.push(a)}function fr(e){var t=e.stack;var n=t.pop();var a=t.pop();var i=t.pop();if(A.DEBUG){console.log(e.step,"ROLL[]")}t.push(a);t.push(n);t.push(i)}function vr(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"MAX[]",n,a)}t.push(Math.max(a,n))}function gr(e){var t=e.stack;var n=t.pop();var a=t.pop();if(A.DEBUG){console.log(e.step,"MIN[]",n,a)}t.push(Math.min(a,n))}function br(e){var t=e.stack.pop();if(A.DEBUG){console.log(e.step,"SCANTYPE[]",t)}}function xr(e){var t=e.stack.pop();var n=e.stack.pop();if(A.DEBUG){console.log(e.step,"INSTCTRL[]",t,n)}switch(t){case 1:e.inhibitGridFit=!!n;return;case 2:e.ignoreCvt=!!n;return;default:throw new Error("invalid INSTCTRL[] selector")}}function n(e,t){var n=t.stack;var a=t.prog;var i=t.ip;if(A.DEBUG){console.log(t.step,"PUSHB["+e+"]")}for(var r=0;r<e;r++){n.push(a[++i])}t.ip=i}function a(e,t){var n=t.ip;var a=t.prog;var i=t.stack;if(A.DEBUG){console.log(t.ip,"PUSHW["+e+"]")}for(var r=0;r<e;r++){var s=a[++n]<<8|a[++n];if(s&32768){s=-((s^65535)+1)}i.push(s)}t.ip=n}function s(e,t,n,a,i,r){var s=r.stack;var o=e&&s.pop();var l=s.pop();var u=r.rp0;var m=r.z0[u];var p=r.z1[l];var c=r.minDis;var d=r.fv;var h=r.dpv;var f;var v;var g;var b;v=f=h.distance(p,m,true,true);g=v>=0?1:-1;v=Math.abs(v);if(e){b=r.cvt[o];if(a&&Math.abs(v-b)<r.cvCutIn){v=b}}if(n&&v<c){v=c}if(a){v=r.round(v)}d.setRelative(p,m,g*v,h);d.touch(p);if(A.DEBUG){console.log(r.step,(e?"MIRP[":"MDRP[")+(t?"M":"m")+(n?">":"_")+(a?"R":"_")+(i===0?"Gr":i===1?"Bl":i===2?"Wh":"")+"]",e?o+"("+r.cvt[o]+","+b+")":"",l,"(d =",f,"->",g*v,")")}r.rp1=r.rp0;r.rp2=l;if(t){r.rp0=l}}ha=[Ma.bind(undefined,g),Ma.bind(undefined,v),Ra.bind(undefined,g),Ra.bind(undefined,v),Pa.bind(undefined,g),Pa.bind(undefined,v),wa.bind(undefined,0),wa.bind(undefined,1),ka.bind(undefined,0),ka.bind(undefined,1),Fa,Ga,Ua,Ba,Da,Va,za,Xa,qa,Ha,Ya,Wa,Za,Ka,Ja,Qa,$a,ei,ti,ni,undefined,undefined,ai,ii,ri,si,oi,mi,pi,undefined,undefined,undefined,li,ui,ci,undefined,di.bind(undefined,0),di.bind(undefined,1),hi.bind(undefined,g),hi.bind(undefined,v),fi.bind(undefined,0),fi.bind(undefined,1),vi.bind(undefined,0),vi.bind(undefined,1),gi.bind(undefined,0),gi.bind(undefined,1),bi,xi,Oi.bind(undefined,0),Oi.bind(undefined,1),_i,Ti,Ii.bind(undefined,0),Ii.bind(undefined,1),yi,Ai,Si,Ei,Ci,ji,Ni.bind(undefined,0),Ni.bind(undefined,1),undefined,Li.bind(undefined,0),Li.bind(undefined,1),Mi,undefined,Ri,undefined,undefined,Pi,wi,ki,Fi,Gi,Ui,Bi,Di,Vi,zi,Xi,qi,Hi,Yi.bind(undefined,1),Wi,Zi,Ki,Ji,Qi,$i,er,tr,nr,ar,ir.bind(undefined,0),ir.bind(undefined,1),ir.bind(undefined,2),ir.bind(undefined,3),undefined,undefined,undefined,undefined,rr,Yi.bind(undefined,2),Yi.bind(undefined,3),sr.bind(undefined,1),sr.bind(undefined,2),sr.bind(undefined,3),or,lr,undefined,undefined,ur,undefined,mr,pr,ii,ii,undefined,undefined,undefined,undefined,undefined,cr,dr.bind(undefined,0),dr.bind(undefined,1),hr,undefined,fr,vr,gr,br,xr,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,n.bind(undefined,1),n.bind(undefined,2),n.bind(undefined,3),n.bind(undefined,4),n.bind(undefined,5),n.bind(undefined,6),n.bind(undefined,7),n.bind(undefined,8),a.bind(undefined,1),a.bind(undefined,2),a.bind(undefined,3),a.bind(undefined,4),a.bind(undefined,5),a.bind(undefined,6),a.bind(undefined,7),a.bind(undefined,8),s.bind(undefined,0,0,0,0,0),s.bind(undefined,0,0,0,0,1),s.bind(undefined,0,0,0,0,2),s.bind(undefined,0,0,0,0,3),s.bind(undefined,0,0,0,1,0),s.bind(undefined,0,0,0,1,1),s.bind(undefined,0,0,0,1,2),s.bind(undefined,0,0,0,1,3),s.bind(undefined,0,0,1,0,0),s.bind(undefined,0,0,1,0,1),s.bind(undefined,0,0,1,0,2),s.bind(undefined,0,0,1,0,3),s.bind(undefined,0,0,1,1,0),s.bind(undefined,0,0,1,1,1),s.bind(undefined,0,0,1,1,2),s.bind(undefined,0,0,1,1,3),s.bind(undefined,0,1,0,0,0),s.bind(undefined,0,1,0,0,1),s.bind(undefined,0,1,0,0,2),s.bind(undefined,0,1,0,0,3),s.bind(undefined,0,1,0,1,0),s.bind(undefined,0,1,0,1,1),s.bind(undefined,0,1,0,1,2),s.bind(undefined,0,1,0,1,3),s.bind(undefined,0,1,1,0,0),s.bind(undefined,0,1,1,0,1),s.bind(undefined,0,1,1,0,2),s.bind(undefined,0,1,1,0,3),s.bind(undefined,0,1,1,1,0),s.bind(undefined,0,1,1,1,1),s.bind(undefined,0,1,1,1,2),s.bind(undefined,0,1,1,1,3),s.bind(undefined,1,0,0,0,0),s.bind(undefined,1,0,0,0,1),s.bind(undefined,1,0,0,0,2),s.bind(undefined,1,0,0,0,3),s.bind(undefined,1,0,0,1,0),s.bind(undefined,1,0,0,1,1),s.bind(undefined,1,0,0,1,2),s.bind(undefined,1,0,0,1,3),s.bind(undefined,1,0,1,0,0),s.bind(undefined,1,0,1,0,1),s.bind(undefined,1,0,1,0,2),s.bind(undefined,1,0,1,0,3),s.bind(undefined,1,0,1,1,0),s.bind(undefined,1,0,1,1,1),s.bind(undefined,1,0,1,1,2),s.bind(undefined,1,0,1,1,3),s.bind(undefined,1,1,0,0,0),s.bind(undefined,1,1,0,0,1),s.bind(undefined,1,1,0,0,2),s.bind(undefined,1,1,0,0,3),s.bind(undefined,1,1,0,1,0),s.bind(undefined,1,1,0,1,1),s.bind(undefined,1,1,0,1,2),s.bind(undefined,1,1,0,1,3),s.bind(undefined,1,1,1,0,0),s.bind(undefined,1,1,1,0,1),s.bind(undefined,1,1,1,0,2),s.bind(undefined,1,1,1,0,3),s.bind(undefined,1,1,1,1,0),s.bind(undefined,1,1,1,1,1),s.bind(undefined,1,1,1,1,2),s.bind(undefined,1,1,1,1,3)];function Or(e){this.char=e;this.state={};this.activeState=null}function _r(e,t,n){this.contextName=n;this.startIndex=e;this.endOffset=t}function Tr(e,t,n){this.contextName=e;this.openRange=null;this.ranges=[];this.checkStart=t;this.checkEnd=n}function j(e,t){this.context=e;this.index=t;this.length=e.length;this.current=e[t];this.backtrack=e.slice(0,t);this.lookahead=e.slice(t+1)}function Ir(e){this.eventId=e;this.subscribers=[]}function yr(n){var a=this;var e=["start","end","next","newToken","contextStart","contextEnd","insertToken","removeToken","removeRange","replaceToken","replaceRange","composeRUD","updateContextsRanges"];e.forEach(function(e){Object.defineProperty(a.events,e,{value:new Ir(e)})});if(!!n){e.forEach(function(e){var t=n[e];if(typeof t==="function"){a.events[e].subscribe(t)}})}var t=["insertToken","removeToken","removeRange","replaceToken","replaceRange","composeRUD"];t.forEach(function(e){a.events[e].subscribe(a.updateContextsRanges)})}function b(e){this.tokens=[];this.registeredContexts={};this.contextCheckers=[];this.events={};this.registeredModifiers=[];yr.call(this,e)}Or.prototype.setState=function(e,t){this.state[e]=t;this.activeState={key:e,value:this.state[e]};return this.activeState};Or.prototype.getState=function(e){return this.state[e]||null};b.prototype.inboundIndex=function(e){return e>=0&&e<this.tokens.length};b.prototype.composeRUD=function(e){var t=this;var n=true;var a=e.map(function(e){return t[e[0]].apply(t,e.slice(1).concat(n))});var i=function(e){return typeof e==="object"&&e.hasOwnProperty("FAIL")};if(a.every(i)){return{FAIL:"composeRUD: one or more operations hasn't completed successfully",report:a.filter(i)}}this.dispatch("composeRUD",[a.filter(function(e){return!i(e)})])};b.prototype.replaceRange=function(e,t,n,a){t=t!==null?t:this.tokens.length;var i=n.every(function(e){return e instanceof Or});if(!isNaN(e)&&this.inboundIndex(e)&&i){var r=this.tokens.splice.apply(this.tokens,[e,t].concat(n));if(!a){this.dispatch("replaceToken",[e,t,n])}return[r,n]}else{return{FAIL:"replaceRange: invalid tokens or startIndex."}}};b.prototype.replaceToken=function(e,t,n){if(!isNaN(e)&&this.inboundIndex(e)&&t instanceof Or){var a=this.tokens.splice(e,1,t);if(!n){this.dispatch("replaceToken",[e,t])}return[a[0],t]}else{return{FAIL:"replaceToken: invalid token or index."}}};b.prototype.removeRange=function(e,t,n){t=!isNaN(t)?t:this.tokens.length;var a=this.tokens.splice(e,t);if(!n){this.dispatch("removeRange",[a,e,t])}return a};b.prototype.removeToken=function(e,t){if(!isNaN(e)&&this.inboundIndex(e)){var n=this.tokens.splice(e,1);if(!t){this.dispatch("removeToken",[n,e])}return n}else{return{FAIL:"removeToken: invalid token index."}}};b.prototype.insertToken=function(e,t,n){var a=e.every(function(e){return e instanceof Or});if(a){this.tokens.splice.apply(this.tokens,[t,0].concat(e));if(!n){this.dispatch("insertToken",[e,t])}return e}else{return{FAIL:"insertToken: invalid token(s)."}}};b.prototype.registerModifier=function(s,o,l){this.events.newToken.subscribe(function(e,t){var n=[e,t];var a=o===null||o.apply(this,n)===true;var i=[e,t];if(a){var r=l.apply(this,i);e.setState(s,r)}});this.registeredModifiers.push(s)};Ir.prototype.subscribe=function(e){if(typeof e==="function"){return this.subscribers.push(e)-1}else{return{FAIL:"invalid '"+this.eventId+"' event handler"}}};Ir.prototype.unsubscribe=function(e){this.subscribers.splice(e,1)};j.prototype.setCurrentIndex=function(e){this.index=e;this.current=this.context[e];this.backtrack=this.context.slice(0,e);this.lookahead=this.context.slice(e+1)};j.prototype.get=function(e){switch(true){case e===0:return this.current;case e<0&&Math.abs(e)<=this.backtrack.length:return this.backtrack.slice(e)[0];case e>0&&e<=this.lookahead.length:return this.lookahead[e-1];default:return null}};b.prototype.rangeToText=function(e){if(e instanceof _r){return this.getRangeTokens(e).map(function(e){return e.char}).join("")}};b.prototype.getText=function(){return this.tokens.map(function(e){return e.char}).join("")};b.prototype.getContext=function(e){var t=this.registeredContexts[e];return!!t?t:null};b.prototype.on=function(e,t){var n=this.events[e];if(!!n){return n.subscribe(t)}else{return null}};b.prototype.dispatch=function(e,t){var n=this;var a=this.events[e];if(a instanceof Ir){a.subscribers.forEach(function(e){e.apply(n,t||[])})}};b.prototype.registerContextChecker=function(e,t,n){if(!!this.getContext(e)){return{FAIL:"context name '"+e+"' is already registered."}}if(typeof t!=="function"){return{FAIL:"missing context start check."}}if(typeof n!=="function"){return{FAIL:"missing context end check."}}var a=new Tr(e,t,n);this.registeredContexts[e]=a;this.contextCheckers.push(a);return a};b.prototype.getRangeTokens=function(e){var t=e.startIndex+e.endOffset;return[].concat(this.tokens.slice(e.startIndex,t))};b.prototype.getContextRanges=function(e){var t=this.getContext(e);if(!!t){return t.ranges}else{return{FAIL:"context checker '"+e+"' is not registered."}}};b.prototype.resetContextsRanges=function(){var e=this.registeredContexts;for(var t in e){if(e.hasOwnProperty(t)){var n=e[t];n.ranges=[]}}};b.prototype.updateContextsRanges=function(){this.resetContextsRanges();var e=this.tokens.map(function(e){return e.char});for(var t=0;t<e.length;t++){var n=new j(e,t);this.runContextCheck(n)}this.dispatch("updateContextsRanges",[this.registeredContexts])};b.prototype.setEndOffset=function(e,t){var n=this.getContext(t).openRange.startIndex;var a=new _r(n,e,t);var i=this.getContext(t).ranges;a.rangeId=t+"."+i.length;i.push(a);this.getContext(t).openRange=null;return a};b.prototype.runContextCheck=function(r){var s=this;var o=r.index;this.contextCheckers.forEach(function(e){var t=e.contextName;var n=s.getContext(t).openRange;if(!n&&e.checkStart(r)){n=new _r(o,null,t);s.getContext(t).openRange=n;s.dispatch("contextStart",[t,o])}if(!!n&&e.checkEnd(r)){var a=o-n.startIndex+1;var i=s.setEndOffset(a,t);s.dispatch("contextEnd",[t,i])}})};b.prototype.tokenize=function(e){this.tokens=[];this.resetContextsRanges();var t=Array.from(e);this.dispatch("start");for(var n=0;n<t.length;n++){var a=t[n];var i=new j(t,n);this.dispatch("next",[i]);this.runContextCheck(i);var r=new Or(a);this.tokens.push(r);this.dispatch("newToken",[r,i])}this.dispatch("end",[this.tokens]);return this.tokens};function x(e){return/[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e)}function Ar(e){return/[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e)}function N(e){return/[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e)}function Sr(e){return/[A-z]/.test(e)}function Er(e){return/\s/.test(e)}function T(e){this.font=e;this.features={}}function Cr(e){this.id=e.id;this.tag=e.tag;this.substitution=e.substitution}function jr(e,t){if(!e){return-1}switch(t.format){case 1:return t.glyphs.indexOf(e);case 2:var n=t.ranges;for(var a=0;a<n.length;a++){var i=n[a];if(e>=i.start&&e<=i.end){var r=e-i.start;return i.index+r}}break;default:return-1}return-1}function Nr(e,t){var n=jr(e,t.coverage);if(n===-1){return null}return e+t.deltaGlyphId}function Lr(e,t){var n=jr(e,t.coverage);if(n===-1){return null}return t.substitute[n]}function Mr(e,t){var n=[];for(var a=0;a<e.length;a++){var i=e[a];var r=t.current;r=Array.isArray(r)?r[0]:r;var s=jr(r,i);if(s!==-1){n.push(s)}}if(n.length!==e.length){return-1}return n}function Rr(e,t){var n=t.inputCoverage.length+t.lookaheadCoverage.length+t.backtrackCoverage.length;if(e.context.length<n){return[]}var a=Mr(t.inputCoverage,e);if(a===-1){return[]}var i=t.inputCoverage.length-1;if(e.lookahead.length<t.lookaheadCoverage.length){return[]}var r=e.lookahead.slice(i);while(r.length&&N(r[0].char)){r.shift()}var s=new j(r,0);var o=Mr(t.lookaheadCoverage,s);var l=[].concat(e.backtrack);l.reverse();while(l.length&&N(l[0].char)){l.shift()}if(l.length<t.backtrackCoverage.length){return[]}var u=new j(l,0);var m=Mr(t.backtrackCoverage,u);var p=a.length===t.inputCoverage.length&&o.length===t.lookaheadCoverage.length&&m.length===t.backtrackCoverage.length;var c=[];if(p){for(var d=0;d<t.lookupRecords.length;d++){var h=t.lookupRecords[d];var f=h.lookupListIndex;var v=this.getLookupByIndex(f);for(var g=0;g<v.subtables.length;g++){var b=v.subtables[g];var x=this.getLookupMethod(v,b);var O=this.getSubstitutionType(v,b);if(O==="12"){for(var _=0;_<a.length;_++){var T=e.get(_);var I=x(T);if(I){c.push(I)}}}}}}return c}function Pr(e,t){var n=e.current;var a=jr(n,t.coverage);if(a===-1){return null}var i;var r=t.ligatureSets[a];for(var s=0;s<r.length;s++){i=r[s];for(var o=0;o<i.components.length;o++){var l=e.lookahead[o];var u=i.components[o];if(l!==u){break}if(o===i.components.length-1){return i}}}return null}function wr(e,t){var n=jr(e,t.coverage);if(n===-1){return null}return t.sequences[n]}T.prototype.getDefaultScriptFeaturesIndexes=function(){var e=this.font.tables.gsub.scripts;for(var t=0;t<e.length;t++){var n=e[t];if(n.tag==="DFLT"){return n.script.defaultLangSys.featureIndexes}}return[]};T.prototype.getScriptFeaturesIndexes=function(e){var t=this.font.tables;if(!t.gsub){return[]}if(!e){return this.getDefaultScriptFeaturesIndexes()}var n=this.font.tables.gsub.scripts;for(var a=0;a<n.length;a++){var i=n[a];if(i.tag===e&&i.script.defaultLangSys){return i.script.defaultLangSys.featureIndexes}else{var r=i.langSysRecords;if(!!r){for(var s=0;s<r.length;s++){var o=r[s];if(o.tag===e){var l=o.langSys;return l.featureIndexes}}}}}return this.getDefaultScriptFeaturesIndexes()};T.prototype.mapTagsToFeatures=function(e,t){var n={};for(var a=0;a<e.length;a++){var i=e[a].tag;var r=e[a].feature;n[i]=r}this.features[t].tags=n};T.prototype.getScriptFeatures=function(e){var t=this.features[e];if(this.features.hasOwnProperty(e)){return t}var n=this.getScriptFeaturesIndexes(e);if(!n){return null}var a=this.font.tables.gsub;t=n.map(function(e){return a.features[e]});this.features[e]=t;this.mapTagsToFeatures(t,e);return t};T.prototype.getSubstitutionType=function(e,t){var n=e.lookupType.toString();var a=t.substFormat.toString();return n+a};T.prototype.getLookupMethod=function(e,t){var n=this;var a=this.getSubstitutionType(e,t);switch(a){case"11":return function(e){return Nr.apply(n,[e,t])};case"12":return function(e){return Lr.apply(n,[e,t])};case"63":return function(e){return Rr.apply(n,[e,t])};case"41":return function(e){return Pr.apply(n,[e,t])};case"21":return function(e){return wr.apply(n,[e,t])};default:throw new Error("lookupType: "+e.lookupType+" - "+"substFormat: "+t.substFormat+" "+"is not yet supported")}};T.prototype.lookupFeature=function(e){var t=e.contextParams;var n=t.index;var a=this.getFeature({tag:e.tag,script:e.script});if(!a){return new Error("font '"+this.font.names.fullName.en+"' "+"doesn't support feature '"+e.tag+"' "+"for script '"+e.script+"'.")}var i=this.getFeatureLookups(a);var r=[].concat(t.context);for(var s=0;s<i.length;s++){var o=i[s];var l=this.getLookupSubtables(o);for(var u=0;u<l.length;u++){var m=l[u];var p=this.getSubstitutionType(o,m);var c=this.getLookupMethod(o,m);var d=void 0;switch(p){case"11":d=c(t.current);if(d){r.splice(n,1,new Cr({id:11,tag:e.tag,substitution:d}))}break;case"12":d=c(t.current);if(d){r.splice(n,1,new Cr({id:12,tag:e.tag,substitution:d}))}break;case"63":d=c(t);if(Array.isArray(d)&&d.length){r.splice(n,1,new Cr({id:63,tag:e.tag,substitution:d}))}break;case"41":d=c(t);if(d){r.splice(n,1,new Cr({id:41,tag:e.tag,substitution:d}))}break;case"21":d=c(t.current);if(d){r.splice(n,1,new Cr({id:21,tag:e.tag,substitution:d}))}break}t=new j(r,n);if(Array.isArray(d)&&!d.length){continue}d=null}}return r.length?r:null};T.prototype.supports=function(t){if(!t.script){return false}this.getScriptFeatures(t.script);var e=this.features.hasOwnProperty(t.script);if(!t.tag){return e}var n=this.features[t.script].some(function(e){return e.tag===t.tag});return e&&n};T.prototype.getLookupSubtables=function(e){return e.subtables||null};T.prototype.getLookupByIndex=function(e){var t=this.font.tables.gsub.lookups;return t[e]||null};T.prototype.getFeatureLookups=function(e){return e.lookupListIndexes.map(this.getLookupByIndex.bind(this))};T.prototype.getFeature=function e(t){if(!this.font){return{FAIL:"No font was found"}}if(!this.features.hasOwnProperty(t.script)){this.getScriptFeatures(t.script)}var n=this.features[t.script];if(!n){return{FAIL:"No feature for script "+t.script}}if(!n.tags[t.tag]){return null}return this.features[t.script].tags[t.tag]};function kr(e){var t=e.current;var n=e.get(-1);return n===null&&x(t)||!x(n)&&x(t)}function Fr(e){var t=e.get(1);return t===null||!x(t)}var Gr={startCheck:kr,endCheck:Fr};function Ur(e){var t=e.current;var n=e.get(-1);return(x(t)||N(t))&&!x(n)}function Br(e){var t=e.get(1);switch(true){case t===null:return true;case!x(t)&&!N(t):var n=Er(t);if(!n){return true}if(n){var a=false;a=e.lookahead.some(function(e){return x(e)||N(e)});if(!a){return true}}break;default:return false}}var Dr={startCheck:Ur,endCheck:Br};function Vr(e,t,n){t[n].setState(e.tag,e.substitution)}function zr(e,t,n){t[n].setState(e.tag,e.substitution)}function Xr(a,i,r){a.substitution.forEach(function(e,t){var n=i[r+t];n.setState(a.tag,e)})}function qr(e,t,n){var a=t[n];a.setState(e.tag,e.substitution.ligGlyph);var i=e.substitution.components.length;for(var r=0;r<i;r++){a=t[n+r+1];a.setState("deleted",true)}}var Hr={11:Vr,12:zr,63:Xr,41:qr};function Yr(e,t,n){if(e instanceof Cr&&Hr[e.id]){Hr[e.id](e,t,n)}}function Wr(e){var t=[].concat(e.backtrack);for(var n=t.length-1;n>=0;n--){var a=t[n];var i=Ar(a);var r=N(a);if(!i&&!r){return true}if(i){return false}}return false}function Zr(e){if(Ar(e.current)){return false}for(var t=0;t<e.lookahead.length;t++){var n=e.lookahead[t];var a=N(n);if(!a){return true}}return false}function Kr(e){var r=this;var s="arab";var o=this.featuresTags[s];var l=this.tokenizer.getRangeTokens(e);if(l.length===1){return}var u=new j(l.map(function(e){return e.getState("glyphIndex")}),0);var m=new j(l.map(function(e){return e.char}),0);l.forEach(function(e,t){if(N(e.char)){return}u.setCurrentIndex(t);m.setCurrentIndex(t);var n=0;if(Wr(m)){n|=1}if(Zr(m)){n|=2}var a;switch(n){case 1:a="fina";break;case 2:a="init";break;case 3:a="medi";break}if(o.indexOf(a)===-1){return}var i=r.query.lookupFeature({tag:a,script:s,contextParams:u});if(i instanceof Error){return console.info(i.message)}i.forEach(function(e,t){if(e instanceof Cr){Yr(e,l,t);u.context[t]=e.substitution}})})}function Jr(e,t){var n=e.map(function(e){return e.activeState.value});return new j(n,t||0)}function Qr(e){var a=this;var i="arab";var r=this.tokenizer.getRangeTokens(e);var s=Jr(r);s.context.forEach(function(e,t){s.setCurrentIndex(t);var n=a.query.lookupFeature({tag:"rlig",script:i,contextParams:s});if(n.length){n.forEach(function(e){return Yr(e,r,t)});s=Jr(r)}})}function $r(e){var t=e.current;var n=e.get(-1);return n===null&&Sr(t)||!Sr(n)&&Sr(t)}function es(e){var t=e.get(1);return t===null||!Sr(t)}var ts={startCheck:$r,endCheck:es};function ns(e,t){var n=e.map(function(e){return e.activeState.value});return new j(n,t||0)}function as(e){var a=this;var i="latn";var r=this.tokenizer.getRangeTokens(e);var s=ns(r);s.context.forEach(function(e,t){s.setCurrentIndex(t);var n=a.query.lookupFeature({tag:"liga",script:i,contextParams:s});if(n.length){n.forEach(function(e){return Yr(e,r,t)});s=ns(r)}})}function L(e){this.baseDir=e||"ltr";this.tokenizer=new b;this.featuresTags={}}L.prototype.setText=function(e){this.text=e};L.prototype.contextChecks={latinWordCheck:ts,arabicWordCheck:Gr,arabicSentenceCheck:Dr};function is(e){var t=this.contextChecks[e+"Check"];return this.tokenizer.registerContextChecker(e,t.startCheck,t.endCheck)}function rs(){is.call(this,"latinWord");is.call(this,"arabicWord");is.call(this,"arabicSentence");return this.tokenizer.tokenize(this.text)}function ss(){var n=this;var e=this.tokenizer.getContextRanges("arabicSentence");e.forEach(function(e){var t=n.tokenizer.getRangeTokens(e);n.tokenizer.replaceRange(e.startIndex,e.endOffset,t.reverse())})}L.prototype.registerFeatures=function(t,e){var n=this;var a=e.filter(function(e){return n.query.supports({script:t,tag:e})});if(!this.featuresTags.hasOwnProperty(t)){this.featuresTags[t]=a}else{this.featuresTags[t]=this.featuresTags[t].concat(a)}};L.prototype.applyFeatures=function(e,t){if(!e){throw new Error("No valid font was provided to apply features")}if(!this.query){this.query=new T(e)}for(var n=0;n<t.length;n++){var a=t[n];if(!this.query.supports({script:a.script})){continue}this.registerFeatures(a.script,a.tags)}};L.prototype.registerModifier=function(e,t,n){this.tokenizer.registerModifier(e,t,n)};function os(){if(this.tokenizer.registeredModifiers.indexOf("glyphIndex")===-1){throw new Error("glyphIndex modifier is required to apply "+"arabic presentation features.")}}function ls(){var t=this;var e="arab";if(!this.featuresTags.hasOwnProperty(e)){return}os.call(this);var n=this.tokenizer.getContextRanges("arabicWord");n.forEach(function(e){Kr.call(t,e)})}function us(){var t=this;var e="arab";if(!this.featuresTags.hasOwnProperty(e)){return}var n=this.featuresTags[e];if(n.indexOf("rlig")===-1){return}os.call(this);var a=this.tokenizer.getContextRanges("arabicWord");a.forEach(function(e){Qr.call(t,e)})}function ms(){var t=this;var e="latn";if(!this.featuresTags.hasOwnProperty(e)){return}var n=this.featuresTags[e];if(n.indexOf("liga")===-1){return}os.call(this);var a=this.tokenizer.getContextRanges("latinWord");a.forEach(function(e){as.call(t,e)})}L.prototype.checkContextReady=function(e){return!!this.tokenizer.getContext(e)};L.prototype.applyFeaturesToContexts=function(){if(this.checkContextReady("arabicWord")){ls.call(this);us.call(this)}if(this.checkContextReady("latinWord")){ms.call(this)}if(this.checkContextReady("arabicSentence")){ss.call(this)}};L.prototype.processText=function(e){if(!this.text||this.text!==e){this.setText(e);rs.call(this);this.applyFeaturesToContexts()}};L.prototype.getBidiText=function(e){this.processText(e);return this.tokenizer.getText()};L.prototype.getTextGlyphs=function(e){this.processText(e);var t=[];for(var n=0;n<this.tokenizer.tokens.length;n++){var a=this.tokenizer.tokens[n];if(a.state.deleted){continue}var i=a.activeState.value;t.push(Array.isArray(i)?i[0]:i)}return t};function U(e){e=e||{};e.tables=e.tables||{};if(!e.empty){aa(e.familyName,"When creating a new Font object, familyName is required.");aa(e.styleName,"When creating a new Font object, styleName is required.");aa(e.unitsPerEm,"When creating a new Font object, unitsPerEm is required.");aa(e.ascender,"When creating a new Font object, ascender is required.");aa(e.descender<=0,"When creating a new Font object, negative descender value is required.");this.names={fontFamily:{en:e.familyName||" "},fontSubfamily:{en:e.styleName||" "},fullName:{en:e.fullName||e.familyName+" "+e.styleName},postScriptName:{en:e.postScriptName||(e.familyName+e.styleName).replace(/\s/g,"")},designer:{en:e.designer||" "},designerURL:{en:e.designerURL||" "},manufacturer:{en:e.manufacturer||" "},manufacturerURL:{en:e.manufacturerURL||" "},license:{en:e.license||" "},licenseURL:{en:e.licenseURL||" "},version:{en:e.version||"Version 0.1"},description:{en:e.description||" "},copyright:{en:e.copyright||" "},trademark:{en:e.trademark||" "}};this.unitsPerEm=e.unitsPerEm||1e3;this.ascender=e.ascender;this.descender=e.descender;this.createdTimestamp=e.createdTimestamp;this.tables=Object.assign(e.tables,{os2:Object.assign({usWeightClass:e.weightClass||this.usWeightClasses.MEDIUM,usWidthClass:e.widthClass||this.usWidthClasses.MEDIUM,fsSelection:e.fsSelection||this.fsSelectionValues.REGULAR},e.tables.os2)})}this.supported=true;this.glyphs=new y.GlyphSet(this,e.glyphs||[]);this.encoding=new We(this);this.position=new Jn(this);this.substitution=new t(this);this.tables=this.tables||{};this._push=null;this._hmtxTableData={};Object.defineProperty(this,"hinting",{get:function(){if(this._hinting){return this._hinting}if(this.outlinesFormat==="truetype"){return this._hinting=new ba(this)}}})}U.prototype.hasChar=function(e){return this.encoding.charToGlyphIndex(e)!==null};U.prototype.charToGlyphIndex=function(e){return this.encoding.charToGlyphIndex(e)};U.prototype.charToGlyph=function(e){var t=this.charToGlyphIndex(e);var n=this.glyphs.get(t);if(!n){n=this.glyphs.get(0)}return n};U.prototype.updateFeatures=function(t){return this.defaultRenderOptions.features.map(function(e){if(e.script==="latn"){return{script:"latn",tags:e.tags.filter(function(e){return t[e]})}}else{return e}})};U.prototype.stringToGlyphs=function(e,t){var n=this;var a=new L;var i=function(e){return n.charToGlyphIndex(e.char)};a.registerModifier("glyphIndex",null,i);var r=t?this.updateFeatures(t.features):this.defaultRenderOptions.features;a.applyFeatures(this,r);var s=a.getTextGlyphs(e);var o=s.length;var l=new Array(o);var u=this.glyphs.get(0);for(var m=0;m<o;m+=1){l[m]=this.glyphs.get(s[m])||u}return l};U.prototype.nameToGlyphIndex=function(e){return this.glyphNames.nameToGlyphIndex(e)};U.prototype.nameToGlyph=function(e){var t=this.nameToGlyphIndex(e);var n=this.glyphs.get(t);if(!n){n=this.glyphs.get(0)}return n};U.prototype.glyphIndexToName=function(e){if(!this.glyphNames.glyphIndexToName){return""}return this.glyphNames.glyphIndexToName(e)};U.prototype.getKerningValue=function(e,t){e=e.index||e;t=t.index||t;var n=this.position.defaultKerningTables;if(n){return this.position.getKerningValue(n,e,t)}return this.kerningPairs[e+","+t]||0};U.prototype.defaultRenderOptions={kerning:true,features:[{script:"arab",tags:["init","medi","fina","rlig"]},{script:"latn",tags:["liga","rlig"]}]};U.prototype.forEachGlyph=function(e,t,n,a,i,r){t=t!==undefined?t:0;n=n!==undefined?n:0;a=a!==undefined?a:72;i=Object.assign({},this.defaultRenderOptions,i);var s=1/this.unitsPerEm*a;var o=this.stringToGlyphs(e,i);var l;if(i.kerning){var u=i.script||this.position.getDefaultScriptName();l=this.position.getKerningTables(u,i.language)}for(var m=0;m<o.length;m+=1){var p=o[m];r.call(this,p,t,n,a,i);if(p.advanceWidth){t+=p.advanceWidth*s}if(i.kerning&&m<o.length-1){var c=l?this.position.getKerningValue(l,p.index,o[m+1].index):this.getKerningValue(p,o[m+1]);t+=c*s}if(i.letterSpacing){t+=i.letterSpacing*a}else if(i.tracking){t+=i.tracking/1e3*a}}return t};U.prototype.getPath=function(e,t,n,a,r){var s=new h;this.forEachGlyph(e,t,n,a,r,function(e,t,n,a){var i=e.getPath(t,n,a,r,this);s.extend(i)});return s};U.prototype.getPaths=function(e,t,n,a,r){var s=[];this.forEachGlyph(e,t,n,a,r,function(e,t,n,a){var i=e.getPath(t,n,a,r,this);s.push(i)});return s};U.prototype.getAdvanceWidth=function(e,t,n){return this.forEachGlyph(e,0,0,t,n,function(){})};U.prototype.draw=function(e,t,n,a,i,r){this.getPath(t,n,a,i,r).draw(e)};U.prototype.drawPoints=function(i,e,t,n,a,r){this.forEachGlyph(e,t,n,a,r,function(e,t,n,a){e.drawPoints(i,t,n,a)})};U.prototype.drawMetrics=function(i,e,t,n,a,r){this.forEachGlyph(e,t,n,a,r,function(e,t,n,a){e.drawMetrics(i,t,n,a)})};U.prototype.getEnglishName=function(e){var t=this.names[e];if(t){return t.en}};U.prototype.validate=function(){var n=this;function a(e,t){}function e(e){var t=n.getEnglishName(e);a(t&&t.trim().length>0)}e("fontFamily");e("weightName");e("manufacturer");e("copyright");e("version");a(this.unitsPerEm>0)};U.prototype.toTables=function(){return Hn.fontToTable(this)};U.prototype.toBuffer=function(){console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");return this.toArrayBuffer()};U.prototype.toArrayBuffer=function(){var e=this.toTables();var t=e.encode();var n=new ArrayBuffer(t.length);var a=new Uint8Array(n);for(var i=0;i<t.length;i++){a[i]=t[i]}return n};U.prototype.download=function(e){var t=this.getEnglishName("fontFamily");var n=this.getEnglishName("fontSubfamily");e=e||t.replace(/\s/g,"")+"-"+n+".otf";var a=this.toArrayBuffer();if(ea()){window.URL=window.URL||window.webkitURL;if(window.URL){var i=new DataView(a);var r=new Blob([i],{type:"font/opentype"});var s=document.createElement("a");s.href=window.URL.createObjectURL(r);s.download=e;var o=document.createEvent("MouseEvents");o.initEvent("click",true,false);s.dispatchEvent(o)}else{console.warn("Font file could not be downloaded. Try using a different browser.")}}else{var l=require("fs");var u=na(a);l.writeFileSync(e,u)}};U.prototype.fsSelectionValues={ITALIC:1,UNDERSCORE:2,NEGATIVE:4,OUTLINED:8,STRIKEOUT:16,BOLD:32,REGULAR:64,USER_TYPO_METRICS:128,WWS:256,OBLIQUE:512};U.prototype.usWidthClasses={ULTRA_CONDENSED:1,EXTRA_CONDENSED:2,CONDENSED:3,SEMI_CONDENSED:4,MEDIUM:5,SEMI_EXPANDED:6,EXPANDED:7,EXTRA_EXPANDED:8,ULTRA_EXPANDED:9};U.prototype.usWeightClasses={THIN:100,EXTRA_LIGHT:200,LIGHT:300,NORMAL:400,MEDIUM:500,SEMI_BOLD:600,BOLD:700,EXTRA_BOLD:800,BLACK:900};function ps(e,t){var n=JSON.stringify(e);var a=256;for(var i in t){var r=parseInt(i);if(!r||r<256){continue}if(JSON.stringify(t[i])===n){return r}if(a<=r){a=r+1}}t[a]=e;return a}function cs(e,t,n){var a=ps(t.name,n);return[{name:"tag_"+e,type:"TAG",value:t.tag},{name:"minValue_"+e,type:"FIXED",value:t.minValue<<16},{name:"defaultValue_"+e,type:"FIXED",value:t.defaultValue<<16},{name:"maxValue_"+e,type:"FIXED",value:t.maxValue<<16},{name:"flags_"+e,type:"USHORT",value:0},{name:"nameID_"+e,type:"USHORT",value:a}]}function ds(e,t,n){var a={};var i=new G.Parser(e,t);a.tag=i.parseTag();a.minValue=i.parseFixed();a.defaultValue=i.parseFixed();a.maxValue=i.parseFixed();i.skip("uShort",1);a.name=n[i.parseUShort()]||{};return a}function hs(e,t,n,a){var i=ps(t.name,a);var r=[{name:"nameID_"+e,type:"USHORT",value:i},{name:"flags_"+e,type:"USHORT",value:0}];for(var s=0;s<n.length;++s){var o=n[s].tag;r.push({name:"axis_"+e+" "+o,type:"FIXED",value:t.coordinates[o]<<16})}return r}function fs(e,t,n,a){var i={};var r=new G.Parser(e,t);i.name=a[r.parseUShort()]||{};r.skip("uShort",1);i.coordinates={};for(var s=0;s<n.length;++s){i.coordinates[n[s].tag]=r.parseFixed()}return i}function vs(e,t){var n=new C.Table("fvar",[{name:"version",type:"ULONG",value:65536},{name:"offsetToData",type:"USHORT",value:0},{name:"countSizePairs",type:"USHORT",value:2},{name:"axisCount",type:"USHORT",value:e.axes.length},{name:"axisSize",type:"USHORT",value:20},{name:"instanceCount",type:"USHORT",value:e.instances.length},{name:"instanceSize",type:"USHORT",value:4+e.axes.length*4}]);n.offsetToData=n.sizeOf();for(var a=0;a<e.axes.length;a++){n.fields=n.fields.concat(cs(a,e.axes[a],t))}for(var i=0;i<e.instances.length;i++){n.fields=n.fields.concat(hs(i,e.instances[i],e.axes,t))}return n}function gs(e,t,n){var a=new G.Parser(e,t);var i=a.parseULong();I.argument(i===65536,"Unsupported fvar table version.");var r=a.parseOffset16();a.skip("uShort",1);var s=a.parseUShort();var o=a.parseUShort();var l=a.parseUShort();var u=a.parseUShort();var m=[];for(var p=0;p<s;p++){m.push(ds(e,t+r+p*o,n))}var c=[];var d=t+r+s*o;for(var h=0;h<l;h++){c.push(fs(e,d+h*u,m,n))}return{axes:m,instances:c}}var bs={make:vs,parse:gs};var xs=function(){return{coverage:this.parsePointer(m.coverage),attachPoints:this.parseList(m.pointer(m.uShortList))}};var Os=function(){var e=this.parseUShort();I.argument(e===1||e===2||e===3,"Unsupported CaretValue table version.");if(e===1){return{coordinate:this.parseShort()}}else if(e===2){return{pointindex:this.parseShort()}}else if(e===3){return{coordinate:this.parseShort()}}};var _s=function(){return this.parseList(m.pointer(Os))};var Ts=function(){return{coverage:this.parsePointer(m.coverage),ligGlyphs:this.parseList(m.pointer(_s))}};var Is=function(){this.parseUShort();return this.parseList(m.pointer(m.coverage))};function ys(e,t){t=t||0;var n=new m(e,t);var a=n.parseVersion(1);I.argument(a===1||a===1.2||a===1.3,"Unsupported GDEF table version.");var i={version:a,classDef:n.parsePointer(m.classDef),attachList:n.parsePointer(xs),ligCaretList:n.parsePointer(Ts),markAttachClassDef:n.parsePointer(m.classDef)};if(a>=1.2){i.markGlyphSets=n.parsePointer(Is)}return i}var As={parse:ys};var M=new Array(10);M[1]=function e(){var t=this.offset+this.relativeOffset;var n=this.parseUShort();if(n===1){return{posFormat:1,coverage:this.parsePointer(m.coverage),value:this.parseValueRecord()}}else if(n===2){return{posFormat:2,coverage:this.parsePointer(m.coverage),values:this.parseValueRecordList()}}I.assert(false,"0x"+t.toString(16)+": GPOS lookup type 1 format must be 1 or 2.")};M[2]=function e(){var t=this.offset+this.relativeOffset;var n=this.parseUShort();I.assert(n===1||n===2,"0x"+t.toString(16)+": GPOS lookup type 2 format must be 1 or 2.");var a=this.parsePointer(m.coverage);var i=this.parseUShort();var r=this.parseUShort();if(n===1){return{posFormat:n,coverage:a,valueFormat1:i,valueFormat2:r,pairSets:this.parseList(m.pointer(m.list(function(){return{secondGlyph:this.parseUShort(),value1:this.parseValueRecord(i),value2:this.parseValueRecord(r)}})))}}else if(n===2){var s=this.parsePointer(m.classDef);var o=this.parsePointer(m.classDef);var l=this.parseUShort();var u=this.parseUShort();return{posFormat:n,coverage:a,valueFormat1:i,valueFormat2:r,classDef1:s,classDef2:o,class1Count:l,class2Count:u,classRecords:this.parseList(l,m.list(u,function(){return{value1:this.parseValueRecord(i),value2:this.parseValueRecord(r)}}))}}};M[3]=function e(){return{error:"GPOS Lookup 3 not supported"}};M[4]=function e(){return{error:"GPOS Lookup 4 not supported"}};M[5]=function e(){return{error:"GPOS Lookup 5 not supported"}};M[6]=function e(){return{error:"GPOS Lookup 6 not supported"}};M[7]=function e(){return{error:"GPOS Lookup 7 not supported"}};M[8]=function e(){return{error:"GPOS Lookup 8 not supported"}};M[9]=function e(){return{error:"GPOS Lookup 9 not supported"}};function Ss(e,t){t=t||0;var n=new m(e,t);var a=n.parseVersion(1);I.argument(a===1||a===1.1,"Unsupported GPOS table version "+a);if(a===1){return{version:a,scripts:n.parseScriptList(),features:n.parseFeatureList(),lookups:n.parseLookupList(M)}}else{return{version:a,scripts:n.parseScriptList(),features:n.parseFeatureList(),lookups:n.parseLookupList(M),variations:n.parseFeatureVariationsList()}}}var Es=new Array(10);function Cs(e){return new C.Table("GPOS",[{name:"version",type:"ULONG",value:65536},{name:"scripts",type:"TABLE",value:new C.ScriptList(e.scripts)},{name:"features",type:"TABLE",value:new C.FeatureList(e.features)},{name:"lookups",type:"TABLE",value:new C.LookupList(e.lookups,Es)}])}var js={parse:Ss,make:Cs};function Ns(e){var t={};e.skip("uShort");var n=e.parseUShort();I.argument(n===0,"Unsupported kern sub-table version.");e.skip("uShort",2);var a=e.parseUShort();e.skip("uShort",3);for(var i=0;i<a;i+=1){var r=e.parseUShort();var s=e.parseUShort();var o=e.parseShort();t[r+","+s]=o}return t}function Ls(e){var t={};e.skip("uShort");var n=e.parseULong();if(n>1){console.warn("Only the first kern subtable is supported.")}e.skip("uLong");var a=e.parseUShort();var i=a&255;e.skip("uShort");if(i===0){var r=e.parseUShort();e.skip("uShort",3);for(var s=0;s<r;s+=1){var o=e.parseUShort();var l=e.parseUShort();var u=e.parseShort();t[o+","+l]=u}}return t}function Ms(e,t){var n=new G.Parser(e,t);var a=n.parseUShort();if(a===0){return Ns(n)}else if(a===1){return Ls(n)}else{throw new Error("Unsupported kern table version ("+a+").")}}var Rs={parse:Ms};function Ps(e,t,n,a){var i=new G.Parser(e,t);var r=a?i.parseUShort:i.parseULong;var s=[];for(var o=0;o<n+1;o+=1){var l=r.call(i);if(a){l*=2}s.push(l)}return s}var ws={parse:Ps};function ks(e,n){var t=require("fs");t.readFile(e,function(e,t){if(e){return n(e.message)}n(null,ta(t))})}function Fs(e,t){var n=new XMLHttpRequest;n.open("get",e,true);n.responseType="arraybuffer";n.onload=function(){if(n.response){return t(null,n.response)}else{return t("Font could not be loaded: "+n.statusText)}};n.onerror=function(){t("Font could not be loaded")};n.send()}function Gs(e,t){var n=[];var a=12;for(var i=0;i<t;i+=1){var r=G.getTag(e,a);var s=G.getULong(e,a+4);var o=G.getULong(e,a+8);var l=G.getULong(e,a+12);n.push({tag:r,checksum:s,offset:o,length:l,compression:false});a+=16}return n}function Us(e,t){var n=[];var a=44;for(var i=0;i<t;i+=1){var r=G.getTag(e,a);var s=G.getULong(e,a+4);var o=G.getULong(e,a+8);var l=G.getULong(e,a+12);var u=void 0;if(o<l){u="WOFF"}else{u=false}n.push({tag:r,offset:s,compression:u,compressedLength:o,length:l});a+=20}return n}function B(e,t){if(t.compression==="WOFF"){var n=new Uint8Array(e.buffer,t.offset+2,t.compressedLength-2);var a=new Uint8Array(t.length);ie(n,a);if(a.byteLength!==t.length){throw new Error("Decompression error: "+t.tag+" decompressed length doesn't match recorded length")}var i=new DataView(a.buffer,0);return{data:i,offset:0}}else{return{data:e,offset:t.offset}}}function Bs(e,t){t=t===undefined||t===null?{}:t;var n;var a;var i=new U({empty:true});var r=new DataView(e,0);var s;var o=[];var l=G.getTag(r,0);if(l===String.fromCharCode(0,1,0,0)||l==="true"||l==="typ1"){i.outlinesFormat="truetype";s=G.getUShort(r,4);o=Gs(r,s)}else if(l==="OTTO"){i.outlinesFormat="cff";s=G.getUShort(r,4);o=Gs(r,s)}else if(l==="wOFF"){var u=G.getTag(r,4);if(u===String.fromCharCode(0,1,0,0)){i.outlinesFormat="truetype"}else if(u==="OTTO"){i.outlinesFormat="cff"}else{throw new Error("Unsupported OpenType flavor "+l)}s=G.getUShort(r,12);o=Us(r,s)}else{throw new Error("Unsupported OpenType signature "+l)}var m;var p;var c;var d;var h;var f;var v;var g;var b;var x;var O;var _;for(var T=0;T<s;T+=1){var I=o[T];var y=void 0;switch(I.tag){case"cmap":y=B(r,I);i.tables.cmap=Xe.parse(y.data,y.offset);i.encoding=new Ze(i.tables.cmap);break;case"cvt ":y=B(r,I);_=new G.Parser(y.data,y.offset);i.tables.cvt=_.parseShortList(I.length/2);break;case"fvar":p=I;break;case"fpgm":y=B(r,I);_=new G.Parser(y.data,y.offset);i.tables.fpgm=_.parseByteList(I.length);break;case"head":y=B(r,I);i.tables.head=qt.parse(y.data,y.offset);i.unitsPerEm=i.tables.head.unitsPerEm;n=i.tables.head.indexToLocFormat;break;case"hhea":y=B(r,I);i.tables.hhea=Wt.parse(y.data,y.offset);i.ascender=i.tables.hhea.ascender;i.descender=i.tables.hhea.descender;i.numberOfHMetrics=i.tables.hhea.numberOfHMetrics;break;case"hmtx":v=I;break;case"ltag":y=B(r,I);a=nn.parse(y.data,y.offset);break;case"maxp":y=B(r,I);i.tables.maxp=sn.parse(y.data,y.offset);i.numGlyphs=i.tables.maxp.numGlyphs;break;case"name":x=I;break;case"OS/2":y=B(r,I);i.tables.os2=En.parse(y.data,y.offset);break;case"post":y=B(r,I);i.tables.post=Nn.parse(y.data,y.offset);i.glyphNames=new Je(i.tables.post);break;case"prep":y=B(r,I);_=new G.Parser(y.data,y.offset);i.tables.prep=_.parseByteList(I.length);break;case"glyf":c=I;break;case"loca":b=I;break;case"CFF ":m=I;break;case"kern":g=I;break;case"GDEF":d=I;break;case"GPOS":h=I;break;case"GSUB":f=I;break;case"meta":O=I;break}}var A=B(r,x);i.tables.name=Tn.parse(A.data,A.offset,a);i.names=i.tables.name;if(c&&b){var k=n===0;var S=B(r,b);var F=ws.parse(S.data,S.offset,i.numGlyphs,k);var E=B(r,c);i.glyphs=da.parse(E.data,E.offset,F,i,t)}else if(m){var C=B(r,m);Vt.parse(C.data,C.offset,i,t)}else{throw new Error("Font doesn't contain TrueType or CFF outlines.")}var j=B(r,v);$t.parse(i,j.data,j.offset,i.numberOfHMetrics,i.numGlyphs,i.glyphs,t);et(i,t);if(g){var N=B(r,g);i.kerningPairs=Rs.parse(N.data,N.offset)}else{i.kerningPairs={}}if(d){var L=B(r,d);i.tables.gdef=As.parse(L.data,L.offset)}if(h){var M=B(r,h);i.tables.gpos=js.parse(M.data,M.offset);i.position.init()}if(f){var R=B(r,f);i.tables.gsub=wn.parse(R.data,R.offset)}if(p){var P=B(r,p);i.tables.fvar=bs.parse(P.data,P.offset,i.names)}if(O){var w=B(r,O);i.tables.meta=Gn.parse(w.data,w.offset);i.metas=i.tables.meta}return i}function Ds(e,r,s){s=s===undefined||s===null?{}:s;var t=typeof window==="undefined";var n=t&&!s.isUrl?ks:Fs;return new Promise(function(a,i){n(e,function(e,t){if(e){if(r){return r(e)}else{i(e)}}var n;try{n=Bs(t,s)}catch(e){if(r){return r(e,null)}else{i(e)}}if(r){return r(null,n)}else{a(n)}})})}function Vs(e,t){var n=require("fs");var a=n.readFileSync(e);return Bs(ta(a),t)}var zs=Object.freeze({__proto__:null,Font:U,Glyph:f,Path:h,BoundingBox:o,_parse:G,parse:Bs,load:Ds,loadSync:Vs});A.BoundingBox=o;A.Font=U;A.Glyph=f;A.Path=h;A._parse=G;A.default=zs;A.load=Ds;A.loadSync=Vs;A.parse=Bs;Object.defineProperty(A,"__esModule",{value:true})});(function(e){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=e()}else if(typeof define==="function"&&define.amd){define([],e)}else{var t;if(typeof window!=="undefined"){t=window}else if(typeof global!=="undefined"){t=global}else if(typeof self!=="undefined"){t=self}else{t=this}t.earcut=e()}})(function(){var e,t,n;return function(){function m(r,s,o){function l(n,e){if(!s[n]){if(!r[n]){var t="function"==typeof require&&require;if(!e&&t)return t(n,!0);if(u)return u(n,!0);var a=new Error("Cannot find module '"+n+"'");throw a.code="MODULE_NOT_FOUND",a}var i=s[n]={exports:{}};r[n][0].call(i.exports,function(e){var t=r[n][1][e];return l(t||e)},i,i.exports,m,r,s,o)}return s[n].exports}for(var u="function"==typeof require&&require,e=0;e<o.length;e++)l(o[e]);return l}return m}()({1:[function(e,t,n){"use strict";t.exports=a;t.exports.default=a;function a(e,t,n){n=n||2;var a=t&&t.length,i=a?t[0]*n:e.length,r=f(e,0,i,n,true),s=[];if(!r||r.next===r.prev)return s;var o,l,u,m,p,c,d;if(a)r=g(e,t,r,n);if(e.length>80*n){o=u=e[0];l=m=e[1];for(var h=n;h<i;h+=n){p=e[h];c=e[h+1];if(p<o)o=p;if(c<l)l=c;if(p>u)u=p;if(c>m)m=c}d=Math.max(u-o,m-l);d=d!==0?1/d:0}v(r,s,n,o,l,d);return s}function f(e,t,n,a,i){var r,s;if(i===P(e,t,n,a)>0){for(r=t;r<n;r+=a)s=L(r,e[r],e[r+1],s)}else{for(r=n-a;r>=t;r-=a)s=L(r,e[r],e[r+1],s)}if(s&&o(s,s.next)){M(s);s=s.next}return s}function m(e,t){if(!e)return e;if(!t)t=e;var n=e,a;do{a=false;if(!n.steiner&&(o(n,n.next)||A(n.prev,n,n.next)===0)){M(n);n=t=n.prev;if(n===n.next)break;a=true}else{n=n.next}}while(a||n!==t);return t}function v(e,t,n,a,i,r,s){if(!e)return;if(!s&&r)_(e,a,i,r);var o=e,l,u;while(e.prev!==e.next){l=e.prev;u=e.next;if(r?c(e,a,i,r):p(e)){t.push(l.i/n);t.push(e.i/n);t.push(u.i/n);M(e);e=u.next;o=u.next;continue}e=u;if(e===o){if(!s){v(m(e),t,n,a,i,r,1)}else if(s===1){e=d(m(e),t,n);v(e,t,n,a,i,r,2)}else if(s===2){h(e,t,n,a,i,r)}break}}}function p(e){var t=e.prev,n=e,a=e.next;if(A(t,n,a)>=0)return false;var i=e.next.next;while(i!==e.prev){if(y(t.x,t.y,n.x,n.y,a.x,a.y,i.x,i.y)&&A(i.prev,i,i.next)>=0)return false;i=i.next}return true}function c(e,t,n,a){var i=e.prev,r=e,s=e.next;if(A(i,r,s)>=0)return false;var o=i.x<r.x?i.x<s.x?i.x:s.x:r.x<s.x?r.x:s.x,l=i.y<r.y?i.y<s.y?i.y:s.y:r.y<s.y?r.y:s.y,u=i.x>r.x?i.x>s.x?i.x:s.x:r.x>s.x?r.x:s.x,m=i.y>r.y?i.y>s.y?i.y:s.y:r.y>s.y?r.y:s.y;var p=T(o,l,t,n,a),c=T(u,m,t,n,a);var d=e.prevZ,h=e.nextZ;while(d&&d.z>=p&&h&&h.z<=c){if(d!==e.prev&&d!==e.next&&y(i.x,i.y,r.x,r.y,s.x,s.y,d.x,d.y)&&A(d.prev,d,d.next)>=0)return false;d=d.prevZ;if(h!==e.prev&&h!==e.next&&y(i.x,i.y,r.x,r.y,s.x,s.y,h.x,h.y)&&A(h.prev,h,h.next)>=0)return false;h=h.nextZ}while(d&&d.z>=p){if(d!==e.prev&&d!==e.next&&y(i.x,i.y,r.x,r.y,s.x,s.y,d.x,d.y)&&A(d.prev,d,d.next)>=0)return false;d=d.prevZ}while(h&&h.z<=c){if(h!==e.prev&&h!==e.next&&y(i.x,i.y,r.x,r.y,s.x,s.y,h.x,h.y)&&A(h.prev,h,h.next)>=0)return false;h=h.nextZ}return true}function d(e,t,n){var a=e;do{var i=a.prev,r=a.next.next;if(!o(i,r)&&l(i,a,a.next,r)&&C(i,r)&&C(r,i)){t.push(i.i/n);t.push(a.i/n);t.push(r.i/n);M(a);M(a.next);a=e=r}a=a.next}while(a!==e);return m(a)}function h(e,t,n,a,i,r){var s=e;do{var o=s.next.next;while(o!==s.prev){if(s.i!==o.i&&u(s,o)){var l=N(s,o);s=m(s,s.next);l=m(l,l.next);v(s,t,n,a,i,r);v(l,t,n,a,i,r);return}o=o.next}s=s.next}while(s!==e)}function g(e,t,n,a){var i=[],r,s,o,l,u;for(r=0,s=t.length;r<s;r++){o=t[r]*a;l=r<s-1?t[r+1]*a:e.length;u=f(e,o,l,a,false);if(u===u.next)u.steiner=true;i.push(I(u))}i.sort(b);for(r=0;r<i.length;r++){n=x(i[r],n);n=m(n,n.next)}return n}function b(e,t){return e.x-t.x}function x(e,t){var n=r(e,t);if(!n){return t}var a=N(n,e);var i=m(n,n.next);m(a,a.next);return t===n?i:t}function r(e,t){var n=t,a=e.x,i=e.y,r=-Infinity,s;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){var o=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(o<=a&&o>r){r=o;if(o===a){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!s)return null;if(a===r)return s;var l=s,u=s.x,m=s.y,p=Infinity,c;n=s;do{if(a>=n.x&&n.x>=u&&a!==n.x&&y(i<m?a:r,i,u,m,i<m?r:a,i,n.x,n.y)){c=Math.abs(i-n.y)/(a-n.x);if(C(n,e)&&(c<p||c===p&&(n.x>s.x||n.x===s.x&&O(s,n)))){s=n;p=c}}n=n.next}while(n!==l);return s}function O(e,t){return A(e.prev,e,t.prev)<0&&A(t.next,e,e.next)<0}function _(e,t,n,a){var i=e;do{if(i.z===null)i.z=T(i.x,i.y,t,n,a);i.prevZ=i.prev;i.nextZ=i.next;i=i.next}while(i!==e);i.prevZ.nextZ=null;i.prevZ=null;s(i)}function s(e){var t,n,a,i,r,s,o,l,u=1;do{n=e;e=null;r=null;s=0;while(n){s++;a=n;o=0;for(t=0;t<u;t++){o++;a=a.nextZ;if(!a)break}l=u;while(o>0||l>0&&a){if(o!==0&&(l===0||!a||n.z<=a.z)){i=n;n=n.nextZ;o--}else{i=a;a=a.nextZ;l--}if(r)r.nextZ=i;else e=i;i.prevZ=r;r=i}n=a}r.nextZ=null;u*=2}while(s>1);return e}function T(e,t,n,a,i){e=32767*(e-n)*i;t=32767*(t-a)*i;e=(e|e<<8)&16711935;e=(e|e<<4)&252645135;e=(e|e<<2)&858993459;e=(e|e<<1)&1431655765;t=(t|t<<8)&16711935;t=(t|t<<4)&252645135;t=(t|t<<2)&858993459;t=(t|t<<1)&1431655765;return e|t<<1}function I(e){var t=e,n=e;do{if(t.x<n.x||t.x===n.x&&t.y<n.y)n=t;t=t.next}while(t!==e);return n}function y(e,t,n,a,i,r,s,o){return(i-s)*(t-o)-(e-s)*(r-o)>=0&&(e-s)*(a-o)-(n-s)*(t-o)>=0&&(n-s)*(r-o)-(i-s)*(a-o)>=0}function u(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!i(e,t)&&(C(e,t)&&C(t,e)&&j(e,t)&&(A(e.prev,e,t.prev)||A(e,t.prev,t))||o(e,t)&&A(e.prev,e,e.next)>0&&A(t.prev,t,t.next)>0)}function A(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function o(e,t){return e.x===t.x&&e.y===t.y}function l(e,t,n,a){var i=E(A(e,t,n));var r=E(A(e,t,a));var s=E(A(n,a,e));var o=E(A(n,a,t));if(i!==r&&s!==o)return true;if(i===0&&S(e,n,t))return true;if(r===0&&S(e,a,t))return true;if(s===0&&S(n,e,a))return true;if(o===0&&S(n,t,a))return true;return false}function S(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function E(e){return e>0?1:e<0?-1:0}function i(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&l(n,n.next,e,t))return true;n=n.next}while(n!==e);return false}function C(e,t){return A(e.prev,e,e.next)<0?A(e,t,e.next)>=0&&A(e,e.prev,t)>=0:A(e,t,e.prev)<0||A(e,e.next,t)<0}function j(e,t){var n=e,a=false,i=(e.x+t.x)/2,r=(e.y+t.y)/2;do{if(n.y>r!==n.next.y>r&&n.next.y!==n.y&&i<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x)a=!a;n=n.next}while(n!==e);return a}function N(e,t){var n=new R(e.i,e.x,e.y),a=new R(t.i,t.x,t.y),i=e.next,r=t.prev;e.next=t;t.prev=e;n.next=i;i.prev=n;a.next=n;n.prev=a;r.next=a;a.prev=r;return a}function L(e,t,n,a){var i=new R(e,t,n);if(!a){i.prev=i;i.next=i}else{i.next=a.next;i.prev=a;a.next.prev=i;a.next=i}return i}function M(e){e.next.prev=e.prev;e.prev.next=e.next;if(e.prevZ)e.prevZ.nextZ=e.nextZ;if(e.nextZ)e.nextZ.prevZ=e.prevZ}function R(e,t,n){this.i=e;this.x=t;this.y=n;this.prev=null;this.next=null;this.z=null;this.prevZ=null;this.nextZ=null;this.steiner=false}a.deviation=function(e,t,n,a){var i=t&&t.length;var r=i?t[0]*n:e.length;var s=Math.abs(P(e,0,r,n));if(i){for(var o=0,l=t.length;o<l;o++){var u=t[o]*n;var m=o<l-1?t[o+1]*n:e.length;s-=Math.abs(P(e,u,m,n))}}var p=0;for(o=0;o<a.length;o+=3){var c=a[o]*n;var d=a[o+1]*n;var h=a[o+2]*n;p+=Math.abs((e[c]-e[h])*(e[d+1]-e[c+1])-(e[c]-e[d])*(e[h+1]-e[c+1]))}return s===0&&p===0?0:Math.abs((p-s)/s)};function P(e,t,n,a){var i=0;for(var r=t,s=n-a;r<n;r+=a){i+=(e[s]-e[r])*(e[r+1]+e[s+1]);s=r}return i}a.flatten=function(e){var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},a=0;for(var i=0;i<e.length;i++){for(var r=0;r<e[i].length;r++){for(var s=0;s<t;s++)n.vertices.push(e[i][r][s])}if(i>0){a+=e[i-1].length;n.holes.push(a)}}return n}},{}]},{},[1])(1)});(function(){"use strict";function i(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}function E(e){var t="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return t?t.call(e):{next:i(e)}}function r(e){if(!(e instanceof Array)){e=E(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}var s="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){if(e==Array.prototype||e==Object.prototype)return e;e[t]=n.value;return e};function e(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}var u=e(this);function t(e,t){if(t)e:{var n=u;e=e.split(".");for(var a=0;a<e.length-1;a++){var i=e[a];if(!(i in n))break e;n=n[i]}e=e[e.length-1];a=n[e];t=t(a);t!=a&&null!=t&&s(n,e,{configurable:!0,writable:!0,value:t})}}var n;if("function"==typeof Object.setPrototypeOf)n=Object.setPrototypeOf;else{var a;e:{var o={D:!0},l={};try{l.__proto__=o;a=l.D;break e}catch(e){}a=!1}n=a?function(e,t){e.__proto__=t;if(e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var m=n;function p(){this.g=!1;this.b=null;this.f=void 0;this.a=1;this.j=this.h=0;this.c=null}function c(e){if(e.g)throw new TypeError("Generator is already running");e.g=!0}p.prototype.i=function(e){this.f=e};function d(e,t){e.c={F:t,G:!0};e.a=e.h||e.j}p.prototype.return=function(e){this.c={return:e};this.a=this.j};function C(e,t,n){e.a=n;return{value:t}}function h(e){this.a=new p;this.b=e}function f(e,t){c(e.a);var n=e.a.b;if(n)return v(e,"return"in n?n["return"]:function(e){return{value:e,done:!0}},t,e.a.return);e.a.return(t);return g(e)}function v(t,e,n,a){try{var i=e.call(t.a.b,n);if(!(i instanceof Object))throw new TypeError("Iterator result "+i+" is not an object");if(!i.done)return t.a.g=!1,i;var r=i.value}catch(e){return t.a.b=null,d(t.a,e),g(t)}t.a.b=null;a.call(t.a,r);return g(t)}function g(t){for(;t.a.a;)try{var e=t.b(t.a);if(e)return t.a.g=!1,{value:e.value,done:!1}}catch(e){t.a.f=void 0,d(t.a,e)}t.a.g=!1;if(t.a.c){e=t.a.c;t.a.c=null;if(e.G)throw e.F;return{value:e.return,done:!0}}return{value:void 0,done:!0}}function b(t){this.next=function(e){c(t.a);t.a.b?e=v(t,t.a.b.next,e,t.a.i):(t.a.i(e),e=g(t));return e};this.throw=function(e){c(t.a);t.a.b?e=v(t,t.a.b["throw"],e,t.a.i):(d(t.a,e),e=g(t));return e};this.return=function(e){return f(t,e)};this[Symbol.iterator]=function(){return this}}function j(e,t){t=new b(new h(t));m&&e.prototype&&m(t,e.prototype);return t}t("Symbol",function(e){function t(e){if(this instanceof t)throw new TypeError("Symbol is not a constructor");return new n("jscomp_symbol_"+(e||"")+"_"+a++,e)}function n(e,t){this.a=e;s(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;n.prototype.toString=function(){return this.a};var a=0;return t});t("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var t="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),n=0;n<t.length;n++){var a=u[t[n]];"function"===typeof a&&"function"!=typeof a.prototype[e]&&s(a.prototype,e,{configurable:!0,writable:!0,value:function(){return x(i(this))}})}return e});function x(e){e={next:e};e[Symbol.iterator]=function(){return this};return e}var O="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var a=arguments[n];if(a)for(var i in a)Object.prototype.hasOwnProperty.call(a,i)&&(e[i]=a[i])}return e};t("Object.assign",function(e){return e||O});t("Promise",function(e){function o(e){this.b=0;this.c=void 0;this.a=[];this.i=!1;var t=this.f();try{e(t.resolve,t.reject)}catch(e){t.reject(e)}}function t(){this.a=null}function l(t){return t instanceof o?t:new o(function(e){e(t)})}if(e)return e;t.prototype.b=function(e){if(null==this.a){this.a=[];var t=this;this.c(function(){t.g()})}this.a.push(e)};var n=u.setTimeout;t.prototype.c=function(e){n(e,0)};t.prototype.g=function(){for(;this.a&&this.a.length;){var e=this.a;this.a=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(e){this.f(e)}}}this.a=null};t.prototype.f=function(e){this.c(function(){throw e})};o.prototype.f=function(){function e(t){return function(e){a||(a=!0,t.call(n,e))}}var n=this,a=!1;return{resolve:e(this.H),reject:e(this.g)}};o.prototype.H=function(e){if(e===this)this.g(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof o)this.B(e);else{e:switch(typeof e){case"object":var t=null!=e;break e;case"function":t=!0;break e;default:t=!1}t?this.A(e):this.h(e)}};o.prototype.A=function(e){var t=void 0;try{t=e.then}catch(e){this.g(e);return}"function"==typeof t?this.C(t,e):this.h(e)};o.prototype.g=function(e){this.j(2,e)};o.prototype.h=function(e){this.j(1,e)};o.prototype.j=function(e,t){if(0!=this.b)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.b);this.b=e;this.c=t;2===this.b&&this.I();this.s()};o.prototype.I=function(){var t=this;n(function(){if(t.u()){var e=u.console;"undefined"!==typeof e&&e.error(t.c)}},1)};o.prototype.u=function(){if(this.i)return!1;var e=u.CustomEvent,t=u.Event,n=u.dispatchEvent;if("undefined"===typeof n)return!0;"function"===typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"===typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=u.document.createEvent("CustomEvent"),e.initCustomEvent("unhandledrejection",!1,!0,e));e.promise=this;e.reason=this.c;return n(e)};o.prototype.s=function(){if(null!=this.a){for(var e=0;e<this.a.length;++e)i.b(this.a[e]);this.a=null}};var i=new t;o.prototype.B=function(e){var t=this.f();e.o(t.resolve,t.reject)};o.prototype.C=function(e,t){var n=this.f();try{e.call(t,n.resolve,n.reject)}catch(e){n.reject(e)}};o.prototype.then=function(e,t){function n(t,e){return"function"==typeof t?function(e){try{a(t(e))}catch(e){i(e)}}:e}var a,i,r=new o(function(e,t){a=e;i=t});this.o(n(e,a),n(t,i));return r};o.prototype.catch=function(e){return this.then(void 0,e)};o.prototype.o=function(e,t){function n(){switch(a.b){case 1:e(a.c);break;case 2:t(a.c);break;default:throw Error("Unexpected state: "+a.b)}}var a=this;null==this.a?i.b(n):this.a.push(n);this.i=!0};o.resolve=l;o.reject=function(n){return new o(function(e,t){t(n)})};o.race=function(i){return new o(function(e,t){for(var n=E(i),a=n.next();!a.done;a=n.next())l(a.value).o(e,t)})};o.all=function(e){var r=E(e),s=r.next();return s.done?l([]):new o(function(n,e){function t(t){return function(e){a[t]=e;i--;0==i&&n(a)}}var a=[],i=0;do{a.push(void 0),i++,l(s.value).o(t(a.length-1),e),s=r.next()}while(!s.done)})};return o});function _(t,n){t instanceof String&&(t+="");var a=0,i=!1,e={next:function(){if(!i&&a<t.length){var e=a++;return{value:n(e,t[e]),done:!1}}i=!0;return{done:!0,value:void 0}}};e[Symbol.iterator]=function(){return e};return e}t("Array.prototype.keys",function(e){return e?e:function(){return _(this,function(e){return e})}});var T=this||self;function I(e,t){e=e.split(".");var n=T;e[0]in n||"undefined"==typeof n.execScript||n.execScript("var "+e[0]);for(var a;e.length&&(a=e.shift());)e.length||void 0===t?n[a]&&n[a]!==Object.prototype[a]?n=n[a]:n=n[a]={}:n[a]=t}function N(r,s){var o=void 0;return new(o||(o=Promise))(function(e,t){function n(e){try{i(s.next(e))}catch(e){t(e)}}function a(e){try{i(s["throw"](e))}catch(e){t(e)}}function i(t){t.done?e(t.value):new o(function(e){e(t.value)}).then(n,a)}i((s=s.apply(r,void 0)).next())})}function y(e,t,n){n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER);e.shaderSource(n,t);e.compileShader(n);if(!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function A(e,t){this.b=e;this.f=t;this.c=0}var S=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function k(e,t){return t+e}function L(e,t){window[e]=t}function F(e){var t=document.createElement("script");t.setAttribute("src",e);t.setAttribute("crossorigin","anonymous");document.body.appendChild(t);return new Promise(function(e){t.addEventListener("load",function(){e()},!1)})}function M(e){for(var t=[],n=e.size(),a=0;a<n;++a){var i=e.get(a);t.push({x:i.x,y:i.y,visibility:i.hasVisibility?i.visibility:void 0})}return t}function R(e,t,n){this.graph=e;this.locateFile=t;this.v=n}R.prototype.toArrayBuffer=function(){return N(this,function e(){var t=this,n;return j(e,function(e){return 1==e.a?(t.graph.url?e=C(e,fetch(t.locateFile(t.graph.url,t.v)),3):(e.a=2,e=void 0),e):2!=e.a&&(n=e.f,n.body)?e.return(n.arrayBuffer()):e.return(new ArrayBuffer(0))})})};function G(){return N(this,function e(){return j(e,function(e){switch(e.a){case 1:return e.h=2,C(e,WebAssembly.instantiate(S),4);case 4:e.a=3;e.h=0;break;case 2:return e.h=0,e.c=null,e.return(!1);case 3:return e.return(!0)}})})}function P(e){this.b=e;this.listeners={};this.j={};this.A={};this.g=this.u=!0;this.i=Promise.resolve();this.locateFile=e&&e.locateFile||k;if("object"===typeof window)e=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if("undefined"!==typeof location)e=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");this.v=e}P.prototype.close=function(){this.c&&this.c.delete();return Promise.resolve()};function U(e){return N(e,function e(){var t=this,n,a,i,r,s,o,l,u,m;return j(e,function(e){switch(e.a){case 1:n=t;if(!t.u)return e.return();L("createMediapipeSolutionsWasm",{locateFile:t.locateFile});L("createMediapipeSolutionsPackedAssets",{locateFile:t.locateFile});a=t.b.files||[];return C(e,G(),2);case 2:return i=e.f,C(e,Promise.all(a.map(function(e){return void 0===e.simd||e.simd&&i||!e.simd&&!i?F(n.locateFile(e.url,n.v)):Promise.resolve()})),3);case 3:return r=window.createMediapipeSolutionsWasm,s=window.createMediapipeSolutionsPackedAssets,C(e,r(s),4);case 4:return t.a=e.f,t.f=document.createElement("canvas"),t.a.canvas=t.f,t.a.createContext(t.f,!0,!0,{}),t.c=new t.a.SolutionWasm,o=new R(t.b.graph,t.locateFile,t.v),C(e,t.loadGraph(o),5);case 5:if(t.b.listeners)for(l=E(t.b.listeners),u=l.next();!u.done;u=l.next())m=u.value,V(t,m);t.u=!1;e.a=0}})})}P.prototype.setOptions=function(e){if(this.b.options){for(var t=[],n=E(Object.keys(e)),a=n.next();!a.done;a=n.next()){var i=a.value;(a=this.b.options[i])&&a.graphOptionXref&&(i={valueNumber:0===a.type?e[i]:0,valueBoolean:1===a.type?e[i]:!1},a=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),a.graphOptionXref),i),t.push(a))}0!==t.length&&(this.g=!0,this.h=t)}};function B(e){return N(e,function e(){var t=this,n,a,i,r,s;return j(e,function(e){if(!t.g)return e.return();n=t.f.getContext("webgl2");if(!n)return alert("Failed to create WebGL canvas context when passing video frame."),e.return();t.s=n;if(t.h){a=new t.a.GraphOptionChangeRequestList;i=E(t.h);for(r=i.next();!r.done;r=i.next())s=r.value,a.push_back(s);t.c.changeOptions(a);a.delete();t.h=void 0}t.g=!1;e.a=0})})}P.prototype.initialize=function(){return N(this,function e(){var t=this;return j(e,function(e){return 1==e.a?C(e,U(t),2):C(e,B(t),0)})})};P.prototype.loadGraph=function(a){return N(this,function e(){var t,n=this;return j(e,function(e){if(1==e.a)return C(e,a.toArrayBuffer(),2);t=e.f;n.c.loadGraph(t);e.a=0})})};P.prototype.send=function(d,h){return N(this,function e(){var i=this,r,s,o,l,u,m,p,c;return j(e,function(e){if(1==e.a){if(!i.b.inputs)return e.return();r=1e3*(h||performance.now());return C(e,i.i,2)}if(3!=e.a)return C(e,i.initialize(),3);s=new i.a.PacketDataList;o=E(Object.keys(d));for(l=o.next();!l.done;l=o.next())if(u=l.value,m=i.b.inputs[u]){e:{var t=d[u];switch(m.type){case"video":var n=i.j[m.stream];n||(n=new A(i.a,i.s),i.j[m.stream]=n);0===n.c&&(n.c=n.b.createTexture());var a=n.f;a.canvas.width=t.videoWidth;a.canvas.height=t.videoHeight;a.activeTexture(a.TEXTURE0);n.b.bindTexture2d(n.c);a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,t);n.b.bindTexture2d(0);n={glName:n.c,width:t.videoWidth,height:t.videoHeight};break e;default:n={}}}p=n;c=m.stream;s.pushTexture2d(Object.assign(Object.assign({},p),{stream:c,timestamp:r}))}i.c.send(s);s.delete();e.a=0})})};function D(e,t,n){if(n.isNumber())return n.getNumber();if(n.isRect())return n.getRect();if(n.isLandmarks())return n.getLandmarks();if(n.isLandmarksList())return n.getLandmarksList();if(n.isClassificationsList())return n.getClassificationsList();if(n.isTexture2d()){var a=e.A[t];a||(a=new A(e.a,e.s),e.A[t]=a);e=a;n=n.getTexture2d();t=e.f;if(void 0===e.g){a=y(t,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0);var i=y(t,"\n  precision highp float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),r=t.createProgram();t.attachShader(r,a);t.attachShader(r,i);t.linkProgram(r);if(!t.getProgramParameter(r,t.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+t.getProgramInfoLog(r));a=e.g=r;t.useProgram(a);i=t.getUniformLocation(a,"sampler0");e.a={m:t.getAttribLocation(a,"aVertex"),l:t.getAttribLocation(a,"aTex"),J:i};e.i=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e.i);t.enableVertexAttribArray(e.a.m);t.vertexAttribPointer(e.a.m,2,t.FLOAT,!1,0,0);t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),t.STATIC_DRAW);t.bindBuffer(t.ARRAY_BUFFER,null);e.h=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e.h);t.enableVertexAttribArray(e.a.l);t.vertexAttribPointer(e.a.l,2,t.FLOAT,!1,0,0);t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),t.STATIC_DRAW);t.bindBuffer(t.ARRAY_BUFFER,null);t.uniform1i(i,0)}a=e.a;t.useProgram(e.g);t.canvas.width=n.width;t.canvas.height=n.height;t.viewport(0,0,n.width,n.height);t.activeTexture(t.TEXTURE0);e.b.bindTexture2d(n.glName);t.enableVertexAttribArray(a.m);t.bindBuffer(t.ARRAY_BUFFER,e.i);t.vertexAttribPointer(a.m,2,t.FLOAT,!1,0,0);t.enableVertexAttribArray(a.l);t.bindBuffer(t.ARRAY_BUFFER,e.h);t.vertexAttribPointer(a.l,2,t.FLOAT,!1,0,0);t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null);t.drawArrays(t.TRIANGLE_FAN,0,4);t.disableVertexAttribArray(a.m);t.disableVertexAttribArray(a.l);t.bindBuffer(t.ARRAY_BUFFER,null);e.b.bindTexture2d(0);return e.f.canvas}}function V(e,y){for(var A=y.name||"$",S=[].concat(r(y.wants)),t=new e.a.StringList,n=E(y.wants),a=n.next();!a.done;a=n.next())t.push_back(a.value);n=e.a.PacketListener.implement({onResults:function(I){return N(e,function e(){var b,x,O=this,_,T;return j(e,function(e){if(1==e.a){b={};for(x=0;x<y.wants.length;++x)b[S[x]]=D(O,y.wants[x],I.get(x));if(y.outs){for(var t=b,n=y.outs,a={},i=E(Object.keys(n)),r=i.next();!r.done;r=i.next()){r=r.value;var s=n[r];if("string"===typeof s)a[r]=t[s];else{var o=t[s.stream];if(void 0!==o){if("landmarks"===s.type)a[r]=M(o);else if("landmarks_list"===s.type){for(var l=[],u=o.size(),m=0;m<u;++m){var p=o.get(m);l.push(M(p))}a[r]=l}else if("classifications_list"===s.type){l=[];u=o.size();for(m=0;m<u;++m){var c=o.get(m);p=l;for(var d=p.push,h=[],f=c.size(),v=0;v<f;++v){var g=c.get(v);h.push({index:g.index,score:g.score,label:g.label})}d.call(p,h)}a[r]=l}else throw Error("Unknown output config type: '"+s.type+"'");s.transform&&(a[r]=s.transform(a[r]))}}}b=a}(_=O.listeners[A])?e=C(e,O.i,3):(e.a=0,e=void 0);return e}if(T=_(b))return O.i=T,e.return(T);e.a=0})})}});e.c.attachMultiListener(t,n);t.delete()}P.prototype.onResults=function(e,t){this.listeners[t||"$"]=e};I("Solution",P);I("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"});function w(e){e=e||{};this.a=new P({locateFile:e.locateFile,files:[{url:"hands_solution_packed_assets_loader.js"},{simd:!1,url:"hands_solution_wasm_bin.js"},{simd:!0,url:"hands_solution_simd_wasm_bin.js"}],graph:{url:"hands.binarypb"},inputs:{image:{type:"video",stream:"input_frames_gpu"}},listeners:[{wants:["multi_hand_landmarks","image_transformed","multi_handedness"],outs:{image:"image_transformed",multiHandLandmarks:{type:"landmarks_list",stream:"multi_hand_landmarks"},multiHandedness:{type:"classifications_list",stream:"multi_handedness",transform:function(e){return e.map(function(e){return e[0]})}}}}],options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumHands:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculator",fieldName:"int_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"handlandmarktrackinggpu__palmdetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"handlandmarktrackinggpu__handlandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}}}})}w.prototype.close=function(){this.a.close();return Promise.resolve()};w.prototype.onResults=function(e){this.a.onResults(e)};w.prototype.initialize=function(){return N(this,function e(){var t=this;return j(e,function(e){return C(e,t.a.initialize(),0)})})};w.prototype.send=function(n){return N(this,function e(){var t=this;return j(e,function(e){return C(e,t.a.send(n),0)})})};w.prototype.setOptions=function(e){this.a.setOptions(e)};I("HAND_CONNECTIONS",[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]]);I("Hands",w)}).call(this);(function(){"use strict";var r="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){if(e==Array.prototype||e==Object.prototype)return e;e[t]=n.value;return e};function e(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}var s=e(this);function t(e,t){if(t)e:{var n=s;e=e.split(".");for(var a=0;a<e.length-1;a++){var i=e[a];if(!(i in n))break e;n=n[i]}e=e[e.length-1];a=n[e];t=t(a);t!=a&&null!=t&&r(n,e,{configurable:!0,writable:!0,value:t})}}var n="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var a=arguments[n];if(a)for(var i in a)Object.prototype.hasOwnProperty.call(a,i)&&(e[i]=a[i])}return e};t("Object.assign",function(e){return e||n});var a=this||self;var i={facingMode:"user",width:640,height:480};function o(e,t){this.video=e;this.a=0;this.b=Object.assign(Object.assign({},i),t)}function l(e){window.requestAnimationFrame(function(){m(e)})}function u(e,t){e.video.srcObject=t;e.video.onloadedmetadata=function(){e.video.play();l(e)}}function m(e){var t=null;e.video.paused||e.video.currentTime===e.a||(e.a=e.video.currentTime,t=e.b.onFrame());t?t.then(function(){l(e)}):l(e)}o.prototype.start=function(){var t=this;navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||alert("No navigator.mediaDevices.getUserMedia exists.");var e=this.b;return navigator.mediaDevices.getUserMedia({video:{facingMode:e.facingMode,width:e.width,height:e.height}}).then(function(e){u(t,e)}).catch(function(e){console.error("Failed to acquire camera feed: "+e);alert("Failed to acquire camera feed: "+e);throw e})};var p=["Camera"],c=a;p[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+p[0]);for(var d;p.length&&(d=p.shift());)p.length||void 0===o?c[d]&&c[d]!==Object.prototype[d]?c=c[d]:c=c[d]={}:c[d]=o}).call(this);(()=>{"use strict";var e={};const s={ANIM:{EASINGS:["linear","absolute","smoothstep","smootherstep","Cubic In","Cubic Out","Cubic In Out","Expo In","Expo Out","Expo In Out","Sin In","Sin Out","Sin In Out","Quart In","Quart Out","Quart In Out","Quint In","Quint Out","Quint In Out","Back In","Back Out","Back In Out","Elastic In","Elastic Out","Bounce In","Bounce Out"],EASING_LINEAR:0,EASING_ABSOLUTE:1,EASING_SMOOTHSTEP:2,EASING_SMOOTHERSTEP:3,EASING_CUBICSPLINE:4,EASING_CUBIC_IN:5,EASING_CUBIC_OUT:6,EASING_CUBIC_INOUT:7,EASING_EXPO_IN:8,EASING_EXPO_OUT:9,EASING_EXPO_INOUT:10,EASING_SIN_IN:11,EASING_SIN_OUT:12,EASING_SIN_INOUT:13,EASING_BACK_IN:14,EASING_BACK_OUT:15,EASING_BACK_INOUT:16,EASING_ELASTIC_IN:17,EASING_ELASTIC_OUT:18,EASING_BOUNCE_IN:19,EASING_BOUNCE_OUT:21,EASING_QUART_IN:22,EASING_QUART_OUT:23,EASING_QUART_INOUT:24,EASING_QUINT_IN:25,EASING_QUINT_OUT:26,EASING_QUINT_INOUT:27},OP:{OP_PORT_TYPE_VALUE:0,OP_PORT_TYPE_NUMBER:0,OP_PORT_TYPE_FUNCTION:1,OP_PORT_TYPE_TRIGGER:1,OP_PORT_TYPE_OBJECT:2,OP_PORT_TYPE_TEXTURE:2,OP_PORT_TYPE_ARRAY:3,OP_PORT_TYPE_DYNAMIC:4,OP_PORT_TYPE_STRING:5,OP_VERSION_PREFIX:"_v"},PORT:{PORT_DIR_IN:0,PORT_DIR_OUT:1},PACO:{PACO_CLEAR:0,PACO_VALUECHANGE:1,PACO_OP_DELETE:2,PACO_UNLINK:3,PACO_LINK:4,PACO_LOAD:5,PACO_OP_CREATE:6,PACO_OP_ENABLE:7,PACO_OP_DISABLE:8,PACO_UIATTRIBS:9,PACO_VARIABLES:10,PACO_TRIGGERS:11,PACO_PORT_SETVARIABLE:12,PACO_PORT_SETANIMATED:13,PACO_PORT_ANIM_UPDATED:14,PACO_DESERIALIZE:15,PACO_OP_RELOAD:16}};const t=class{constructor(t,e,n,a,i,r){this._valuePort=n;this._varNamePort=a;this._op=t;this._type=e;this._typeId=-1;this._triggerPort=i;this._nextPort=r;this._btnCreate=t.inTriggerButton("Create new variable");this._btnCreate.setUiAttribs({hidePort:true});this._btnCreate.onTriggered=this._createVar.bind(this);this._helper=t.inUiTriggerButtons("",["Rename"]);this._helper.setUiAttribs({hidePort:true});this._helper.onTriggered=e=>{if(e=="Rename")CABLES.CMD.PATCH.renameVariable(t.varName.get())};this._op.setPortGroup("Variable",[this._helper,this._varNamePort,this._btnCreate]);a.setUiAttribs({_variableSelect:true});this._op.on("uiParamPanel",this._updateVarNamesDropdown.bind(this));this._op.patch.addEventListener("variablesChanged",this._updateName.bind(this));this._op.patch.addEventListener("variableRename",this._renameVar.bind(this));this._varNamePort.onChange=this._updateName.bind(this);this._isTexture=this._valuePort.uiAttribs.objType==="texture";this._valuePort.changeAlways=true;if(this._triggerPort){this._triggerPort.onTriggered=()=>{this._setVarValue(true)}}else{this._valuePort.onChange=this._setVarValue.bind(this)}this._op.init=()=>{this._updateName();if(!this._triggerPort)this._setVarValue();this._updateErrorUi()};if(e=="array")this._typeId=s.OP.OP_PORT_TYPE_ARRAY;else if(e=="object")this._typeId=s.OP.OP_PORT_TYPE_OBJECT;else if(e=="string")this._typeId=s.OP.OP_PORT_TYPE_STRING;else if(e=="texture")this._typeId=s.OP.OP_PORT_TYPE_TEXTURE;else this._typeId=s.OP.OP_PORT_TYPE_VALUE}_updateErrorUi(){if(CABLES.UI){if(!this._varNamePort.get())this._op.setUiError("novarname","no variable selected");else{if(this._op.hasUiErrors){this._op.setUiError("novarname",null)}}}}_updateName(){const e=this._varNamePort.get();this._op.setTitle("var set");this._op.setUiAttrib({extendTitle:"#"+e});this._updateErrorUi();const t=this._op.patch.getVar(e);if(t&&!t.type)t.type=this._type;if(!this._op.patch.hasVar(e)&&e!=0&&!this._triggerPort){this._setVarValue()}if(!this._op.patch.hasVar(e)&&e!=0&&this._triggerPort){if(this._type=="string")this._op.patch.setVarValue(e,"");else if(this._type=="number")this._op.patch.setVarValue(e,"");else this._op.patch.setVarValue(e,null)}if(this._op.isCurrentUiOp()){this._updateVarNamesDropdown();this._op.refreshParams()}this._updateDisplay();this._op.patch.emitEvent("opVariableNameChanged",this._op,this._varNamePort.get())}_createVar(){CABLES.CMD.PATCH.createVariable(this._op,this._type,()=>{this._updateName()})}_updateDisplay(){this._valuePort.setUiAttribs({greyout:!this._varNamePort.get()})}_updateVarNamesDropdown(){if(CABLES.UI&&CABLES.UI.loaded&&CABLES.UI.loaded){const e=CABLES.UI.uiProfiler.start("[vars] _updateVarNamesDropdown");const t=[];const n=this._op.patch.getVars();for(const a in n)if(n[a].type==this._type&&a!="0")t.push(a);this._varNamePort.uiAttribs.values=t;e.finish()}}_renameVar(e,t){if(e!=this._varNamePort.get())return;this._varNamePort.set(t);this._updateName()}_setVarValue(e){const t=this._varNamePort.get();if(!t)return;const n=this._valuePort.get();if(this._typeId==s.OP.OP_PORT_TYPE_VALUE||this._typeId==s.OP.OP_PORT_TYPE_STRING){this._op.patch.setVarValue(t,n)}else if(this._typeId==s.OP.OP_PORT_TYPE_ARRAY){this._arr=[];CABLES.copyArray(n,this._arr);this._op.patch.setVarValue(t,this._arr)}else{if(this._typeId==s.OP.OP_PORT_TYPE_OBJECT){if(this._isTexture)this._op.patch.setVarValue(t,CGL.Texture.getEmptyTexture(this._op.patch.cgl));else this._op.patch.setVarValue(t,null);if(n&&n.tex&&n._cgl&&!this._isTexture)this._op.setUiError("texobj","Dont use object variables for textures, use varSetTexture");else this._op.setUiError("texobj",null)}this._op.patch.setVarValue(t,n)}if(e&&this._nextPort)this._nextPort.trigger()}};const n=class{constructor(e,t,n,a){this._op=e;this._type=t;this._varnamePort=n;this._variable=null;this._valueOutPort=a;this._listenerId=null;this._op.on("uiParamPanel",this._updateVarNamesDropdown.bind(this));this._op.on("uiErrorChange",this._updateTitle.bind(this));this._op.patch.on("variableRename",this._renameVar.bind(this));this._op.patch.on("variableDeleted",e=>{if(this._op.isCurrentUiOp())this._op.refreshParams()});n.setUiAttribs({_variableSelect:true});n.setUiAttribs({_variableSelectGet:true});this._varnamePort.onChange=this._changeVar.bind(this);this._op.patch.addEventListener("variablesChanged",this._init.bind(this));this._op.onDelete=()=>{if(this._variable&&this._listenerId)this._variable.off(this._listenerId)};this._op.init=()=>{this._init()}}get variable(){return this._variable}_changeVar(){if(this._variable&&this._listenerId){this._variable.off(this._listenerId)}this._init()}_renameVar(e,t){if(e!=this._varnamePort.get())return;this._varnamePort.set(t);this._updateVarNamesDropdown();this._updateTitle();this._listenerId=this._variable.on("change",this._setValueOut.bind(this))}_updateVarNamesDropdown(){if(CABLES.UI&&CABLES.UI.loaded){const e=[];const t=this._op.patch.getVars();for(const n in t)if(t[n].type==this._type&&n!="0")e.push(n);this._op.varName.uiAttribs.values=e}}_setValueOut(e){if(this._valueOutPort)if(this._typeId==s.OP.OP_PORT_TYPE_ARRAY&&this._typeId==s.OP.OP_PORT_TYPE_OBJECT)this._valueOutPort.setRef(e);else this._valueOutPort.set(e)}_updateTitle(){if(this._variable){this._op.setUiError("unknownvar",null);this._op.setTitle("var get");this._op.setUiAttrib({extendTitle:"#"+this._varnamePort.get()});if(this._valueOutPort)this._valueOutPort.set(this._variable.getValue())}else{this._op.setUiError("unknownvar","unknown variable! - there is no setVariable with this name ("+this._varnamePort.get()+")");this._op.setUiAttrib({extendTitle:"#invalid"});if(this._valueOutPort)this._valueOutPort.set(0)}}_init(){this._updateVarNamesDropdown();if(this._variable&&this._listenerId)this._variable.off(this._listenerId);this._variable=this._op.patch.getVar(this._op.varName.get());if(this._variable)this._listenerId=this._variable.on("change",this._setValueOut.bind(this));this._updateTitle();this._op.patch.emitEvent("opVariableNameChanged",this._op,this._varnamePort.get())}};CABLES.VarSetOpWrapper=t;CABLES.VarGetOpWrapper=n;((this.CABLES=this.CABLES||{}).COREMODULES=this.CABLES.COREMODULES||{}).Vargetset=e.Cables})();(()=>{"use strict";var e={};function t(){return`
IN vec3 vPosition;
IN vec2 attrTexCoord;
IN vec3 attrVertNormal;
IN float attrVertIndex;
IN vec3 attrTangent;
IN vec3 attrBiTangent;

UNI mat4 projMatrix;
UNI mat4 modelMatrix;
UNI mat4 viewMatrix;


OUT vec2 texCoord;
OUT vec3 norm;

{{MODULES_HEAD}}

${this.type==="point"?"OUT vec3 modelPos;":""}
void main() {
    texCoord=attrTexCoord;
    texCoord.y = 1. - texCoord.y;
    norm=attrVertNormal;
    vec4 pos = vec4(vPosition, 1.0);
    mat4 mMatrix=modelMatrix;
    vec3 tangent = attrTangent;
    vec3 bitangent = attrBiTangent;

    {{MODULE_VERTEX_POSITION}}

    mat4 mvMatrix=viewMatrix * mMatrix;
    vec4 vPos = projMatrix * mvMatrix * pos;
    ${this.type==="point"?"modelPos = (mMatrix * pos).xyz;":""}
    gl_Position = vPos;
}
`}function n(){return`
   {{MODULES_HEAD}}
   ${this.type==="point"?"IN vec3 modelPos;":""}
   ${this.type==="point"?"UNI vec3 inLightPosition;":""}
   ${this.type==="point"?"UNI vec2 inNearFar;":""}

    IN vec2 texCoord;

    void main() {
        {{MODULE_BEGIN_FRAG}}
        vec4 col = vec4(1.);


        outColor = vec4(1.);

        {{MODULE_COLOR}}

        ${this.type==="point"?"vec3 fromLightToFrag = (modelPos - inLightPosition);":""}


        ${this.type==="point"?"float depth = (length(fromLightToFrag) - inNearFar.x) / (inNearFar.y - inNearFar.x);":"float depth = gl_FragCoord.z;"}

        float dx = dFdx(depth); // for biasing depth-per-pixel
        float dy = dFdy(depth); // for biasing depth-per-pixel

        float clampedDerivative = clamp(dot(dx, dx) + dot(dy, dy), 0., 1.);
        float moment2 = dot(depth, depth) + 0.25 * clampedDerivative;

        outColor.x = depth;
        outColor.y = moment2;
        outColor.z = depth;
    }
`}function a(){if(this.type==="point")return"";return`

IN vec3 vPosition;
IN vec2 attrTexCoord;

OUT vec2 texCoord;
OUT vec2 coord0;
OUT vec2 coord1;
OUT vec2 coord2;
OUT vec2 coord3;
OUT vec2 coord4;
OUT vec2 coord5;
OUT vec2 coord6;

UNI mat4 projMatrix;
UNI mat4 mvMatrix;
UNI mat4 modelMatrix;

UNI vec2 inXY;

void main() {
    texCoord=attrTexCoord;

    vec4 pos = vec4(vPosition,  1.0);

    {{MODULE_VERTEX_POSITION}}

    coord3 = attrTexCoord;


    coord0 = attrTexCoord + (-3.0368997744118595 * inXY);
    coord0 = clamp(coord0, 0., 1.);
    coord1 = attrTexCoord + (-2.089778445362373 * inXY);
    coord1 = clamp(coord1, 0., 1.);
    coord2 = attrTexCoord + (-1.2004366090034069 * inXY);
    coord2 = clamp(coord2, 0., 1.);
    coord4 = attrTexCoord + (1.2004366090034069 * inXY);
    coord4 = clamp(coord4, 0., 1.);
    coord5 = attrTexCoord + (2.089778445362373* inXY);
    coord5 = clamp(coord5, 0., 1.);
    coord6 = attrTexCoord + (3.0368997744118595 * inXY);
    coord6 = clamp(coord6, 0., 1.);

    gl_Position = projMatrix * mvMatrix * pos;
}
    `}function i(){if(this.type==="point")return"";return`
UNI sampler2D tex;

IN vec2 coord0;
IN vec2 coord1;
IN vec2 coord2;
IN vec2 coord3;
IN vec2 coord4;
IN vec2 coord5;
IN vec2 coord6;

void main() {

    vec4 color = vec4(0.0);


    color.xyz += texture(tex, coord0).xyz * 0.06927096443792478;  // 1/64
    color.xyz += texture(tex, coord1).xyz * 0.1383328848652136;   // 6/64
    color.xyz += texture(tex, coord2).xyz * 0.21920904690397863;  // 15/64
    color.xyz += texture(tex, coord3).xyz * 0.14637421;           // 20/64
    color.xyz += texture(tex, coord4).xyz * 0.21920904690397863;  // 15/64
    color.xyz += texture(tex, coord5).xyz * 0.1383328848652136;   // 6/64
    color.xyz += texture(tex, coord6).xyz * 0.06927096443795711;  // 1/64

    color.a = 1.;

    outColor = color;
}
    `}function r(e,t){this.type=t.type||"point";this.color=t.color||[1,1,1];this.specular=t.specular||[0,0,0];this.position=t.position||null;this.intensity=t.intensity||1;this.radius=t.radius||1;this.falloff=t.falloff||1;this.spotExponent=t.spotExponent||1;this.cosConeAngleInner=t.cosConeAngleInner||0;this.cosConeAngle=t.cosConeAngle||0;this.conePointAt=t.conePointAt||[0,0,0];this.castShadow=t.castShadow||false;this.nearFar=t.nearFar||[0,0];this.normalOffset=t.normalOffset||0;this.shadowBias=t.shadowBias||0;this.shadowStrength=t.shadowStrength||0;this.lightMatrix=null;this.shadowMap=null;this.shadowMapDepth=null;this.shadowCubeMap=null;this._cgl=e;this.state={isUpdating:false};this._framebuffer=null;this._shaderShadowMap={shader:null,uniforms:{lightPosition:null,nearFar:null},matrices:{modelMatrix:mat4.create(),viewMatrix:mat4.create(),projMatrix:mat4.create(),biasMatrix:mat4.fromValues(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1)},vectors:{lookAt:vec3.create(),camPos:vec3.create(),up:vec3.fromValues(0,1,0)}};this._effectBlur=null;this._shaderBlur={shader:null,uniforms:{XY:null}};this._cubemap=null;return this}r.prototype.getModifiableParameters=function(){return["color","specular","position","intensity","radius","falloff","spotExponent","cosConeAngleInner","cosConeAngle","conePointAt"]};r.prototype.createProjectionMatrix=r.prototype.updateProjectionMatrix=function(e,t,n,a){if(this.type==="spot"){mat4.perspective(this._shaderShadowMap.matrices.projMatrix,-2*CGL.DEG2RAD*a,1,t,n)}else if(this.type==="directional"){mat4.ortho(this._shaderShadowMap.matrices.projMatrix,-1*e,e,-1*e,e,t,n)}else if(this.type==="point"){mat4.perspective(this._shaderShadowMap.matrices.projMatrix,CGL.DEG2RAD*90,1,t,n);this.nearFar=[t,n]}};r.prototype.hasFramebuffer=function(){return!!this._framebuffer};r.prototype.hasShadowMapShader=function(){return!!this._shaderShadowMap.shader};r.prototype.hasBlurShader=function(){return!!this._shaderBlur.shader};r.prototype.hasBlurEffect=function(){return!!this._effectBlur};r.prototype.getShadowMap=function(){if(this.type==="point")return null;return this._framebuffer.getTextureColor()};r.prototype.getShadowMapDepth=function(){if(this.type==="point")return null;return this._framebuffer.getTextureDepth()};r.prototype.createFramebuffer=function(e,t,n){this.state.isUpdating=true;const a=e||512;const i=t||512;if(this.type==="point"){if(!this.hasCubemap()){this._cubemap=new CGL.CubemapFramebuffer(this._cgl,a,i,{name:"point light shadowmap"})}else{this._cubemap.setSize(a,i)}this._cubemap.setCamPos(this.position);this._cubemap.setMatrices(this._shaderShadowMap.matrices.modelMatrix,this._shaderShadowMap.matrices.viewMatrix,this._shaderShadowMap.matrices.projMatrix);this.state.isUpdating=false;return}if(this.hasFramebuffer())this._framebuffer.delete();if(n){if(n.filter){n.isFloatingPointTexture=n.filter!==CGL.Texture.FILTER_MIPMAP}}if(this._cgl.glVersion==1){this._framebuffer=new CGL.Framebuffer(this._cgl,a,i,{isFloatingPointTexture:true,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...n})}else{this._framebuffer=new CGL.Framebuffer2(this._cgl,a,i,{isFloatingPointTexture:true,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...n})}this.state.isUpdating=false};r.prototype.hasCubemap=function(){return!!this._cubemap};r.prototype.setFramebufferSize=function(e){if(this.hasFramebuffer())this._framebuffer.setSize(e,e)};r.prototype.createShadowMapShader=function(e,t){if(this.hasShadowMapShader())return;this.state.isUpdating=true;this._shaderShadowMap.shader=new CGL.Shader(this._cgl,"shadowPass"+this.type.charAt(0).toUpperCase()+this.type.slice(1));this._shaderShadowMap.shader.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);const n=e||this.getShadowPassVertexShader();const a=t||this.getShadowPassFragmentShader();this._shaderShadowMap.shader.setSource(n,a);this._shaderShadowMap.shader.offScreenPass=true;if(this.type==="point"){this._shaderShadowMap.uniforms.lightPosition=new CGL.Uniform(this._shaderShadowMap.shader,"3f","inLightPosition",vec3.create());this._shaderShadowMap.uniforms.nearFar=new CGL.Uniform(this._shaderShadowMap.shader,"2f","inNearFar",vec2.create())}if(this._cgl.glVersion==1){this._cgl.enableExtension("OES_texture_float");this._cgl.enableExtension("OES_texture_float_linear");this._cgl.enableExtension("OES_texture_half_float");this._cgl.enableExtension("OES_texture_half_float_linear");this._shaderShadowMap.shader.enableExtension("GL_OES_standard_derivatives");this._shaderShadowMap.shader.enableExtension("GL_OES_texture_float");this._shaderShadowMap.shader.enableExtension("GL_OES_texture_float_linear");this._shaderShadowMap.shader.enableExtension("GL_OES_texture_half_float");this._shaderShadowMap.shader.enableExtension("GL_OES_texture_half_float_linear")}this.state.isUpdating=false};r.prototype.createBlurEffect=function(e){if(this.type==="point")return;this.state.isUpdating=true;if(this.hasBlurEffect())this._effectBlur.delete();this._effectBlur=new CGL.TextureEffect(this._cgl,{isFloatingPointTexture:true,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...e});this.state.isUpdating=false};r.prototype.createBlurShader=function(e,t){if(this.hasBlurShader()){return}if(this.type==="point")return;this.state.isUpdating=true;const n=e||this.getBlurPassVertexShader();const a=t||this.getBlurPassFragmentShader();this._shaderBlur.shader=new CGL.Shader(this._cgl,"blurPass"+this.type.charAt(0).toUpperCase()+this.type.slice(1));this._shaderBlur.shader.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);this._shaderBlur.shader.setSource(n,a);this._shaderBlur.uniforms.XY=new CGL.Uniform(this._shaderBlur.shader,"2f","inXY",vec2.create());this._shaderBlur.shader.offScreenPass=true;this.state.isUpdating=false};r.prototype.renderPasses=function(e,t,n){if(this.state.isUpdating)return;if(this._cgl.tempData.shadowPass)return;this._cgl.pushCullFace(true);this._cgl.pushCullFaceFacing(this._cgl.gl.FRONT);this._cgl.gl.enable(this._cgl.gl.POLYGON_OFFSET_FILL);this._cgl.gl.polygonOffset(e,e);this._cgl.tempData.renderOffscreen=true;this._cgl.tempData.shadowPass=true;this._cgl.pushBlend(false);this._cgl.gl.colorMask(true,true,this.type==="point",this.type==="point");this.renderShadowPass(n);this._cgl.gl.cullFace(this._cgl.gl.BACK);this._cgl.gl.disable(this._cgl.gl.CULL_FACE);this._cgl.gl.disable(this._cgl.gl.POLYGON_OFFSET_FILL);if(this.type!=="point")this.renderBlurPass(t);this._cgl.gl.colorMask(true,true,true,true);this._cgl.popBlend();this._cgl.popCullFaceFacing();this._cgl.popCullFace();this._cgl.tempData.shadowPass=false;this._cgl.tempData.renderOffscreen=false;if(this.type!=="point"){this.shadowMap=this._framebuffer.getTextureColor();this.shadowMapDepth=this._framebuffer.getTextureDepth()}else{this.shadowMap=null;this.shadowMapDepth=null}};r.prototype.renderShadowPass=function(t){if(this.state.isUpdating)return;if(this.type==="point"){this._shaderShadowMap.uniforms.nearFar.setValue(this.nearFar);this._shaderShadowMap.uniforms.lightPosition.setValue(this.position);this._cubemap.setCamPos(this.position);this._cubemap.setMatrices(this._shaderShadowMap.matrices.modelMatrix,this._shaderShadowMap.matrices.viewMatrix,this._shaderShadowMap.matrices.projMatrix);this._cgl.pushShader(this._shaderShadowMap.shader);this._cubemap.renderStart();for(let e=0;e<6;e+=1){this._cubemap.renderStartCubemapFace(e);if(t)t();this._cubemap.renderEndCubemapFace()}this._cubemap.renderEnd();this._cgl.popShader();this.shadowCubeMap=this._cubemap.getTextureColor();return}this._cgl.pushShader(this._shaderShadowMap.shader);this._cgl.pushModelMatrix();this._cgl.pushViewMatrix();this._cgl.pushPMatrix();this._framebuffer.renderStart(this._cgl);mat4.copy(this._cgl.mMatrix,this._shaderShadowMap.matrices.modelMatrix);vec3.set(this._shaderShadowMap.vectors.camPos,this.position[0],this.position[1],this.position[2]);if(this.type==="spot")vec3.set(this._shaderShadowMap.vectors.lookAt,this.conePointAt[0],this.conePointAt[1],this.conePointAt[2]);mat4.lookAt(this._cgl.vMatrix,this._shaderShadowMap.vectors.camPos,this._shaderShadowMap.vectors.lookAt,this._shaderShadowMap.vectors.up);mat4.copy(this._cgl.pMatrix,this._shaderShadowMap.matrices.projMatrix);if(!this.lightMatrix)this.lightMatrix=mat4.create();mat4.mul(this.lightMatrix,this._cgl.pMatrix,this._cgl.vMatrix);mat4.mul(this.lightMatrix,this._cgl.mMatrix,this.lightMatrix);mat4.mul(this.lightMatrix,this._shaderShadowMap.matrices.biasMatrix,this.lightMatrix);this._cgl.gl.clearColor(1,1,1,1);this._cgl.gl.clear(this._cgl.gl.DEPTH_BUFFER_BIT|this._cgl.gl.COLOR_BUFFER_BIT);if(t)t();this._framebuffer.renderEnd(this._cgl);this._cgl.popPMatrix();this._cgl.popModelMatrix();this._cgl.popViewMatrix();this._cgl.popShader()};r.prototype.renderBlurPass=function(e){if(this.state.isUpdating)return;this._cgl.pushShader(this._shaderBlur.shader);this._effectBlur.setSourceTexture(this._framebuffer.getTextureColor());this._effectBlur.startEffect();this._effectBlur.bind();this._cgl.setTexture(0,this._effectBlur.getCurrentSourceTexture().tex);this._shaderBlur.uniforms.XY.setValue([e,0]);this._effectBlur.finish();this._effectBlur.bind();this._cgl.setTexture(0,this._effectBlur.getCurrentSourceTexture().tex);this._shaderBlur.uniforms.XY.setValue([0,e]);this._effectBlur.finish();this._effectBlur.endEffect();this._cgl.popShader()};r.prototype.getShadowPassVertexShader=t;r.prototype.getShadowPassFragmentShader=n;r.prototype.getBlurPassVertexShader=a;r.prototype.getBlurPassFragmentShader=i;CGL.Light=r;((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Light=e.Light})();(()=>{"use strict";var e={};class n{constructor(e,t){this.initiator=e;this._options=t}stack(e){console.info("["+this.initiator+"] ",e);console.log((new Error).stack)}groupCollapsed(e){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments);console.groupCollapsed("["+this.initiator+"] "+e)}table(e){console.table(e)}groupEnd(){console.groupEnd()}error(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)||!CABLES.UI){console.error("["+this.initiator+"]",...arguments)}if(this._options&&this._options.onError){this._options.onError(this.initiator,...arguments)}}errorGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)}warn(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:1},...arguments)||!CABLES.logSilent)console.warn("["+this.initiator+"]",...arguments)}verbose(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}info(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.info("["+this.initiator+"]",...arguments)}log(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}logGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)}userInteraction(e){}}const t=8;class a{constructor(e={}){this.id=CABLES.uuid();this.width=0;this.height=0;this.name="unknown";e=e||{};this.pixelFormat=e.pixelFormat||a.PFORMATSTR_RGBA8UB;this.name=e.name||"unknown";if(!e.width)e.width=t;if(!e.height)e.height=t}}a.getDefaultTextureData=(e,r,s={})=>{if(e=="empty"){return new Uint8Array(r*r*4).fill(0)}else if(e=="color"){const i=new Uint8Array(r*r*4);let t=s.r||1;let n=s.g||1;let a=s.b||1;for(let e=0;e<r*r;e++){i[e*4+0]=t;i[e*4+1]=n;i[e*4+2]=a;i[e*4+3]=255}return i}else if(e=="randomUInt"){const i=new Uint8Array(r*r*4);for(let e=0;e<r*r;e++){i[e*4+0]=Math.random()*255;i[e*4+1]=Math.random()*255;i[e*4+2]=Math.random()*255;i[e*4+3]=255}return i}else if(e=="random"||e=="randomFloat"){const i=new Float32Array(r*r*4);for(let e=0;e<r*r;e++){i[e*4+0]=(Math.random()-.5)*2;i[e*4+1]=(Math.random()-.5)*2;i[e*4+2]=(Math.random()-.5)*2;i[e*4+3]=1}return i}else if(e=="stripes"){const o=[];let n=s.r;let a=s.g;let i=s.b;if(n===undefined)n=1;if(a===undefined)a=1;if(i===undefined)i=1;for(let t=0;t<r;t++){for(let e=0;e<r;e++){if((e+t)%64<32){o.push((200+t/r*25+e/r*25)*n);o.push((200+t/r*25+e/r*25)*a);o.push((200+t/r*25+e/r*25)*i)}else{o.push((40+t/r*25+e/r*25)*n);o.push((40+t/r*25+e/r*25)*a);o.push((40+t/r*25+e/r*25)*i)}o.push(255)}}return new Uint8Array(o)}else{console.warn("unknown default texture",e);return a.getDefaultTextureData("stripes",r,{r:1,g:0,b:0})}};a.FILTER_NEAREST=0;a.FILTER_LINEAR=1;a.FILTER_MIPMAP=2;a.WRAP_REPEAT=0;a.WRAP_MIRRORED_REPEAT=1;a.WRAP_CLAMP_TO_EDGE=2;a.TYPE_DEFAULT=0;a.TYPE_DEPTH=1;a.TYPE_FLOAT=2;a.PFORMATSTR_RGB565="RGB 5/6/5bit ubyte";a.PFORMATSTR_R8UB="R 8bit ubyte";a.PFORMATSTR_RG8UB="RG 8bit ubyte";a.PFORMATSTR_RGB8UB="RGB 8bit ubyte";a.PFORMATSTR_RGBA8UB="RGBA 8bit ubyte";a.PFORMATSTR_SRGBA8="SRGBA 8bit ubyte";a.PFORMATSTR_R11FG11FB10F="RGB 11/11/10bit float";a.PFORMATSTR_R16F="R 16bit float";a.PFORMATSTR_RG16F="RG 16bit float";a.PFORMATSTR_RGB16F="RGB 16bit float";a.PFORMATSTR_RGBA16F="RGBA 16bit float";a.PFORMATSTR_R32F="R 32bit float";a.PFORMATSTR_RG32F="RG 32bit float";a.PFORMATSTR_RGB32F="RGB 32bit float";a.PFORMATSTR_RGBA32F="RGBA 32bit float";a.PFORMATSTR_DEPTH="DEPTH";a.PIXELFORMATS=[a.PFORMATSTR_RGB565,a.PFORMATSTR_R8UB,a.PFORMATSTR_RG8UB,a.PFORMATSTR_RGB8UB,a.PFORMATSTR_RGBA8UB,a.PFORMATSTR_SRGBA8,a.PFORMATSTR_R11FG11FB10F,a.PFORMATSTR_R16F,a.PFORMATSTR_RG16F,a.PFORMATSTR_RGBA16F,a.PFORMATSTR_R32F,a.PFORMATSTR_RGBA32F];const i=8;class u extends a{constructor(e,t={}){super(t);if(!e)throw new Error("no cgl");this._log=new n("cgl_texture");this._cgl=e;this.tex=this._cgl.gl.createTexture();this.loading=false;this.flip=true;this.flipped=false;this.shadowMap=false;this.deleted=false;this.image=null;this.anisotropic=0;this.filter=u.FILTER_NEAREST;this.wrap=u.WRAP_CLAMP_TO_EDGE;this.texTarget=this._cgl.gl.TEXTURE_2D;if(t&&t.type)this.texTarget=t.type;this.textureType=u.TYPE_DEFAULT;this.unpackAlpha=true;this._fromData=true;this._glDataType=-1;this._glInternalFormat=-1;this._glDataFormat=-1;if(t){if(t.isDepthTexture)this.textureType=u.TYPE_DEPTH;if(t.isFloatingPointTexture===true)this.textureType=u.TYPE_FLOAT;if("textureType"in t)this.textureType=t.textureType;if("filter"in t)this.filter=t.filter;if("wrap"in t)this.wrap=t.wrap;if("unpackAlpha"in t)this.unpackAlpha=t.unpackAlpha;if("flip"in t)this.flip=t.flip;if("shadowMap"in t)this.shadowMap=t.shadowMap;if("anisotropic"in t)this.anisotropic=t.anisotropic}else{t={}}if(!t.pixelFormat&&t.isFloatingPointTexture)this.pixelFormat=u.PFORMATSTR_RGBA32F;if(this.textureType==u.TYPE_DEPTH)this.pixelFormat=u.PFORMATSTR_DEPTH;this._cgl.profileData.profileTextureNew++;this.setFormat(u.setUpGlPixelFormat(this._cgl,this.pixelFormat));this._cgl.profileData.addHeavyEvent("texture created",this.name,t.width+"x"+t.height);this.setSize(t.width,t.height);this.getInfoOneLine()}isFloatingPoint(){return u.isPixelFormatFloat(this.pixelFormat)}compareSettings(e){if(!e)return false;return e.width==this.width&&e.height==this.height&&e.filter==this.filter&&e.wrap==this.wrap&&e.textureType==this.textureType&&e.unpackAlpha==this.unpackAlpha&&e.anisotropic==this.anisotropic&&e.shadowMap==this.shadowMap&&e.texTarget==this.texTarget&&e.flip==this.flip}clone(){const e=new u(this._cgl,{name:this.name,filter:this.filter,anisotropic:this.anisotropic,wrap:this.wrap,textureType:this.textureType,pixelFormat:this.pixelFormat,unpackAlpha:this.unpackAlpha,flip:this.flip,width:this.width,height:this.height});this._cgl.profileData.addHeavyEvent("texture created",this.name,this.width+"x"+this.height);if(!this.compareSettings(e)){this._log.error("Cloned texture settings do not compare!");this._log.error(this);this._log.error(e)}return e}setFormat(e){this.pixelFormat=e.pixelFormat;this._glDataFormat=e.glDataFormat;this._glInternalFormat=e.glInternalFormat;this._glDataType=e.glDataType}setSize(e,t){if(this._cgl.aborted)return;if(e!=e||e<=0||!e)e=i;if(t!=t||t<=0||!t)t=i;if(e>this._cgl.maxTexSize||t>this._cgl.maxTexSize)this._log.error("texture size too big! "+e+"x"+t+" / max: "+this._cgl.maxTexSize);e=Math.min(e,this._cgl.maxTexSize);t=Math.min(t,this._cgl.maxTexSize);e=Math.floor(e);t=Math.floor(t);if(this.width==e&&this.height==t)return;e=this._cgl.checkTextureSize(e);t=this._cgl.checkTextureSize(t);this.width=e;this.height=t;this.deleted=false;this.setFormat(u.setUpGlPixelFormat(this._cgl,this.pixelFormat));this.shortInfoString=this.getInfoOneLine();this._cgl.gl.bindTexture(this.texTarget,this.tex);this._cgl.profileData.profileTextureResize++;const n=null;this._cgl.gl.texImage2D(this.texTarget,0,this._glInternalFormat,e,t,0,this._glDataFormat,this._glDataType,n);this._setFilter();this.updateMipMap();this._cgl.gl.bindTexture(this.texTarget,null)}initFromData(e,t,n,a,i){this.filter=a;this.wrap=i;if(a==undefined)this.filter=u.FILTER_LINEAR;if(i==undefined)this.wrap=u.WRAP_CLAMP_TO_EDGE;this.width=t;this.height=n;this._fromData=true;this.deleted=false;if(this.height>this._cgl.maxTexSize||this.width>this._cgl.maxTexSize){const r=CGL.Texture.getTempTexture(this._cgl);this.width=r.width;this.height=r.height;this.tex=r.tex;this._log.warn("[cgl_texture] texture size too big!",this.width,this.height,this._cgl.maxTexSize);return}if(this.flip)this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL,this.flip);this._cgl.gl.bindTexture(this.texTarget,this.tex);this.setFormat(u.setUpGlPixelFormat(this._cgl,this.pixelFormat));this._cgl.gl.texImage2D(this.texTarget,0,this._glInternalFormat,t,n,0,this._glDataFormat,this._glDataType,e);this._setFilter();this.updateMipMap();if(this.flip)this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL,false);this._cgl.gl.bindTexture(this.texTarget,null)}updateMipMap(){if((this._cgl.glVersion==2||this.isPowerOfTwo())&&this.filter==u.FILTER_MIPMAP){this._cgl.gl.generateMipmap(this.texTarget);this._cgl.profileData.profileGenMipMap++}}initTexture(e,t){this._cgl.printError("before initTexture");this._cgl.checkFrameStarted("texture inittexture");this._fromData=false;this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.unpackAlpha);if(e.width||e.videoWidth)this.width=e.videoWidth||e.width;if(e.height||e.videoHeight)this.height=e.videoHeight||e.height;if(t!==undefined)this.filter=t;if(e.height>this._cgl.maxTexSize||e.width>this._cgl.maxTexSize){const n=CGL.Texture.getTempTexture(this._cgl);this.width=n.width;this.height=n.height;this.tex=n.tex;this._log.warn("[cgl_texture] texture size too big!",e.width,e.height,this._cgl.maxTexSize);return}this._cgl.gl.bindTexture(this.texTarget,this.tex);this.deleted=false;this.flipped=!this.flip;if(this.flipped)this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL,this.flipped);this.setFormat(u.setUpGlPixelFormat(this._cgl,this.pixelFormat));this._cgl.gl.texImage2D(this.texTarget,0,this._glInternalFormat,this._glDataFormat,this._glDataType,e);this._setFilter();this.updateMipMap();this._cgl.gl.bindTexture(this.texTarget,null);this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false);if(this.flipped)this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL,false);this.getInfoOneLine();this._cgl.printError("initTexture")}dispose(){this.delete()}delete(){if(this.loading){return}this.deleted=true;this.width=0;this.height=0;this._cgl.profileData.profileTextureDelete++;this._cgl.gl.deleteTexture(this.tex);this.image=null;this.tex=null}isPowerOfTwo(){return u.isPowerOfTwo(this.width)&&u.isPowerOfTwo(this.height)}printInfo(){console.log(this.getInfo())}getInfoReadable(){const e=this.getInfo();let t="";e.name=e.name.substr(0,e.name.indexOf("?rnd="));for(const n in e){t+="* "+n+":  **"+e[n]+"**\n"}return t}getInfoOneLine(){let e=""+this.width+"x"+this.height;e+=" ";e+=this.pixelFormat;if(this.filter===CGL.Texture.FILTER_NEAREST)e+=" nearest";if(this.filter===CGL.Texture.FILTER_LINEAR)e+=" linear";if(this.filter===CGL.Texture.FILTER_MIPMAP)e+=" mipmap";if(this.wrap===CGL.Texture.WRAP_CLAMP_TO_EDGE)e+=" clamp";if(this.wrap===CGL.Texture.WRAP_REPEAT)e+=" repeat";if(this.wrap===CGL.Texture.WRAP_MIRRORED_REPEAT)e+=" repeatmir";this.shortInfoString=e;return e}getInfoOneLineShort(){let e=""+this.width+"x"+this.height;e+=" ";e+=this.pixelFormat;this.shortInfoString=e;return e}getInfo(){return u.getTexInfo(this)}_setFilter(){this._cgl.printError("before _setFilter");if(!this._fromData){this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.unpackAlpha)}if(this.shadowMap){this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D,this._cgl.gl.TEXTURE_COMPARE_MODE,this._cgl.gl.COMPARE_REF_TO_TEXTURE);this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D,this._cgl.gl.TEXTURE_COMPARE_FUNC,this._cgl.gl.LEQUAL)}if(this.textureType==u.TYPE_FLOAT&&this.filter==u.FILTER_MIPMAP){this.filter=u.FILTER_LINEAR;this._log.stack("texture: HDR and mipmap filtering at the same time is not possible")}if(this._cgl.glVersion==1&&!this.isPowerOfTwo()){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.CLAMP_TO_EDGE);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.CLAMP_TO_EDGE);this.filter=u.FILTER_NEAREST;this.wrap=u.WRAP_CLAMP_TO_EDGE}else{if(this.wrap==u.WRAP_CLAMP_TO_EDGE){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.CLAMP_TO_EDGE);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.CLAMP_TO_EDGE)}else if(this.wrap==u.WRAP_REPEAT){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.REPEAT);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.REPEAT)}else if(this.wrap==u.WRAP_MIRRORED_REPEAT){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.MIRRORED_REPEAT);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.MIRRORED_REPEAT)}if(this.filter==u.FILTER_NEAREST){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.NEAREST)}else if(this.filter==u.FILTER_LINEAR){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.LINEAR);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.LINEAR)}else if(this.filter==u.FILTER_MIPMAP){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.LINEAR);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.LINEAR_MIPMAP_LINEAR)}else{this._log.log("unknown texture filter!",this.filter);throw new Error("unknown texture filter!"+this.filter)}if(this.anisotropic){const e=this._cgl.enableExtension("EXT_texture_filter_anisotropic");if(this._cgl.maxAnisotropic){const t=Math.min(this._cgl.maxAnisotropic,this.anisotropic);this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D,e.TEXTURE_MAX_ANISOTROPY_EXT,t)}}}this.getInfoOneLine();this._cgl.printError("_setFilter")}}u.load=function(n,a,i,e){if(!a)return i({error:true});let r=null;if(!n.patch.loading.existByName(a))r=n.patch.loading.start("cgl.texture",a);const s=new u(n);s.name=a;s.image=new Image;s.image.crossOrigin="anonymous";s.loading=true;if(e&&e.hasOwnProperty("filter"))s.filter=e.filter;if(e&&e.hasOwnProperty("flip"))s.flip=e.flip;if(e&&e.hasOwnProperty("wrap"))s.wrap=e.wrap;if(e&&e.hasOwnProperty("anisotropic"))s.anisotropic=e.anisotropic;if(e&&e.hasOwnProperty("unpackAlpha"))s.unpackAlpha=e.unpackAlpha;if(e&&e.hasOwnProperty("pixelFormat"))s.pixelFormat=e.pixelFormat;s.image.onabort=s.image.onerror=e=>{console.warn("[cgl.texture.load] error loading texture",a,e);s.loading=false;if(r)n.patch.loading.finished(r);const t={error:true};if(i)i(t,s)};s.image.onload=function(e){n.addNextFrameOnceCallback(()=>{s.initTexture(s.image);if(r)n.patch.loading.finished(r);s.loading=false;if(i)i(null,s)})};s.image.src=a;return s};u.getTempTexture=function(e){if(!e)console.error("[getTempTexture] no cgl!");if(!e.tempTexture)e.tempTexture=u.getTemporaryTexture(e,256,u.FILTER_LINEAR,u.REPEAT);return e.tempTexture};u.getErrorTexture=function(e){if(!e)console.error("[getTempTexture] no cgl!");if(!e.errorTexture)e.errorTexture=u.getTemporaryTexture(e,256,u.FILTER_LINEAR,u.REPEAT,1,.2,.2);return e.errorTexture};u.getEmptyTexture=function(e,t){if(t)return u.getEmptyTextureFloat(e);if(!e)console.error("[getEmptyTexture] no cgl!");if(e.tempTextureEmpty)return e.tempTextureEmpty;let n=8;e.tempTextureEmpty=new u(e,{name:"emptyTexture"});const a=u.getDefaultTextureData("empty",n);e.tempTextureEmpty.initFromData(a,n,n,u.FILTER_NEAREST,u.WRAP_REPEAT);return e.tempTextureEmpty};u.getEmptyTextureFloat=function(e){if(!e)console.error("[getEmptyTextureFloat] no cgl!");if(e.tempTextureEmptyFloat)return e.tempTextureEmptyFloat;e.tempTextureEmptyFloat=new u(e,{name:"emptyTexture",isFloatingPointTexture:true});const t=new Float32Array(8*8*4).fill(1);for(let e=0;e<8*8*4;e+=4)t[e+3]=0;e.tempTextureEmptyFloat.initFromData(t,8,8,u.FILTER_NEAREST,u.WRAP_REPEAT);return e.tempTextureEmptyFloat};u.getRandomTexture=function(e){if(!e)console.error("[getRandomTexture] no cgl!");if(e.randomTexture)return e.randomTexture;const t=256;const n=u.getDefaultTextureData("randomUInt",t);e.randomTexture=new u(e);e.randomTexture.initFromData(n,t,t,u.FILTER_NEAREST,u.WRAP_REPEAT);return e.randomTexture};u.getRandomFloatTexture=function(e){if(!e)console.error("[getRandomTexture] no cgl!");if(e.getRandomFloatTexture)return e.getRandomFloatTexture;const t=256;const n=u.getDefaultTextureData("randomFloat",t);e.getRandomFloatTexture=new u(e,{isFloatingPointTexture:true});e.getRandomFloatTexture.initFromData(n,t,t,u.FILTER_NEAREST,u.WRAP_REPEAT);return e.getRandomFloatTexture};u.getBlackTexture=function(e){if(!e)this._log.error("[getBlackTexture] no cgl!");if(e.blackTexture)return e.blackTexture;const t=8;const n=u.getDefaultTextureData("color",t,{r:0,g:0,b:0});e.blackTexture=new u(e);e.blackTexture.initFromData(n,t,t,u.FILTER_NEAREST,u.WRAP_REPEAT);return e.blackTexture};u.getEmptyCubemapTexture=function(t){const n=[t.gl.TEXTURE_CUBE_MAP_POSITIVE_X,t.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,t.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,t.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,t.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,t.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];const e=t.gl.createTexture();const a=t.gl.TEXTURE_CUBE_MAP;const i=u.FILTER_NEAREST;const r=u.WRAP_CLAMP_TO_EDGE;const s=8;const o=8;t.profileData.profileTextureNew++;t.gl.bindTexture(a,e);t.profileData.profileTextureResize++;for(let e=0;e<6;e+=1){const l=new Uint8Array(8*8*4);t.gl.texImage2D(n[e],0,t.gl.RGBA,8,8,0,t.gl.RGBA,t.gl.UNSIGNED_BYTE,l);t.gl.texParameteri(a,t.gl.TEXTURE_MAG_FILTER,t.gl.NEAREST);t.gl.texParameteri(a,t.gl.TEXTURE_MIN_FILTER,t.gl.NEAREST);t.gl.texParameteri(a,t.gl.TEXTURE_WRAP_S,t.gl.CLAMP_TO_EDGE);t.gl.texParameteri(a,t.gl.TEXTURE_WRAP_T,t.gl.CLAMP_TO_EDGE)}t.gl.bindTexture(a,null);return{id:CABLES.uuid(),tex:e,cubemap:e,width:s,height:o,filter:i,wrap:r,unpackAlpha:true,flip:true,_fromData:true,name:"emptyCubemapTexture",anisotropic:0}};u.getTempGradientTexture=function(e){if(!e)console.error("[getTempGradientTexture] no cgl!");return u.getTempTexture(e)};u.getTemporaryTexture=function(e,t,n,a,i,r,s){const o=u.getDefaultTextureData("stripes",256,{r:i,g:r,b:s});const l=new u(e);l.initFromData(o,t,t,n,a);return l};u.createFromImage=function(e,t,n){n=n||{};const a=new u(e,n);a.flip=false;a.image=t;a.width=t.videoWidth||t.width||8;a.height=t.videoHeight||t.height||8;if(n.hasOwnProperty("wrap"))a.wrap=n.wrap;a.initTexture(t,n.filter);return a};u.fromImage=function(e,t,n,a){console.error("deprecated texture from image...");const i=new u(e);i.flip=false;if(n)i.filter=n;if(a)i.wrap=a;i.image=t;i.initTexture(t);return i};u.isPowerOfTwo=function(e){return e==1||e==2||e==4||e==8||e==16||e==32||e==64||e==128||e==256||e==512||e==1024||e==2048||e==4096||e==8192||e==16384};u.getTexInfo=function(e){const t={};t.name=e.name;t["power of two"]=e.isPowerOfTwo();t.size=e.width+" x "+e.height;let n=e.texTarget;if(e.texTarget==e._cgl.gl.TEXTURE_2D)n="TEXTURE_2D";t.target=n;t.unpackAlpha=e.unpackAlpha;if(e.cubemap)t.cubemap=true;if(e.textureType==u.TYPE_FLOAT)t.textureType="TYPE_FLOAT";if(e.textureType==u.TYPE_HALF_FLOAT)t.textureType="TYPE_HALF_FLOAT";else if(e.textureType==u.TYPE_DEPTH)t.textureType="TYPE_DEPTH";else if(e.textureType==u.TYPE_DEFAULT)t.textureType="TYPE_DEFAULT";else t.textureType="UNKNOWN "+this.textureType;if(e.wrap==u.WRAP_CLAMP_TO_EDGE)t.wrap="CLAMP_TO_EDGE";else if(e.wrap==u.WRAP_REPEAT)t.wrap="WRAP_REPEAT";else if(e.wrap==u.WRAP_MIRRORED_REPEAT)t.wrap="WRAP_MIRRORED_REPEAT";else t.wrap="UNKNOWN";if(e.filter==u.FILTER_NEAREST)t.filter="FILTER_NEAREST";else if(e.filter==u.FILTER_LINEAR)t.filter="FILTER_LINEAR";else if(e.filter==u.FILTER_MIPMAP)t.filter="FILTER_MIPMAP";else t.filter="UNKNOWN";t.pixelFormat=e.pixelFormat||"unknown";return t};u.setUpGlPixelFormat=function(e,t){const n={};if(!t){e._log.error("no pixelformatstr!");e._log.log(new Error);t=u.PFORMATSTR_RGBA8UB}n.pixelFormatBase=t;n.pixelFormat=t;n.glDataType=e.gl.UNSIGNED_BYTE;n.glInternalFormat=e.gl.RGBA8;n.glDataFormat=e.gl.RGBA;let a=e.gl.FLOAT;if(e.glUseHalfFloatTex){if(t==u.PFORMATSTR_RGBA32F)t=u.PFORMATSTR_RGBA16F;if(t==u.PFORMATSTR_RG32F)t=u.PFORMATSTR_RG16F;if(t==u.PFORMATSTR_R32F)t=u.PFORMATSTR_R16F}if(t.contains("16bit")){if(e.glVersion==2){const i=e.enableExtension("EXT_color_buffer_half_float");if(!i){console.warn("no 16bit extension, fallback to 32bit",t);if(t==u.PFORMATSTR_RGBA16F)t=u.PFORMATSTR_RGBA32F;if(t==u.PFORMATSTR_RGB16F)t=u.PFORMATSTR_RGB32F;if(t==u.PFORMATSTR_RG16F)t=u.PFORMATSTR_RG32F;if(t==u.PFORMATSTR_R16F)t=u.PFORMATSTR_R32F}else{a=e.gl.HALF_FLOAT}}}if(e.glVersion==1){n.glInternalFormat=e.gl.RGBA;if(t==u.PFORMATSTR_RGBA16F||t==u.PFORMATSTR_RG16F||t==u.PFORMATSTR_R16F){const r=e.enableExtension("OES_texture_half_float");if(!r)throw new Error("no half float texture extension");a=r.HALF_FLOAT_OES}}if(t==u.PFORMATSTR_RGBA8UB){}else if(t==u.PFORMATSTR_RGB565){n.glInternalFormat=e.gl.RGB565;n.glDataFormat=e.gl.RGB}else if(t==u.PFORMATSTR_R8UB){n.glInternalFormat=e.gl.R8;n.glDataFormat=e.gl.RED}else if(t==u.PFORMATSTR_RG8UB){n.glInternalFormat=e.gl.RG8;n.glDataFormat=e.gl.RG}else if(t==u.PFORMATSTR_RGB8UB){n.glInternalFormat=e.gl.RGB8;n.glDataFormat=e.gl.RGB}else if(t==u.PFORMATSTR_SRGBA8){n.glInternalFormat=e.gl.SRGB8_ALPHA8}else if(t==u.PFORMATSTR_R32F){n.glInternalFormat=e.gl.R32F;n.glDataFormat=e.gl.RED;n.glDataType=a}else if(t==u.PFORMATSTR_R16F){n.glInternalFormat=e.gl.R16F;n.glDataType=a;n.glDataFormat=e.gl.RED}else if(t==u.PFORMATSTR_RG16F){n.glInternalFormat=e.gl.RG16F;n.glDataType=a;n.glDataFormat=e.gl.RG}else if(t==u.PFORMATSTR_RGBA16F){if(e.glVersion==1)n.glInternalFormat=e.gl.RGBA;else n.glInternalFormat=e.gl.RGBA16F;n.glDataType=a}else if(t==u.PFORMATSTR_R11FG11FB10F){n.glInternalFormat=e.gl.R11F_G11F_B10F;n.glDataType=a;n.glDataFormat=e.gl.RGB}else if(t==u.PFORMATSTR_RGBA32F){if(e.glVersion==1)n.glInternalFormat=e.gl.RGBA;else n.glInternalFormat=e.gl.RGBA32F;n.glDataType=a}else if(t==u.PFORMATSTR_DEPTH){if(e.glVersion==1){n.glInternalFormat=e.gl.DEPTH_COMPONENT;n.glDataType=e.gl.UNSIGNED_SHORT;n.glDataFormat=e.gl.DEPTH_COMPONENT}else{n.glInternalFormat=e.gl.DEPTH_COMPONENT32F;n.glDataType=e.gl.FLOAT;n.glDataFormat=e.gl.DEPTH_COMPONENT}}else{console.log("unknown pixelformat ",t)}if(t.contains("32bit")||t==u.PFORMATSTR_R11FG11FB10F){if(e.glVersion==2)e.enableExtension("EXT_color_buffer_float");if(e.glVersion==2)e.enableExtension("EXT_float_blend");e.enableExtension("OES_texture_float_linear")}n.numColorChannels=u.getPixelFormatNumChannels(t);if(!n.glDataType||!n.glInternalFormat||!n.glDataFormat)console.log("pixelformat wrong ?!",t,n.glDataType,n.glInternalFormat,n.glDataFormat,this);return n};u.getPixelFormatNumChannels=e=>{if(e.startsWith("RGBA"))return 4;if(e.startsWith("RGB"))return 3;if(e.startsWith("RG"))return 2;return 1};u.isPixelFormatFloat=e=>{return(e||"").contains("float")};u.isPixelFormatHalfFloat=e=>{return(e||"").contains("float")&&(e||"").contains("16bit")};const r=8;class s{constructor(e,t){this.id=CABLES.uuid();this.name=t.name||"unknown cubemap texture";this._cgl=e;this.textureType=u.TYPE_DEFAULT;this._options=t;this._cubemapFaces=[this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];this.cubemap=this.tex=this._cgl.gl.createTexture();this.texTarget=this._cgl.gl.TEXTURE_CUBE_MAP;this.width=r;this.height=r;this.filter=t.filter||CGL.Texture.FILTER_NEAREST;this.wrap=t.wrap||CGL.Texture.WRAP_CLAMP_TO_EDGE;this.unpackAlpha=t.unpackAlpha||true;this.flip=t.flip||true;if(!t.hasOwnProperty("pixelFormat")||!t.pixelFormat){if(t.isFloatingPointTexture)t.pixelFormat=u.PFORMATSTR_RGBA32F;else t.pixelFormat=u.PFORMATSTR_RGBA8UB}this.pixelFormat=t.pixelFormat;this._cgl.profileData.profileTextureNew++;this.setSize(t.width,t.height)}getInfo(){return{pixelFormat:this.pixelFormat}}setSize(e,t){this.delete();this.cubemap=this.tex=this._cgl.gl.createTexture();this._cgl.checkFrameStarted("cubemap corelib setsize");if(e!=e||e<=0||!e)e=r;if(t!=t||t<=0||!t)t=r;if(e>this._cgl.maxTexSize||t>this._cgl.maxTexSize)console.error("texture size too big! "+e+"x"+t+" / max: "+this._cgl.maxTexSize);e=Math.min(e,this._cgl.maxTexSize);t=Math.min(t,this._cgl.maxTexSize);e=Math.floor(e);t=Math.floor(t);this.width=e;this.height=t;this._cgl.gl.bindTexture(this.texTarget,this.tex);this._cgl.profileData.profileTextureResize++;const n=u.setUpGlPixelFormat(this._cgl,this._options.pixelFormat);this.pixelFormat=n.pixelFormat;if(CGL.Texture.isPixelFormatHalfFloat(n.pixelFormat)){const a=this._cgl.enableExtension("EXT_color_buffer_half_float");if(!this._cgl.enableExtension("OES_texture_float_linear")){this.filter=u.FILTER_NEAREST}}else if(CGL.Texture.isPixelFormatFloat(n.pixelFormat)){if(!this._cgl.enableExtension("OES_texture_float_linear")){console.log("no linear pixelformat,using nearest");this.filter=u.FILTER_NEAREST}}for(let e=0;e<6;e++){this._cgl.gl.texImage2D(this._cubemapFaces[e],0,n.glInternalFormat,this.width,this.height,0,n.glDataFormat,n.glDataType,null)}this._setFilter();this.updateMipMap();this._cgl.gl.bindTexture(this.texTarget,null)}_setFilter(){this._cgl.checkFrameStarted("cubemap corelib");this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.unpackAlpha);if(CGL.Texture.isPixelFormatFloat(this.pixelFormat)&&this.filter==CGL.Texture.FILTER_MIPMAP){console.log("texture: HDR and mipmap filtering at the same time is not possible");this.filter=CGL.Texture.FILTER_LINEAR}if(this._cgl.glVersion==1&&!u.isPowerOfTwo()){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.CLAMP_TO_EDGE);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.CLAMP_TO_EDGE);this.filter=CGL.Texture.FILTER_NEAREST;this.wrap=CGL.Texture.WRAP_CLAMP_TO_EDGE}else{if(this.wrap==CGL.Texture.WRAP_CLAMP_TO_EDGE){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.CLAMP_TO_EDGE);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.CLAMP_TO_EDGE)}else if(this.wrap==CGL.Texture.WRAP_REPEAT){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.REPEAT);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.REPEAT)}else if(this.wrap==CGL.Texture.WRAP_MIRRORED_REPEAT){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_S,this._cgl.gl.MIRRORED_REPEAT);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_WRAP_T,this._cgl.gl.MIRRORED_REPEAT)}else{throw new Error("[CubemapTexture] unknown texture filter!"+this.filter)}if(this.filter==CGL.Texture.FILTER_NEAREST){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.NEAREST);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.NEAREST)}else if(this.filter==CGL.Texture.FILTER_LINEAR){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.LINEAR);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.LINEAR)}else if(this.filter==CGL.Texture.FILTER_MIPMAP){this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MAG_FILTER,this._cgl.gl.LINEAR);this._cgl.gl.texParameteri(this.texTarget,this._cgl.gl.TEXTURE_MIN_FILTER,this._cgl.gl.LINEAR_MIPMAP_LINEAR)}else{throw new Error("[CubemapTexture] unknown texture filter!"+this.filter)}}}updateMipMap(){if(this.filter==CGL.Texture.FILTER_MIPMAP){this._cgl.gl.bindTexture(this.texTarget,this.tex);this._cgl.gl.generateMipmap(this.texTarget);this._cgl.profileData.profileGenMipMap++}}delete(){this._cgl.gl.deleteTexture(this.tex)}}class o{constructor(e,t,n,a){this._cgl=e;this.width=t||8;this.height=n||8;this._cubemapProperties=[{face:this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,lookAt:vec3.fromValues(1,0,0),up:vec3.fromValues(0,-1,0)},{face:this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,lookAt:vec3.fromValues(-1,0,0),up:vec3.fromValues(0,-1,0)},{face:this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,lookAt:vec3.fromValues(0,1,0),up:vec3.fromValues(0,0,1)},{face:this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,lookAt:vec3.fromValues(0,-1,0),up:vec3.fromValues(0,0,-1)},{face:this._cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,lookAt:vec3.fromValues(0,0,1),up:vec3.fromValues(0,-1,0)},{face:this._cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,lookAt:vec3.fromValues(0,0,-1),up:vec3.fromValues(0,-1,0)}];this._lookAtTemp=vec3.fromValues(0,0,0);this.camPos=vec3.fromValues(0,0,0);this._modelMatrix=mat4.create();this._viewMatrix=mat4.create();this._projectionMatrix=mat4.perspective(mat4.create(),CGL.DEG2RAD*90,1,.1,1e3);this._depthRenderbuffer=null;this._framebuffer=null;this._depthbuffer=null;this._textureDepth=null;this._options=a||{};this.name=this._options.name||"unknown cubemapframebuffer";if(!this._options.hasOwnProperty("numRenderBuffers"))this._options.numRenderBuffers=1;if(!this._options.hasOwnProperty("depth"))this._options.depth=true;if(!this._options.hasOwnProperty("clear"))this._options.clear=true;if(!this._options.hasOwnProperty("multisampling")){this._options.multisampling=false;this._options.multisamplingSamples=0}if(this._options.multisamplingSamples){if(this._cgl.glSlowRenderer)this._options.multisamplingSamples=0;if(!this._cgl.gl.MAX_SAMPLES)this._options.multisamplingSamples=0;else this._options.multisamplingSamples=Math.min(this._cgl.gl.getParameter(this._cgl.gl.MAX_SAMPLES),this._options.multisamplingSamples)}if(!this._options.hasOwnProperty("filter"))this._options.filter=CGL.Texture.FILTER_LINEAR;if(!this._options.hasOwnProperty("wrap"))this._options.wrap=CGL.Texture.WRAP_CLAMP_TO_EDGE;this._cgl.checkFrameStarted("cubemap framebuffer");let i=a.pixeFormat;if(!i&&a.isFloatingPointTexture)i=CGL.Texture.PFORMATSTR_RGBA32F;this.texture=new s(this._cgl,{width:this.width,height:this.height,pixelFormat:a.pixelFormat,filter:this._options.filter,wrap:this._options.wrap,name:this.name+" cubemaptexture"});this.initializeRenderbuffers();this.setSize(this.width,this.height)}initializeRenderbuffers(){this._framebuffer=this._cgl.gl.createFramebuffer();this._depthbuffer=this._cgl.gl.createRenderbuffer();this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,this._framebuffer);this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER,this._depthbuffer);this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.DEPTH_COMPONENT16,this.width,this.height);this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER,this._cgl.gl.DEPTH_ATTACHMENT,this._cgl.gl.RENDERBUFFER,this._depthbuffer);this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER,null);this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,null)}getWidth(){return this.width}getHeight(){return this.height}getGlFrameBuffer(){return this._framebuffer}getDepthRenderBuffer(){return this._depthRenderbuffer}getTextureColor(){return this.texture}getTextureDepth(){return this._textureDepth}dispose(){if(this.texture)this.texture=this.texture.delete();if(this._framebuffer)this._cgl.gl.deleteFramebuffer(this._framebuffer);if(this._depthRenderbuffer)this._cgl.gl.deleteRenderbuffer(this._depthbuffer)}delete(){this.dispose()}setSize(e,t){this._cgl.printError("before cubemap setsize");this.width=Math.floor(e);this.height=Math.floor(t);this.width=Math.min(this.width,this._cgl.maxTexSize);this.height=Math.min(this.height,this._cgl.maxTexSize);this._cgl.profileData.profileFrameBuffercreate++;this._framebuffer=this._cgl.gl.createFramebuffer();this._depthbuffer=this._cgl.gl.createRenderbuffer();this.texture.setSize(this.width,this.height);this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,this._framebuffer);this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER,this._depthbuffer);this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.DEPTH_COMPONENT16,this.width,this.height);this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER,this._cgl.gl.DEPTH_ATTACHMENT,this._cgl.gl.RENDERBUFFER,this._depthbuffer);if(!this._cgl.gl.isFramebuffer(this._framebuffer)){console.error("invalid framebuffer...")}const n=this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);this.checkErrorsByStatus(n);this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_CUBE_MAP,null);this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER,null);this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,null);this._cgl.printError("cubemap setsize")}checkErrorsByStatus(e){switch(e){case this._cgl.gl.FRAMEBUFFER_COMPLETE:break;case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:console.error("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...",this.width,this.height,this.texture.tex,this._depthBuffer);throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:console.error("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:console.error("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:console.error("FRAMEBUFFER_UNSUPPORTED");throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");case 36059:console.error("Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour.");break;default:console.error("incomplete framebuffer",e);console.log(this);throw new Error("Incomplete framebuffer: "+e)}}setFilter(e){this.texture.filter=e;this.texture.setSize(this.width,this.height)}setCamPos(e){this.camPos=e||this.camPos}setMatrices(e,t,n){this._modelMatrix=e||this._modelMatrix;this._viewMatrix=t||this._viewMatrix;this._projectionMatrix=n||this._projectionMatrix}renderStart(){this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_CUBE_MAP,this.texture.tex);this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,this._framebuffer);this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER,this._depthbuffer);this._cgl.gl.viewport(0,0,this.width,this.height);this._cgl.pushGlFrameBuffer(this._framebuffer);this._cgl.pushFrameBuffer(this)}renderStartCubemapFace(e){this._cgl.pushModelMatrix();this._cgl.pushViewMatrix();this._cgl.pushPMatrix();this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER,this._cgl.gl.COLOR_ATTACHMENT0,this._cubemapProperties[e].face,this.texture.tex,0);this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER,this._cgl.gl.DEPTH_ATTACHMENT,this._cgl.gl.RENDERBUFFER,this._depthbuffer);if(this._options.clear){this._cgl.gl.clearColor(0,0,0,1);this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT|this._cgl.gl.DEPTH_BUFFER_BIT)}this.setMatricesCubemapFace(e)}setMatricesCubemapFace(e){mat4.copy(this._cgl.mMatrix,this._modelMatrix);vec3.add(this._lookAtTemp,this.camPos,this._cubemapProperties[e].lookAt);mat4.lookAt(this._cgl.vMatrix,this.camPos,this._lookAtTemp,this._cubemapProperties[e].up);mat4.copy(this._cgl.pMatrix,this._projectionMatrix)}renderEndCubemapFace(){this._cgl.popPMatrix();this._cgl.popModelMatrix();this._cgl.popViewMatrix()}renderEnd(){this._cgl.profileData.profileFramebuffer++;if(this._cgl.glVersion!==1){this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER,this._framebuffer)}this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER,this._cgl.popGlFrameBuffer());this._cgl.popFrameBuffer();this._cgl.resetViewPort();this.updateMipMap()}updateMipMap(){if(!this.texture)return;this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_CUBE_MAP,this.texture.tex);this.texture.updateMipMap();this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_CUBE_MAP,null)}}CGL.CubemapFramebuffer=o;((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Cubemapframebuffer=e.Cubemapframebuffer})();(()=>{"use strict";var e={};class t{constructor(e,t,n){this._cgl=e;this._name=t;this._origShaders={};this._uniforms=[];this._structUniforms=[];this._definesToggled={};this._defines={};this._mods=[];this._textures=[];this._boundShader=null;this._changedDefines=true;this._changedUniforms=true;this._modulesChanged=false;this.needsTexturePush=false;this._lastShader=null;this._attributes=[];if(n&&n.opId)this.opId=n.opId;if(this._cgl.glVersion==1){this._cgl.enableExtension("OES_texture_float");this._cgl.enableExtension("OES_texture_float_linear");this._cgl.enableExtension("OES_texture_half_float");this._cgl.enableExtension("OES_texture_half_float_linear")}}bind(e,t){const n=e||this._cgl.getShader();if(!n)return;this._boundShader=this._origShaders[n.id];let a=false;if(this._boundShader&&this._lastShader!=this._boundShader.shader){if(!this._boundShader.shader.hasModule(this._mods[0].id))a=true}if(a||!this._boundShader||n.lastCompile!=this._boundShader.lastCompile||this._modulesChanged||n._needsRecompile){if(this._boundShader)this._boundShader.shader.dispose();if(n._needsRecompile)n.compile();this.needsTexturePush=true;this._boundShader=this._origShaders[n.id]={lastCompile:n.lastCompile,orig:n,shader:n.copy()};this._addModulesToShader(this._boundShader.shader);this._updateDefinesShader(this._boundShader.shader);this._updateUniformsShader(this._boundShader.shader)}this._boundShader.wireframe=n.wireframe;if(this._changedDefines)this._updateDefines();if(this._changedUniforms)this._updateUniforms();if(t!==false)this._cgl.pushShader(this._boundShader.shader);this._boundShader.shader.copyUniformValues(this._boundShader.orig);if(this.needsTexturePush){for(let e=0;e<this._textures.length;e++){const i=this._textures[e][0];const r=this._textures[e][1];const s=this._textures[e][2];if(this._getUniform(i)){const o=this.getPrefixedName(i);const l=this._boundShader.shader.getUniform(o);if(l)this._boundShader.shader.pushTexture(l,r,s)}}this.needsTexturePush=false;this._textures.length=0}this._modulesChanged=false;this._boundShader.shader.fromMod=this;if(this.onBind)this.onBind(this._boundShader.shader);return this._boundShader.shader}unbind(e){if(this._boundShader){if(e!==false)this._cgl.popShader()}this._boundShader=null}_addModulesToShader(t){let n;if(this._mods.length>1)n=this._mods[0];for(let e=0;e<this._mods.length;e++)t.addModule(this._mods[e],n)}_removeModulesFromShader(e){for(const t in this._origShaders)this._origShaders[t].shader.removeModule(e)}addModule(e){this._mods.push(e);this._modulesChanged=true}removeModule(t){const n=[];let a=false;for(let e=0;e<this._mods.length;e++){if(this._mods[e].title==t){a=true;this._removeModulesFromShader(this._mods[e]);n.push(e)}}for(let e=n.length-1;e>=0;e-=1)this._mods.splice(n[e],1);this._modulesChanged=true}_updateUniformsShader(a){for(let e=0;e<this._uniforms.length;e++){const t=this._uniforms[e];const n=this.getPrefixedName(t.name);if(!a.hasUniform(n)&&!t.structName){let e=null;if(t.shaderType==="both"){e=a.addUniformBoth(t.type,n,t.v1,t.v2,t.v3,t.v4);e.comment="mod: "+this._name}else if(t.shaderType==="frag"){e=a.addUniformFrag(t.type,n,t.v1,t.v2,t.v3,t.v4);e.comment="mod: "+this._name}else if(t.shaderType==="vert"){e=a.addUniformVert(t.type,n,t.v1,t.v2,t.v3,t.v4);e.comment="mod: "+this._name}}}for(let n=0;n<this._structUniforms.length;n+=1){const i=this._structUniforms[n];let e=i.uniformName;let t=i.structName;const r=i.members;e=this.getPrefixedName(i.uniformName);t=this.getPrefixedName(i.structName);if(i.shaderType==="frag"){a.addUniformStructFrag(t,e,r)}if(i.shaderType==="vert"){a.addUniformStructVert(t,e,r)}if(i.shaderType==="both"){a.addUniformStructBoth(t,e,r)}}}_updateUniforms(){for(const e in this._origShaders)this._updateUniformsShader(this._origShaders[e].shader);this._changedUniforms=false}_setUniformValue(e,t,n){const a=e.getUniform(t);if(a)a.setValue(n)}setUniformValue(e,t){const n=this._getUniform(e);if(!n)return;const a=this.getPrefixedName(e);for(const i in this._origShaders){this._setUniformValue(this._origShaders[i].shader,a,t)}}hasUniform(e){return this._getUniform(e)}_getUniform(t){for(let e=0;e<this._uniforms.length;e++){if(this._uniforms[e].name==t)return this._uniforms[e];if(this._uniforms[e].structName){if(this._uniforms[e].propertyName==t)return this._uniforms[e]}}return false}_getStructUniform(t){for(let e=0;e<this._structUniforms.length;e+=1)if(this._structUniforms[e].uniformName===t)return this._structUniforms[e];return null}_isStructUniform(t){for(let e=0;e<this._uniforms.length;e++){if(this._uniforms[e].name==t)return false;if(this._uniforms[e].structName){if(this._uniforms[e].propertyName==t)return true}}return false}addUniform(t,n,a,i,r,s,o,l,u,m){if(!this._getUniform(n)){let e="both";if(m)e=m;this._uniforms.push({type:t,name:n,v1:a,v2:i,v3:r,v4:s,structUniformName:o,structName:l,propertyName:u,shaderType:e});this._changedUniforms=true}}addUniformFrag(e,t,n,a,i,r){this.addUniform(e,t,n,a,i,r,null,null,null,"frag");this._changedUniforms=true}addUniformVert(e,t,n,a,i,r){this.addUniform(e,t,n,a,i,r,null,null,null,"vert");this._changedUniforms=true}addUniformBoth(e,t,n,a,i,r){this.addUniform(e,t,n,a,i,r,null,null,null,"both");this._changedUniforms=true}addUniformStruct(t,n,a,i){for(let e=0;e<a.length;e+=1){const r=a[e];if((r.type==="2i"||r.type==="i"||r.type==="3i")&&i==="both")console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:",t," with member:",r.name," of type:",r.type,".");if(!this._getUniform(n+"."+r.name)){this.addUniform(r.type,n+"."+r.name,r.v1,r.v2,r.v3,r.v4,n,t,r.name,i)}}if(!this._getStructUniform(n)){this._structUniforms.push({structName:t,uniformName:n,members:a,shaderType:i})}}addUniformStructVert(e,t,n){this.addUniformStruct(e,t,n,"vert")}addUniformStructFrag(e,t,n){this.addUniformStruct(e,t,n,"frag")}addUniformStructBoth(e,t,n){this.addUniformStruct(e,t,n,"both")}addAttribute(t){for(let e=0;e<this._attributes.length;e++){if(this._attributes[e].name==t.name&&this._attributes[e].nameFrag==t.nameFrag)return}this._attributes.push(t)}pushTexture(e,t,n){if(!t)throw new Error("no texture given to texturestack");this._textures.push([e,t,n]);this.needsTexturePush=true}_removeUniformFromShader(e,t){if(t.hasUniform(e))t.removeUniform(e)}removeUniform(t){if(this._getUniform(t)){for(let e=this._uniforms.length-1;e>=0;e-=1){const n=t;if(this._uniforms[e].name==t&&!this._uniforms[e].structName){for(const a in this._origShaders){this._removeUniformFromShader(this.getPrefixedName(n),this._origShaders[a].shader)}this._uniforms.splice(e,1)}}this._changedUniforms=true}}removeUniformStruct(t){if(this._getStructUniform(t)){for(let e=this._structUniforms.length-1;e>=0;e-=1){const n=this._structUniforms[e];if(n.uniformName===t){for(const a in this._origShaders){for(let e=0;e<n.members.length;e+=1){const i=n.members[e];this._removeUniformFromShader(this.getPrefixedName(i.name),this._origShaders[a].shader)}}this._structUniforms.splice(e,1)}}this._changedUniforms=true}}getPrefixedName(e){const t=this._mods[0].group;if(t===undefined){return}if(e.startsWith("MOD_")){e=e.substr("MOD_".length);e="mod"+t+"_"+e}return e}_updateDefinesShader(e){for(const t in this._defines){const n=this.getPrefixedName(t);if(this._defines[t]!==null&&this._defines[t]!==undefined)e.define(n,this._defines[t]);else e.removeDefine(n)}for(const t in this._definesToggled){const n=this.getPrefixedName(t);e.toggleDefine(n,this._definesToggled[t])}}_updateDefines(){for(const e in this._origShaders)this._updateDefinesShader(this._origShaders[e].shader);this._changedDefines=false}define(e,t){if(t===undefined)t=true;this._defines[e]=t;this._changedDefines=true}removeDefine(e){this._defines[e]=null;this._changedDefines=true}hasDefine(e){if(this._defines[e]!==null&&this._defines[e]!==undefined)return true;return false}toggleDefine(e,t){this._changedDefines=true;this._definesToggled[e]=t}currentShader(){if(!this._boundShader)return null;return this._boundShader.shader}dispose(){}}CGL.ShaderModifier=t;((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Shadermodifier=e.Shadermodifier})();(()=>{"use strict";var e={};const t=class{constructor(n,e){e=e||{};this._op=n;n.patchId=n.addInPort(new CABLES.Port(n,"patchId",CABLES.OP_PORT_TYPE_STRING,{display:"readonly",hidePort:true,hideParam:true}));n.setUiAttribs({subPatchOp:{version:2}});if(n.uiAttribs.parentOfSubpatch){n.patchId.set(n.uiAttribs.parentOfSubpatch)}else{if(e.subId)n.patchId.set(e.subId);else n.patchId.set(CABLES.generateUUID())}n.patchId.onChange=()=>{if(e.subId)n.patchId.value=e.subId};n.init=()=>{n.setStorage({subPatchVer:2})};n.loadDependencies=(e,t)=>{if(CABLES.UI){gui.serverOps.loadProjectDependencies(e,()=>{if(t)t()})}else if(t)t()};n.on("delete",()=>{if(n.patch.clearSubPatchCache)n.patch.clearSubPatchCache(this.patchId);const t=n.patch.ops;for(let e=t.length-1;e>=0;e--)if(t[e]&&t[e].uiAttribs&&t[e].uiAttribs.subPatch==n.patchId.get())n.patch.deleteOp(t[e].id)});this._op.isExposableSubpatchOp=()=>{return true}}get patchId(){return this._op.patchId.get()}};CABLES.SubPatchOp=t;((this.CABLES=this.CABLES||{}).COREMODULES=this.CABLES.COREMODULES||{}).Subpatchop=e.Cables})();(()=>{"use strict";var e={};const t=class{constructor(){this.patch=null;this.fsElement=null;this.callbacks={}}add(e,t,n){this.patch=e;this.callbacks[t]=n;this.show()}remove(e){delete this.callbacks[e];if(Object.keys(this.callbacks).length==0){if(this.fsElement)this.fsElement.remove();this.fsElement=null}}show(){if(!this.fsElement){this.fsElement=document.createElement("div");const e=this.patch.cgl.canvas.parentElement;if(e)e.appendChild(this.fsElement);this.fsElement.addEventListener("pointerdown",e=>{for(const t in this.callbacks)this.callbacks[t]()})}this.fsElement.style.padding="10px";this.fsElement.style.position="absolute";this.fsElement.style.right="20px";this.fsElement.style.bottom="20px";this.fsElement.style.width="24px";this.fsElement.style.height="24px";this.fsElement.style.cursor="pointer";this.fsElement.style["border-radius"]="40px";this.fsElement.style.background="#444";this.fsElement.style["z-index"]="9999";this.fsElement.style.display="block";this.fsElement.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>'}};CABLES.interActionNeededButton=CABLES.interActionNeededButton||new t;((this.CABLES=this.CABLES||{}).COREMODULES=this.CABLES.COREMODULES||{}).Interactionneededbutton=e.Cables})();(()=>{"use strict";var e={};class m{constructor(e,t){this.initiator=e;this._options=t}stack(e){console.info("["+this.initiator+"] ",e);console.log((new Error).stack)}groupCollapsed(e){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments);console.groupCollapsed("["+this.initiator+"] "+e)}table(e){console.table(e)}groupEnd(){console.groupEnd()}error(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)||!CABLES.UI){console.error("["+this.initiator+"]",...arguments)}if(this._options&&this._options.onError){this._options.onError(this.initiator,...arguments)}}errorGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)}warn(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:1},...arguments)||!CABLES.logSilent)console.warn("["+this.initiator+"]",...arguments)}verbose(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}info(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.info("["+this.initiator+"]",...arguments)}log(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}logGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)}userInteraction(e){}}const i={};i.float32Concat=function(e,t){if(!(e instanceof Float32Array))e=new Float32Array(e);if(!(t instanceof Float32Array))t=new Float32Array(t);const n=new Float32Array(e.length+t.length);n.set(e);n.set(t,e.length);return n};const k=function(e){let t=e.split(".")[e.split(".").length-1];if(t.contains(CONSTANTS.OP.OP_VERSION_PREFIX)){const n=t.split(CONSTANTS.OP.OP_VERSION_PREFIX)[1];t=t.substring(0,t.length-(CONSTANTS.OP.OP_VERSION_PREFIX+n).length)}return t};const F=function(t){for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.seededRandom()*(e+1));const a=t[e];t[e]=t[n];t[n]=a}return t};const t={};const n=function(){let e=Math.random().toString(36).substr(2,9);if(t.hasOwnProperty(e))e=n();t[e]=true;return e};const G=null&&n;const a=function(){let n=(new Date).getTime();const e="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=(n+Math.random()*16)%16|0;n=Math.floor(n/16);return(e=="x"?t:t&3|8).toString(16)});return e};const U=null&&a;const B=null&&a;function r(e){for(const t in e){if(e[t]&&typeof objValue==="object"&&e[t].constructor===Object)e[t]=r(e[t]);if(e[t]===null||e[t]===undefined)delete e[t];else if(Array.isArray(e[t])&&e[t].length==0)delete e[t]}return e}const s=function(n,e="id"){let a=0;if(Array.prototype.reduce){a=n.split("").reduce((e,t)=>{e=(e<<5)-e+t.charCodeAt(0);return e&e},0)}else{if(n.length>0){for(let t=0;t<n.length;t++){let e=n.charCodeAt(t);a=(a<<5)-a+e;a&=a}}}return e+""+a};const D=null&&s;let o=0;const V=function(){o++;return o};const z=function(e){const t=Math.max(0,Math.min(1,(e-0)/(1-0)));e=t*t*(3-2*t);return e};const X=function(e){const t=Math.max(0,Math.min(1,(e-0)/(1-0)));e=t*t*t*(t*(t*6-15)+10);return e};const q=function(e,t,n){return Math.min(Math.max(e,t),n)};const H=function(e,t,n,a,i,r){if(e>=n)return i;if(e<=t)return a;let s=false;const o=Math.min(t,n);const l=Math.max(t,n);if(o!=t)s=true;let u=false;const m=Math.min(a,i);const p=Math.max(a,i);if(m!=a)u=true;let c=0;let d=0;if(s)c=(l-e)*(p-m)/(l-o);else c=(e-o)*(p-m)/(l-o);if(u)d=p-c;else d=c+m;if(!r)return d;if(r==1){e=Math.max(0,Math.min(1,(d-a)/(i-a)));return a+e*e*(3-2*e)*(i-a)}if(r==2){e=Math.max(0,Math.min(1,(d-a)/(i-a)));return a+e*e*e*(e*(e*6-15)+10)*(i-a)}return d};Math.randomSeed=1;Math.setRandomSeed=function(e){Math.randomSeed=e*50728129;if(e!=0){Math.randomSeed=Math.seededRandom()*17624813;Math.randomSeed=Math.seededRandom()*9737333}};Math.seededRandom=function(e,t){if(Math.randomSeed===0)Math.randomSeed=Math.random()*999;e=e||1;t=t||0;Math.randomSeed=(Math.randomSeed*9301+49297)%233280;const n=Math.randomSeed/233280;return t+n*(e-t)};i.isNumeric=function(e){return!isNaN(parseFloat(e))&&isFinite(e)};i.isArray=function(e){return Object.prototype.toString.call(e)==="[object Array]"};String.prototype.endl=function(){return this+"\n"};String.prototype.startsWith=function(e){if(!this||!e)return false;if(this.length>=e.length){if(this.substring(0,e.length)==e)return true}return false};String.prototype.endsWith=String.prototype.endsWith||function(e){return this.match(e+"$")==e};String.prototype.contains=String.prototype.contains||function(e){return this.indexOf(e)>-1};const Y=function(e=""){if(!e)return"";if(e.startsWith("data:"))return;if(e.contains("?"))e+="&";else e+="?";return e+"cache="+CABLES.uuid()};const W=function(t,n){if(!t)return null;n=n||[];n.length=t.length;for(let e=0;e<t.length;e++){n[e]=t[e]}return n};const Z=function(e){let t=CABLES.filename(e);const n=t.split(".");t=n[0];return t};const K=function(){console.log("logstack",(new Error).stack)};const J=function(e){let t="";if(!e)return"";if(e.startsWith("data:")&&e.contains(":")){const n=e.split(",");return n[0]}let n=(e+"").split("/");if(n.length>0){const a=n[n.length-1];let e=a.split("?");t=e[0]}return t||""};const Q=function(e,t,n,a,i){u({url:e,cb:t,method:n,data:a,contenttype:i,sync:true})};const $=function(e,t,n,a,i,r,s={},o={}){const l={url:e,cb:t,method:n,data:a,contenttype:i,sync:false,jsonP:r,headers:s};if(o&&o.credentials)l.credentials=o.credentials;u(l)};const u=function(t){if(!t.hasOwnProperty("asynch"))t.asynch=true;let n;try{n=new XMLHttpRequest}catch(e){}n.onreadystatechange=function(){if(n.readyState!=4)return;if(t.cb){if(n.status==200||n.status==0)t.cb(false,n.responseText,n);else t.cb(true,n.responseText,n)}};try{n.open(t.method?t.method.toUpperCase():"GET",t.url,!t.sync)}catch(e){if(t.cb&&e)t.cb(true,e.msg,n)}if(typeof t.headers==="object"){if(t.headers){const a=Object.keys(t.headers);for(let e=0;e<a.length;e++){const i=a[e];const r=t.headers[i];n.setRequestHeader(i,r)}}}if(t.credentials&&t.credentials!=="omit"){n.withCredentials=true}try{if(!t.post&&!t.data){n.send()}else{n.setRequestHeader("Content-type",t.contenttype?t.contenttype:"application/x-www-form-urlencoded");n.send(t.data||t.post)}}catch(e){if(t.cb)t.cb(true,e.msg,n)}};const ee=function(e){if(!e&&e!==0)return"Unidentified";const t={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};if(t[e]){return t[e]}else{return String.fromCharCode(e)}};window.performance=window.performance||{offset:Date.now(),now:function e(){return Date.now()-this.offset}};const te=function(e){CABLES.errorConsole=CABLES.errorConsole||{log:[]};CABLES.errorConsole.log.push({initiator:e,arguments:arguments});if(!CABLES.errorConsole.ele){const t=document.createElement("div");t.id="cablesErrorConsole";t.style.width="90%";t.style.height="300px";t.style.zIndex="9999999";t.style.display="inline-block";t.style.position="absolute";t.style.padding="10px";t.style.fontFamily="monospace";t.style.color="red";t.style.backgroundColor="#200";CABLES.errorConsole.ele=t;document.body.appendChild(t)}let a="ERROR<br/>for more info, open your browsers dev tools console (Ctrl+Shift+I or Command+Alt+I)<br/>";for(let n=0;n<CABLES.errorConsole.log.length;n++){a+=CABLES.errorConsole.log[n].initiator+" ";for(let e=1;e<CABLES.errorConsole.log[n].arguments.length;e++){if(e>2)a+=", ";let t=CABLES.errorConsole.log[n].arguments[e];if(t.constructor.name.indexOf("Error")>-1||t.constructor.name.indexOf("error")>-1){let e="Uncaught ErrorEvent ";if(t.message)e+=" message: "+t.message;a+=e}else if(typeof t=="string")a+=t;else if(typeof t=="number")a+=String(t)+" "}a+="<br/>"}CABLES.errorConsole.ele.innerHTML=a};class l{constructor(e){this._init();this._first=true;this._wireMesh=null;if(e)this.apply(e)}_init(){this._max=[-0,-0,-0];this._min=[0,0,0];this._center=[0,0,0];this._size=[0,0,0];this._maxAxis=0;this._first=true}get maxAxis(){return this._maxAxis||1}get size(){return this._size}get center(){return this._center}get x(){return this._center[0]}get y(){return this._center[1]}get z(){return this._center[2]}get minX(){return this._min[0]}get minY(){return this._min[1]}get minZ(){return this._min[2]}get maxX(){return this._max[0]}get maxY(){return this._max[1]}get maxZ(){return this._max[2]}apply(t,e){if(!t){return}if(t instanceof l){const n=t;this.applyPos(n.maxX,n.maxY,n.maxZ);this.applyPos(n.minX,n.minY,n.minZ)}else{for(let e=0;e<t.vertices.length;e+=3)this.applyPos(t.vertices[e],t.vertices[e+1],t.vertices[e+2])}this.calcCenterSize()}copy(){return new l(this)}get changed(){return!(this._max[0]==-Number.MAX_VALUE&&this._max[1]==-Number.MAX_VALUE&&this._max[2]==-Number.MAX_VALUE)}applyPos(e,t,n){if(e==Number.MAX_VALUE||e==-Number.MAX_VALUE||t==Number.MAX_VALUE||t==-Number.MAX_VALUE||n==Number.MAX_VALUE||n==-Number.MAX_VALUE)return;if(!CABLES.UTILS.isNumeric(e)||!CABLES.UTILS.isNumeric(t)||!CABLES.UTILS.isNumeric(n))return;if(this._first){this._max[0]=e;this._max[1]=t;this._max[2]=n;this._min[0]=e;this._min[1]=t;this._min[2]=n;this._first=false;return}this._max[0]=Math.max(this._max[0],e);this._max[1]=Math.max(this._max[1],t);this._max[2]=Math.max(this._max[2],n);this._min[0]=Math.min(this._min[0],e);this._min[1]=Math.min(this._min[1],t);this._min[2]=Math.min(this._min[2],n)}calcCenterSize(){if(this._first)return;this._size[0]=this._max[0]-this._min[0];this._size[1]=this._max[1]-this._min[1];this._size[2]=this._max[2]-this._min[2];this._center[0]=(this._min[0]+this._max[0])/2;this._center[1]=(this._min[1]+this._max[1])/2;this._center[2]=(this._min[2]+this._max[2])/2;this._maxAxis=Math.max(this._size[2],Math.max(this._size[0],this._size[1]))}mulMat4(e){if(this._first){this._max[0]=0;this._max[1]=0;this._max[2]=0;this._min[0]=0;this._min[1]=0;this._min[2]=0;this._first=false}vec3.transformMat4(this._max,this._max,e);vec3.transformMat4(this._min,this._min,e);this.calcCenterSize()}render(e,t,n){if(!this._wireMesh)this._wireMesh=new CGL.WireCube(e);e.pushModelMatrix();mat4.translate(e.mMatrix,e.mMatrix,this._center);if(CABLES.UI&&n){CABLES.UI.OverlayMeshes.drawCube(n,this._size[0]/2,this._size[1]/2,this._size[2]/2)}e.popModelMatrix()}}const p=function(e){this.name=e||"unknown";this._log=new m("cgl_geometry");this.faceVertCount=3;this.glPrimitive=null;this._attributes={};this._vertices=[];this.verticesIndices=[];this.isGeometry=true;this.morphTargets=[];Object.defineProperty(this,"vertices",{get(){return this._vertices},set(e){this.setVertices(e)}});Object.defineProperty(this,"texCoords",{get(){const e=this.getAttribute("texCoords");if(!e)return[];return e.data},set(e){this.setAttribute("texCoords",e,2)}});Object.defineProperty(this,"vertexNormals",{get(){const e=this.getAttribute("vertexNormals");if(!e)return[];return e.data},set(e){this.setAttribute("vertexNormals",e,3)}});Object.defineProperty(this,"tangents",{get(){const e=this.getAttribute("tangents");if(!e)return[];return e.data},set(e){this.setAttribute("tangents",e,3)}});Object.defineProperty(this,"biTangents",{get(){const e=this.getAttribute("biTangents");if(!e)return[];return e.data},set(e){this.setAttribute("biTangents",e,3)}});Object.defineProperty(this,"vertexColors",{get(){const e=this.getAttribute("vertexColors");if(!e)return[];return e.data},set(e){this.setAttribute("vertexColors",e,4)}})};p.prototype.clear=function(){this._vertices=new Float32Array([]);this.verticesIndices=[];this.texCoords=new Float32Array([]);this.vertexNormals=new Float32Array([]);this.tangents=[];this.biTangents=[];this._attributes={}};p.prototype.getAttributes=function(){return this._attributes};p.prototype.getAttribute=function(e){for(const t in this._attributes){if(this._attributes[t].name==e)return this._attributes[t]}return null};p.prototype.setAttribute=function(e,t,n){let a="";if(!n||n>4){console.log("itemsize wrong?",n,e);this._log.stack("itemsize");n=3}if(n==1)a="float";else if(n==2)a="vec2";else if(n==3)a="vec3";else if(n==4)a="vec4";const i={name:e,data:t,itemSize:n,type:a};this._attributes[e]=i};p.prototype.copyAttribute=function(e,t){const n=this.getAttribute(e);t.setAttribute(e,new Float32Array(n.data),n.itemSize)};p.prototype.setVertices=function(e){if(e instanceof Float32Array)this._vertices=e;else this._vertices=new Float32Array(e)};p.prototype.setTexCoords=function(e){if(e instanceof Float32Array)this.texCoords=e;else this.texCoords=new Float32Array(e)};p.prototype.calcNormals=function(e){const t={smooth:e};this.calculateNormals(t)};p.prototype.flipNormals=function(t,n,a){let i=vec3.create();if(t==undefined)t=1;if(n==undefined)n=1;if(a==undefined)a=1;for(let e=0;e<this.vertexNormals.length;e+=3){vec3.set(i,this.vertexNormals[e+0],this.vertexNormals[e+1],this.vertexNormals[e+2]);i[0]*=-t;i[1]*=-n;i[2]*=-a;vec3.normalize(i,i);this.vertexNormals[e+0]=i[0];this.vertexNormals[e+1]=i[1];this.vertexNormals[e+2]=i[2]}};p.prototype.getNumTriangles=function(){if(this.verticesIndices&&this.verticesIndices.length)return this.verticesIndices.length/3;return this.vertices.length/3};p.prototype.flipVertDir=function(){const t=[];t.length=this.verticesIndices.length;for(let e=0;e<this.verticesIndices.length;e+=3){t[e]=this.verticesIndices[e+2];t[e+1]=this.verticesIndices[e+1];t[e+2]=this.verticesIndices[e]}this.verticesIndices=t};p.prototype.setPointVertices=function(t){if(t.length%3!==0){this._log.error("SetPointVertices: Array must be multiple of three.");return}if(!(t instanceof Float32Array))this.vertices=new Float32Array(t);else this.vertices=t;if(!(this.texCoords instanceof Float32Array))this.texCoords=new Float32Array(t.length/3*2);this.verticesIndices.length=t.length/3;for(let e=0;e<t.length/3;e++){this.verticesIndices[e]=e;this.texCoords[e*2]=0;this.texCoords[e*2+1]=0}};p.prototype.merge=function(t){if(!t)return;if(this.isIndexed()!=t.isIndexed()){if(this.isIndexed()){this.unIndex(false,true)}if(t.isIndexed()){const e=t.copy();e.unIndex(false,true);t=e}}const n=this.verticesIndices.length;const a=this._vertices.length/3;this.verticesIndices.length+=t.verticesIndices.length;for(let e=0;e<t.verticesIndices.length;e++)this.verticesIndices[n+e]=t.verticesIndices[e]+a;this.vertices=i.float32Concat(this._vertices,t.vertices);this.texCoords=i.float32Concat(this.texCoords,t.texCoords);this.vertexNormals=i.float32Concat(this.vertexNormals,t.vertexNormals);this.tangents=i.float32Concat(this.tangents,t.tangents);this.biTangents=i.float32Concat(this.biTangents,t.biTangents)};p.prototype.copy=function(){const t=new p(this.name+" copy");t.faceVertCount=this.faceVertCount;t.glPrimitive=this.glPrimitive;t.setVertices(this._vertices.slice(0));if(this.verticesIndices){t.verticesIndices.length=this.verticesIndices.length;for(let e=0;e<this.verticesIndices.length;e++)t.verticesIndices[e]=this.verticesIndices[e]}for(let e in this._attributes)this.copyAttribute(e,t);t.morphTargets.length=this.morphTargets.length;for(let e=0;e<this.morphTargets.length;e++)t.morphTargets[e]=this.morphTargets[e];return t};p.prototype.calculateNormals=function(t){t=t||{};if(t.smooth===false)this.unIndex();const n=vec3.create();const a=vec3.create();const i=vec3.create();function r(e){vec3.subtract(n,e[0],e[1]);vec3.subtract(a,e[0],e[2]);vec3.cross(i,n,a);vec3.normalize(i,i);if(t&&t.forceZUp){if(i[2]<0){i[0]*=-1;i[1]*=-1;i[2]*=-1}}return i}this.getVertexVec=function(e){const t=[0,0,0];t[0]=this.vertices[e*3+0];t[1]=this.vertices[e*3+1];t[2]=this.vertices[e*3+2];return t};if(!(this.vertexNormals instanceof Float32Array)||this.vertexNormals.length!=this.vertices.length)this.vertexNormals=new Float32Array(this.vertices.length);for(let e=0;e<this.vertices.length;e++){this.vertexNormals[e]=0}if(!this.isIndexed()){const s=[];for(let e=0;e<this.vertices.length;e+=9){const o=[[this.vertices[e+0],this.vertices[e+1],this.vertices[e+2]],[this.vertices[e+3],this.vertices[e+4],this.vertices[e+5]],[this.vertices[e+6],this.vertices[e+7],this.vertices[e+8]]];const l=r(o);s.push(l[0],l[1],l[2],l[0],l[1],l[2],l[0],l[1],l[2])}this.vertexNormals=s}else{const u=[];u.length=Math.floor(this.verticesIndices.length/3);for(let e=0;e<this.verticesIndices.length;e+=3){const o=[this.getVertexVec(this.verticesIndices[e+0]),this.getVertexVec(this.verticesIndices[e+1]),this.getVertexVec(this.verticesIndices[e+2])];u[e/3]=r(o);this.vertexNormals[this.verticesIndices[e+0]*3+0]+=u[e/3][0];this.vertexNormals[this.verticesIndices[e+0]*3+1]+=u[e/3][1];this.vertexNormals[this.verticesIndices[e+0]*3+2]+=u[e/3][2];this.vertexNormals[this.verticesIndices[e+1]*3+0]+=u[e/3][0];this.vertexNormals[this.verticesIndices[e+1]*3+1]+=u[e/3][1];this.vertexNormals[this.verticesIndices[e+1]*3+2]+=u[e/3][2];this.vertexNormals[this.verticesIndices[e+2]*3+0]+=u[e/3][0];this.vertexNormals[this.verticesIndices[e+2]*3+1]+=u[e/3][1];this.vertexNormals[this.verticesIndices[e+2]*3+2]+=u[e/3][2]}for(let t=0;t<this.verticesIndices.length;t+=3){for(let e=0;e<3;e++){const m=[this.vertexNormals[this.verticesIndices[t+e]*3+0],this.vertexNormals[this.verticesIndices[t+e]*3+1],this.vertexNormals[this.verticesIndices[t+e]*3+2]];vec3.normalize(m,m);this.vertexNormals[this.verticesIndices[t+e]*3+0]=m[0];this.vertexNormals[this.verticesIndices[t+e]*3+1]=m[1];this.vertexNormals[this.verticesIndices[t+e]*3+2]=m[2]}}}};p.prototype.calcTangentsBitangents=function(){if(!this.vertices.length){return}if(!this.vertexNormals.length){return}if(!this.texCoords.length){const O=this.vertices.length/3*2;this.texCoords=new Float32Array(O);for(let e=0;e<O;e+=1)this.texCoords[e]=0}if(!this.verticesIndices||!this.verticesIndices.length){return}if(this.verticesIndices.length%3!==0){this._log.error("Vertex indices mismatch!");return}const t=this.verticesIndices.length/3;const n=this.vertices.length/3;this.tangents=new Float32Array(this.vertexNormals.length);this.biTangents=new Float32Array(this.vertexNormals.length);const a=[];a.length=n*2;const i=vec3.create();const r=vec3.create();const s=vec3.create();const o=vec2.create();const l=vec2.create();const u=vec2.create();const m=vec3.create();const p=vec3.create();for(let e=0;e<t;e+=1){const _=this.verticesIndices[e*3];const T=this.verticesIndices[e*3+1];const I=this.verticesIndices[e*3+2];vec3.set(i,this.vertices[_*3],this.vertices[_*3+1],this.vertices[_*3+2]);vec3.set(r,this.vertices[T*3],this.vertices[T*3+1],this.vertices[T*3+2]);vec3.set(s,this.vertices[I*3],this.vertices[I*3+1],this.vertices[I*3+2]);vec2.set(o,this.texCoords[_*2],this.texCoords[_*2+1]);vec2.set(l,this.texCoords[T*2],this.texCoords[T*2+1]);vec2.set(u,this.texCoords[I*2],this.texCoords[I*2+1]);const y=r[0]-i[0];const A=s[0]-i[0];const S=r[1]-i[1];const E=s[1]-i[1];const C=r[2]-i[2];const j=s[2]-i[2];const N=l[0]-o[0];const L=u[0]-o[0];const M=l[1]-o[1];const R=u[1]-o[1];const P=1/(N*R-L*M);vec3.set(m,(R*y-M*A)*P,(R*S-M*E)*P,(R*C-M*j)*P);vec3.set(p,(N*A-L*y)*P,(N*E-L*S)*P,(N*j-L*C)*P);a[_]=m;a[T]=m;a[I]=m;a[_+n]=p;a[T+n]=p;a[I+n]=p}const c=vec3.create();const d=vec3.create();const h=vec3.create();const f=vec3.create();const v=vec3.create();const g=vec3.create();const b=vec3.create();const x=vec3.create();for(let e=0;e<n;e+=1){if(!a[e])continue;vec3.set(c,this.vertexNormals[e*3],this.vertexNormals[e*3+1],this.vertexNormals[e*3+2]);vec3.set(d,a[e][0],a[e][1],a[e][2]);const w=vec3.dot(c,d);vec3.scale(v,c,w);vec3.subtract(g,d,v);vec3.normalize(x,g);vec3.cross(b,c,d);const k=1;vec3.scale(h,x,1/k);vec3.cross(f,c,h);this.tangents[e*3+0]=h[0];this.tangents[e*3+1]=h[1];this.tangents[e*3+2]=h[2];this.biTangents[e*3+0]=f[0];this.biTangents[e*3+1]=f[1];this.biTangents[e*3+2]=f[2]}};p.prototype.isIndexed=function(){if(this._vertices.length==0)return true;return this.verticesIndices.length!=0};p.prototype.unIndex=function(e,t){const n=[];const a=[];let i=0;for(let e in this._attributes){const r=this._attributes[e];let n=[];for(let t=0;t<this.verticesIndices.length;t+=3){for(let e=0;e<3;e++){if(r.itemSize==3)n.push(r.data[this.verticesIndices[t+e]*3+0],r.data[this.verticesIndices[t+e]*3+1],r.data[this.verticesIndices[t+e]*3+2]);else if(r.itemSize==4)n.push(r.data[this.verticesIndices[t+e]*4+0],r.data[this.verticesIndices[t+e]*4+1],r.data[this.verticesIndices[t+e]*4+2],r.data[this.verticesIndices[t+e]*4+3]);else if(r.itemSize==2)n.push(r.data[this.verticesIndices[t+e]*2+0],r.data[this.verticesIndices[t+e]*2+1]);else if(r.itemSize==1)n.push(r.data[this.verticesIndices[t+e]]);else console.log("unknown attr",r)}}this.setAttribute(r.name,n,r.itemSize)}for(let e=0;e<this.verticesIndices.length;e+=3){n.push(this.vertices[this.verticesIndices[e+0]*3+0],this.vertices[this.verticesIndices[e+0]*3+1],this.vertices[this.verticesIndices[e+0]*3+2]);a.push(i);i++;n.push(this.vertices[this.verticesIndices[e+1]*3+0],this.vertices[this.verticesIndices[e+1]*3+1],this.vertices[this.verticesIndices[e+1]*3+2]);a.push(i);i++;n.push(this.vertices[this.verticesIndices[e+2]*3+0],this.vertices[this.verticesIndices[e+2]*3+1],this.vertices[this.verticesIndices[e+2]*3+2]);a.push(i);i++}this.vertices=n;this.verticesIndices=[];if(e)this.verticesIndices=a;if(!t)this.calculateNormals()};p.prototype.calcBarycentric=function(){let t=[];t.length=this.vertices.length;for(let e=0;e<this.vertices.length;e++)t[e]=0;let n=0;for(let e=0;e<this.vertices.length;e+=3){t[e+n]=1;n++;if(n==3)n=0}this.setAttribute("attrBarycentric",t,3)};p.prototype.getBounds=function(){return new l(this)};p.prototype.center=function(e,t,n){if(e===undefined){e=true;t=true;n=true}let a=0;const i=this.getBounds();const r=[i.minX+(i.maxX-i.minX)/2,i.minY+(i.maxY-i.minY)/2,i.minZ+(i.maxZ-i.minZ)/2];for(a=0;a<this.vertices.length;a+=3){if(this.vertices[a+0]==this.vertices[a+0]){if(e)this.vertices[a+0]-=r[0];if(t)this.vertices[a+1]-=r[1];if(n)this.vertices[a+2]-=r[2]}}return r};p.prototype.mapTexCoords2d=function(){const t=this.getBounds();const n=this.vertices.length/3;this.texCoords=new Float32Array(n*2);for(let e=0;e<n;e++){const a=this.vertices[e*3+0];const i=this.vertices[e*3+1];this.texCoords[e*2+0]=a/(t.maxX-t.minX)+.5;this.texCoords[e*2+1]=1-i/(t.maxY-t.minY)+.5}};p.prototype.getInfoOneLine=function(){let e="";if(this.faceVertCount==3&&this.verticesIndices)e+=this.verticesIndices.length/3;else e+=0;e+=" tris ";if(this.vertices)e+=this.vertices.length/3;else e+=0;e+=" verts";return e};p.prototype.getInfo=function(){const e={};if(this.faceVertCount==3&&this.verticesIndices)e.numFaces=this.verticesIndices.length/3;else e.numFaces=0;if(this.verticesIndices&&this.verticesIndices.length)e.indices=this.verticesIndices.length;if(this.vertices)e.numVerts=this.vertices.length/3;else e.numVerts=0;if(this.vertexNormals)e.numNormals=this.vertexNormals.length/3;else e.numNormals=0;if(this.texCoords)e.numTexCoords=this.texCoords.length/2;else e.numTexCoords=0;if(this.tangents)e.numTangents=this.tangents.length/3;else e.numTangents=0;if(this.biTangents)e.numBiTangents=this.biTangents.length/3;else e.numBiTangents=0;if(this.biTangents)e.numBiTangents=this.biTangents.length/3;else e.numBiTangents=0;if(this.vertexColors)e.numVertexColors=this.vertexColors.length/4;else e.numVertexColors=0;if(this.getAttributes())e.numAttribs=Object.keys(this.getAttributes()).length;else e.numAttribs=0;e.isIndexed=this.isIndexed();return e};p.buildFromFaces=function(t,e,n){const a=[];const i=[];for(let e=0;e<t.length;e+=3){const s=t[e+0];const o=t[e+1];const l=t[e+2];const u=[-1,-1,-1];if(n)for(let e=0;e<a.length;e+=3){if(a[e+0]==s[0]&&a[e+1]==s[1]&&a[e+2]==s[2])u[0]=e/3;if(a[e+0]==o[0]&&a[e+1]==o[1]&&a[e+2]==o[2])u[1]=e/3;if(a[e+0]==l[0]&&a[e+1]==l[1]&&a[e+2]==l[2])u[2]=e/3}if(u[0]==-1){a.push(s[0],s[1],s[2]);u[0]=(a.length-1)/3}if(u[1]==-1){a.push(o[0],o[1],o[2]);u[1]=(a.length-1)/3}if(u[2]==-1){a.push(l[0],l[1],l[2]);u[2]=(a.length-1)/3}i.push(parseInt(u[0],10));i.push(parseInt(u[1],10));i.push(parseInt(u[2],10))}const r=new p(e);r.name=e;r.vertices=a;r.verticesIndices=i;return r};const c=function(){this._log=new m("eventtarget");this._eventCallbacks={};this._logName="";this._logEvents=false;this._listeners={};this.addEventListener=this.on=function(e,t,n){const a={id:(n||"")+CABLES.simpleId(),name:e,cb:t};if(!this._eventCallbacks[e])this._eventCallbacks[e]=[a];else this._eventCallbacks[e].push(a);this._listeners[a.id]=a;return a.id};this.hasEventListener=function(e,t){if(e&&!t){if(this._listeners[e])return true;else return false}else{this._log.warn("old eventtarget function haseventlistener!");if(e&&t){if(this._eventCallbacks[e]){const n=this._eventCallbacks[e].indexOf(t);if(n==-1)return false;return true}}}};this.hasListenerForEventName=function(e){return this._eventCallbacks[e]&&this._eventCallbacks[e].length>0};this.removeEventListener=this.off=function(a,t){if(a===null||a===undefined)return;if(!t){const i=this._listeners[a];if(!i){this._log.log("removeEvent: could not find event...",a,this);return}let n=true;while(n){n=false;let t=-1;for(let e=0;e<this._eventCallbacks[i.name].length;e++){if(this._eventCallbacks[i.name][e].id.startsWith(a)){n=true;t=e}}if(t!==-1){this._eventCallbacks[i.name].splice(t,1);delete this._listeners[a]}}return}this._log.info("[eventtaget] ","old function signature: removeEventListener! use listener id");this._log.log((new Error).stack);let n=null;for(let e=0;e<this._eventCallbacks[a].length;e++)if(this._eventCallbacks[a][e].cb==t)n=e;if(n!==null){delete this._eventCallbacks[n]}else this._log.warn("removeEventListener not found "+a)};this.logEvents=function(e,t){this._logEvents=e;this._logName=t};this.emitEvent=function(t,n,a,i,r,s,o){if(this._logEvents)this._log.log("[event] ",this._logName,t,this._eventCallbacks);if(this._eventCallbacks[t]){for(let e=0;e<this._eventCallbacks[t].length;e++){if(this._eventCallbacks[t][e]){this._eventCallbacks[t][e].cb(n,a,i,r,s,o)}}}else{if(this._logEvents)this._log.log("[event] has no event callback",t,this._eventCallbacks)}}};const d={ANIM:{EASINGS:["linear","absolute","smoothstep","smootherstep","Cubic In","Cubic Out","Cubic In Out","Expo In","Expo Out","Expo In Out","Sin In","Sin Out","Sin In Out","Quart In","Quart Out","Quart In Out","Quint In","Quint Out","Quint In Out","Back In","Back Out","Back In Out","Elastic In","Elastic Out","Bounce In","Bounce Out"],EASING_LINEAR:0,EASING_ABSOLUTE:1,EASING_SMOOTHSTEP:2,EASING_SMOOTHERSTEP:3,EASING_CUBICSPLINE:4,EASING_CUBIC_IN:5,EASING_CUBIC_OUT:6,EASING_CUBIC_INOUT:7,EASING_EXPO_IN:8,EASING_EXPO_OUT:9,EASING_EXPO_INOUT:10,EASING_SIN_IN:11,EASING_SIN_OUT:12,EASING_SIN_INOUT:13,EASING_BACK_IN:14,EASING_BACK_OUT:15,EASING_BACK_INOUT:16,EASING_ELASTIC_IN:17,EASING_ELASTIC_OUT:18,EASING_BOUNCE_IN:19,EASING_BOUNCE_OUT:21,EASING_QUART_IN:22,EASING_QUART_OUT:23,EASING_QUART_INOUT:24,EASING_QUINT_IN:25,EASING_QUINT_OUT:26,EASING_QUINT_INOUT:27},OP:{OP_PORT_TYPE_VALUE:0,OP_PORT_TYPE_NUMBER:0,OP_PORT_TYPE_FUNCTION:1,OP_PORT_TYPE_TRIGGER:1,OP_PORT_TYPE_OBJECT:2,OP_PORT_TYPE_TEXTURE:2,OP_PORT_TYPE_ARRAY:3,OP_PORT_TYPE_DYNAMIC:4,OP_PORT_TYPE_STRING:5,OP_VERSION_PREFIX:"_v"},PORT:{PORT_DIR_IN:0,PORT_DIR_OUT:1},PACO:{PACO_CLEAR:0,PACO_VALUECHANGE:1,PACO_OP_DELETE:2,PACO_UNLINK:3,PACO_LINK:4,PACO_LOAD:5,PACO_OP_CREATE:6,PACO_OP_ENABLE:7,PACO_OP_DISABLE:8,PACO_UIATTRIBS:9,PACO_VARIABLES:10,PACO_TRIGGERS:11,PACO_PORT_SETVARIABLE:12,PACO_PORT_SETANIMATED:13,PACO_PORT_ANIM_UPDATED:14,PACO_DESERIALIZE:15,PACO_OP_RELOAD:16}};const h=function(e){this.time=0;this.value=0;this.onChange=null;this._easing=0;this.cb=null;this.cbTriggered=false;this.setEasing(d.ANIM.EASING_LINEAR);this.set(e)};h.cubicSpline=function(e,t,n){let a=t.value,i=t.bezTangOut,r=n.value,s=n.bezTangIn;let o=e;let l=o*o;let u=l*o;return(2*u-3*l+1)*a+(u-2*l+o)*i+(-2*u+3*l)*r+(u-l)*s};h.easeCubicSpline=function(e,t){return h.cubicSpline(e,this,t)};h.linear=function(e,t,n){return parseFloat(t.value)+parseFloat(n.value-t.value)*e};h.easeLinear=function(e,t){return h.linear(e,this,t)};h.easeAbsolute=function(e,t){return this.value};const f=function(e){return e=2**(10*(e-1))};h.easeExpoIn=function(e,t){e=f(e);return h.linear(e,this,t)};const v=function(e){e=-(2**(-10*e))+1;return e};h.easeExpoOut=function(e,t){e=v(e);return h.linear(e,this,t)};const g=function(e){e*=2;if(e<1){e=.5*2**(10*(e-1))}else{e--;e=.5*(-(2**(-10*e))+2)}return e};h.easeExpoInOut=function(e,t){e=g(e);return h.linear(e,this,t)};h.easeSinIn=function(e,t){e=-1*Math.cos(e*Math.PI/2)+1;return h.linear(e,this,t)};h.easeSinOut=function(e,t){e=Math.sin(e*Math.PI/2);return h.linear(e,this,t)};h.easeSinInOut=function(e,t){e=-.5*(Math.cos(Math.PI*e)-1);return h.linear(e,this,t)};const b=function(e){e=e*e*e;return e};h.easeCubicIn=function(e,t){e=b(e);return h.linear(e,this,t)};h.easeInQuint=function(e,t){e=e*e*e*e*e;return h.linear(e,this,t)};h.easeOutQuint=function(e,t){e=(e-=1)*e*e*e*e+1;return h.linear(e,this,t)};h.easeInOutQuint=function(e,t){if((e/=.5)<1)e=.5*e*e*e*e*e;else e=.5*((e-=2)*e*e*e*e+2);return h.linear(e,this,t)};h.easeInQuart=function(e,t){e=e*e*e*e;return h.linear(e,this,t)};h.easeOutQuart=function(e,t){e=-1*((e-=1)*e*e*e-1);return h.linear(e,this,t)};h.easeInOutQuart=function(e,t){if((e/=.5)<1)e=.5*e*e*e*e;else e=-.5*((e-=2)*e*e*e-2);return h.linear(e,this,t)};h.bounce=function(e){if((e/=1)<1/2.75)e=7.5625*e*e;else if(e<2/2.75)e=7.5625*(e-=1.5/2.75)*e+.75;else if(e<2.5/2.75)e=7.5625*(e-=2.25/2.75)*e+.9375;else e=7.5625*(e-=2.625/2.75)*e+.984375;return e};h.easeInBounce=function(e,t){return h.linear(h.bounce(e),this,t)};h.easeOutBounce=function(e,t){return h.linear(h.bounce(e),this,t)};h.easeInElastic=function(e,t){let n=1.70158;let a=0;let i=1;const r=0;const s=1;const o=1;if(e===0)e=r;else if((e/=s)==1)e=r+o;else{if(!a)a=s*.3;if(i<Math.abs(o)){i=o;n=a/4}else n=a/(2*Math.PI)*Math.asin(o/i);e=-(i*2**(10*(e-=1))*Math.sin((e*s-n)*(2*Math.PI)/a))+r}return h.linear(e,this,t)};h.easeOutElastic=function(e,t){let n=1.70158;let a=0;let i=1;const r=0;const s=1;const o=1;if(e===0)e=r;else if((e/=s)==1)e=r+o;else{if(!a)a=s*.3;if(i<Math.abs(o)){i=o;n=a/4}else n=a/(2*Math.PI)*Math.asin(o/i);e=i*2**(-10*e)*Math.sin((e*s-n)*(2*Math.PI)/a)+o+r}return h.linear(e,this,t)};h.easeInBack=function(e,t){const n=1.70158;e=e*e*((n+1)*e-n);return h.linear(e,this,t)};h.easeOutBack=function(e,t){const n=1.70158;e=(e=e/1-1)*e*((n+1)*e+n)+1;return h.linear(e,this,t)};h.easeInOutBack=function(e,t){let n=1.70158;const a=1/2;if((e/=1/2)<1)e=a*(e*e*(((n*=1.525)+1)*e-n));else e=a*((e-=2)*e*(((n*=1.525)+1)*e+n)+2);return h.linear(e,this,t)};const x=function(e){e--;e=e*e*e+1;return e};h.easeCubicOut=function(e,t){e=x(e);return h.linear(e,this,t)};const O=function(e){e*=2;if(e<1)e=.5*e*e*e;else{e-=2;e=.5*(e*e*e+2)}return e};h.easeCubicInOut=function(e,t){e=O(e);return h.linear(e,this,t)};h.easeSmoothStep=function(e,t){const n=Math.max(0,Math.min(1,e));e=n*n*(3-2*n);return h.linear(e,this,t)};h.easeSmootherStep=function(e,t){const n=Math.max(0,Math.min(1,(e-0)/(1-0)));e=n*n*n*(n*(n*6-15)+10);return h.linear(e,this,t)};h.prototype.setEasing=function(e){this._easing=e;if(this._easing==d.ANIM.EASING_LINEAR)this.ease=h.easeLinear;else if(this._easing==d.ANIM.EASING_ABSOLUTE)this.ease=h.easeAbsolute;else if(this._easing==d.ANIM.EASING_SMOOTHSTEP)this.ease=h.easeSmoothStep;else if(this._easing==d.ANIM.EASING_SMOOTHERSTEP)this.ease=h.easeSmootherStep;else if(this._easing==d.ANIM.EASING_CUBIC_IN)this.ease=h.easeCubicIn;else if(this._easing==d.ANIM.EASING_CUBIC_OUT)this.ease=h.easeCubicOut;else if(this._easing==d.ANIM.EASING_CUBIC_INOUT)this.ease=h.easeCubicInOut;else if(this._easing==d.ANIM.EASING_EXPO_IN)this.ease=h.easeExpoIn;else if(this._easing==d.ANIM.EASING_EXPO_OUT)this.ease=h.easeExpoOut;else if(this._easing==d.ANIM.EASING_EXPO_INOUT)this.ease=h.easeExpoInOut;else if(this._easing==d.ANIM.EASING_SIN_IN)this.ease=h.easeSinIn;else if(this._easing==d.ANIM.EASING_SIN_OUT)this.ease=h.easeSinOut;else if(this._easing==d.ANIM.EASING_SIN_INOUT)this.ease=h.easeSinInOut;else if(this._easing==d.ANIM.EASING_BACK_OUT)this.ease=h.easeOutBack;else if(this._easing==d.ANIM.EASING_BACK_IN)this.ease=h.easeInBack;else if(this._easing==d.ANIM.EASING_BACK_INOUT)this.ease=h.easeInOutBack;else if(this._easing==d.ANIM.EASING_ELASTIC_IN)this.ease=h.easeInElastic;else if(this._easing==d.ANIM.EASING_ELASTIC_OUT)this.ease=h.easeOutElastic;else if(this._easing==d.ANIM.EASING_ELASTIC_INOUT)this.ease=h.easeElasticInOut;else if(this._easing==d.ANIM.EASING_BOUNCE_IN)this.ease=h.easeInBounce;else if(this._easing==d.ANIM.EASING_BOUNCE_OUT)this.ease=h.easeOutBounce;else if(this._easing==d.ANIM.EASING_QUART_OUT)this.ease=h.easeOutQuart;else if(this._easing==d.ANIM.EASING_QUART_IN)this.ease=h.easeInQuart;else if(this._easing==d.ANIM.EASING_QUART_INOUT)this.ease=h.easeInOutQuart;else if(this._easing==d.ANIM.EASING_QUINT_OUT)this.ease=h.easeOutQuint;else if(this._easing==d.ANIM.EASING_QUINT_IN)this.ease=h.easeInQuint;else if(this._easing==d.ANIM.EASING_QUINT_INOUT)this.ease=h.easeInOutQuint;else if(this._easing==d.ANIM.EASING_CUBICSPLINE){this.ease=h.easeCubicSpline}else{this._easing=d.ANIM.EASING_LINEAR;this.ease=h.easeLinear}};h.prototype.trigger=function(){this.cb();this.cbTriggered=true};h.prototype.setValue=function(e){this.value=e;if(this.onChange!==null)this.onChange()};h.prototype.set=function(e){if(e){if(e.e)this.setEasing(e.e);if(e.cb){this.cb=e.cb;this.cbTriggered=false}if(e.b){}if(e.hasOwnProperty("t"))this.time=e.t;if(e.hasOwnProperty("time"))this.time=e.time;if(e.hasOwnProperty("v"))this.value=e.v;else if(e.hasOwnProperty("value"))this.value=e.value}if(this.onChange!==null)this.onChange()};h.prototype.getSerialized=function(){const e={};e.t=this.time;e.v=this.value;e.e=this._easing;return e};h.prototype.getEasing=function(){return this._easing};const _=function(e){c.apply(this);e=e||{};this.keys=[];this.onChange=null;this.stayInTimeline=false;this.loop=false;this._log=new m("Anim");this._lastKeyIndex=0;this._cachedIndex=0;this.name=e.name||null;this.defaultEasing=e.defaultEasing||d.ANIM.EASING_LINEAR;this.onLooped=null;this._timesLooped=0;this._needsSort=false};_.prototype.forceChangeCallback=function(){if(this.onChange!==null)this.onChange();this.emitEvent("onChange",this)};_.prototype.getLoop=function(){return this.loop};_.prototype.setLoop=function(e){this.loop=e;this.emitEvent("onChange",this)};_.prototype.hasEnded=function(e){if(this.keys.length===0)return true;if(this.keys[this._lastKeyIndex].time<=e)return true;return false};_.prototype.isRising=function(e){if(this.hasEnded(e))return false;const t=this.getKeyIndex(e);if(this.keys[t].value<this.keys[t+1].value)return true;return false};_.prototype.clearBefore=function(e){const t=this.getValue(e);const n=this.getKeyIndex(e);this.setValue(e,t);if(n>1)this.keys.splice(0,n);this._updateLastIndex()};_.prototype.clear=function(e){let t=0;if(e)t=this.getValue(e);this.keys.length=0;this._updateLastIndex();if(e)this.setValue(e,t);if(this.onChange!==null)this.onChange();this.emitEvent("onChange",this)};_.prototype.sortKeys=function(){this.keys.sort((e,t)=>{return parseFloat(e.time)-parseFloat(t.time)});this._updateLastIndex();this._needsSort=false;if(this.keys.length%1e3==0)console.log(this.name,this.keys.length)};_.prototype.getLength=function(){if(this.keys.length===0)return 0;return this.keys[this.keys.length-1].time};_.prototype.getKeyIndex=function(t){let n=0;let a=0;if(this._cachedIndex&&this.keys.length>this._cachedIndex&&t>=this.keys[this._cachedIndex].time)a=this._cachedIndex;for(let e=a;e<this.keys.length;e++){if(t>=this.keys[e].time)n=e;if(this.keys[e].time>t){if(t!=0)this._cachedIndex=n;return n}}return n};_.prototype.setValue=function(t,n,a){let i=null;if(this.keys.length==0||t<=this.keys[this.keys.length-1].time)for(let e=0;e<this.keys.length;e++)if(this.keys[e].time==t){i=this.keys[e];this.keys[e].setValue(n);this.keys[e].cb=a;break}if(!i){i=new h({time:t,value:n,e:this.defaultEasing,cb:a});this.keys.push(i);this._updateLastIndex()}if(this.onChange)this.onChange();this.emitEvent("onChange",this);this._needsSort=true;return i};_.prototype.setKeyEasing=function(e,t){if(this.keys[e]){this.keys[e].setEasing(t);this.emitEvent("onChange",this)}};_.prototype.getSerialized=function(){const t={};t.keys=[];t.loop=this.loop;for(let e=0;e<this.keys.length;e++)t.keys.push(this.keys[e].getSerialized());return t};_.prototype.getKey=function(e){const t=this.getKeyIndex(e);return this.keys[t]};_.prototype.getNextKey=function(e){let t=this.getKeyIndex(e)+1;if(t>=this.keys.length)t=this.keys.length-1;return this.keys[t]};_.prototype.isFinished=function(e){if(this.keys.length<=0)return true;return e>this.keys[this.keys.length-1].time};_.prototype.isStarted=function(e){if(this.keys.length<=0)return false;return e>=this.keys[0].time};_.prototype.getValue=function(e){if(this.keys.length===0){return 0}if(this._needsSort)this.sortKeys();if(!this.loop&&e>this.keys[this._lastKeyIndex].time){if(this.keys[this._lastKeyIndex].cb&&!this.keys[this._lastKeyIndex].cbTriggered)this.keys[this._lastKeyIndex].trigger();return this.keys[this._lastKeyIndex].value}if(e<this.keys[0].time){return this.keys[0].value}if(this.loop&&e>this.keys[this._lastKeyIndex].time){const s=e/this.keys[this._lastKeyIndex].time;if(s>this._timesLooped){this._timesLooped++;if(this.onLooped)this.onLooped()}e=(e-this.keys[0].time)%(this.keys[this._lastKeyIndex].time-this.keys[0].time);e+=this.keys[0].time}const t=this.getKeyIndex(e);if(t>=this._lastKeyIndex){if(this.keys[this._lastKeyIndex].cb&&!this.keys[this._lastKeyIndex].cbTriggered)this.keys[this._lastKeyIndex].trigger();return this.keys[this._lastKeyIndex].value}const n=t+1;const a=this.keys[t];const i=this.keys[n];if(a.cb&&!a.cbTriggered)a.trigger();if(!i)return-1;const r=(e-a.time)/(i.time-a.time);if(!a.ease)this.log._warn("has no ease",a,i);return a.ease(r,i)};_.prototype._updateLastIndex=function(){this._lastKeyIndex=this.keys.length-1};_.prototype.addKey=function(e){if(e.time===undefined){this.log.warn("key time undefined, ignoring!")}else{this.keys.push(e);if(this.onChange!==null)this.onChange();this.emitEvent("onChange",this)}this._updateLastIndex()};_.prototype.easingFromString=function(e){if(e=="linear")return d.ANIM.EASING_LINEAR;if(e=="absolute")return d.ANIM.EASING_ABSOLUTE;if(e=="smoothstep")return d.ANIM.EASING_SMOOTHSTEP;if(e=="smootherstep")return d.ANIM.EASING_SMOOTHERSTEP;if(e=="Cubic In")return d.ANIM.EASING_CUBIC_IN;if(e=="Cubic Out")return d.ANIM.EASING_CUBIC_OUT;if(e=="Cubic In Out")return d.ANIM.EASING_CUBIC_INOUT;if(e=="Expo In")return d.ANIM.EASING_EXPO_IN;if(e=="Expo Out")return d.ANIM.EASING_EXPO_OUT;if(e=="Expo In Out")return d.ANIM.EASING_EXPO_INOUT;if(e=="Sin In")return d.ANIM.EASING_SIN_IN;if(e=="Sin Out")return d.ANIM.EASING_SIN_OUT;if(e=="Sin In Out")return d.ANIM.EASING_SIN_INOUT;if(e=="Back In")return d.ANIM.EASING_BACK_IN;if(e=="Back Out")return d.ANIM.EASING_BACK_OUT;if(e=="Back In Out")return d.ANIM.EASING_BACK_INOUT;if(e=="Elastic In")return d.ANIM.EASING_ELASTIC_IN;if(e=="Elastic Out")return d.ANIM.EASING_ELASTIC_OUT;if(e=="Bounce In")return d.ANIM.EASING_BOUNCE_IN;if(e=="Bounce Out")return d.ANIM.EASING_BOUNCE_OUT;if(e=="Quart Out")return d.ANIM.EASING_QUART_OUT;if(e=="Quart In")return d.ANIM.EASING_QUART_IN;if(e=="Quart In Out")return d.ANIM.EASING_QUART_INOUT;if(e=="Quint Out")return d.ANIM.EASING_QUINT_OUT;if(e=="Quint In")return d.ANIM.EASING_QUINT_IN;if(e=="Quint In Out")return d.ANIM.EASING_QUINT_INOUT};_.prototype.createPort=function(e,t,n){const a=e.inDropDown(t,d.ANIM.EASINGS,"Cubic Out");a.set("linear");a.defaultValue="linear";a.onChange=function(){this.defaultEasing=this.easingFromString(a.get());this.emitEvent("onChangeDefaultEasing",this);if(n)n()}.bind(this);return a};_.slerpQuaternion=function(e,t,n,a,i,r){if(!_.slerpQuaternion.q1){_.slerpQuaternion.q1=quat.create();_.slerpQuaternion.q2=quat.create()}const s=n.getKeyIndex(e);let o=s+1;if(o>=n.keys.length)o=n.keys.length-1;if(s==o){quat.set(t,n.keys[s].value,a.keys[s].value,i.keys[s].value,r.keys[s].value)}else{const l=n.keys[s].time;const u=n.keys[o].time;const m=(e-l)/(u-l);quat.set(_.slerpQuaternion.q1,n.keys[s].value,a.keys[s].value,i.keys[s].value,r.keys[s].value);quat.set(_.slerpQuaternion.q2,n.keys[o].value,a.keys[o].value,i.keys[o].value,r.keys[o].value);quat.slerp(t,_.slerpQuaternion.q1,_.slerpQuaternion.q2,m)}return t};const T={Key:h};const I=function(e,t,n,a){c.apply(this);this.data={};this._log=new m("core_port");this.direction=d.PORT.PORT_DIR_IN;this.id=String(CABLES.simpleId());this._op=e;this.links=[];this.value=0;this.name=t;this.type=n||d.OP.OP_PORT_TYPE_VALUE;this.uiAttribs=a||{};this.anim=null;this._oldAnimVal=-5711;this.defaultValue=null;this._uiActiveState=true;this.ignoreValueSerialize=false;this.onLinkChanged=null;this.crashed=false;this._valueBeforeLink=null;this._lastAnimFrame=-1;this._animated=false;this.onValueChanged=null;this.onTriggered=null;this.onUiActiveStateChange=null;this.changeAlways=false;this.forceRefChange=false;this._useVariableName=null;this.activityCounter=0;this.apf=0;this.activityCounterStartFrame=0;this._tempLastUiValue=null;Object.defineProperty(this,"title",{get(){return this.uiAttribs.title||this.name}});Object.defineProperty(this,"parent",{get(){this._log.stack("use port.op, not .parent");return this._op}});Object.defineProperty(this,"op",{get(){return this._op}});Object.defineProperty(this,"val",{get(){return this.get()},set(e){this.setValue(e)}})};I.prototype.copyLinkedUiAttrib=function(e,t){if(!CABLES.UI)return;if(!this.isLinked())return;const n={};n[e]=this.links[0].getOtherPort(this).getUiAttrib(e);t.setUiAttribs(n)};I.prototype.getValueForDisplay=function(){let e=this.value;if(typeof this.value==="string"||this.value instanceof String){if(e.length>1e3){e=e.substring(0,999);e+="..."}if(this.uiAttribs&&this.uiAttribs.display=="boolnum"){e+=" - ";if(!this.value)e+="false";else e+="true"}e=e.replace(/[\u00A0-\u9999<>\&]/g,function(e){return"&#"+e.charCodeAt(0)+";"});if(e.length>100)e=e.substring(0,100)}else{e=this.value}return e};I.prototype.onAnimToggle=function(){};I.prototype._onAnimToggle=function(){this.onAnimToggle()};I.prototype.remove=function(){this.removeLinks();this._op.removePort(this)};I.prototype.setUiAttribs=function(e){let t=false;if(!this.uiAttribs)this.uiAttribs={};for(const n in e){if(e[n]===undefined){delete this.uiAttribs[n];continue}if(this.uiAttribs[n]!=e[n])t=true;this.uiAttribs[n]=e[n];if(n=="group"&&this.indexPort)this.indexPort.setUiAttribs({group:e[n]})}if(e.hasOwnProperty("expose"))this._op.patch.emitEvent("subpatchExpose",this._op.uiAttribs.subPatch);if(t)this.emitEvent("onUiAttrChange",e,this)};I.prototype.getUiAttribs=function(){return this.uiAttribs};I.prototype.getUiAttrib=function(e){if(!this.uiAttribs||!this.uiAttribs.hasOwnProperty(e)){return null}return this.uiAttribs[e]};I.prototype.get=function(){if(this._animated&&this._lastAnimFrame!=this._op.patch.getFrameNum()){this._lastAnimFrame=this._op.patch.getFrameNum();let e=this.anim.getValue(this._op.patch.timer.getTime());if(this.value!=e){this.value=e;this._oldAnimVal=this.value;this.forceChange()}}return this.value};I.prototype.setRef=function(e){this.forceRefChange=true;this.set(e)};I.prototype.set=I.prototype.setValue=function(e){if(e===undefined)e=null;if(CABLES.UI&&CABLES.UI.showDevInfos)if(this.direction==d.PORT.PORT_DIR_OUT&&this.type==d.OP.OP_PORT_TYPE_OBJECT&&e&&!this.forceRefChange)this._log.warn("object port uses .set",this.name,this.op.objName);if(this._op.enabled&&!this.crashed){if(e!==this.value||this.changeAlways||this.type==d.OP.OP_PORT_TYPE_TEXTURE||this.type==d.OP.OP_PORT_TYPE_ARRAY){if(this._animated){this.anim.setValue(this._op.patch.timer.getTime(),e)}else{try{this.value=e;this.forceChange()}catch(e){this.crashed=true;this.setValue=function(e){};this.onTriggered=function(){};this._log.error("exception in ",this._op);this._log.error(e);this._op.patch.emitEvent("exception",e,this._op)}if(this._op&&this._op.patch&&this._op.patch.isEditorMode()&&this.type==d.OP.OP_PORT_TYPE_TEXTURE)gui.texturePreview().updateTexturePort(this)}if(this.direction==d.PORT.PORT_DIR_OUT)for(let e=0;e<this.links.length;++e)this.links[e].setValue()}}};I.prototype.updateAnim=function(){if(this._animated){this.value=this.get();if(this._oldAnimVal!=this.value||this.changeAlways){this._oldAnimVal=this.value;this.forceChange()}this._oldAnimVal=this.value}};I.prototype.forceChange=function(){if(this.onValueChanged||this.onChange){}this._activity();this.emitEvent("change",this.value,this);if(this.onChange)this.onChange(this,this.value);else if(this.onValueChanged)this.onValueChanged(this,this.value)};I.prototype.getTypeString=function(){if(this.type==d.OP.OP_PORT_TYPE_VALUE)return"Number";if(this.type==d.OP.OP_PORT_TYPE_FUNCTION)return"Trigger";if(this.type==d.OP.OP_PORT_TYPE_OBJECT)return"Object";if(this.type==d.OP.OP_PORT_TYPE_DYNAMIC)return"Dynamic";if(this.type==d.OP.OP_PORT_TYPE_ARRAY)return"Array";if(this.type==d.OP.OP_PORT_TYPE_STRING)return"String";return"Unknown"};I.prototype.deSerializeSettings=function(e){if(!e)return;if(e.animated)this.setAnimated(e.animated);if(e.useVariable)this.setVariableName(e.useVariable);if(e.title)this.setUiAttribs({title:e.title});if(e.expose)this.setUiAttribs({expose:true});if(e.order)this.setUiAttribs({order:e.order});if(e.multiPortManual)this.setUiAttribs({multiPortManual:e.multiPortManual});if(e.multiPortNum)this.setUiAttribs({multiPortNum:e.multiPortNum});if(e.anim){if(!this.anim)this.anim=new _({name:"port "+this.name});this._op._hasAnimPort=true;this.anim.addEventListener("onChange",()=>{this._op.patch.emitEvent("portAnimUpdated",this._op,this,this.anim)});if(e.anim.loop)this.anim.loop=e.anim.loop;for(const t in e.anim.keys){this.anim.keys.push(new T.Key(e.anim.keys[t]))}this.anim.sortKeys()}};I.prototype.setInitialValue=function(e){if(this.op.preservedPortLinks[this.name]){for(let e=0;e<this.op.preservedPortLinks[this.name].length;e++){const t=this.op.preservedPortLinks[this.name][e];this.op.patch._addLink(t.objIn,t.objOut,t.portIn,t.portOut)}}if(this.op.preservedPortValues&&this.op.preservedPortValues.hasOwnProperty(this.name)&&this.op.preservedPortValues[this.name]!==undefined){this.set(this.op.preservedPortValues[this.name])}else if(e!==undefined)this.set(e);if(e!==undefined)this.defaultValue=e};I.prototype.getSerialized=function(){let e={name:this.getName()};if(!this.ignoreValueSerialize&&this.links.length===0){if(this.type==d.OP.OP_PORT_TYPE_OBJECT&&this.value&&this.value.tex){}else e.value=this.value}if(this._useVariableName)e.useVariable=this._useVariableName;if(this._animated)e.animated=true;if(this.anim)e.anim=this.anim.getSerialized();if(this.uiAttribs.multiPortNum)e.multiPortNum=this.uiAttribs.multiPortNum;if(this.uiAttribs.multiPortManual)e.multiPortManual=this.uiAttribs.multiPortManual;if(this.uiAttribs.display=="file")e.display=this.uiAttribs.display;if(this.uiAttribs.expose){e.expose=true;if(this.uiAttribs.hasOwnProperty("order"))e.order=this.uiAttribs.order}if(this.uiAttribs.title)e.title=this.uiAttribs.title;if((this.preserveLinks||this.direction==d.PORT.PORT_DIR_OUT)&&this.links.length>0){e.links=[];for(const t in this.links){if(!this.links[t].ignoreInSerialize&&(this.links[t].portIn&&this.links[t].portOut))e.links.push(this.links[t].getSerialized())}}if(this.direction==d.PORT.PORT_DIR_IN&&this.links.length>0){for(const t in this.links){if(!this.links[t].portIn||!this.links[t].portOut)continue;const n=this.links[t].getOtherPort(this);if(n.op.isInBlueprint2&&this.op.isInBlueprint2){if(n.op.isInBlueprint2()&&!this.op.isInBlueprint2()){e.links=e.links||[];e.links.push(this.links[t].getSerialized())}}}}if(e.links&&e.links.length==0)delete e.links;if(this.type===d.OP.OP_PORT_TYPE_FUNCTION)delete e.value;if(this.type===d.OP.OP_PORT_TYPE_FUNCTION&&this.links.length==0)e=null;if(e&&Object.keys(e).length==1&&e.name)e=null;r(e);return e};I.prototype.shouldLink=function(){return true};I.prototype.removeLinks=function(){let e=0;while(this.links.length>0){e++;if(e>5e3){this._log.warn("could not delete links... / infinite loop");this.links.length=0;break}this.links[0].remove()}};I.prototype.removeLink=function(e){for(const t in this.links)if(this.links[t]==e)this.links.splice(t,1);if(this.direction==d.PORT.PORT_DIR_IN){if(this.type==d.OP.OP_PORT_TYPE_VALUE)this.setValue(this._valueBeforeLink||0);else this.setValue(this._valueBeforeLink||null)}if(CABLES.UI&&this._op.checkLinkTimeWarnings)this._op.checkLinkTimeWarnings();try{if(this.onLinkChanged)this.onLinkChanged();this.emitEvent("onLinkChanged");this.emitEvent("onLinkRemoved");this._op.emitEvent("onLinkChanged")}catch(e){this._log.error(e)}};I.prototype.getName=function(){return this.name};I.prototype.getTitle=function(){if(this.uiAttribs.title)return this.uiAttribs.title;return this.name};I.prototype.addLink=function(e){this._valueBeforeLink=this.value;this.links.push(e);if(CABLES.UI&&this._op.checkLinkTimeWarnings)this._op.checkLinkTimeWarnings();try{if(this.onLinkChanged)this.onLinkChanged();this.emitEvent("onLinkChanged");this._op.emitEvent("onLinkChanged")}catch(e){this._log.error(e)}};I.prototype.getLinkTo=function(e){for(const t in this.links)if(this.links[t].portIn==e||this.links[t].portOut==e)return this.links[t]};I.prototype.removeLinkTo=function(e){for(const t in this.links){if(this.links[t].portIn==e||this.links[t].portOut==e){this.links[t].remove();if(CABLES.UI&&this._op.checkLinkTimeWarnings)this._op.checkLinkTimeWarnings();if(this.onLinkChanged)this.onLinkChanged();this.emitEvent("onLinkChanged");this.emitEvent("onLinkRemoved");return}}};I.prototype.isLinkedTo=function(e){for(const t in this.links)if(this.links[t].portIn==e||this.links[t].portOut==e)return true;return false};I.prototype._activity=function(){this.activityCounter++};I.prototype.trigger=function(){const t=this.links.length;this._activity();if(t===0)return;if(!this._op.enabled)return;let n=null;try{for(let e=0;e<t;++e){if(this.links[e].portIn){n=this.links[e].portIn;n.op.patch.pushTriggerStack(n);n._onTriggered();n.op.patch.popTriggerStack()}if(this.links[e])this.links[e].activity()}}catch(e){n.op.enabled=false;if(this._op.patch.isEditorMode()){if(n.op.onError)n.op.onError(e)}this._log.error("exception in port: ",n.name,n.op.name,n.op);this._log.error(e)}};I.prototype.call=function(){this._log.warn("call deprecated - use trigger() ");this.trigger()};I.prototype.execute=function(){this._log.warn("### execute port: "+this.getName(),this.goals.length)};I.prototype.setVariableName=function(e){this._useVariableName=e;this._op.patch.on("variableRename",(e,t)=>{if(e!=this._useVariableName)return;this._useVariableName=t})};I.prototype.getVariableName=function(){return this._useVariableName};I.prototype.setVariable=function(e){this.setAnimated(false);const t={useVariable:false};if(this._variableIn&&this._varChangeListenerId){this._variableIn.off(this._varChangeListenerId);this._variableIn=null}if(e){this._variableIn=this._op.patch.getVar(e);if(!this._variableIn){this._log.warn("PORT VAR NOT FOUND!!!",e)}else{if(this.type==d.OP.OP_PORT_TYPE_OBJECT){this._varChangeListenerId=this._variableIn.on("change",()=>{this.set(null);this.set(this._variableIn.getValue())})}else{this._varChangeListenerId=this._variableIn.on("change",this.set.bind(this))}this.set(this._variableIn.getValue())}this._useVariableName=e;t.useVariable=true;t.variableName=this._useVariableName}else{t.variableName=this._useVariableName=null;t.useVariable=false}this.setUiAttribs(t);this._op.patch.emitEvent("portSetVariable",this._op,this,e)};I.prototype._handleNoTriggerOpAnimUpdates=function(e){let t=false;for(let e=0;e<this._op.portsIn.length;e++){if(this._op.portsIn.type==d.OP.OP_PORT_TYPE_FUNCTION){t=true;break}}if(!t){if(e)this._notriggerAnimUpdate=this._op.patch.on("onRenderFrame",()=>{this.updateAnim()});else this._op.patch.removeEventListener(this._notriggerAnimUpdate)}};I.prototype.setAnimated=function(e){if(this._animated!=e){this._animated=e;this._op._hasAnimPort=true;if(this._animated&&!this.anim){this.anim=new _({name:"port "+this.name});this.anim.addEventListener("onChange",()=>{this._op.patch.emitEvent("portAnimUpdated",this._op,this,this.anim)})}this._onAnimToggle()}this._handleNoTriggerOpAnimUpdates(e);if(!e){this.anim=null}this.setUiAttribs({isAnimated:this._animated})};I.prototype.toggleAnim=function(){this._animated=!this._animated;if(this._animated&&!this.anim){this.anim=new _({name:"port "+this.name});this.anim.addEventListener("onChange",()=>{this._op.patch.emitEvent("portAnimUpdated",this._op,this,this.anim)})}this.setAnimated(this._animated);this._onAnimToggle();this.setUiAttribs({isAnimated:this._animated})};I.prototype.getType=function(){return this.type};I.prototype.isLinked=function(){return this.links.length>0||this._animated||this._useVariableName!=null};I.prototype.isBoundToVar=function(){const e=this._useVariableName!=null;this.uiAttribs.boundToVar=e;return e};I.prototype.isAnimated=function(){return this._animated};I.prototype.isHidden=function(){return this.uiAttribs.hidePort};I.prototype._onTriggered=function(e){this._activity();this._op.updateAnims();if(this._op.enabled&&this.onTriggered)this.onTriggered(e);if(this._op.enabled)this.emitEvent("trigger")};I.prototype._onSetProfiling=function(e){this._op.patch.profiler.add("port",this);this.setValue(e);this._op.patch.profiler.add("port",null)};I.prototype._onTriggeredProfiling=function(){if(this._op.enabled&&this.onTriggered){this._op.patch.profiler.add("port",this);this.onTriggered();this._op.patch.profiler.add("port",null)}};I.prototype.getUiActiveState=function(){return this._uiActiveState};I.prototype.setUiActiveState=function(e){this._uiActiveState=e;if(this.onUiActiveStateChange)this.onUiActiveStateChange()};I.prototype.onValueChange=function(e){this.onChange=e};I.prototype.hidePort=function(){};I.portTypeNumberToString=function(e){if(e==d.OP.OP_PORT_TYPE_VALUE)return"value";if(e==d.OP.OP_PORT_TYPE_FUNCTION)return"function";if(e==d.OP.OP_PORT_TYPE_OBJECT)return"object";if(e==d.OP.OP_PORT_TYPE_ARRAY)return"array";if(e==d.OP.OP_PORT_TYPE_STRING)return"string";if(e==d.OP.OP_PORT_TYPE_DYNAMIC)return"dynamic";return"unknown"};class y{constructor(e,t,n,a,i,r,s,o,l,u){this._log=new m("cg_uniform");this._type=t;this._name=n;this._shader=e;this._value=1e-5;this._oldValue=null;this._port=null;this._structName=l;this._structUniformName=o;this._propertyName=u;this._shader._addUniform(this);this.needsUpdate=true;this.shaderType=null;this.comment=null;if(t=="f"){this.set=this.setValue=this.setValueF.bind(this);this.updateValue=this.updateValueF.bind(this)}else if(t=="f[]"){this.set=this.setValue=this.setValueArrayF.bind(this);this.updateValue=this.updateValueArrayF.bind(this)}else if(t=="2f[]"){this.set=this.setValue=this.setValueArray2F.bind(this);this.updateValue=this.updateValueArray2F.bind(this)}else if(t=="3f[]"){this.set=this.setValue=this.setValueArray3F.bind(this);this.updateValue=this.updateValueArray3F.bind(this)}else if(t=="4f[]"){this.set=this.setValue=this.setValueArray4F.bind(this);this.updateValue=this.updateValueArray4F.bind(this)}else if(t=="i"){this.set=this.setValue=this.setValueI.bind(this);this.updateValue=this.updateValueI.bind(this)}else if(t=="2i"){this.set=this.setValue=this.setValue2I.bind(this);this.updateValue=this.updateValue2I.bind(this)}else if(t=="3i"){this.set=this.setValue=this.setValue3I.bind(this);this.updateValue=this.updateValue3I.bind(this)}else if(t=="4i"){this.set=this.setValue=this.setValue4I.bind(this);this.updateValue=this.updateValue4I.bind(this)}else if(t=="b"){this.set=this.setValue=this.setValueBool.bind(this);this.updateValue=this.updateValueBool.bind(this)}else if(t=="4f"){this.set=this.setValue=this.setValue4F.bind(this);this.updateValue=this.updateValue4F.bind(this)}else if(t=="3f"){this.set=this.setValue=this.setValue3F.bind(this);this.updateValue=this.updateValue3F.bind(this)}else if(t=="2f"){this.set=this.setValue=this.setValue2F.bind(this);this.updateValue=this.updateValue2F.bind(this)}else if(t=="t"){this.set=this.setValue=this.setValueT.bind(this);this.updateValue=this.updateValueT.bind(this)}else if(t=="sampler"){if(this.setValueAny){this.set=this.setValue=this.setValueAny.bind(this);this.updateValue=this.updateValueAny.bind(this)}}else if(t=="tc"){this.set=this.setValue=this.setValueT.bind(this);this.updateValue=this.updateValueT.bind(this)}else if(t=="t[]"){this.set=this.setValue=this.setValueArrayT.bind(this);this.updateValue=this.updateValueArrayT.bind(this)}else if(t=="m4"||t=="m4[]"){this.set=this.setValue=this.setValueM4.bind(this);this.updateValue=this.updateValueM4.bind(this)}else{this._log.error("Unknown uniform type "+t)}if(typeof a=="object"&&a instanceof I){this._port=a;this._value=this._port.get();if(i&&r&&s){if(!(i instanceof I)||!(r instanceof I)||!(s instanceof I)){this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ",this._name)}this._value=[0,0,0,0];this._port2=i;this._port3=r;this._port4=s;this._port.on("change",this.updateFromPort4f.bind(this));this._port2.on("change",this.updateFromPort4f.bind(this));this._port3.on("change",this.updateFromPort4f.bind(this));this._port4.on("change",this.updateFromPort4f.bind(this));this.updateFromPort4f()}else if(i&&r){if(!(i instanceof I)||!(r instanceof I)){this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ",this._name)}this._value=[0,0,0];this._port2=i;this._port3=r;this._port.on("change",this.updateFromPort3f.bind(this));this._port2.on("change",this.updateFromPort3f.bind(this));this._port3.on("change",this.updateFromPort3f.bind(this));this.updateFromPort3f()}else if(i){if(!(i instanceof I)){this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ",this._name)}this._value=[0,0];this._port2=i;this._port.on("change",this.updateFromPort2f.bind(this));this._port2.on("change",this.updateFromPort2f.bind(this));this.updateFromPort2f()}else{this._port.on("change",this.updateFromPort.bind(this))}}else this._value=a;if(this._value==undefined){console.log("value undefined",this);this._value=0}this.setValue(this._value);this.needsUpdate=true}getType(){return this._type}get type(){return this._type}get name(){return this._name}getName(){return this._name}getValue(){return this._value}getShaderType(){return this.shaderType}isStructMember(){return!!this._structName}updateFromPort4f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this._value[2]=this._port3.get();this._value[3]=this._port4.get();this.setValue(this._value)}updateFromPort3f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this._value[2]=this._port3.get();this.setValue(this._value)}updateFromPort2f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this.setValue(this._value)}updateFromPort(){this.setValue(this._port.get())}}const A=y;class S extends A{constructor(e,t,n,a,i,r,s,o,l,u){super(e,t,n,a,i,r,s,o,l,u);this._loc=-1;this._cgl=e._cgl}get name(){return this._name}copy(e){const t=new S(e,this._type,this._name,this._value,this._port2,this._port3,this._port4,this._structUniformName,this._structName,this._propertyName);t.shaderType=this.shaderType;return t}getGlslTypeString(){return S.glslTypeString(this._type)}_isValidLoc(){return this._loc!=-1}resetLoc(){this._loc=-1;this.needsUpdate=true}bindTextures(){}getLoc(){return this._loc}updateFromPort4f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this._value[2]=this._port3.get();this._value[3]=this._port4.get();this.setValue(this._value)}updateFromPort3f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this._value[2]=this._port3.get();this.setValue(this._value)}updateFromPort2f(){this._value[0]=this._port.get();this._value[1]=this._port2.get();this.setValue(this._value)}updateFromPort(){this.setValue(this._port.get())}updateValueF(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;this._shader.getCgl().gl.uniform1f(this._loc,this._value);this._cgl.profileData.profileUniformCount++}setValueF(e){if(e!=this._value){this.needsUpdate=true;this._value=e}}updateValueI(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;this._shader.getCgl().gl.uniform1i(this._loc,this._value);this._cgl.profileData.profileUniformCount++}updateValue2I(){if(!this._value)return;if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._shader.getCgl().gl.uniform2i(this._loc,this._value[0],this._value[1]);this.needsUpdate=false;this._cgl.profileData.profileUniformCount++}updateValue3I(){if(!this._value)return;if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._shader.getCgl().gl.uniform3i(this._loc,this._value[0],this._value[1],this._value[2]);this.needsUpdate=false;this._cgl.profileData.profileUniformCount++}updateValue4I(){if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._shader.getCgl().gl.uniform4i(this._loc,this._value[0],this._value[1],this._value[2],this._value[3]);this._cgl.profileData.profileUniformCount++}setValueI(e){if(e!=this._value){this.needsUpdate=true;this._value=e}}setValue2I(e){if(!e)return;if(!this._oldValue){this._oldValue=[e[0]-1,1];this.needsUpdate=true}else if(e[0]!=this._oldValue[0]||e[1]!=this._oldValue[1]){this._oldValue[0]=e[0];this._oldValue[1]=e[1];this.needsUpdate=true}this._value=e}setValue3I(e){if(!e)return;if(!this._oldValue){this._oldValue=[e[0]-1,1,2];this.needsUpdate=true}else if(e[0]!=this._oldValue[0]||e[1]!=this._oldValue[1]||e[2]!=this._oldValue[2]){this._oldValue[0]=e[0];this._oldValue[1]=e[1];this._oldValue[2]=e[2];this.needsUpdate=true}this._value=e}setValue4I(e){this.needsUpdate=true;this._value=e||vec4.create()}updateValueBool(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;this._shader.getCgl().gl.uniform1i(this._loc,this._value?1:0);this._cgl.profileData.profileUniformCount++}setValueBool(e){if(e!=this._value){this.needsUpdate=true;this._value=e}}setValueArray4F(e){this.needsUpdate=true;this._value=e}updateValueArray4F(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;if(!this._value)return;this._shader.getCgl().gl.uniform4fv(this._loc,this._value);this._cgl.profileData.profileUniformCount++}setValueArray3F(e){this.needsUpdate=true;this._value=e}updateValueArray3F(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;if(!this._value)return;this._shader.getCgl().gl.uniform3fv(this._loc,this._value);this._cgl.profileData.profileUniformCount++}setValueArray2F(e){this.needsUpdate=true;this._value=e}updateValueArray2F(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;if(!this._value)return;this._shader.getCgl().gl.uniform2fv(this._loc,this._value);this._cgl.profileData.profileUniformCount++}setValueArrayF(e){this.needsUpdate=true;this._value=e}updateValueArrayF(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;if(!this._value)return;this._shader.getCgl().gl.uniform1fv(this._loc,this._value);this._cgl.profileData.profileUniformCount++}setValueArrayT(e){this.needsUpdate=true;this._value=e}updateValue3F(){if(!this._value)return;if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._shader.getCgl().gl.uniform3f(this._loc,this._value[0],this._value[1],this._value[2]);this.needsUpdate=false;this._cgl.profileData.profileUniformCount++}setValue3F(e){if(!e)return;if(!this._oldValue){this._oldValue=[e[0]-1,1,2];this.needsUpdate=true}else if(e[0]!=this._oldValue[0]||e[1]!=this._oldValue[1]||e[2]!=this._oldValue[2]){this._oldValue[0]=e[0];this._oldValue[1]=e[1];this._oldValue[2]=e[2];this.needsUpdate=true}this._value=e}updateValue2F(){if(!this._value)return;if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._shader.getCgl().gl.uniform2f(this._loc,this._value[0],this._value[1]);this.needsUpdate=false;this._cgl.profileData.profileUniformCount++}setValue2F(e){if(!e)return;if(!this._oldValue){this._oldValue=[e[0]-1,1];this.needsUpdate=true}else if(e[0]!=this._oldValue[0]||e[1]!=this._oldValue[1]){this._oldValue[0]=e[0];this._oldValue[1]=e[1];this.needsUpdate=true}this._value=e}updateValue4F(){if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}if(!this._value){this._log.warn("no value for uniform",this._name,this);this._value=[0,0,0,0]}this.needsUpdate=false;this._shader.getCgl().gl.uniform4f(this._loc,this._value[0],this._value[1],this._value[2],this._value[3]);this._cgl.profileData.profileUniformCount++}setValue4F(e){if(typeof this.value=="number")this.value=vec4.create();if(!e)return;if(!this._oldValue){this._oldValue=[e[0]-1,1,2,3];this.needsUpdate=true}else if(e[0]!=this._oldValue[0]||e[1]!=this._oldValue[1]||e[2]!=this._oldValue[2]||e[3]!=this._oldValue[3]){this._oldValue[0]=e[0];this._oldValue[1]=e[1];this._oldValue[2]=e[2];this.needsUpdate=true}this._value=e}updateValueM4(){if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}if(!this._value||this._value.length%16!=0)return console.log("this.name",this._name,this._value);this._shader.getCgl().gl.uniformMatrix4fv(this._loc,false,this._value);this._cgl.profileData.profileUniformCount++}setValueM4(e){this.needsUpdate=true;this._value=e||mat4.create()}updateValueArrayT(){if(!this._isValidLoc())this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);else this.needsUpdate=false;if(!this._value)return;this._shader.getCgl().gl.uniform1iv(this._loc,this._value);this._cgl.profileData.profileUniformCount++}updateValueT(){if(!this._isValidLoc()){this._loc=this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(),this._name);this._cgl.profileData.profileShaderGetUniform++;this._cgl.profileData.profileShaderGetUniformName=this._name}this._cgl.profileData.profileUniformCount++;this._shader.getCgl().gl.uniform1i(this._loc,this._value);this.needsUpdate=false}setValueT(e){this.needsUpdate=true;this._value=e}}S.glslTypeString=e=>{if(e=="f")return"float";if(e=="b")return"bool";if(e=="i")return"int";if(e=="2i")return"ivec2";if(e=="2f")return"vec2";if(e=="3f")return"vec3";if(e=="4f")return"vec4";if(e=="m4")return"mat4";if(e=="t")return"sampler2D";if(e=="tc")return"samplerCube";if(e=="3f[]")return null;if(e=="m4[]")return null;if(e=="f[]")return null;console.warn("[CGL UNIFORM] unknown glsl type string ",e)};const E={SHADERVAR_VERTEX_POSITION:"vPosition",SHADERVAR_VERTEX_NUMBER:"attrVertIndex",SHADERVAR_VERTEX_NORMAL:"attrVertNormal",SHADERVAR_VERTEX_TEXCOORD:"attrTexCoord",SHADERVAR_INSTANCE_MMATRIX:"instMat",SHADERVAR_VERTEX_COLOR:"attrVertColor",SHADERVAR_INSTANCE_INDEX:"instanceIndex",SHADERVAR_UNI_PROJMAT:"projMatrix",SHADERVAR_UNI_VIEWMAT:"viewMatrix",SHADERVAR_UNI_MODELMAT:"modelMatrix",SHADERVAR_UNI_NORMALMAT:"normalMatrix",SHADERVAR_UNI_INVVIEWMAT:"inverseViewMatrix",SHADERVAR_UNI_INVPROJMAT:"invProjMatrix",SHADERVAR_UNI_MATERIALID:"materialId",SHADERVAR_UNI_OBJECTID:"objectId",SHADERVAR_UNI_VIEWPOS:"camPos"};const C={BLEND_NONE:0,BLEND_NORMAL:1,BLEND_ADD:2,BLEND_SUB:3,BLEND_MUL:4};const j=180/Math.PI;const N=Math.PI/180;const L={MATH:{DEG2RAD:N,RAD2DEG:j},SHADER:E,BLEND_MODES:C};const M={};M.lastMesh=null;const R=function(e,t,n){this._cgl=e;let a=n||{};if(CABLES.UTILS.isNumeric(a))a={glPrimitive:n};this._log=new m("cgl_mesh");this._bufVertexAttrib=null;this._bufVerticesIndizes=this._cgl.gl.createBuffer();this._indexType=this._cgl.gl.UNSIGNED_SHORT;this._attributes=[];this._attribLocs={};this._geom=null;this._lastShader=null;this._numInstances=0;this._glPrimitive=a.glPrimitive;this.opId=a.opId||"";this._preWireframeGeom=null;this.addVertexNumbers=false;this._name="unknown";this.feedBackAttributes=[];this.setGeom(t);this._feedBacks=[];this._feedBacksChanged=false;this._transformFeedBackLoc=-1;this._lastAttrUpdate=0;this.memFreed=false;this._cgl.profileData.addHeavyEvent("mesh constructed",this._name);this._queryExt=null;Object.defineProperty(this,"numInstances",{get(){return this._numInstances},set(e){this.setNumInstances(e)}})};R.prototype.freeMem=function(){this.memFreed=true;for(let e=0;e<this._attributes.length;e++){this._attributes[e].floatArray=null}};R.prototype.updateVertices=function(e){this.setAttribute(L.SHADER.SHADERVAR_VERTEX_POSITION,e.vertices,3);this._numVerts=e.vertices.length/3};R.prototype.setAttributePointer=function(t,n,a,i){for(let e=0;e<this._attributes.length;e++){if(this._attributes[e].name==t){if(!this._attributes[e].pointer)this._attributes[e].pointer=[];this._attributes[e].pointer.push({loc:-1,name:n,stride:a,offset:i,instanced:t==L.SHADER.SHADERVAR_INSTANCE_MMATRIX})}}};R.prototype.getAttribute=function(t){for(let e=0;e<this._attributes.length;e++)if(this._attributes[e].name==t)return this._attributes[e]};R.prototype.setAttributeRange=function(e,t,n,a){if(!e)return;if(!n&&!a)return;if(!e.name){this._log.stack("no attrname?!")}this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER,e.buffer);this._cgl.profileData.profileMeshAttributes+=a-n||0;this._cgl.profileData.profileSingleMeshAttribute[this._name]=this._cgl.profileData.profileSingleMeshAttribute[this._name]||0;this._cgl.profileData.profileSingleMeshAttribute[this._name]+=a-n||0;if(e.numItems<t.length/e.itemSize){this._resizeAttr(t,e)}if(a>t.length){if(CABLES.platform.isDevEnv())this._log.log(this._cgl.canvas.id+" "+e.name+" buffersubdata out of bounds ?",t.length,a,n,e);return}if(this._cgl.glVersion==1)this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER,0,t);else this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER,n*4,t,n,a-n)};R.prototype._resizeAttr=function(e,t){if(t.buffer)this._cgl.gl.deleteBuffer(t.buffer);t.buffer=this._cgl.gl.createBuffer();this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER,t.buffer);this._bufferArray(e,t);t.numItems=e.length/t.itemSize};R.prototype._bufferArray=function(e,t){let n=t.floatArray||null;if(!e)return;if(this._cgl.debugOneFrame){console.log("_bufferArray",e.length,t.name)}if(!(e instanceof Float32Array)){if(t&&n&&n.length==e.length){n.set(e)}else{n=new Float32Array(e);if(this._cgl.debugOneFrame){console.log("_bufferArray create new float32array",e.length,t.name)}if(e.length>1e4){this._cgl.profileData.profileNonTypedAttrib++;this._cgl.profileData.profileNonTypedAttribNames="("+this._name+":"+t.name+")"}}}else n=e;t.arrayLength=n.length;t.floatArray=null;this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER,n,this._cgl.gl.DYNAMIC_DRAW)};R.prototype.addAttribute=R.prototype.updateAttribute=R.prototype.setAttribute=function(e,t,n,a){if(!t){this._log.error("mesh addAttribute - no array given! "+e);throw new Error}let i=null;let r=false;let s=0;const o=t.length/n;this._cgl.profileData.profileMeshAttributes+=o||0;if(typeof a=="function"){i=a}if(typeof a=="object"){if(a.cb)i=a.cb;if(a.instanced)r=a.instanced}if(e==L.SHADER.SHADERVAR_INSTANCE_MMATRIX)r=true;for(s=0;s<this._attributes.length;s++){const m=this._attributes[s];if(m.name==e){if(m.numItems===o){}else{this._resizeAttr(t,m)}this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER,m.buffer);this._bufferArray(t,m);return m}}const l=this._cgl.gl.createBuffer();this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER,l);let u=this._cgl.gl.FLOAT;if(a&&a.type)u=a.type;const m={buffer:l,name:e,cb:i,itemSize:n,numItems:o,startItem:0,instanced:r,type:u};this._bufferArray(t,m);if(e==L.SHADER.SHADERVAR_VERTEX_POSITION)this._bufVertexAttrib=m;this._attributes.push(m);this._attribLocs={};return m};R.prototype.getAttributes=function(){return this._attributes};R.prototype.updateTexCoords=function(e){if(e.texCoords&&e.texCoords.length>0){this.setAttribute(L.SHADER.SHADERVAR_VERTEX_TEXCOORD,e.texCoords,2)}else{const t=new Float32Array(Math.round(e.vertices.length/3*2));this.setAttribute(L.SHADER.SHADERVAR_VERTEX_TEXCOORD,t,2)}};R.prototype.updateNormals=function(e){if(e.vertexNormals&&e.vertexNormals.length>0){this.setAttribute(L.SHADER.SHADERVAR_VERTEX_NORMAL,e.vertexNormals,3)}else{const t=new Float32Array(Math.round(e.vertices.length));this.setAttribute(L.SHADER.SHADERVAR_VERTEX_NORMAL,t,3)}};R.prototype._setVertexNumbers=function(e){if(!this._verticesNumbers||this._verticesNumbers.length!=this._numVerts||e){if(e)this._verticesNumbers=e;else{this._verticesNumbers=new Float32Array(this._numVerts);for(let e=0;e<this._numVerts;e++)this._verticesNumbers[e]=e}this.setAttribute(L.SHADER.SHADERVAR_VERTEX_NUMBER,this._verticesNumbers,1,(e,t,n)=>{if(!n.uniformNumVertices)n.uniformNumVertices=new S(n,"f","numVertices",this._numVerts);n.uniformNumVertices.setValue(this._numVerts)})}};R.prototype.setVertexIndices=function(t){if(!this._bufVerticesIndizes){this._log.warn("no bufVerticesIndizes: "+this._name);return}if(t.length>0){if(t instanceof Float32Array)this._log.warn("vertIndices float32Array: "+this._name);for(let e=0;e<t.length;e++){if(t[e]>=this._numVerts){this._log.warn("invalid index in "+this._name,e,t[e]);return}}this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER,this._bufVerticesIndizes);if(t.length>65535){this.vertIndicesTyped=new Uint32Array(t);this._indexType=this._cgl.gl.UNSIGNED_INT}else if(t instanceof Uint32Array){this.vertIndicesTyped=t;this._indexType=this._cgl.gl.UNSIGNED_INT}else if(!(t instanceof Uint16Array)){this.vertIndicesTyped=new Uint16Array(t);this._indexType=this._cgl.gl.UNSIGNED_SHORT}else this.vertIndicesTyped=t;this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER,this.vertIndicesTyped,this._cgl.gl.DYNAMIC_DRAW);this._bufVerticesIndizes.itemSize=1;this._bufVerticesIndizes.numItems=t.length}else this._bufVerticesIndizes.numItems=0};R.prototype.setGeom=function(e,t){this._geom=e;if(e.glPrimitive!=null)this._glPrimitive=e.glPrimitive;if(this._geom&&this._geom.name)this._name="mesh "+this._geom.name;M.lastMesh=null;this._cgl.profileData.profileMeshSetGeom++;this._disposeAttributes();this.updateVertices(this._geom);this.setVertexIndices(this._geom.verticesIndices);if(this.addVertexNumbers)this._setVertexNumbers();const n=this._geom.getAttributes();const a={texCoords:L.SHADER.SHADERVAR_VERTEX_TEXCOORD,vertexNormals:L.SHADER.SHADERVAR_VERTEX_NORMAL,vertexColors:L.SHADER.SHADERVAR_VERTEX_COLOR,tangents:"attrTangent",biTangents:"attrBiTangent"};for(const i in n)if(n[i].data&&n[i].data.length)this.setAttribute(a[i]||i,n[i].data,n[i].itemSize);if(t){this._geom=null}};R.prototype._preBind=function(t){for(let e=0;e<this._attributes.length;e++)if(this._attributes[e].cb)this._attributes[e].cb(this._attributes[e],this._geom,t)};R.prototype._checkAttrLengths=function(){if(this.memFreed)return;for(let e=0;e<this._attributes.length;e++){if(this._attributes[e].arrayLength/this._attributes[e].itemSize<this._attributes[0].arrayLength/this._attributes[0].itemSize){let e="unknown";if(this._geom)e=this._geom.name}}};R.prototype._bind=function(t){if(!t.isValid())return;let n=[];if(this._attribLocs[t.id])n=this._attribLocs[t.id];else this._attribLocs[t.id]=n;this._lastShader=t;if(t.lastCompile>this._lastAttrUpdate||n.length!=this._attributes.length){this._lastAttrUpdate=t.lastCompile;for(let e=0;e<this._attributes.length;e++)n[e]=-1}for(let e=0;e<this._attributes.length;e++){const a=this._attributes[e];if(n[e]==-1){if(a._attrLocationLastShaderTime!=t.lastCompile){a._attrLocationLastShaderTime=t.lastCompile;n[e]=this._cgl.glGetAttribLocation(t.getProgram(),a.name);this._cgl.profileData.profileAttrLoc++}}if(n[e]!=-1){this._cgl.gl.enableVertexAttribArray(n[e]);this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER,a.buffer);if(a.instanced){if(a.itemSize<=4){if(!a.itemSize||a.itemSize==0)this._log.warn("instanced attrib itemsize error",this._geom.name,a);this._cgl.gl.vertexAttribPointer(n[e],a.itemSize,a.type,false,a.itemSize*4,0);this._cgl.gl.vertexAttribDivisor(n[e],1)}else if(a.itemSize==16){const i=16*4;this._cgl.gl.vertexAttribPointer(n[e],4,a.type,false,i,0);this._cgl.gl.enableVertexAttribArray(n[e]+1);this._cgl.gl.vertexAttribPointer(n[e]+1,4,a.type,false,i,4*4*1);this._cgl.gl.enableVertexAttribArray(n[e]+2);this._cgl.gl.vertexAttribPointer(n[e]+2,4,a.type,false,i,4*4*2);this._cgl.gl.enableVertexAttribArray(n[e]+3);this._cgl.gl.vertexAttribPointer(n[e]+3,4,a.type,false,i,4*4*3);this._cgl.gl.vertexAttribDivisor(n[e],1);this._cgl.gl.vertexAttribDivisor(n[e]+1,1);this._cgl.gl.vertexAttribDivisor(n[e]+2,1);this._cgl.gl.vertexAttribDivisor(n[e]+3,1)}else{this._log.warn("unknown instance attrib size",a.name)}}else{if(!a.itemSize||a.itemSize==0)this._log.warn("attrib itemsize error",this._name,a);this._cgl.gl.vertexAttribPointer(n[e],a.itemSize,a.type,false,a.itemSize*4,0);if(a.pointer){for(let e=0;e<a.pointer.length;e++){const r=a.pointer[e];if(r.loc==-1)r.loc=this._cgl.glGetAttribLocation(t.getProgram(),r.name);this._cgl.profileData.profileAttrLoc++;this._cgl.gl.enableVertexAttribArray(r.loc);this._cgl.gl.vertexAttribPointer(r.loc,a.itemSize,a.type,false,r.stride,r.offset)}}if(this.bindFeedback)this.bindFeedback(a)}}}if(this._bufVerticesIndizes&&this._bufVerticesIndizes.numItems!==0)this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER,this._bufVerticesIndizes)};R.prototype.unBind=function(){const e=this._lastShader;this._lastShader=null;if(!e)return;let t=[];if(this._attribLocs[e.id])t=this._attribLocs[e.id];else this._attribLocs[e.id]=t;M.lastMesh=null;for(let e=0;e<this._attributes.length;e++){if(this._attributes[e].instanced){if(this._attributes[e].itemSize<=4){if(t[e]!=-1)this._cgl.gl.vertexAttribDivisor(t[e],0);if(t[e]>=0)this._cgl.gl.disableVertexAttribArray(t[e])}else{this._cgl.gl.vertexAttribDivisor(t[e],0);this._cgl.gl.vertexAttribDivisor(t[e]+1,0);this._cgl.gl.vertexAttribDivisor(t[e]+2,0);this._cgl.gl.vertexAttribDivisor(t[e]+3,0);this._cgl.gl.disableVertexAttribArray(t[e]+1);this._cgl.gl.disableVertexAttribArray(t[e]+2);this._cgl.gl.disableVertexAttribArray(t[e]+3)}}if(t[e]!=-1)this._cgl.gl.disableVertexAttribArray(t[e])}};R.prototype.meshChanged=function(){return this._cgl.lastMesh&&this._cgl.lastMesh!=this};R.prototype.printDebug=function(e){console.log("--attributes");for(let e=0;e<this._attributes.length;e++){console.log("attribute "+e+" "+this._attributes[e].name)}};R.prototype.setNumVertices=function(e){this._bufVertexAttrib.numItems=e};R.prototype.getNumVertices=function(){return this._bufVertexAttrib.numItems};R.prototype.render=function(n){if(!n||!n.isValid()||this._cgl.aborted)return;this._checkAttrLengths();if(this._geom){if(this._preWireframeGeom&&!n.wireframe&&!this._geom.isIndexed()){this.setGeom(this._preWireframeGeom);this._preWireframeGeom=null}if(n.wireframe){let e=false;if(this._geom.isIndexed()){if(!this._preWireframeGeom){this._preWireframeGeom=this._geom;this._geom=this._geom.copy()}this._geom.unIndex();e=true}if(!this._geom.getAttribute("attrBarycentric")){if(!this._preWireframeGeom){this._preWireframeGeom=this._geom;this._geom=this._geom.copy()}e=true;this._geom.calcBarycentric()}if(e)this.setGeom(this._geom)}}let e=false;if(M.lastMesh!=this){if(M.lastMesh)M.lastMesh.unBind();e=true}if(e)this._preBind(n);if(!n.bind())return;this._bind(n);if(this.addVertexNumbers)this._setVertexNumbers();M.lastMesh=this;let t=this._cgl.gl.TRIANGLES;if(this._glPrimitive!==undefined)t=this._glPrimitive;if(n.glPrimitive!==null)t=n.glPrimitive;let a=1;let i=this._cgl.profileData.doProfileGlQuery;let r=false;if(i){let e=this._name+" - "+n.getName()+" #"+n.id;if(this._numInstances)e+=" instanced "+this._numInstances+"x";let t=this._cgl.profileData.glQueryData[e];if(!t)t={id:e,num:0};if(n.opId)t.shaderOp=n.opId;if(this.opId)t.meshOp=this.opId;this._cgl.profileData.glQueryData[e]=t;if(!this._queryExt&&this._queryExt!==false)this._queryExt=this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2")||false;if(this._queryExt){if(t._drawQuery){const s=this._cgl.gl.getQueryParameter(t._drawQuery,this._cgl.gl.QUERY_RESULT_AVAILABLE);if(s){const o=this._cgl.gl.getQueryParameter(t._drawQuery,this._cgl.gl.QUERY_RESULT);const l=o/1e6;t._times=t._times||0;t._times+=l;t._numcount++;t.when=performance.now();t._drawQuery=null;t.queryStarted=false}}if(!t.queryStarted){t._drawQuery=this._cgl.gl.createQuery();this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT,t._drawQuery);r=t.queryStarted=true}}}if(this.hasFeedbacks&&this.hasFeedbacks())this.drawFeedbacks(n,t);else if(!this._bufVerticesIndizes||this._bufVerticesIndizes.numItems===0){if(t==this._cgl.gl.TRIANGLES)a=3;if(this._numInstances===0)this._cgl.gl.drawArrays(t,this._bufVertexAttrib.startItem,this._bufVertexAttrib.numItems-this._bufVertexAttrib.startItem);else this._cgl.gl.drawArraysInstanced(t,this._bufVertexAttrib.startItem,this._bufVertexAttrib.numItems,this._numInstances)}else{if(t==this._cgl.gl.TRIANGLES)a=3;if(this._numInstances===0){this._cgl.gl.drawElements(t,this._bufVerticesIndizes.numItems,this._indexType,0)}else{this._cgl.gl.drawElementsInstanced(t,this._bufVerticesIndizes.numItems,this._indexType,0,this._numInstances)}}if(this._cgl.debugOneFrame&&this._cgl.gl.getError()!=this._cgl.gl.NO_ERROR){this._log.error("mesh draw gl error");this._log.error("mesh",this);this._log.error("shader",n);const u=[];for(let e=0;e<this._cgl.gl.getProgramParameter(n.getProgram(),this._cgl.gl.ACTIVE_ATTRIBUTES);e++){const m=this._cgl.gl.getActiveAttrib(n.getProgram(),e).name;this._log.error("attrib ",m)}}this._cgl.profileData.profileMeshNumElements+=this._bufVertexAttrib.numItems/a*(this._numInstances||1);this._cgl.profileData.profileMeshDraw++;if(i&&r){this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT)}this._cgl.printError("mesh render "+this._name);this.unBind()};R.prototype.setNumInstances=function(t){t=Math.max(0,t);if(this._numInstances!=t){this._numInstances=t;const n=new Float32Array(t);for(let e=0;e<t;e++)n[e]=e;this.setAttribute(L.SHADER.SHADERVAR_INSTANCE_INDEX,n,1,{instanced:true})}};R.prototype._disposeAttributes=function(){if(!this._attributes)return;for(let e=0;e<this._attributes.length;e++){if(this._attributes[e].buffer){this._cgl.gl.deleteBuffer(this._attributes[e].buffer);this._attributes[e].buffer=null}}this._attributes.length=0};R.prototype.dispose=function(){if(this._bufVertexAttrib&&this._bufVertexAttrib.buffer)this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);if(this._bufVerticesIndizes)this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);this._bufVerticesIndizes=null;this._disposeAttributes()};const P={};P.getSimpleRect=function(e,t,n=1){const a=new p(t);a.vertices=[1*n,1*n,0,-1*n,1*n,0,1*n,-1*n,0,-1*n,-1*n,0];a.texCoords=[1,1,0,1,1,0,0,0];a.verticesIndices=[0,1,2,2,1,3];a.vertexNormals=[0,0,0,0,0,0,0,0,0,0,0,0];return e.createMesh(a)};P.getSimpleCube=function(e,t){const n=new p(t);n.vertices=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];n.setTexCoords([0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,0,0,0]);n.verticesIndices=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];n.vertexNormals=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]);n.tangents=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1]);n.biTangents=new Float32Array([-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]);return new R(e,n)};class w{constructor(e,t,n){this.cgl=e;this._options=n;this.fb=null;let a=n.shader;this._useDefaultShader=true;if(n.shader)this._useDefaultShader=false;n.numRenderBuffers=n.numRenderBuffers||1;if(!a){a="".endl()+"IN vec2 texCoord;";for(let e=0;e<n.numRenderBuffers;e++){a=a.endl()+"UNI sampler2D tex"+e+";".endl()}a=a.endl()+"void main()".endl()+"{";if(n.numRenderBuffers==1){a=a.endl()+"    outColor= texture(tex0,texCoord);".endl()}else for(let e=0;e<n.numRenderBuffers;e++){a=a.endl()+"outColor"+e+" = texture(tex"+e+",texCoord);".endl()}a=a.endl()+"}"}const i=n.vertexShader||"".endl()+"IN vec3 vPosition;".endl()+"IN vec2 attrTexCoord;".endl()+"OUT vec2 texCoord;".endl()+"void main()".endl()+"{".endl()+"   texCoord=attrTexCoord;".endl()+"   gl_Position = vec4(vPosition,  1.0);".endl()+"}";this.bgShader=new CGL.Shader(e,"corelib copytexture "+t);this.bgShader.setSource(i,a);if(!n.vertexShader)this.bgShader.ignoreMissingUniforms=true;new CGL.Uniform(this.bgShader,"t","tex",0);new CGL.Uniform(this.bgShader,"t","tex1",1);new CGL.Uniform(this.bgShader,"t","tex2",2);new CGL.Uniform(this.bgShader,"t","tex3",3);this.mesh=P.getSimpleRect(this.cgl,"texEffectRect")}setSize(e,t){this._options.width=e;this._options.height=t}copy(e,t,n,a,i){const r=this.cgl;if(!e)e=CGL.Texture.getEmptyTexture(this.cgl);let s=this._options.width||e.width,o=this._options.height||e.height;if(this.fb){if(s<=0)s=8;if(o<=0)o=8;if(this.fb.getWidth()!=s||this.fb.getHeight()!=o)this.fb.setSize(s,o)}else{let e=CGL.Texture.FILTER_LINEAR;let t=CGL.Texture.WRAP_CLAMP_TO_EDGE;if(this._options.isFloatingPointTexture)e=CGL.Texture.FILTER_NEAREST;if(this._options.hasOwnProperty("filter"))e=this._options.filter;if(this._options.hasOwnProperty("wrap"))t=this._options.wrap;const l={isFloatingPointTexture:this._options.isFloatingPointTexture,pixelFormat:this._options.pixelFormat,numRenderBuffers:this._options.numRenderBuffers||1,filter:e,wrap:t};if(r.glVersion==1)this.fb=new CGL.Framebuffer(r,s,o,l);else this.fb=new CGL.Framebuffer2(r,s,o,l)}r.tempData.renderOffscreen=true;this.fb.renderStart(r);r.setTexture(0,e.tex);if(t)r.setTexture(1,t.tex);if(n)r.setTexture(2,n.tex);if(a)r.setTexture(3,a.tex);if(i)r.setTexture(4,i.tex);r.pushShader(this.bgShader);this.mesh.render(this.bgShader);r.popShader();this.fb.renderEnd();r.tempData.renderOffscreen=false;return this.fb.getTextureColor()}dispose(){if(this.fb)this.fb.dispose();if(this.bgShader)this.bgShader.dispose();if(this.mesh)this.mesh.dispose()}}CGL.CopyTexture=w;((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Copytexture=e.Copytexture})();(()=>{"use strict";var e={};class t{constructor(e,t){this.initiator=e;this._options=t}stack(e){console.info("["+this.initiator+"] ",e);console.log((new Error).stack)}groupCollapsed(e){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments);console.groupCollapsed("["+this.initiator+"] "+e)}table(e){console.table(e)}groupEnd(){console.groupEnd()}error(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)||!CABLES.UI){console.error("["+this.initiator+"]",...arguments)}if(this._options&&this._options.onError){this._options.onError(this.initiator,...arguments)}}errorGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:2},...arguments)}warn(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:1},...arguments)||!CABLES.logSilent)console.warn("["+this.initiator+"]",...arguments)}verbose(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}info(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.info("["+this.initiator+"]",...arguments)}log(){if(CABLES.UI&&CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)||!CABLES.logSilent)console.log("["+this.initiator+"]",...arguments)}logGui(){if(CABLES.UI)CABLES.UI.logFilter.filterLog({initiator:this.initiator,level:0},...arguments)}userInteraction(e){}}class n{constructor(){this._log=new t("LoadingStatus");this.pixelData=null;this._finishedFence=true;this._size=0;this._pbo=null}_fence(r){const s=r.gl;this._finishedFence=false;return new Promise(function(t,n){if(r.aborted)return;let a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);if(!a)return;s.flush();function i(){if(r.aborted)return;const e=s.clientWaitSync(a,0,0);if(e==s.WAIT_FAILED){console.error("fence wait failed");if(n)n()}else if(e==s.TIMEOUT_EXPIRED){return setTimeout(i,0)}else if(e==s.CONDITION_SATISFIED){t();s.deleteSync(a)}else if(e==s.ALREADY_SIGNALED){t();s.deleteSync(a)}else{this._log.log("unknown fence status",e)}}i()})}read(n,a,e,i,r,s,o,t){if(CABLES.UI)if(!CABLES.UI.loaded||performance.now()-CABLES.UI.loadedTime<1e3)return;if(!this._finishedFence)return;const l=n.gl;let u=1;if(n.aborted)return;if(!a)return;if(e===CGL.Texture.TYPE_FLOAT)e=CGL.Texture.PFORMATSTR_RGBA32F;let m=CGL.Texture.isPixelFormatFloat(e);if(m)u=4;if(CGL.Texture.isPixelFormatHalfFloat(e))u=2;const p=CGL.Texture.setUpGlPixelFormat(n,e);const c=p.numColorChannels*s*o;if(s==0||o==0||c==0)return;if(!this._pixelData||this._size!=c*u){if(u>1)this._pixelData=new Float32Array(c);else this._pixelData=new Uint8Array(c);this._size=c*u}let d=l.UNSIGNED_BYTE;if(u>1)d=l.FLOAT;if(this._size==0||!this._pixelData){this._log.error("readpixel size 0",this._size,s,o);return}if(this._finishedFence){this._pbo=l.createBuffer();l.bindBuffer(l.PIXEL_PACK_BUFFER,this._pbo);l.bufferData(l.PIXEL_PACK_BUFFER,this._pixelData.byteLength,l.DYNAMIC_READ);l.bindFramebuffer(l.FRAMEBUFFER,a);l.bindBuffer(l.PIXEL_PACK_BUFFER,this._pbo);n.profileData.profileFencedPixelRead++;if(this._size!=c*u)this._log.error("buffer size invalid",c,s,o,u);let e=p.glDataType;if(u>1)e=n.gl.FLOAT;let t=p.glDataFormat;l.readPixels(i,r,s,o,t,e,0);l.bindBuffer(l.PIXEL_PACK_BUFFER,null);l.bindFramebuffer(l.FRAMEBUFFER,null)}let h=this._pixelData.byteLength;if(this._finishedFence&&this._pbo)this._fence(n).then(e=>{this._wasTriggered=false;this._finishedFence=true;if(!e&&this._pixelData&&this._pixelData.byteLength==h){l.bindBuffer(l.PIXEL_PACK_BUFFER,this._pbo);l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,this._pixelData);l.bindBuffer(l.PIXEL_PACK_BUFFER,null);if(t)t(this._pixelData)}l.deleteBuffer(this._pbo);this._pbo=null});return true}}CGL.PixelReader=n;((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Pixelreader=e.Pixelreader})();